/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./examples/src/decoder.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./examples/src/decoder.ts":
/*!*********************************!*\
  !*** ./examples/src/decoder.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nself.importScripts(\"../vendor/three.min.js\");\nconst index_worker_1 = __webpack_require__(/*! @here/harp-omv-datasource/index-worker */ \"./node_modules/@here/harp-omv-datasource/index-worker.js\");\nindex_worker_1.OmvTileDecoderService.start();\nindex_worker_1.OmvTilerService.start();\n\n\n//# sourceURL=webpack:///./examples/src/decoder.ts?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index-decoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index-decoder.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/StyleSetEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/IMeshBuffers */ \"./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Outliner */ \"./node_modules/@here/harp-datasource-protocol/lib/Outliner.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ThreeBufferUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ \"./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js\"), exports);\n//# sourceMappingURL=index-decoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/index-decoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Components used for the decoding and styling of data that is used by the Datasources.\n *\n * @remarks\n * The DataSource Protocol package contains components used for the decoding and styling\n * of data that is used by the Datasources.\n * This code is shared between the ui-thread and the web-workers which are\n * used to parallelise the decoding of the data.\n * This module contains interfaces for choosing techniques form the techniques\n * catalog that are applied via the {@link Theme} files to draw geometries on the map canvas.\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TechniqueParams */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PostEffects */ \"./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PropertyValue */ \"./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ITileDecoder */ \"./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ITiler */ \"./node_modules/@here/harp-datasource-protocol/lib/ITiler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DecodedTile */ \"./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TileInfo */ \"./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ \"./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ThemeVisitor */ \"./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorUtils = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\nconst SHIFT_TRANSPARENCY = 24;\nconst SHIFT_RED = 16;\nconst SHIFT_GREEN = 8;\nconst SHIFT_BLUE = 0;\n//    Allow bitwise operations for colors decoding\nconst HEX_FULL_CHANNEL = 0xff;\nconst HEX_RGB_MASK = 0xffffff;\nconst HEX_TRGB_MASK = 0xffffffff;\nconst tmpColor = new THREE.Color();\n/**\n * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.\n *\n * The functions provided allows for conversion from and to our custom number based color format,\n * which contains transparency, red, green and blue color channels in a way that each channel\n * occupies 8 bits of resulting number (color format 0xTTRRGGBB).\n * In order to preserve compatibility with THREE.Color class and its hexadecimal color\n * representation, we do not store __alpha__ channel in encoded color's number, but replace it\n * with __transparency__ channel, which is simply opposite to alpha:\n * ```transparency = 0xFF - alpha```\n * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,\n * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],\n * [[THREE.Color.setHex]]).\n * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.\n */\nvar ColorUtils;\n(function (ColorUtils) {\n    /**\n     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).\n     *\n     * We do not use direct alpha channel mapping to hex in order to preserve compatibility\n     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency\n     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].\n     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and\n     * color defining transparency (alpha < 255) is always recognizable by the oldest\n     * bit set:\n     * ```typescript\n     * (color >> SHIFT_TRANSPARENCY) !== 0.\n     * ```\n     * @note All input components are floating points in <0, 1> range (inclusively).\n     * @note Although method encodes transparency channel in single number value, it is still\n     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to\n     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.\n     */\n    function getHexFromRgba(r, g, b, a) {\n        harp_utils_1.assert(a >= 0 && a <= 1);\n        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);\n        return ((t << SHIFT_TRANSPARENCY) ^\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));\n    }\n    ColorUtils.getHexFromRgba = getHexFromRgba;\n    /**\n     * Encodes RGB all color channels in single number with format 0xRRGGBB.\n     *\n     * All input channels should be in <0, 1> range (inclusively).\n     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.\n     *\n     * @note This method is fully compatible with THREE.js color encoding, so\n     * you may pass this value directly to THREE.Color c-tor.\n     */\n    function getHexFromRgb(r, g, b) {\n        harp_utils_1.assert(r >= 0 && r <= 1);\n        harp_utils_1.assert(g >= 0 && g <= 1);\n        harp_utils_1.assert(b >= 0 && b <= 1);\n        return (((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));\n    }\n    ColorUtils.getHexFromRgb = getHexFromRgb;\n    /**\n     * Encode and convert HSL value to number coded color format (0xRRGGBB).\n     *\n     * @see getHexFromRgb.\n     * @param h - Hue component value between 0 and 1.\n     * @param s - Saturation value between 0 and 1.\n     * @param l - Lightness channel between 0 and 1.\n     */\n    function getHexFromHsl(h, s, l) {\n        harp_utils_1.assert(h >= 0 && h <= 1);\n        harp_utils_1.assert(s >= 0 && s <= 1);\n        harp_utils_1.assert(l >= 0 && l <= 1);\n        return tmpColor.setHSL(h, s, l).getHex();\n    }\n    ColorUtils.getHexFromHsl = getHexFromHsl;\n    /**\n     * Retrieve RGBA channels separately from number encoded custom color format.\n     *\n     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color\n     * format.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating\n     * point from 0 to 1 inclusively.\n     */\n    function getRgbaFromHex(hex, target = new RGBA_1.RGBA()) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        target.r = ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.g = ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.b = ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.a =\n            (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /\n                HEX_FULL_CHANNEL;\n        return target;\n    }\n    ColorUtils.getRgbaFromHex = getRgbaFromHex;\n    /**\n     * Determines if number encoded color contains alpha (opacity) defined and different then 255.\n     *\n     * @param hex - The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns True if color has transparency defined.\n     */\n    function hasAlphaInHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex >> SHIFT_TRANSPARENCY !== 0;\n    }\n    ColorUtils.hasAlphaInHex = hasAlphaInHex;\n    /**\n     * Retrieves alpha color channel from hex encoded color value.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns The floating point alpha component in <0, 1> range.\n     */\n    function getAlphaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return (((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL);\n    }\n    ColorUtils.getAlphaFromHex = getAlphaFromHex;\n    /**\n     * Remove transparency info from the number coded color, makes it compatible with external libs.\n     *\n     * @see getAlphaFromHex.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns number coded color value representable as 0xRRGGBB in hex.\n     */\n    function removeAlphaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex & HEX_RGB_MASK;\n    }\n    ColorUtils.removeAlphaFromHex = removeAlphaFromHex;\n})(ColorUtils = exports.ColorUtils || (exports.ColorUtils = {}));\n//# sourceMappingURL=ColorUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFeatureText = exports.getFeatureName = exports.getFeatureId = exports.getProjectionName = exports.getProjection = exports.GeometryType = exports.getArrayConstructor = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst TechniqueAttr_1 = __webpack_require__(/*! ./TechniqueAttr */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js\");\nconst Techniques_1 = __webpack_require__(/*! ./Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\");\n/**\n * Returns an array with the data type specified as parameter.\n *\n * @param attr - specifies which type of data is being stored in the array\n */\nfunction getArrayConstructor(attr) {\n    switch (attr) {\n        case \"float\":\n            return Float32Array;\n        case \"uint8\":\n            return Uint8Array;\n        case \"uint16\":\n            return Uint16Array;\n        case \"uint32\":\n            return Uint32Array;\n        case \"int8\":\n            return Int8Array;\n        case \"int16\":\n            return Int16Array;\n        case \"int32\":\n            return Int32Array;\n    }\n}\nexports.getArrayConstructor = getArrayConstructor;\n/**\n * Geometry types supported by [[Geometry]] objects.\n */\nvar GeometryType;\n(function (GeometryType) {\n    GeometryType[GeometryType[\"Unspecified\"] = 0] = \"Unspecified\";\n    GeometryType[GeometryType[\"Point\"] = 1] = \"Point\";\n    GeometryType[GeometryType[\"Line\"] = 2] = \"Line\";\n    GeometryType[GeometryType[\"SolidLine\"] = 3] = \"SolidLine\";\n    GeometryType[GeometryType[\"Text\"] = 4] = \"Text\";\n    GeometryType[GeometryType[\"TextPath\"] = 5] = \"TextPath\";\n    GeometryType[GeometryType[\"ExtrudedLine\"] = 6] = \"ExtrudedLine\";\n    GeometryType[GeometryType[\"Polygon\"] = 7] = \"Polygon\";\n    GeometryType[GeometryType[\"ExtrudedPolygon\"] = 8] = \"ExtrudedPolygon\";\n    GeometryType[GeometryType[\"Object3D\"] = 9] = \"Object3D\";\n    GeometryType[GeometryType[\"Other\"] = 1000] = \"Other\";\n})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));\n/**\n * Returns the projection object specified in the parameter.\n *\n * @param projectionName - string describing projection to be used\n */\nfunction getProjection(projectionName) {\n    switch (projectionName) {\n        case \"mercator\":\n            return harp_geoutils_1.mercatorProjection;\n        case \"webMercator\":\n            return harp_geoutils_1.webMercatorProjection;\n        case \"sphere\":\n            return harp_geoutils_1.sphereProjection;\n        case \"normalizedEquirectangular\":\n            return harp_geoutils_1.normalizedEquirectangularProjection;\n        case \"equirectangular\":\n            return harp_geoutils_1.equirectangularProjection;\n        default:\n            throw new Error(`Unknown projection ${projectionName}`);\n    } // switch\n}\nexports.getProjection = getProjection;\n/**\n * String with the projection's name.\n *\n * @param projection - `Projection` object containing the name of the projection to retrieve\n */\nfunction getProjectionName(projection) {\n    if (projection === harp_geoutils_1.mercatorProjection) {\n        return \"mercator\";\n    }\n    else if (projection === harp_geoutils_1.webMercatorProjection) {\n        return \"webMercator\";\n    }\n    else if (projection === harp_geoutils_1.sphereProjection) {\n        return \"sphere\";\n    }\n    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {\n        return \"normalizedEquirectangular\";\n    }\n    else if (projection === harp_geoutils_1.equirectangularProjection) {\n        return \"equirectangular\";\n    }\n    throw new Error(\"Unknown projection\");\n}\nexports.getProjectionName = getProjectionName;\n/**\n * @returns Feature id from the provided attribute map.\n */\nfunction getFeatureId(attributeMap) {\n    if (attributeMap === undefined) {\n        return 0;\n    }\n    if (typeof attributeMap === \"number\") {\n        return attributeMap;\n    }\n    if (attributeMap.hasOwnProperty(\"$id\")) {\n        return attributeMap.$id;\n    }\n    return 0;\n}\nexports.getFeatureId = getFeatureId;\n/**\n * Determine the name of (OMV) feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param env - Environment containing the tags from the (OMV) feature.\n * @param useAbbreviation - `true` to use the abbreviation if available.\n * @param useIsoCode - `true` to use the tag \"iso_code\".\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nfunction getFeatureName(env, basePropName, useAbbreviation, useIsoCode, languages) {\n    var _a;\n    let name;\n    if (basePropName === undefined) {\n        basePropName = \"name\";\n    }\n    if (useAbbreviation) {\n        const abbreviation = env.lookup(`${basePropName}:short`);\n        if (typeof abbreviation === \"string\" && abbreviation.length > 0) {\n            return abbreviation;\n        }\n    }\n    if (useIsoCode) {\n        const isoCode = env.lookup(`iso_code`);\n        if (typeof isoCode === \"string\" && isoCode.length > 0) {\n            return isoCode;\n        }\n    }\n    if (languages !== undefined) {\n        for (const lang of languages) {\n            name = (_a = env.lookup(`${basePropName}:${lang}`)) !== null && _a !== void 0 ? _a : env.lookup(`${basePropName}_${lang}`);\n            if (typeof name === \"string\" && name.length > 0) {\n                return name;\n            }\n        }\n    }\n    name = env.lookup(basePropName);\n    if (typeof name === \"string\") {\n        return name;\n    }\n    return undefined;\n}\nexports.getFeatureName = getFeatureName;\n/**\n * Determine the text string of the map feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param feature - Feature, including properties from the (OMV) feature.\n * @param technique - technique defining how text should be created from feature\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nfunction getFeatureText(context, technique, languages) {\n    let useAbbreviation;\n    let useIsoCode;\n    const env = context instanceof Expr_1.Env ? context : context.env;\n    let propName = \"name\";\n    if (Techniques_1.isTextTechnique(technique) ||\n        Techniques_1.isPoiTechnique(technique) ||\n        Techniques_1.isLineMarkerTechnique(technique)) {\n        if (technique.text !== undefined) {\n            return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);\n        }\n        if (technique.label !== undefined) {\n            propName = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.label);\n            if (typeof propName !== \"string\") {\n                return undefined;\n            }\n        }\n        useAbbreviation = technique.useAbbreviation;\n        useIsoCode = technique.useIsoCode;\n    }\n    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);\n}\nexports.getFeatureText = getFeatureText;\n//# sourceMappingURL=DecodedTile.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Env.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Env.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEnv = exports.Env = void 0;\n/**\n * A class used to lookup properties by name.\n *\n * @remarks\n * Concrete implementation of `Env` like {@link MapEnv} are used\n * to resolve the property names used in {@link Expr | style expressions}.\n *\n * @example\n * ```typescript\n * const env = new MapEnv({\n *     kind: \"landuse\",\n * });\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n *\n * const value = expr.evaluate(env);\n *\n * console.log(`kind is '${value}`);\n * ```\n */\nclass Env {\n    /**\n     * Returns `true` if the given object is an instance of {@link Env}.\n     *\n     * @param object - The object to test.\n     */\n    static isEnv(object) {\n        return object instanceof Env;\n    }\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     */\n    lookup(name) {\n        return undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment. (Here: empty object).\n     */\n    unmap() {\n        return {};\n    }\n}\nexports.Env = Env;\n/**\n * `MapEnv` is a concrete implementation of {@link Env} that\n * creates a lookup environment from a set of properties.\n *\n * @example\n * ```typescript\n * const baseEnv = new MapEnv({\n *     $zoom: 14,\n * });\n *\n * // extends baseEnv with a the new binding (kind, \"landuse\").\n * const env = new MapEnv({ kind: \"landuse\" }, baseEnv);\n *\n * const zoom = env.lookup(\"$zoom\"); // zoom is 14\n * const kind = env.lookup(\"kind\"); // kind is is \"landuse\"\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n * const value = expr.evaluate(env); // value is \"landuse\"\n * ```\n */\nclass MapEnv extends Env {\n    constructor(entries, parent) {\n        super();\n        this.entries = entries;\n        this.parent = parent;\n    }\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     * @override\n     */\n    lookup(name) {\n        if (this.entries.hasOwnProperty(name)) {\n            const value = this.entries[name];\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return this.parent ? this.parent.lookup(name) : undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment, takes care of the parent\n     * object.\n     * @override\n     */\n    unmap() {\n        const obj = this.parent ? this.parent.unmap() : {};\n        for (const key in this.entries) {\n            if (this.entries.hasOwnProperty(key)) {\n                obj[key] = this.entries[key];\n            }\n        }\n        return obj;\n    }\n}\nexports.MapEnv = MapEnv;\n//# sourceMappingURL=Env.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Env.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Expr.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InterpolateExpr = exports.StepExpr = exports.CaseExpr = exports.MatchExpr = exports.CallExpr = exports.HasAttributeExpr = exports.ObjectLiteralExpr = exports.StringLiteralExpr = exports.NumberLiteralExpr = exports.BooleanLiteralExpr = exports.NullLiteralExpr = exports.LiteralExpr = exports.VarExpr = exports.Expr = exports.ExprScope = exports.isJsonExpr = exports.ExprDependencies = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js\");\nconst ExprInstantiator_1 = __webpack_require__(/*! ./ExprInstantiator */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js\");\nconst ExprParser_1 = __webpack_require__(/*! ./ExprParser */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst Pixels_1 = __webpack_require__(/*! ./Pixels */ \"./node_modules/@here/harp-datasource-protocol/lib/Pixels.js\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\n__exportStar(__webpack_require__(/*! ./Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\"), exports);\nconst exprEvaluator = new ExprEvaluator_1.ExprEvaluator();\nconst exprInstantiator = new ExprInstantiator_1.ExprInstantiator();\n/**\n * The dependencies of an {@link Expr}.\n */\nclass ExprDependencies {\n    constructor() {\n        /**\n         * The properties needed to evaluate the {@link Expr}.\n         */\n        this.properties = new Set();\n    }\n}\nexports.ExprDependencies = ExprDependencies;\nclass ComputeExprDependencies {\n    /**\n     * Gets the dependencies of an {@link Expr}.\n     *\n     * @param expr - The {@link Expr} to process.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param dependencies - The output [[Set]] of dependency names.\n     */\n    static of(expr) {\n        const dependencies = new ExprDependencies();\n        expr.accept(this.instance, dependencies);\n        return dependencies;\n    }\n    visitNullLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitNumberLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitStringLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitObjectLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitVarExpr(expr, context) {\n        context.properties.add(expr.name);\n    }\n    visitHasAttributeExpr(expr, context) {\n        context.properties.add(expr.name);\n    }\n    visitCallExpr(expr, context) {\n        expr.args.forEach(childExpr => childExpr.accept(this, context));\n        switch (expr.op) {\n            case \"dynamic-properties\":\n                context.volatile = true;\n                break;\n            case \"feature-state\":\n                context.featureState = true;\n                context.properties.add(\"$state\");\n                context.properties.add(\"$id\");\n                break;\n            case \"id\":\n                context.properties.add(\"$id\");\n                break;\n            case \"zoom\":\n            case \"world-ppi-scale\":\n            case \"world-discrete-ppi-scale\":\n                context.properties.add(\"$zoom\");\n                break;\n            case \"geometry-type\":\n                context.properties.add(\"$geometryType\");\n                break;\n            default:\n                break;\n        }\n    }\n    visitMatchExpr(expr, context) {\n        expr.value.accept(this, context);\n        expr.branches.forEach(([_, branch]) => branch.accept(this, context));\n        expr.fallback.accept(this, context);\n    }\n    visitCaseExpr(expr, context) {\n        expr.branches.forEach(([condition, branch]) => {\n            condition.accept(this, context);\n            branch.accept(this, context);\n        });\n        expr.fallback.accept(this, context);\n    }\n    visitStepExpr(expr, context) {\n        expr.input.accept(this, context);\n        expr.defaultValue.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n    visitInterpolateExpr(expr, context) {\n        expr.input.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n}\nComputeExprDependencies.instance = new ComputeExprDependencies();\nfunction isJsonExpr(v) {\n    return Array.isArray(v) && v.length > 0 && typeof v[0] === \"string\";\n}\nexports.isJsonExpr = isJsonExpr;\n/**\n * The evaluation scope of an {@link Expr}.\n */\nvar ExprScope;\n(function (ExprScope) {\n    /**\n     * The scope of an {@link Expr} used as value of an attribute.\n     */\n    ExprScope[ExprScope[\"Value\"] = 0] = \"Value\";\n    /**\n     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.\n     */\n    ExprScope[ExprScope[\"Condition\"] = 1] = \"Condition\";\n    /**\n     * The scope of an {@link Expr} used as dynamic property attribute value.\n     */\n    ExprScope[ExprScope[\"Dynamic\"] = 2] = \"Dynamic\";\n})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));\n/**\n * Abstract class representing the\n * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}\n * used in {@link Theme}.\n */\nclass Expr {\n    /**\n     * Tests of given value is an {@link Expr}.\n     *\n     * @param value - The object to test.\n     */\n    static isExpr(value) {\n        return value instanceof Expr;\n    }\n    /**\n     * Creates an expression from the given `code`.\n     *\n     * @param code - The code to parse.\n     * @returns The parsed {@link Expr}.\n     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.\n     */\n    static parse(code) {\n        const parser = new ExprParser_1.ExprParser(code);\n        const expr = parser.parse();\n        return expr;\n    }\n    /**\n     * Creates a style expression from JSON.\n     *\n     * @remarks\n     * The optional set of {@link Theme.definitions | definitions} is used\n     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.\n     *\n     * @param json - JSON object representing the expression to parse.\n     * @param definitions - Optional set of definitions used to expand references.\n     * @param definitionExprCache - Optional cache of `Expr` instances\n     *\n     * @example\n     * ```typescript\n     * const expr = Expr.fromJSON([\"all\",\n     *     [\"==\", [\"geometry-type\"], \"LineString\"],\n     *     [\"has\", \"text\"]\n     * ]);\n     * ```\n     */\n    static fromJSON(json, definitions, definitionExprCache) {\n        const referenceResolverState = definitions !== undefined\n            ? {\n                definitions,\n                lockedNames: new Set(),\n                cache: definitionExprCache !== null && definitionExprCache !== void 0 ? definitionExprCache : new Map()\n            }\n            : undefined;\n        return parseNode(json, referenceResolverState);\n    }\n    /**\n     * Evaluate an expression returning a {@link Value} object.\n     *\n     * @param env - The {@link Env} used to lookup symbols.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param cache - A cache of previously computed results.\n     */\n    evaluate(env, scope = ExprScope.Value, cache) {\n        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));\n    }\n    /**\n     * Instantiates this {@link Expr}.\n     *\n     * @remarks\n     * references to the `get` and `has` operator using the given instantiation context.\n     *\n     * @param context - The [[InstantationContext]] used to resolve names.\n     */\n    instantiate(context) {\n        return this.accept(exprInstantiator, context);\n    }\n    /**\n     * Gets the dependencies of this {@link Expr}.\n     */\n    dependencies() {\n        if (!this.m_dependencies) {\n            this.m_dependencies = ComputeExprDependencies.of(this);\n        }\n        return this.m_dependencies;\n    }\n    /**\n     * Create a unique object that is structurally equivalent to this {@link Expr}.\n     *\n     * @param pool - The [[ExprPool]] used to create a unique\n     * equivalent object of this {@link Expr}.\n     */\n    intern(pool) {\n        return pool.add(this);\n    }\n    toJSON() {\n        return new ExprSerializer().serialize(this);\n    }\n    /**\n     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.\n     */\n    isDynamic() {\n        if (this.m_isDynamic === undefined) {\n            this.m_isDynamic = this.exprIsDynamic();\n        }\n        return this.m_isDynamic;\n    }\n}\nexports.Expr = Expr;\n/**\n * A node representing a `get` expression.\n */\nclass VarExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitVarExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.VarExpr = VarExpr;\n/**\n * A node representing a `literal` expression.\n */\nclass LiteralExpr extends Expr {\n    /**\n     * Create a [[LiteralExpr]] from the given value.\n     *\n     * @param value - A constant value.\n     */\n    static fromValue(value) {\n        switch (typeof value) {\n            case \"boolean\":\n                return new BooleanLiteralExpr(value);\n            case \"number\":\n                return new NumberLiteralExpr(value);\n            case \"string\":\n                return new StringLiteralExpr(value);\n            case \"object\":\n                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);\n            default:\n                throw new Error(`failed to create a literal from '${value}'`);\n        } // switch\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.LiteralExpr = LiteralExpr;\n/**\n * Null literal expression.\n */\nclass NullLiteralExpr extends LiteralExpr {\n    constructor() {\n        super();\n        /** @override */\n        this.value = null;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitNullLiteralExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.NullLiteralExpr = NullLiteralExpr;\nNullLiteralExpr.instance = new NullLiteralExpr();\n/**\n * Boolean literal expression.\n */\nclass BooleanLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitBooleanLiteralExpr(this, context);\n    }\n}\nexports.BooleanLiteralExpr = BooleanLiteralExpr;\n/**\n * Number literal expression.\n */\nclass NumberLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitNumberLiteralExpr(this, context);\n    }\n}\nexports.NumberLiteralExpr = NumberLiteralExpr;\n/**\n * String literal expression.\n */\nclass StringLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /**\n     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.\n     */\n    get promotedValue() {\n        var _a, _b, _c;\n        if (this.m_promotedValue === undefined) {\n            this.m_promotedValue = (_b = (_a = RGBA_1.RGBA.parse(this.value)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(this.value)) !== null && _b !== void 0 ? _b : null;\n        }\n        return (_c = this.m_promotedValue) !== null && _c !== void 0 ? _c : undefined;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitStringLiteralExpr(this, context);\n    }\n}\nexports.StringLiteralExpr = StringLiteralExpr;\n/**\n * Object literal expression.\n */\nclass ObjectLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get isArrayLiteral() {\n        return Array.isArray(this.value);\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitObjectLiteralExpr(this, context);\n    }\n}\nexports.ObjectLiteralExpr = ObjectLiteralExpr;\n/**\n * A node reperesenting a `has` expression.\n */\nclass HasAttributeExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitHasAttributeExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.HasAttributeExpr = HasAttributeExpr;\n/**\n * A node representing a `call` expression.\n */\nclass CallExpr extends Expr {\n    constructor(op, args) {\n        super();\n        this.op = op;\n        this.args = args;\n    }\n    /**\n     * Returns the child nodes of this {@link Expr}.\n     *\n     * @deprecated Use {@link CallExpr.args} instead.\n     */\n    get children() {\n        return this.args;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitCallExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        var _a;\n        const descriptor = (_a = this.descriptor) !== null && _a !== void 0 ? _a : ExprEvaluator_1.ExprEvaluator.getOperator(this.op);\n        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {\n            return true;\n        }\n        return this.args.some(e => e.isDynamic());\n    }\n}\nexports.CallExpr = CallExpr;\n/**\n * A node representing a `match` expression.\n */\nclass MatchExpr extends Expr {\n    constructor(value, branches, fallback) {\n        super();\n        this.value = value;\n        this.branches = branches;\n        this.fallback = fallback;\n    }\n    /**\n     * Tests if the given JSON node is a valid label for the `\"match\"` operator.\n     *\n     * @param node - A JSON value.\n     */\n    static isValidMatchLabel(node) {\n        switch (typeof node) {\n            case \"number\":\n            case \"string\":\n                return true;\n            case \"object\":\n                if (!Array.isArray(node) || node.length === 0) {\n                    return false;\n                }\n                const elementTy = typeof node[0];\n                if (elementTy === \"number\" || elementTy === \"string\") {\n                    return node.every(t => typeof t === elementTy);\n                }\n                return false;\n            default:\n                return false;\n        } // switch\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitMatchExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.value.isDynamic() ||\n            this.branches.some(([_, branch]) => branch.isDynamic()) ||\n            this.fallback.isDynamic());\n    }\n}\nexports.MatchExpr = MatchExpr;\n/**\n * A node representing a `case` expression.\n */\nclass CaseExpr extends Expr {\n    constructor(branches, fallback) {\n        super();\n        this.branches = branches;\n        this.fallback = fallback;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitCaseExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||\n            this.fallback.isDynamic());\n    }\n}\nexports.CaseExpr = CaseExpr;\n/**\n * A node representing a `step` expression.\n */\nclass StepExpr extends Expr {\n    constructor(input, defaultValue, stops) {\n        super();\n        this.input = input;\n        this.defaultValue = defaultValue;\n        this.stops = stops;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitStepExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.input.isDynamic() ||\n            this.defaultValue.isDynamic() ||\n            this.stops.some(([_, value]) => value.isDynamic()));\n    }\n}\nexports.StepExpr = StepExpr;\n/**\n * A node representing an `interpolate` expression.\n */\nclass InterpolateExpr extends Expr {\n    constructor(mode, input, stops) {\n        super();\n        this.mode = mode;\n        this.input = input;\n        this.stops = stops;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitInterpolateExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());\n    }\n}\nexports.InterpolateExpr = InterpolateExpr;\n/**\n * Serializes the Expr to JSON.\n *\n * @internal\n */\nclass ExprSerializer {\n    serialize(expr) {\n        return expr.accept(this, undefined);\n    }\n    visitNullLiteralExpr(expr, context) {\n        return null;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitStringLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        if (expr.value instanceof THREE.Vector2) {\n            return [\"make-vector\", expr.value.x, expr.value.y];\n        }\n        else if (expr.value instanceof THREE.Vector3) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z];\n        }\n        else if (expr.value instanceof THREE.Vector4) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z, expr.value.w];\n        }\n        return [\"literal\", expr.value];\n    }\n    visitVarExpr(expr, context) {\n        return [\"get\", expr.name];\n    }\n    visitHasAttributeExpr(expr, context) {\n        return [\"has\", expr.name];\n    }\n    visitCallExpr(expr, context) {\n        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];\n    }\n    visitMatchExpr(expr, context) {\n        const branches = [];\n        for (const [label, body] of expr.branches) {\n            branches.push(label, this.serialize(body));\n        }\n        return [\"match\", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];\n    }\n    visitCaseExpr(expr, context) {\n        const branches = [];\n        for (const [condition, body] of expr.branches) {\n            branches.push(this.serialize(condition), this.serialize(body));\n        }\n        return [\"case\", ...branches, this.serialize(expr.fallback)];\n    }\n    visitStepExpr(expr, context) {\n        const result = [\"step\"];\n        result.push(this.serialize(expr.input));\n        result.push(this.serialize(expr.defaultValue));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n    visitInterpolateExpr(expr, context) {\n        const result = [\"interpolate\", expr.mode];\n        result.push(this.serialize(expr.input));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n}\nfunction parseNode(node, referenceResolverState) {\n    if (Array.isArray(node)) {\n        return parseCall(node, referenceResolverState);\n    }\n    else if (node === null) {\n        return NullLiteralExpr.instance;\n    }\n    else if (typeof node === \"boolean\") {\n        return new BooleanLiteralExpr(node);\n    }\n    else if (typeof node === \"number\") {\n        return new NumberLiteralExpr(node);\n    }\n    else if (typeof node === \"string\") {\n        return new StringLiteralExpr(node);\n    }\n    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);\n}\nfunction parseCall(node, referenceResolverState) {\n    const op = node[0];\n    if (typeof op !== \"string\") {\n        throw new Error(\"expected a builtin function name\");\n    }\n    switch (op) {\n        case \"!has\":\n        case \"!in\":\n            return new CallExpr(\"!\", [parseCall([op.slice(1), ...node.slice(1)])]);\n        case \"ref\":\n            return resolveReference(node, referenceResolverState);\n        case \"get\":\n            return parseGetExpr(node, referenceResolverState);\n        case \"has\":\n            return parseHasExpr(node, referenceResolverState);\n        case \"literal\":\n            return parseLiteralExpr(node);\n        case \"match\":\n            return parseMatchExpr(node, referenceResolverState);\n        case \"case\":\n            return parseCaseExpr(node, referenceResolverState);\n        case \"interpolate\":\n            return parseInterpolateExpr(node, referenceResolverState);\n        case \"step\":\n            return parseStepExpr(node, referenceResolverState);\n        default:\n            return makeCallExpr(op, node, referenceResolverState);\n    } // switch\n}\nfunction parseGetExpr(node, referenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"get\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new VarExpr(name);\n}\nfunction parseHasExpr(node, referenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"has\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new HasAttributeExpr(name);\n}\nfunction parseLiteralExpr(node) {\n    const obj = node[1];\n    if (obj === null || typeof obj !== \"object\") {\n        throw new Error(\"expected an object or array literal\");\n    }\n    return new ObjectLiteralExpr(obj);\n}\nfunction parseMatchExpr(node, referenceResolverState) {\n    if (node.length < 4) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (!(node.length % 2)) {\n        throw new Error(\"fallback is missing in 'match' expression\");\n    }\n    const value = parseNode(node[1], referenceResolverState);\n    const conditions = [];\n    for (let i = 2; i < node.length - 1; i += 2) {\n        const label = node[i];\n        if (!MatchExpr.isValidMatchLabel(label)) {\n            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);\n        }\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        conditions.push([label, expr]);\n    }\n    const fallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new MatchExpr(value, conditions, fallback);\n}\nfunction parseCaseExpr(node, referenceResolverState) {\n    if (node.length < 3) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (node.length % 2) {\n        throw new Error(\"fallback is missing in 'case' expression\");\n    }\n    const branches = [];\n    for (let i = 1; i < node.length - 1; i += 2) {\n        const condition = parseNode(node[i], referenceResolverState);\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        branches.push([condition, expr]);\n    }\n    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new CaseExpr(branches, caseFallback);\n}\nfunction isInterpolationMode(object) {\n    if (!Array.isArray(object)) {\n        return false;\n    }\n    switch (object[0]) {\n        case \"discrete\":\n        case \"linear\":\n        case \"cubic\":\n        case \"exponential\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction parseInterpolateExpr(node, referenceResolverState) {\n    const mode = node[1];\n    if (!isInterpolationMode(mode)) {\n        throw new Error(\"expected an interpolation type\");\n    }\n    if (mode[0] === \"exponential\" && typeof mode[1] !== \"number\") {\n        throw new Error(\"expected the base of the exponential interpolation\");\n    }\n    const input = node[2] !== undefined ? parseNode(node[2], referenceResolverState) : undefined;\n    if (!Expr.isExpr(input)) {\n        throw new Error(`expected the input of the interpolation`);\n    }\n    if (node.length === 3 || !(node.length % 2)) {\n        throw new Error(\"invalid number of samples\");\n    }\n    const stops = [];\n    for (let i = 3; i < node.length - 1; i += 2) {\n        const key = node[i];\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new InterpolateExpr(mode, input, stops);\n}\nfunction parseStepExpr(node, referenceResolverState) {\n    if (node.length < 2) {\n        throw new Error(\"expected the input of the 'step' operator\");\n    }\n    if (node.length < 3 || !(node.length % 2)) {\n        throw new Error(\"not enough arguments\");\n    }\n    const input = parseNode(node[1], referenceResolverState);\n    const defaultValue = parseNode(node[2], referenceResolverState);\n    const stops = [];\n    for (let i = 3; i < node.length; i += 2) {\n        const key = node[i];\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new StepExpr(input, defaultValue, stops);\n}\nfunction makeCallExpr(op, node, referenceResolverState) {\n    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));\n}\nfunction resolveReference(node, referenceResolverState) {\n    if (typeof node[1] !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    if (referenceResolverState === undefined) {\n        throw new Error(`ref used with no definitions`);\n    }\n    const name = node[1];\n    if (referenceResolverState.lockedNames.has(name)) {\n        throw new Error(`circular referene to '${name}'`);\n    }\n    if (!(name in referenceResolverState.definitions)) {\n        throw new Error(`definition '${name}' not found`);\n    }\n    const cachedEntry = referenceResolverState.cache.get(name);\n    if (cachedEntry !== undefined) {\n        return cachedEntry;\n    }\n    let definitionEntry = referenceResolverState.definitions[name];\n    let result;\n    if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(definitionEntry.value)) {\n        // found a reference to an interpolation using\n        // the deprecated object-like syntax.\n        return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));\n    }\n    else if (isJsonExpr(definitionEntry.value)) {\n        definitionEntry = definitionEntry.value;\n    }\n    else {\n        return Expr.fromJSON(definitionEntry.value);\n    }\n    if (isJsonExpr(definitionEntry)) {\n        referenceResolverState.lockedNames.add(name);\n        try {\n            result = parseNode(definitionEntry, referenceResolverState);\n        }\n        finally {\n            referenceResolverState.lockedNames.delete(name);\n        }\n    }\n    else {\n        throw new Error(`unsupported definition ${name}`);\n    }\n    referenceResolverState.cache.set(name, result);\n    return result;\n}\n//# sourceMappingURL=Expr.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Expr.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprEvaluator = exports.ExprEvaluatorContext = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst ArrayOperators_1 = __webpack_require__(/*! ./operators/ArrayOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js\");\nconst CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js\");\nconst ColorOperators_1 = __webpack_require__(/*! ./operators/ColorOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js\");\nconst ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js\");\nconst FeatureOperators_1 = __webpack_require__(/*! ./operators/FeatureOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js\");\nconst FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js\");\nconst MapOperators_1 = __webpack_require__(/*! ./operators/MapOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js\");\nconst MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js\");\nconst MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js\");\nconst ObjectOperators_1 = __webpack_require__(/*! ./operators/ObjectOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js\");\nconst StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js\");\nconst TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js\");\nconst VectorOperators_1 = __webpack_require__(/*! ./operators/VectorOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js\");\nconst Pixels_1 = __webpack_require__(/*! ./Pixels */ \"./node_modules/@here/harp-datasource-protocol/lib/Pixels.js\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\nconst operatorDescriptors = new Map();\n/**\n * Promote string literals and values to color and pixel constants.\n *\n * @hidden\n * @internal\n */\nfunction promoteValue(context, expr) {\n    var _a, _b, _c;\n    if (expr instanceof Expr_1.StringLiteralExpr) {\n        return (_a = expr.promotedValue) !== null && _a !== void 0 ? _a : expr.value;\n    }\n    const value = context.evaluate(expr);\n    if (typeof value === \"string\") {\n        return (_c = (_b = RGBA_1.RGBA.parse(value)) !== null && _b !== void 0 ? _b : Pixels_1.Pixels.parse(value)) !== null && _c !== void 0 ? _c : value;\n    }\n    return value;\n}\nfunction cubicInterpolate(context, interp, t) {\n    if (t < interp.stops[0][0]) {\n        return promoteValue(context, interp.stops[0][1]);\n    }\n    else if (t >= interp.stops[interp.stops.length - 1][0]) {\n        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);\n    }\n    // indices\n    const i1 = interp.stops.findIndex(stop => stop[0] > t);\n    const i0 = Math.max(0, i1 - 1);\n    const iP = i0 === 0 ? i1 : i0 - 1;\n    const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;\n    // keys\n    const tP = interp.stops[iP][0];\n    const t0 = interp.stops[i0][0];\n    const t1 = interp.stops[i1][0];\n    const tN = interp.stops[iN][0];\n    const dt = (t1 - t0) * 0.5;\n    const wP = dt / (t0 - tP);\n    const wN = dt / (tN - t1);\n    const p = (t - t0) / (t1 - t0);\n    const pp = p * p;\n    const ppp = pp * p;\n    // coefficients\n    const cP = -wP * ppp + 2 * wP * pp - wP * p;\n    const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const cN = wN * ppp - wN * pp;\n    // values\n    const vP = promoteValue(context, interp.stops[iP][1]);\n    const v0 = promoteValue(context, interp.stops[i0][1]);\n    const v1 = promoteValue(context, interp.stops[i1][1]);\n    const vN = promoteValue(context, interp.stops[iN][1]);\n    if (typeof vP === \"number\" &&\n        typeof v0 === \"number\" &&\n        typeof v1 === \"number\" &&\n        typeof vN === \"number\") {\n        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;\n    }\n    else if (vP instanceof RGBA_1.RGBA &&\n        v0 instanceof RGBA_1.RGBA &&\n        v1 instanceof RGBA_1.RGBA &&\n        vN instanceof RGBA_1.RGBA) {\n        return new RGBA_1.RGBA(THREE.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1), THREE.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1), THREE.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1), THREE.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1));\n    }\n    else if (vP instanceof Pixels_1.Pixels &&\n        v0 instanceof Pixels_1.Pixels &&\n        v1 instanceof Pixels_1.Pixels &&\n        vN instanceof Pixels_1.Pixels) {\n        return new Pixels_1.Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);\n    }\n    else if (vP instanceof THREE.Color &&\n        v0 instanceof THREE.Color &&\n        v1 instanceof THREE.Color &&\n        vN instanceof THREE.Color) {\n        return new THREE.Color(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b);\n    }\n    else if (vP instanceof THREE.Vector2 &&\n        v0 instanceof THREE.Vector2 &&\n        v1 instanceof THREE.Vector2 &&\n        vN instanceof THREE.Vector2) {\n        return new THREE.Vector2(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y);\n    }\n    else if (vP instanceof THREE.Vector3 &&\n        v0 instanceof THREE.Vector3 &&\n        v1 instanceof THREE.Vector3 &&\n        vN instanceof THREE.Vector3) {\n        return new THREE.Vector3(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z);\n    }\n    else if (vP instanceof THREE.Vector4 &&\n        v0 instanceof THREE.Vector4 &&\n        v1 instanceof THREE.Vector4 &&\n        vN instanceof THREE.Vector4) {\n        return new THREE.Vector4(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z, cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w);\n    }\n    else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {\n        const N = vP.length;\n        const r = [];\n        for (let i = 0; i < N; ++i) {\n            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];\n        }\n        return r;\n    }\n    throw new Error(`failed to interpolate values`);\n}\n/*\n * @hidden\n */\nclass ExprEvaluatorContext {\n    constructor(evaluator, env, scope, cache) {\n        this.evaluator = evaluator;\n        this.env = env;\n        this.scope = scope;\n        this.cache = cache;\n    }\n    /**\n     * Evaluate the given expression.\n     *\n     * @param expr - The {@link Expr} to evaluate.\n     */\n    evaluate(expr) {\n        var _a, _b;\n        if (expr === undefined) {\n            throw new Error(\"Failed to evaluate expression\");\n        }\n        const cachedResult = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(expr);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        const result = expr.accept(this.evaluator, this);\n        (_b = this.cache) === null || _b === void 0 ? void 0 : _b.set(expr, result);\n        return result;\n    }\n    /**\n     * Wraps the given value in an {@link Expr} if needed.\n     *\n     * @param value -\n     */\n    wrapValue(value) {\n        return Expr_1.Expr.isExpr(value) ? value : Expr_1.LiteralExpr.fromValue(value);\n    }\n}\nexports.ExprEvaluatorContext = ExprEvaluatorContext;\n/**\n * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.\n *\n * @hidden\n */\nclass ExprEvaluator {\n    static defineOperator(op, builtin) {\n        operatorDescriptors.set(op, builtin);\n    }\n    static defineOperators(builtins) {\n        Object.getOwnPropertyNames(builtins).forEach(p => {\n            this.defineOperator(p, builtins[p]);\n        });\n    }\n    /**\n     * Returns the [[OperatorDescriptor]] for the given operator name.\n     * @hidden\n     */\n    static getOperator(op) {\n        return operatorDescriptors.get(op);\n    }\n    visitVarExpr(expr, context) {\n        const value = context.env.lookup(expr.name);\n        return value !== undefined ? value : null;\n    }\n    visitNullLiteralExpr(expr, context) {\n        return null;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitStringLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitHasAttributeExpr(expr, context) {\n        return context.env.lookup(expr.name) !== undefined;\n    }\n    visitMatchExpr(match, context) {\n        const r = context.evaluate(match.value);\n        for (const [label, body] of match.branches) {\n            if (Array.isArray(label) && label.includes(r)) {\n                return context.evaluate(body);\n            }\n            else if (label === r) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n    visitCaseExpr(match, context) {\n        if (context.scope === Expr_1.ExprScope.Value) {\n            const firstDynamicCondition = match.branches.findIndex(([condition, _]) => condition.isDynamic());\n            if (firstDynamicCondition !== -1) {\n                let branches;\n                for (let i = 0; i < match.branches.length; ++i) {\n                    const [condition, body] = match.branches[i];\n                    const evaluatedCondition = context.evaluate(condition);\n                    const evaluatedBody = context.evaluate(body);\n                    if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {\n                        return evaluatedBody;\n                    }\n                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {\n                        // skip this branch, it constantly evaluates to false.\n                        continue;\n                    }\n                    if (branches === undefined) {\n                        branches = [];\n                    }\n                    branches === null || branches === void 0 ? void 0 : branches.push([\n                        context.wrapValue(evaluatedCondition),\n                        context.wrapValue(evaluatedBody)\n                    ]);\n                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {\n                        // skip unreachble expressions\n                        return new Expr_1.CaseExpr(branches, Expr_1.LiteralExpr.fromValue(null));\n                    }\n                }\n                const fallback = context.evaluate(match.fallback);\n                return branches === undefined\n                    ? fallback\n                    : new Expr_1.CaseExpr(branches, context.wrapValue(fallback));\n            }\n        }\n        for (const [condition, body] of match.branches) {\n            if (context.evaluate(condition)) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n    visitCallExpr(expr, context) {\n        var _a;\n        const descriptor = (_a = expr.descriptor) !== null && _a !== void 0 ? _a : operatorDescriptors.get(expr.op);\n        if (descriptor) {\n            expr.descriptor = descriptor;\n            let result;\n            if (context.scope === Expr_1.ExprScope.Value && expr.isDynamic()) {\n                if (expr.descriptor.partialEvaluate) {\n                    return expr.descriptor.partialEvaluate(context, expr);\n                }\n                const args = expr.args.map(arg => {\n                    return context.wrapValue(context.evaluate(arg));\n                });\n                if (args.every((arg, i) => arg === expr.args[i])) {\n                    return expr;\n                }\n                result = new Expr_1.CallExpr(expr.op, args);\n            }\n            else {\n                result = descriptor.call(context, expr);\n            }\n            return result;\n        }\n        throw new Error(`undefined operator '${expr.op}'`);\n    }\n    visitStepExpr(expr, context) {\n        if (context.scope === Expr_1.ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            const defaultValue = context.evaluate(expr.defaultValue);\n            return new Expr_1.StepExpr(context.wrapValue(input), context.wrapValue(defaultValue), expr.stops.map(([key, value]) => {\n                const v = context.evaluate(value);\n                return [key, context.wrapValue(v)];\n            }));\n        }\n        else {\n            const input = context.evaluate(expr.input);\n            if (typeof input !== \"number\") {\n                throw new Error(`input '${input}' must be a number`);\n            }\n            if (input < expr.stops[0][0]) {\n                return context.evaluate(expr.defaultValue);\n            }\n            let index = expr.stops.findIndex(s => s[0] > input);\n            if (index === -1) {\n                index = expr.stops.length;\n            }\n            return context.evaluate(expr.stops[index - 1][1]);\n        }\n    }\n    visitInterpolateExpr(expr, context) {\n        if (context.scope === Expr_1.ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            return new Expr_1.InterpolateExpr(expr.mode, context.wrapValue(input), expr.stops.map(([key, value]) => {\n                const v = context.evaluate(value);\n                return [key, context.wrapValue(v)];\n            }));\n        }\n        else {\n            const param = context.evaluate(expr.input);\n            if (typeof param !== \"number\") {\n                throw new Error(`input must be a number`);\n            }\n            if (expr.mode[0] === \"cubic\") {\n                return cubicInterpolate(context, expr, param);\n            }\n            const keyIndex = expr.stops.findIndex(stop => stop[0] > param);\n            if (keyIndex === -1) {\n                // all the keys are smaller than the parameter\n                return context.evaluate(expr.stops[expr.stops.length - 1][1]);\n            }\n            else if (keyIndex === 0) {\n                return context.evaluate(expr.stops[0][1]);\n            }\n            const [key, value] = expr.stops[keyIndex];\n            const [prevKey, prevValue] = expr.stops[keyIndex - 1];\n            const v0 = promoteValue(context, prevValue);\n            let t = 0;\n            switch (expr.mode[0]) {\n                case \"discrete\":\n                    return v0;\n                case \"linear\":\n                    t = (param - prevKey) / (key - prevKey);\n                    break;\n                case \"exponential\": {\n                    const base = expr.mode[1];\n                    t =\n                        base === 1\n                            ? (param - prevKey) / (key - prevKey)\n                            : (Math.pow(base, param - prevKey) - 1) /\n                                (Math.pow(base, key - prevKey) - 1);\n                    break;\n                }\n                default:\n                    throw new Error(`interpolation mode ${JSON.stringify(expr.mode)} is not supported`);\n            }\n            const v1 = promoteValue(context, value);\n            if (typeof v0 === \"number\" && typeof v1 === \"number\") {\n                return THREE.MathUtils.lerp(v0, v1, t);\n            }\n            else if (v0 instanceof RGBA_1.RGBA && v1 instanceof RGBA_1.RGBA) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof Pixels_1.Pixels && v1 instanceof Pixels_1.Pixels) {\n                return new Pixels_1.Pixels(THREE.MathUtils.lerp(v0.value, v1.value, t));\n            }\n            else if (v0 instanceof THREE.Color && v1 instanceof THREE.Color) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof THREE.Vector2 && v1 instanceof THREE.Vector2) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof THREE.Vector3 && v1 instanceof THREE.Vector3) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof THREE.Vector4 && v1 instanceof THREE.Vector4) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {\n                return v0.map((x, i) => THREE.MathUtils.lerp(x, v1[i], t));\n            }\n            throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);\n        }\n    }\n}\nexports.ExprEvaluator = ExprEvaluator;\nExprEvaluator.defineOperators(CastOperators_1.CastOperators);\nExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);\nExprEvaluator.defineOperators(MathOperators_1.MathOperators);\nExprEvaluator.defineOperators(StringOperators_1.StringOperators);\nExprEvaluator.defineOperators(ColorOperators_1.ColorOperators);\nExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);\nExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);\nExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);\nExprEvaluator.defineOperators(ArrayOperators_1.ArrayOperators);\nExprEvaluator.defineOperators(ObjectOperators_1.ObjectOperators);\nExprEvaluator.defineOperators(FeatureOperators_1.FeatureOperators);\nExprEvaluator.defineOperators(MapOperators_1.MapOperators);\nExprEvaluator.defineOperators(VectorOperators_1.VectorOperators);\n//# sourceMappingURL=ExprEvaluator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprInstantiator = void 0;\nconst Env_1 = __webpack_require__(/*! ./Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst emptyEnv = new Env_1.Env();\n/**\n * @hidden\n */\nclass ExprInstantiator {\n    visitNullLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitBooleanLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitStringLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitVarExpr(expr, context) {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name);\n        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);\n    }\n    visitHasAttributeExpr(expr, context) {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name) !== undefined;\n        return Expr_1.LiteralExpr.fromValue(value);\n    }\n    visitCallExpr(expr, context) {\n        const args = expr.args.map(arg => arg.accept(this, context));\n        if (args.some((a, i) => a !== expr.args[i])) {\n            return new Expr_1.CallExpr(expr.op, args);\n        }\n        return expr;\n    }\n    visitMatchExpr(match, context) {\n        const value = match.value.accept(this, context);\n        if (value instanceof Expr_1.LiteralExpr) {\n            const r = value.value;\n            for (const [label, body] of match.branches) {\n                if (Array.isArray(label) && label.includes(r)) {\n                    return body.accept(this, context);\n                }\n                else if (label === r) {\n                    return body.accept(this, context);\n                }\n            }\n            return match.fallback.accept(this, context);\n        }\n        let changed = match.value !== value;\n        const branches = match.branches.map(([label, branch]) => {\n            const newBranch = branch.accept(this, context);\n            if (newBranch !== branch) {\n                changed = true;\n            }\n            return [label, newBranch];\n        });\n        const fallback = match.fallback.accept(this, context);\n        if (fallback !== match.fallback) {\n            changed = true;\n        }\n        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;\n    }\n    visitCaseExpr(expr, context) {\n        const branches = [];\n        let changed = false;\n        for (const [condition, branch] of expr.branches) {\n            const newCondition = condition.accept(this, context);\n            const deps = newCondition.dependencies();\n            if (!condition.isDynamic() && deps.properties.size === 0) {\n                if (Boolean(newCondition.evaluate(emptyEnv, Expr_1.ExprScope.Condition))) {\n                    return branch.accept(this, context);\n                }\n            }\n            else {\n                if (newCondition !== condition) {\n                    changed = true;\n                }\n                branches.push([newCondition, branch]);\n            }\n        }\n        if (branches.length === 0) {\n            // all the conditions of this CaseExpr evaluated\n            // to false, so the resulting of instantiating this CaseExpr\n            // is the same as instantiating its fallback expression.\n            return expr.fallback.accept(this, context);\n        }\n        if (branches.length !== expr.branches.length) {\n            // the number of branches changed, this means that\n            // some of the branches had constant expressions that\n            // evaluate to false. In this case the resulting\n            // `CaseExpr` has less branches.\n            changed = true;\n        }\n        // Instantiate the body of all the branches of this CaseExpr\n        // that have dynamic conditions.\n        branches.forEach(branch => {\n            const instantiatedBranch = branch[1].accept(this, context);\n            if (instantiatedBranch !== branch[1]) {\n                changed = true;\n            }\n            branch[1] = instantiatedBranch;\n        });\n        const fallback = expr.fallback.accept(this, context);\n        if (fallback !== expr.fallback) {\n            changed = true;\n        }\n        if (!changed) {\n            // nothing changed, return the old expression.\n            return expr;\n        }\n        return new Expr_1.CaseExpr(branches, fallback);\n    }\n    visitStepExpr(expr, context) {\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new Expr_1.StepExpr(input, defaultValue, stops);\n    }\n    visitInterpolateExpr(expr, context) {\n        const input = expr.input.accept(this, context);\n        const stops = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new Expr_1.InterpolateExpr(expr.mode, input, stops);\n    }\n}\nexports.ExprInstantiator = ExprInstantiator;\n//# sourceMappingURL=ExprInstantiator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprParser = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * Character value\n */\nvar Character;\n(function (Character) {\n    Character[Character[\"Tab\"] = 9] = \"Tab\";\n    Character[Character[\"Lf\"] = 10] = \"Lf\";\n    Character[Character[\"Cr\"] = 13] = \"Cr\";\n    Character[Character[\"Space\"] = 32] = \"Space\";\n    Character[Character[\"LParen\"] = 40] = \"LParen\";\n    Character[Character[\"RParen\"] = 41] = \"RParen\";\n    Character[Character[\"Comma\"] = 44] = \"Comma\";\n    Character[Character[\"Dot\"] = 46] = \"Dot\";\n    Character[Character[\"LBracket\"] = 91] = \"LBracket\";\n    Character[Character[\"Backslash\"] = 92] = \"Backslash\";\n    Character[Character[\"RBracket\"] = 93] = \"RBracket\";\n    Character[Character[\"_0\"] = 48] = \"_0\";\n    Character[Character[\"_9\"] = 57] = \"_9\";\n    Character[Character[\"_\"] = 95] = \"_\";\n    Character[Character[\"A\"] = 64] = \"A\";\n    Character[Character[\"Z\"] = 90] = \"Z\";\n    Character[Character[\"a\"] = 97] = \"a\";\n    Character[Character[\"z\"] = 122] = \"z\";\n    Character[Character[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    Character[Character[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    Character[Character[\"Exclaim\"] = 33] = \"Exclaim\";\n    Character[Character[\"Equal\"] = 61] = \"Equal\";\n    Character[Character[\"Caret\"] = 94] = \"Caret\";\n    Character[Character[\"Tilde\"] = 126] = \"Tilde\";\n    Character[Character[\"Dollar\"] = 36] = \"Dollar\";\n    Character[Character[\"Less\"] = 60] = \"Less\";\n    Character[Character[\"Greater\"] = 62] = \"Greater\";\n    Character[Character[\"Bar\"] = 124] = \"Bar\";\n    Character[Character[\"Amp\"] = 38] = \"Amp\";\n})(Character || (Character = {}));\n/**\n * Check if a codepoint is a whitespace character.\n */\nfunction isSpace(codepoint) {\n    switch (codepoint) {\n        case Character.Tab:\n        case Character.Lf:\n        case Character.Cr:\n        case Character.Space:\n            return true;\n        default:\n            return false;\n    } // switch\n}\n/**\n * Check if codepoint is a digit character.\n */\nfunction isNumber(codepoint) {\n    return codepoint >= Character._0 && codepoint <= Character._9;\n}\n/**\n * Check if codepoint is a letter character.\n */\nfunction isLetter(codepoint) {\n    return ((codepoint >= Character.a && codepoint <= Character.z) ||\n        (codepoint >= Character.A && codepoint <= Character.Z));\n}\n/**\n * Check if codepoint is either a digit or a letter character.\n */\nfunction isLetterOrNumber(codepoint) {\n    return isLetter(codepoint) || isNumber(codepoint);\n}\n/**\n * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.\n */\nfunction isIdentChar(codepoint) {\n    return (isLetterOrNumber(codepoint) ||\n        codepoint === Character._ ||\n        codepoint === Character.Dollar ||\n        codepoint === Character.Dot ||\n        codepoint === Character.LBracket ||\n        codepoint === Character.RBracket);\n}\n/**\n * Tokens used in theme grammar.\n */\nvar Token;\n(function (Token) {\n    Token[Token[\"Eof\"] = 0] = \"Eof\";\n    Token[Token[\"Error\"] = 1] = \"Error\";\n    Token[Token[\"Identifier\"] = 2] = \"Identifier\";\n    Token[Token[\"Number\"] = 3] = \"Number\";\n    Token[Token[\"String\"] = 4] = \"String\";\n    Token[Token[\"Comma\"] = 5] = \"Comma\";\n    Token[Token[\"LParen\"] = 6] = \"LParen\";\n    Token[Token[\"RParen\"] = 7] = \"RParen\";\n    Token[Token[\"LBracket\"] = 8] = \"LBracket\";\n    Token[Token[\"RBracket\"] = 9] = \"RBracket\";\n    Token[Token[\"Exclaim\"] = 10] = \"Exclaim\";\n    Token[Token[\"TildeEqual\"] = 11] = \"TildeEqual\";\n    Token[Token[\"CaretEqual\"] = 12] = \"CaretEqual\";\n    Token[Token[\"DollarEqual\"] = 13] = \"DollarEqual\";\n    Token[Token[\"EqualEqual\"] = 14] = \"EqualEqual\";\n    Token[Token[\"ExclaimEqual\"] = 15] = \"ExclaimEqual\";\n    Token[Token[\"Less\"] = 16] = \"Less\";\n    Token[Token[\"Greater\"] = 17] = \"Greater\";\n    Token[Token[\"LessEqual\"] = 18] = \"LessEqual\";\n    Token[Token[\"GreaterEqual\"] = 19] = \"GreaterEqual\";\n    Token[Token[\"BarBar\"] = 20] = \"BarBar\";\n    Token[Token[\"AmpAmp\"] = 21] = \"AmpAmp\";\n})(Token || (Token = {}));\n/**\n * Maps a token to its string name.\n */\nfunction tokenSpell(token) {\n    switch (token) {\n        case Token.Eof:\n            return \"eof\";\n        case Token.Error:\n            return \"error\";\n        case Token.Identifier:\n            return \"identifier\";\n        case Token.Number:\n            return \"number\";\n        case Token.String:\n            return \"string\";\n        case Token.Comma:\n            return \",\";\n        case Token.LParen:\n            return \"(\";\n        case Token.RParen:\n            return \")\";\n        case Token.LBracket:\n            return \"[\";\n        case Token.RBracket:\n            return \"]\";\n        case Token.Exclaim:\n            return \"!\";\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        case Token.BarBar:\n            return \"||\";\n        case Token.AmpAmp:\n            return \"&&\";\n        default:\n            throw new Error(`invalid token ${token}`);\n    }\n}\n/**\n * Lexer class implementation.\n */\nclass Lexer {\n    constructor(code) {\n        this.code = code;\n        this.m_token = Token.Error;\n        this.m_index = 0;\n        this.m_char = Character.Lf;\n    }\n    /**\n     * Single lexer token.\n     */\n    token() {\n        return this.m_token;\n    }\n    /**\n     * Parsed text.\n     */\n    text() {\n        var _a;\n        return (_a = this.m_text) !== null && _a !== void 0 ? _a : \"\";\n    }\n    /**\n     * Go to the next token.\n     */\n    next() {\n        this.m_token = this.yylex();\n        if (this.m_token === Token.Error) {\n            throw new Error(`unexpected character ${this.m_char}`);\n        }\n        return this.m_token;\n    }\n    yyinp() {\n        var _a;\n        this.m_char = (_a = this.code.codePointAt(this.m_index++)) !== null && _a !== void 0 ? _a : 0;\n    }\n    yylex() {\n        this.m_text = undefined;\n        while (isSpace(this.m_char)) {\n            this.yyinp();\n        }\n        if (this.m_char === 0) {\n            return Token.Eof;\n        }\n        const ch = this.m_char;\n        this.yyinp();\n        switch (ch) {\n            case Character.LParen:\n                return Token.LParen;\n            case Character.RParen:\n                return Token.RParen;\n            case Character.LBracket:\n                return Token.LBracket;\n            case Character.RBracket:\n                return Token.RBracket;\n            case Character.Comma:\n                return Token.Comma;\n            case Character.SingleQuote:\n            case Character.DoubleQuote: {\n                const start = this.m_index - 1;\n                while (this.m_char && this.m_char !== ch) {\n                    // ### TODO handle escape sequences\n                    this.yyinp();\n                }\n                if (this.m_char !== ch) {\n                    throw new Error(\"Unfinished string literal\");\n                }\n                this.yyinp();\n                this.m_text = this.code.substring(start, this.m_index - 2);\n                return Token.String;\n            }\n            case Character.Exclaim:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.ExclaimEqual;\n                }\n                return Token.Exclaim;\n            case Character.Caret:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.CaretEqual;\n                }\n                return Token.Error;\n            case Character.Tilde:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.TildeEqual;\n                }\n                return Token.Error;\n            case Character.Equal:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.EqualEqual;\n                }\n                return Token.Error;\n            case Character.Less:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.LessEqual;\n                }\n                return Token.Less;\n            case Character.Greater:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.GreaterEqual;\n                }\n                return Token.Greater;\n            case Character.Bar:\n                if (this.m_char === Character.Bar) {\n                    this.yyinp();\n                    return Token.BarBar;\n                }\n                return Token.Error;\n            case Character.Amp:\n                if (this.m_char === Character.Amp) {\n                    this.yyinp();\n                    return Token.AmpAmp;\n                }\n                return Token.Error;\n            default: {\n                const start = this.m_index - 2;\n                if (isLetter(ch) ||\n                    ch === Character._ ||\n                    (ch === Character.Dollar && isIdentChar(this.m_char))) {\n                    while (isIdentChar(this.m_char)) {\n                        this.yyinp();\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Identifier;\n                }\n                else if (isNumber(ch)) {\n                    while (isNumber(this.m_char)) {\n                        this.yyinp();\n                    }\n                    if (this.m_char === Character.Dot) {\n                        this.yyinp();\n                        while (isNumber(this.m_char)) {\n                            this.yyinp();\n                        }\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Number;\n                }\n                else if (ch === Character.Dollar) {\n                    if (this.m_char === Character.Equal) {\n                        this.yyinp();\n                        return Token.DollarEqual;\n                    }\n                    return Token.Error;\n                }\n            }\n        }\n        return Token.Error;\n    }\n}\nfunction getEqualityOp(token) {\n    switch (token) {\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        default:\n            return undefined;\n    } // switch\n}\nfunction getRelationalOp(token) {\n    switch (token) {\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        default:\n            return undefined;\n    } // switch\n}\nclass ExprParser {\n    constructor(code) {\n        this.lex = new Lexer(code);\n        this.lex.next();\n    }\n    parse() {\n        return this.parseLogicalOr();\n    }\n    yyexpect(token) {\n        if (this.lex.token() !== token) {\n            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +\n                `found '${tokenSpell(this.lex.token())}'`);\n        }\n        this.lex.next();\n    }\n    parsePrimary() {\n        switch (this.lex.token()) {\n            case Token.Identifier: {\n                const text = this.lex.text();\n                switch (text) {\n                    case \"has\":\n                        this.lex.next(); // skip has keyword\n                        this.yyexpect(Token.LParen);\n                        const hasAttribute = this.lex.text();\n                        this.yyexpect(Token.Identifier);\n                        this.yyexpect(Token.RParen);\n                        return new Expr_1.HasAttributeExpr(hasAttribute);\n                    case \"length\":\n                        this.lex.next(); // skip length keyword\n                        this.yyexpect(Token.LParen);\n                        const value = this.parseLogicalOr();\n                        this.yyexpect(Token.RParen);\n                        return new Expr_1.CallExpr(\"length\", [value]);\n                    default:\n                        const expr = new Expr_1.VarExpr(text);\n                        this.lex.next();\n                        return expr;\n                }\n            }\n            case Token.LParen: {\n                this.lex.next();\n                const expr = this.parseLogicalOr();\n                this.yyexpect(Token.RParen);\n                return expr;\n            }\n            default:\n                return this.parseLiteral();\n        } // switch\n    }\n    parseLiteral() {\n        switch (this.lex.token()) {\n            case Token.Number: {\n                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));\n                this.lex.next();\n                return expr;\n            }\n            case Token.String: {\n                const expr = new Expr_1.StringLiteralExpr(this.lex.text());\n                this.lex.next();\n                return expr;\n            }\n            default:\n                throw new Error(\"Syntax error\");\n        } // switch\n    }\n    parseUnary() {\n        if (this.lex.token() === Token.Exclaim) {\n            this.lex.next();\n            return new Expr_1.CallExpr(\"!\", [this.parseUnary()]);\n        }\n        return this.parsePrimary();\n    }\n    parseRelational() {\n        let expr = this.parseUnary();\n        while (true) {\n            if (this.lex.token() === Token.Identifier && this.lex.text() === \"in\") {\n                this.lex.next();\n                this.yyexpect(Token.LBracket);\n                const elements = [this.parseLiteral()];\n                while (this.lex.token() === Token.Comma) {\n                    this.lex.next();\n                    elements.push(this.parseLiteral());\n                }\n                this.yyexpect(Token.RBracket);\n                expr = new Expr_1.CallExpr(\"in\", [\n                    expr,\n                    Expr_1.LiteralExpr.fromValue(elements.map(({ value }) => value))\n                ]);\n            }\n            else {\n                const op = getRelationalOp(this.lex.token());\n                if (op === undefined) {\n                    break;\n                }\n                this.lex.next();\n                const right = this.parseUnary();\n                expr = new Expr_1.CallExpr(op, [expr, right]);\n            }\n        }\n        return expr;\n    }\n    parseEquality() {\n        let expr = this.parseRelational();\n        while (true) {\n            let op = getEqualityOp(this.lex.token());\n            if (op === undefined) {\n                break;\n            }\n            if (op === \"~=\") {\n                op = \"in\";\n            }\n            this.lex.next();\n            const right = this.parseRelational();\n            expr = new Expr_1.CallExpr(op, [expr, right]);\n        }\n        return expr;\n    }\n    parseLogicalAnd() {\n        const expr = this.parseEquality();\n        if (this.lex.token() !== Token.AmpAmp) {\n            return expr;\n        }\n        const expressions = [expr];\n        do {\n            this.lex.next();\n            expressions.push(this.parseEquality());\n        } while (this.lex.token() === Token.AmpAmp);\n        return new Expr_1.CallExpr(\"all\", expressions);\n    }\n    parseLogicalOr() {\n        const expr = this.parseLogicalAnd();\n        if (this.lex.token() !== Token.BarBar) {\n            return expr;\n        }\n        const expressions = [expr];\n        do {\n            this.lex.next();\n            expressions.push(this.parseLogicalAnd());\n        } while (this.lex.token() === Token.BarBar);\n        return new Expr_1.CallExpr(\"any\", expressions);\n    }\n}\nexports.ExprParser = ExprParser;\n//# sourceMappingURL=ExprParser.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprPool = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.\n *\n * @hidden\n */\nclass ExprPool {\n    constructor() {\n        this.m_booleanLiterals = new Map();\n        this.m_numberLiterals = new Map();\n        this.m_stringLiterals = new Map();\n        this.m_objectLiterals = new Map();\n        this.m_arrayLiterals = [];\n        this.m_varExprs = new Map();\n        this.m_hasAttributeExprs = new Map();\n        this.m_matchExprs = [];\n        this.m_caseExprs = [];\n        this.m_interpolateExprs = [];\n        this.m_stepExprs = [];\n        this.m_callExprs = new Map();\n    }\n    /**\n     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}\n     * object that is structurally equivalent to `expr`.\n     *\n     * @param expr - The {@link Expr} to add to this [[ExprPool]].\n     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.\n     */\n    add(expr) {\n        return expr.accept(this, undefined);\n    }\n    visitNullLiteralExpr(expr, context) {\n        return Expr_1.NullLiteralExpr.instance;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        const e = this.m_booleanLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_booleanLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        const e = this.m_numberLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_numberLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitStringLiteralExpr(expr, context) {\n        const e = this.m_stringLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_stringLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        const e = this.m_objectLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        if (Array.isArray(expr.value)) {\n            const array = expr.value;\n            const r = this.m_arrayLiterals.find(literal => {\n                const elements = literal.value;\n                if (elements.length !== array.length) {\n                    return false;\n                }\n                return array.every((x, i) => x === elements[i]);\n            });\n            if (r !== undefined) {\n                return r;\n            }\n            this.m_arrayLiterals.push(expr);\n        }\n        this.m_objectLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitVarExpr(expr, context) {\n        const e = this.m_varExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_varExprs.set(expr.name, expr);\n        return expr;\n    }\n    visitHasAttributeExpr(expr, context) {\n        const e = this.m_hasAttributeExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_hasAttributeExprs.set(expr.name, expr);\n        return expr;\n    }\n    visitMatchExpr(expr, context) {\n        const value = expr.value.accept(this, context);\n        const branches = expr.branches.map(([label, body]) => [\n            label,\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        for (const candidate of this.m_matchExprs) {\n            if (candidate.value !== value) {\n                continue;\n            }\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n        const r = new Expr_1.MatchExpr(value, branches, fallback);\n        this.m_matchExprs.push(r);\n        return r;\n    }\n    visitCaseExpr(expr, context) {\n        const branches = expr.branches.map(([condition, body]) => [\n            condition.accept(this, context),\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        for (const candidate of this.m_caseExprs) {\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n        const r = new Expr_1.CaseExpr(branches, fallback);\n        this.m_caseExprs.push(r);\n        return r;\n    }\n    visitCallExpr(expr, context) {\n        // rewrite the actual arguments\n        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));\n        // ensure we have a valid set of interned expressions for the calls\n        if (!this.m_callExprs.has(expr.op)) {\n            this.m_callExprs.set(expr.op, []);\n        }\n        // get the calls for the given operator.\n        const calls = this.m_callExprs.get(expr.op);\n        for (const call of calls) {\n            // check the number of arguments\n            if (call.args.length !== expressions.length) {\n                continue;\n            }\n            // find the index of the first mismatch.\n            let index = 0;\n            for (; index < call.args.length; ++index) {\n                if (call.args[index] !== expressions[index]) {\n                    break;\n                }\n            }\n            if (index === call.args.length) {\n                // no mismatch found, return the 'interned' call.\n                return call;\n            }\n        }\n        const e = new Expr_1.CallExpr(expr.op, expressions);\n        e.descriptor = expr.descriptor;\n        calls.push(e);\n        return e;\n    }\n    visitStepExpr(expr, context) {\n        if (this.m_stepExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const step of this.m_stepExprs) {\n            if (step.input === input &&\n                step.defaultValue === defaultValue &&\n                stops.length === step.stops.length &&\n                stops.every(([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1])) {\n                return step;\n            }\n        }\n        const e = new Expr_1.StepExpr(input, defaultValue, stops);\n        this.m_stepExprs.push(e);\n        return e;\n    }\n    visitInterpolateExpr(expr, context) {\n        if (this.m_interpolateExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const stops = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const interp of this.m_interpolateExprs) {\n            if (interp.input === input &&\n                interp.mode[0] === expr.mode[0] &&\n                interp.mode[1] === expr.mode[1] &&\n                stops.length === interp.stops.length &&\n                stops.every(([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1])) {\n                return interp;\n            }\n        }\n        const e = new Expr_1.InterpolateExpr(expr.mode, input, stops);\n        this.m_interpolateExprs.push(e);\n        return e;\n    }\n}\nexports.ExprPool = ExprPool;\n//# sourceMappingURL=ExprPool.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=GeoJsonDataType.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IMeshBuffers.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ITileDecoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ITiler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ITiler.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ITiler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ITiler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.interpolatedPropertyDefinitionToJsonExpr = exports.isInterpolatedPropertyDefinition = exports.InterpolationMode = void 0;\n/**\n * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.\n * @internal\n */\nvar InterpolationMode;\n(function (InterpolationMode) {\n    InterpolationMode[InterpolationMode[\"Discrete\"] = 0] = \"Discrete\";\n    InterpolationMode[InterpolationMode[\"Linear\"] = 1] = \"Linear\";\n    InterpolationMode[InterpolationMode[\"Cubic\"] = 2] = \"Cubic\";\n    InterpolationMode[InterpolationMode[\"Exponential\"] = 3] = \"Exponential\";\n})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));\n/**\n * Checks if a property is interpolated.\n * @param p - property to be checked\n * @internal\n */\nfunction isInterpolatedPropertyDefinition(p) {\n    if (p &&\n        p.interpolationMode === undefined &&\n        Array.isArray(p.values) &&\n        p.values.length > 0 &&\n        p.values[0] !== undefined &&\n        Array.isArray(p.zoomLevels) &&\n        p.zoomLevels.length > 0 &&\n        p.zoomLevels[0] !== undefined &&\n        p.values.length === p.zoomLevels.length) {\n        return true;\n    }\n    return false;\n}\nexports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;\n/**\n * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].\n *\n * @param property - A valid [[InterpolatedPropertyDefinition]]\n */\nfunction interpolatedPropertyDefinitionToJsonExpr(property) {\n    if (property.interpolation === undefined || property.interpolation === \"Discrete\") {\n        const step = [\"step\", [\"zoom\"], property.values[0]];\n        for (let i = 1; i < property.zoomLevels.length; ++i) {\n            step.push(property.zoomLevels[i], property.values[i]);\n        }\n        return step;\n    }\n    const interpolation = [\"interpolate\"];\n    switch (property.interpolation) {\n        case \"Linear\":\n            interpolation.push([\"linear\"]);\n            break;\n        case \"Cubic\":\n            interpolation.push([\"cubic\"]);\n            break;\n        case \"Exponential\":\n            interpolation.push([\n                \"exponential\",\n                property.exponent !== undefined ? property.exponent : 2\n            ]);\n            break;\n        default:\n            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);\n    } //switch\n    interpolation.push([\"zoom\"]);\n    for (let i = 0; i < property.zoomLevels.length; ++i) {\n        interpolation.push(property.zoomLevels[i], property.values[i]);\n    }\n    return interpolation;\n}\nexports.interpolatedPropertyDefinitionToJsonExpr = interpolatedPropertyDefinitionToJsonExpr;\n//# sourceMappingURL=InterpolatedPropertyDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Outliner.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Outliner.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addPolygonEdges = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst currEdgeStart = new THREE.Vector2();\nconst currEdgeGoal = new THREE.Vector2();\nconst prevEdgeStart = new THREE.Vector2();\nconst prevEdgeGoal = new THREE.Vector2();\n/**\n * Fills an index buffer with the indices for the edges of a polygon contour.\n *\n * @param indexBuffer - Edge index buffer to be filled.\n * @param vertexOffset - Starting offset of the vertices composing the contour.\n * @param vertexStride - Number of elements per contour vertex.\n * @param polygonContour - Vertices that compose the contour.\n * @param polygonContourEdges - Collection of booleans indicating if contour edges should be added.\n */\nfunction addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {\n    for (let i = 0; i < polygonContourEdges.length; ++i) {\n        if (polygonContourEdges[i]) {\n            if (isExtruded === true) {\n                const vFootprint0 = vertexOffset + i * 2;\n                const vRoof0 = vFootprint0 + 1;\n                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;\n                const vRoof1 = vFootprint1 + 1;\n                if (addFootprintEdges === true) {\n                    indexBuffer.push(vFootprint0, vFootprint1);\n                }\n                indexBuffer.push(vRoof0, vRoof1);\n                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;\n                if (polygonContourEdges[prevEdgeIdx]) {\n                    if (wallEdgeSlope !== undefined) {\n                        const v0x = polygonContour[i * vertexStride];\n                        const v0y = polygonContour[i * vertexStride + 1];\n                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];\n                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];\n                        currEdgeStart.set(v0x, v0y);\n                        currEdgeGoal.set(v1x, v1y);\n                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);\n                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);\n                        if (prevEdgeGoal\n                            .sub(prevEdgeStart)\n                            .normalize()\n                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {\n                            indexBuffer.push(vFootprint0, vRoof0);\n                        }\n                    }\n                    else {\n                        indexBuffer.push(vFootprint0, vRoof0);\n                    }\n                }\n            }\n            else {\n                const vFoot0 = vertexOffset + i;\n                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);\n                indexBuffer.push(vFoot0, vRoof0);\n            }\n        }\n    }\n}\nexports.addPolygonEdges = addPolygonEdges;\n//# sourceMappingURL=Outliner.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Outliner.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Pixels.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Pixels.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pixels = void 0;\nconst RX = /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/;\n/**\n * A class representing Pixels.\n *\n * @hidden\n * @internal\n */\nclass Pixels {\n    /**\n     * Constructs a [[Pixels]] literal\n     *\n     * @param value - The number of pixels.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Parses a pixel string literal.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text) {\n        const match = RX.exec(text);\n        if (match === null) {\n            return undefined;\n        }\n        return new Pixels(Number(match[1]));\n    }\n    toJSON() {\n        return `${this.value}px`;\n    }\n}\nexports.Pixels = Pixels;\n//# sourceMappingURL=Pixels.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Pixels.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=PostEffects.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPropertyValue = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst Pixels_1 = __webpack_require__(/*! ./Pixels */ \"./node_modules/@here/harp-datasource-protocol/lib/Pixels.js\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PropertyValue\");\n/**\n * Get the value of the specified property in given `env`.\n *\n * @param property - Property of a technique.\n * @param env - The {@link Env} used to evaluate the property\n * @param cache - An optional expression cache.\n */\nfunction getPropertyValue(property, env, cache) {\n    var _a, _b, _c;\n    if (Expr_1.Expr.isExpr(property)) {\n        try {\n            let r = property.evaluate(env, Expr_1.ExprScope.Dynamic, cache);\n            if (typeof r === \"string\") {\n                r = (_b = (_a = RGBA_1.RGBA.parse(r)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(r)) !== null && _b !== void 0 ? _b : r;\n            }\n            if (r instanceof RGBA_1.RGBA) {\n                return r.getHex();\n            }\n            else if (r instanceof Pixels_1.Pixels) {\n                return r.value * ((_c = Number(env.lookup(\"$pixelToMeters\"))) !== null && _c !== void 0 ? _c : 1);\n            }\n            return r;\n        }\n        catch (error) {\n            logger.error(\"failed to evaluate expression\", JSON.stringify(property), \"error\", String(error));\n            return null;\n        }\n    }\n    if (property === null || typeof property === \"undefined\") {\n        return null;\n    }\n    else if (typeof property !== \"string\") {\n        // Property in numeric or array, etc. format\n        return property;\n    }\n    else {\n        // Non-interpolated string encoded numeral parsing\n        const pixelToMeters = env.lookup(\"$pixelToMeters\") || 1;\n        const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);\n        return value !== undefined ? value : property;\n    }\n}\nexports.getPropertyValue = getPropertyValue;\n//# sourceMappingURL=PropertyValue.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/RGBA.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RGBA = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\n/**\n * A class representing RGBA colors.\n *\n * @hidden\n * @internal\n */\nclass RGBA {\n    /**\n     * Constructs a [[RGBA]] color using the given components in the [0..1] range.\n     */\n    constructor(r = 1, g = 1, b = 1, a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    /**\n     * Parses a string describing a color.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text) {\n        const color = StringEncodedNumeral_1.parseStringEncodedColor(text);\n        if (color === undefined) {\n            return undefined;\n        }\n        return ColorUtils_1.ColorUtils.getRgbaFromHex(color);\n    }\n    /**\n     * Clones this [[RGBA]] color.\n     */\n    clone() {\n        return new RGBA(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Returns this color encoded as one single number.\n     */\n    getHex() {\n        return ColorUtils_1.ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Linearly interpolate the components of this color.\n     */\n    lerp(target, t) {\n        this.r = three_1.MathUtils.lerp(this.r, target.r, t);\n        this.g = three_1.MathUtils.lerp(this.g, target.g, t);\n        this.b = three_1.MathUtils.lerp(this.b, target.b, t);\n        this.a = three_1.MathUtils.lerp(this.a, target.a, t);\n        return this;\n    }\n    /**\n     * Returns this color encoded as JSON literal.\n     */\n    toJSON() {\n        return `rgba(${(this.r * 255) << 0}, ${(this.g * 255) << 0}, ${(this.b * 255) << 0}, ${this.a})`;\n    }\n}\nexports.RGBA = RGBA;\n//# sourceMappingURL=RGBA.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/RGBA.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseStringEncodedColor = exports.parseStringEncodedNumeral = exports.StringEncodedNumeralFormatMaxSize = exports.StringEncodedNumeralFormats = exports.StringEncodedColorFormats = exports.StringEncodedMetricFormats = exports.StringEncodedNumeralType = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n//@ts-ignore\nconst csscolorparser_1 = __webpack_require__(/*! csscolorparser */ \"./node_modules/csscolorparser/csscolorparser.js\");\nconst ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\n/**\n * Enumeration of supported string encoded numerals.\n * @internal\n */\nvar StringEncodedNumeralType;\n(function (StringEncodedNumeralType) {\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Meters\"] = 0] = \"Meters\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Pixels\"] = 1] = \"Pixels\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Hex\"] = 2] = \"Hex\";\n})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));\nconst StringEncodedMeters = {\n    type: StringEncodedNumeralType.Meters,\n    size: 1,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))m$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedMeters.regExp.exec(encodedValue);\n        return match ? (target[0] = Number(match[1])) !== undefined : false;\n    }\n};\nconst StringEncodedPixels = {\n    type: StringEncodedNumeralType.Pixels,\n    size: 1,\n    mask: 1.0,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedPixels.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        target[0] = Number(match[1]);\n        return true;\n    }\n};\nconst StringEncodedHex = {\n    type: StringEncodedNumeralType.Hex,\n    size: 4,\n    regExp: /^\\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedHex.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        const hex = match[1];\n        const size = hex.length;\n        // Only few sizes are possible for given reg-exp.\n        harp_utils_1.assert(size === 4 || size === 8, `Matched incorrect hex color format`);\n        // Note that we simply ignore alpha channel value.\n        // TODO: To be resolved with HARP-7517\n        if (size === 4) {\n            // #RGB or #RGBA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;\n        }\n        else if (size === 8) {\n            // #RRGGBB or #RRGGBBAA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;\n        }\n        return true;\n    }\n};\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.\n * @internal\n */\nexports.StringEncodedMetricFormats = [\n    StringEncodedMeters,\n    StringEncodedPixels\n];\nconst StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.\n * @internal\n */\nexports.StringEncodedColorFormats = [StringEncodedHex];\nconst StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);\n/**\n * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with\n * [[StringEncodedNumeralType]] enum).\n * @internal\n */\nexports.StringEncodedNumeralFormats = [\n    ...exports.StringEncodedMetricFormats,\n    ...exports.StringEncodedColorFormats\n];\n/**\n * @internal\n */\nexports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);\nconst tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);\n/**\n * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].\n *\n * @param numeral - The string representing numeric value.\n * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).\n * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression\n * provided in [[numeral]].\n */\nfunction parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {\n    return parseStringLiteral(numeral, exports.StringEncodedNumeralFormats, pixelToMeters);\n}\nexports.parseStringEncodedNumeral = parseStringEncodedNumeral;\n/**\n * Parse string encoded color value using all known [[StringEncodedColorFormats]].\n *\n * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).\n * @returns The color parsed or __undefined__ if non of the known representations matches\n * the expression provided in [[color]].\n */\nfunction parseStringEncodedColor(color) {\n    return parseStringLiteral(color, exports.StringEncodedColorFormats);\n}\nexports.parseStringEncodedColor = parseStringEncodedColor;\nfunction parseStringLiteral(text, formats, pixelToMeters = 1.0) {\n    const matchedFormat = formats.find(format => {\n        return format.decoder(text, tmpBuffer) ? true : false;\n    });\n    if (matchedFormat === undefined) {\n        const components = csscolorparser_1.parseCSSColor(text);\n        return Array.isArray(components) && !components.some(c => isNaN(c))\n            ? ColorUtils_1.ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3])\n            : undefined;\n    }\n    switch (matchedFormat === null || matchedFormat === void 0 ? void 0 : matchedFormat.type) {\n        case StringEncodedNumeralType.Pixels:\n            return tmpBuffer[0] * pixelToMeters;\n        case StringEncodedNumeralType.Hex:\n            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);\n        default:\n            return tmpBuffer[0];\n    }\n}\n//# sourceMappingURL=StringEncodedNumeral.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeDecodedTechnique = exports.StyleSetEvaluator = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst ExprPool_1 = __webpack_require__(/*! ./ExprPool */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst TechniqueDescriptors_1 = __webpack_require__(/*! ./TechniqueDescriptors */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js\");\nconst Techniques_1 = __webpack_require__(/*! ./Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"StyleSetEvaluator\");\nconst DEFAULT_TECHNIQUE_ATTR_SCOPE = TechniqueDescriptors_1.AttrScope.TechniqueGeometry;\n/**\n * Get the attribute scope of the given style property.\n *\n * @remarks\n * Certain Style properties change their dynamic scope behavior\n * based on other properties. For example, the `color` property\n * of `extruded-polygon` change behavior based on the usage\n * of `vertexColors`.\n *\n * @param style A valid Style.\n * @param attrName The name of the attribute of the {@link style}.\n */\nfunction getStyleAttributeScope(style, attrName) {\n    var _a, _b;\n    if (style.technique === \"extruded-polygon\") {\n        if (attrName === \"color\" && style.vertexColors !== false) {\n            return DEFAULT_TECHNIQUE_ATTR_SCOPE;\n        }\n    }\n    return ((_b = (_a = TechniqueDescriptors_1.getTechniqueAttributeDescriptor(style.technique, attrName)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : DEFAULT_TECHNIQUE_ATTR_SCOPE);\n}\n/**\n * `StyleConditionClassifier` searches for usages of `$layer` in `when` conditions\n * associated with styling rules.\n *\n * @hidden\n */\nclass StyleConditionClassifier {\n    classify(style) {\n        if (style._whenExpr) {\n            const savedStyle = this.switchStyle(style);\n            style._whenExpr = style._whenExpr.accept(this, undefined);\n            this._style = savedStyle;\n        }\n    }\n    visitNullLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitBooleanLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitStringLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitVarExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitHasAttributeExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitMatchExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitCaseExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitCallExpr(call, enclosingExpr) {\n        if (call.op === \"all\") {\n            // processing of an `[\"all\", e1, e2, ... eN]` expression. In this case\n            // search for expressions matching comparison of `$layer` and string literals\n            // in the sub expressions.\n            const children = call.args\n                .map(childExpr => childExpr.accept(this, call))\n                .filter(childExpr => childExpr !== undefined);\n            return new Expr_1.CallExpr(call.op, children);\n        }\n        else if (enclosingExpr) {\n            // `call` is a direct child expression of an `\"all\"` operator.\n            const matched = this.matchVarStringComparison(call);\n            if (matched) {\n                if (this._style.layer === undefined && matched.name === \"$layer\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$layer\"], \"some layer name\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $layer in\n                    // [[StyleInternalParams]].\n                    this._style.layer = matched.value;\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n                else if (this._style._geometryType === undefined &&\n                    matched.name === \"$geometryType\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$geometryType\"], \"geometry\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $geometryType in\n                    // [[StyleInternalParams]].\n                    this._style._geometryType = matched.value;\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n            }\n        }\n        return call;\n    }\n    visitStepExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitInterpolateExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    /**\n     * Tests if the given `call` matches the structure [\"==\", [\"get\", name], value].\n     * If a match is found returns an object containing the `name` and the `value`;\n     *\n     * @param call - The expression to match.\n     */\n    matchVarStringComparison(call) {\n        if (call.op === \"==\") {\n            const left = call.args[0];\n            const right = call.args[1];\n            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {\n                return { name: left.name, value: right.value };\n            }\n            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {\n                return { name: right.name, value: left.value };\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Sets the given `style` as current.\n     *\n     * @returns The previous `style`.\n     */\n    switchStyle(style) {\n        const saved = this._style;\n        this._style = style;\n        return saved;\n    }\n}\nclass OptimizedSubSetKey {\n    constructor(layer, geometryType) {\n        this.key = \"\";\n        this.set(layer, geometryType);\n    }\n    set(layer, geometryType, env) {\n        let keyUpdateNeeded = false;\n        if (layer === undefined) {\n            const envLayer = env !== undefined ? env.lookup(\"$layer\") : undefined;\n            layer = typeof envLayer === \"string\" ? envLayer : undefined;\n        }\n        if (this.layer !== layer) {\n            this.layer = layer;\n            keyUpdateNeeded = true;\n        }\n        if (geometryType === undefined) {\n            const envGeometryType = env !== undefined ? env.lookup(\"$geometryType\") : undefined;\n            geometryType = typeof envGeometryType === \"string\" ? envGeometryType : undefined;\n        }\n        if (this.geometryType !== geometryType) {\n            this.geometryType = geometryType;\n            keyUpdateNeeded = true;\n        }\n        if (keyUpdateNeeded) {\n            this.updateKey();\n        }\n        return this;\n    }\n    updateKey() {\n        if (this.layer !== undefined) {\n            if (this.geometryType !== undefined) {\n                this.key = `${this.layer}:${this.geometryType}`;\n            }\n            else {\n                this.key = `${this.layer}:`;\n            }\n        }\n        else {\n            if (this.geometryType !== undefined) {\n                this.key = `:${this.geometryType}`;\n            }\n            else {\n                this.key = \"all\";\n            }\n        }\n        this.cachedStyleSet = undefined;\n    }\n}\n/**\n * Combine data from datasource and apply the rules from a specified theme to show it on the map.\n */\nclass StyleSetEvaluator {\n    constructor(m_options) {\n        this.m_options = m_options;\n        this.m_techniques = [];\n        this.m_exprPool = new ExprPool_1.ExprPool();\n        this.m_cachedResults = new Map();\n        this.m_styleConditionClassifier = new StyleConditionClassifier();\n        this.m_subStyleSetCache = new Map();\n        this.m_definitionExprCache = new Map();\n        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();\n        this.m_emptyEnv = new Expr_1.Env();\n        this.m_featureDependencies = [];\n        this.m_definitions = this.m_options.definitions;\n        this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);\n        computeDefaultRenderOrder(this.styleSet);\n        this.compileStyleSet();\n    }\n    /**\n     * Find all techniques that fit the current objects' environment.\n     * *The techniques in the resulting array may not be modified* since they are being reused for\n     * identical objects.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     * representation.\n     * @param layer - The optional layer name used to filter techniques.\n     * @param geometryType - The optional geometryType used to filter techniques.\n     */\n    getMatchingTechniques(env, layer, geometryType) {\n        if (this.m_previousResult &&\n            this.m_previousEnv &&\n            this.m_featureDependencies.every(p => { var _a; return ((_a = this.m_previousEnv) === null || _a === void 0 ? void 0 : _a.lookup(p)) === env.lookup(p); })) {\n            return this.m_previousResult;\n        }\n        const result = [];\n        this.m_cachedResults.clear();\n        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;\n        optimizedSubSetKey.set(layer, geometryType, env);\n        // get the requested $layer and $geometryType, if any.\n        this.m_layer = optimizedSubSetKey.layer;\n        this.m_geometryType = optimizedSubSetKey.geometryType;\n        this.m_zoomLevel = env.lookup(\"$zoom\");\n        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);\n        for (const currStyle of searchedStyleSet) {\n            if (this.processStyle(env, currStyle, result)) {\n                break;\n            }\n        }\n        this.m_previousResult = result;\n        this.m_previousEnv = env;\n        return result;\n    }\n    /**\n     * Check if `styleSet` contains any rule related to `layer`.\n     *\n     * @param layer - name of layer\n     */\n    wantsLayer(layer) {\n        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);\n    }\n    /**\n     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.\n     *\n     * @param layer - name of layer\n     * @param geometryType - type of layer - `point`, `line` or `polygon`\n     */\n    wantsFeature(layer, geometryType) {\n        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))\n            .length > 0);\n    }\n    /**\n     * Get the expression evaluation cache, for further feature processing.\n     *\n     * This object is valid until next `getMatchingTechniques` call.\n     */\n    get expressionEvaluatorCache() {\n        return this.m_cachedResults;\n    }\n    /**\n     * Reset array of techniques.\n     *\n     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.\n     */\n    resetTechniques() {\n        for (const techinque of this.m_techniques) {\n            techinque._index = undefined;\n        }\n        this.m_techniques.length = 0;\n        this.m_previousResult = undefined;\n        this.m_previousEnv = undefined;\n    }\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get techniques() {\n        return this.m_techniques;\n    }\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get decodedTechniques() {\n        return this.m_techniques.map(makeDecodedTechnique);\n    }\n    getOptimizedStyleSet(subSetKey) {\n        if (subSetKey.cachedStyleSet !== undefined) {\n            return subSetKey.cachedStyleSet;\n        }\n        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);\n        if (optimizedStyleSet !== undefined) {\n            subSetKey.cachedStyleSet = optimizedStyleSet;\n            return optimizedStyleSet;\n        }\n        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);\n        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);\n        subSetKey.cachedStyleSet = optimizedStyleSet;\n        return optimizedStyleSet;\n    }\n    createPreFilteredStyleSet(subSetKey) {\n        const { layer, geometryType } = subSetKey;\n        return this.styleSet.filter(style => {\n            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {\n                return false;\n            }\n            if (geometryType !== undefined &&\n                style._geometryType !== undefined &&\n                style._geometryType !== geometryType) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * Compile the `when` conditions found when traversting the styling rules.\n     */\n    compileStyleSet() {\n        this.m_featureDependencies = [\"$layer\", \"$geometryType\", \"$zoom\"];\n        this.styleSet.forEach(style => this.compileStyle(style));\n        // Create optimized styleSets for each `layer` & `geometryType` tuple.\n        this.styleSet.forEach(style => {\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));\n        });\n    }\n    /**\n     * Compile the `when` conditions reachable from the given `style`.\n     *\n     * @param style - The current style.\n     */\n    compileStyle(style) {\n        this.checkStyleDynamicAttributes(style);\n        if (style.when !== undefined) {\n            try {\n                style._whenExpr = Array.isArray(style.when)\n                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)\n                    : Expr_1.Expr.parse(style.when);\n                // search for usages of '$layer' and any other\n                // special symbol that can be used to speed up the evaluation\n                // of the `when` conditions associated to this `style`.\n                this.m_styleConditionClassifier.classify(style);\n                if (style._whenExpr !== undefined) {\n                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);\n                }\n                const deps = style._whenExpr.dependencies();\n                deps === null || deps === void 0 ? void 0 : deps.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n                if (Expr_1.isJsonExpr(style.minZoomLevel)) {\n                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel).intern(this.m_exprPool);\n                }\n                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {\n                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel).intern(this.m_exprPool);\n                }\n            }\n            catch (err) {\n                logger.log(\"failed to evaluate expression\", JSON.stringify(style.when), \"error\", String(err));\n            }\n        }\n    }\n    /**\n     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the\n     * current objects' environment. The attributes of the styles are assembled to create a unique\n     * technique for every object.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     *            representation.\n     * @param style - Current style (could also be top of stack).\n     * @param result - The array of resulting techniques. There may be more than one technique per\n     *               object, resulting in multiple graphical objects for representation.\n     * @returns `true` if style has been found and processing is finished. `false` if not found, or\n     *          more than one technique should be applied.\n     */\n    processStyle(env, style, result) {\n        if (!this.checkZoomLevel(env, style)) {\n            return false;\n        }\n        if (this.m_layer !== undefined &&\n            style.layer !== undefined &&\n            style.layer !== this.m_layer) {\n            return false;\n        }\n        if (this.m_geometryType !== undefined &&\n            style._geometryType !== undefined &&\n            style._geometryType !== this.m_geometryType) {\n            return false;\n        }\n        if (style._whenExpr) {\n            try {\n                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {\n                    // Stop processing this styling rule. The `when` condition\n                    // associated with the current `style` evaluates to false so\n                    // no techinque defined by this style should be applied.\n                    return false;\n                }\n            }\n            catch (error) {\n                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);\n                return false;\n            }\n        }\n        if (style.technique === undefined) {\n            return false;\n        }\n        // we found a technique!\n        if (style.technique !== \"none\") {\n            result.push(this.getTechniqueForStyleMatch(env, style));\n        }\n        // stop processing if \"final\" is set\n        return style.final === true;\n    }\n    checkZoomLevel(env, style) {\n        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {\n            return true;\n        }\n        const zoomLevel = this.m_zoomLevel;\n        if (zoomLevel === undefined) {\n            return true;\n        }\n        if (style.minZoomLevel !== undefined) {\n            let minZoomLevel = style.minZoomLevel;\n            if (style._minZoomLevelExpr) {\n                // the constraint is defined as expression, evaluate it and\n                // use its value\n                try {\n                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);\n                }\n                catch (error) {\n                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);\n                }\n            }\n            if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n                return false;\n            }\n        }\n        if (style.maxZoomLevel !== undefined) {\n            let maxZoomLevel = style.maxZoomLevel;\n            if (style._maxZoomLevelExpr) {\n                try {\n                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);\n                }\n                catch (error) {\n                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);\n                }\n            }\n            if (typeof maxZoomLevel === \"number\" && zoomLevel >= maxZoomLevel) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getTechniqueForStyleMatch(env, style) {\n        let technique;\n        if (style._dynamicTechniques !== undefined) {\n            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);\n            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);\n            technique = style._dynamicTechniques.get(key);\n            if (technique === undefined) {\n                technique = this.createTechnique(style, key, dynamicAttributes);\n                style._dynamicTechniques.set(key, technique);\n            }\n        }\n        else {\n            technique = style._staticTechnique;\n            if (technique === undefined) {\n                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);\n            }\n        }\n        if (technique._index === undefined) {\n            technique._index = this.m_techniques.length;\n            this.m_techniques.push(technique);\n        }\n        return technique;\n    }\n    getDynamicTechniqueKey(style, dynamicAttributes) {\n        const dynamicAttrKey = dynamicAttributes\n            .map(([_attrName, attrValue]) => {\n            if (attrValue === undefined) {\n                return \"U\";\n            }\n            else {\n                return JSON.stringify(attrValue);\n            }\n        })\n            .join(\":\");\n        return `${style._styleSetIndex}:${dynamicAttrKey}`;\n    }\n    checkStyleDynamicAttributes(style) {\n        var _a;\n        if (style._dynamicTechniqueAttributes !== undefined || style.technique === \"none\") {\n            return;\n        }\n        style._dynamicTechniqueAttributes = [];\n        style._dynamicFeatureAttributes = [];\n        style._dynamicForwardedAttributes = [];\n        style._staticAttributes = [];\n        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;\n        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;\n        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;\n        const targetStaticAttributes = style._staticAttributes;\n        const processAttribute = (attrName, attrValue) => {\n            if (attrValue === undefined) {\n                return;\n            }\n            if (Expr_1.isJsonExpr(attrValue)) {\n                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);\n            }\n            else if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(attrValue)) {\n                // found a property using an object-like interpolation definition.\n                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);\n            }\n            if (Expr_1.Expr.isExpr(attrValue)) {\n                const deps = attrValue.dependencies();\n                if (deps.featureState) {\n                    if (attrName !== \"enabled\") {\n                        logger.log(\"feature-state is not supported in this context\");\n                    }\n                    else {\n                        style._usesFeatureState = true;\n                    }\n                }\n                if (deps.properties.size === 0 && !attrValue.isDynamic()) {\n                    // no data-dependencies detected.\n                    attrValue = attrValue.evaluate(this.m_emptyEnv);\n                }\n            }\n            if (Expr_1.Expr.isExpr(attrValue)) {\n                const attrScope = getStyleAttributeScope(style, attrName);\n                const deps = attrValue.dependencies();\n                deps.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n                switch (attrScope) {\n                    case TechniqueDescriptors_1.AttrScope.FeatureGeometry:\n                        dynamicFeatureAttributes.push([attrName, attrValue]);\n                        break;\n                    case TechniqueDescriptors_1.AttrScope.TechniqueGeometry:\n                        dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        break;\n                    case TechniqueDescriptors_1.AttrScope.TechniqueRendering:\n                        if (deps.properties.size === 0) {\n                            dynamicForwardedAttributes.push([attrName, attrValue]);\n                        }\n                        else {\n                            dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        }\n                        break;\n                }\n            }\n            else if (attrValue !== undefined && attrValue !== null) {\n                targetStaticAttributes.push([attrName, attrValue]);\n            }\n        };\n        const replacement = new Map([\n            [\"category\", \"_category\"],\n            [\"secondaryCategory\", \"_secondaryCategory\"]\n        ]);\n        for (const p in style) {\n            if (!style.hasOwnProperty(p)) {\n                continue;\n            }\n            if (p.startsWith(\"_\")) {\n                continue;\n            }\n            if ([\"when\", \"technique\", \"layer\", \"attr\", \"description\"].includes(p)) {\n                continue;\n            }\n            const pp = (_a = replacement.get(p)) !== null && _a !== void 0 ? _a : p;\n            processAttribute(pp, style[p]);\n        }\n        if (style.attr !== undefined) {\n            for (const attrName in style.attr) {\n                if (!style.attr.hasOwnProperty(attrName)) {\n                    continue;\n                }\n                processAttribute(attrName, style.attr[attrName]);\n            }\n        }\n        if (dynamicTechniqueAttributes.length > 0) {\n            style._dynamicTechniques = new Map();\n        }\n    }\n    evaluateTechniqueProperties(style, env) {\n        if (style._dynamicTechniqueAttributes === undefined) {\n            return [];\n        }\n        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {\n            try {\n                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);\n                return [attrName, evaluatedValue];\n            }\n            catch (error) {\n                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);\n                return [attrName, null];\n            }\n        });\n    }\n    createTechnique(style, key, dynamicAttrs) {\n        var _a, _b;\n        const technique = {};\n        technique.name = style.technique;\n        if (style._staticAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._staticAttributes) {\n                if (attrValue !== null) {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        for (const [attrName, attrValue] of dynamicAttrs) {\n            if (attrValue !== null) {\n                technique[attrName] = attrValue;\n            }\n        }\n        if (style._dynamicFeatureAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n        if (style._dynamicForwardedAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n        technique._index = this.m_techniques.length;\n        technique._styleSetIndex = style._styleSetIndex;\n        if (style.styleSet !== undefined) {\n            technique._styleSet = style.styleSet;\n        }\n        if (style._usesFeatureState !== undefined) {\n            technique._usesFeatureState = style._usesFeatureState;\n        }\n        Techniques_1.setTechniqueRenderOrderOrPriority(technique, (_a = this.m_options.priorities) !== null && _a !== void 0 ? _a : [], (_b = this.m_options.labelPriorities) !== null && _b !== void 0 ? _b : []);\n        this.m_techniques.push(technique);\n        return technique;\n    }\n}\nexports.StyleSetEvaluator = StyleSetEvaluator;\nfunction computeDefaultRenderOrder(styleSet) {\n    let techniqueRenderOrder = 0;\n    let styleSetIndex = 0;\n    for (const style of styleSet) {\n        style._styleSetIndex = styleSetIndex++;\n        if (style.technique !== undefined && style.renderOrder === undefined) {\n            style.renderOrder = techniqueRenderOrder++;\n        }\n    }\n}\nfunction resolveReferences(styleSet, definitions) {\n    return styleSet.map(style => resolveStyleReferences(style, definitions));\n}\nfunction resolveStyleReferences(style, definitions) {\n    return Object.assign({}, style);\n}\n/**\n * Create transferable representation of dynamic technique.\n *\n * Converts  non-transferable {@link Expr}instances back to JSON form.\n */\nfunction makeDecodedTechnique(technique) {\n    const result = {};\n    for (const attrName in technique) {\n        if (!technique.hasOwnProperty(attrName)) {\n            continue;\n        }\n        let attrValue = technique[attrName];\n        if (typeof attrValue === \"object\" &&\n            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {\n            attrValue = Expr_1.LiteralExpr.fromValue(attrValue);\n        }\n        if (Expr_1.Expr.isExpr(attrValue)) {\n            attrValue = attrValue.toJSON();\n        }\n        result[attrName] = attrValue;\n    }\n    return result;\n}\nexports.makeDecodedTechnique = makeDecodedTechnique;\n//# sourceMappingURL=StyleSetEvaluator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.evaluateTechniqueAttr = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst PropertyValue_1 = __webpack_require__(/*! ./PropertyValue */ \"./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js\");\nfunction evaluateTechniqueAttr(context, attrValue, defaultValue) {\n    if (attrValue === undefined) {\n        return defaultValue;\n    }\n    const result = Expr_1.Env.isEnv(context)\n        ? PropertyValue_1.getPropertyValue(attrValue, context)\n        : PropertyValue_1.getPropertyValue(attrValue, context.env, context.cachedExprResults);\n    return result !== null && result !== void 0 ? result : defaultValue;\n}\nexports.evaluateTechniqueAttr = evaluateTechniqueAttr;\n//# sourceMappingURL=TechniqueAttr.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTechniqueAutomaticAttrs = exports.getTechniqueAttributeDescriptor = exports.getTechniqueDescriptor = exports.AttrScope = void 0;\nvar AttrScope;\n(function (AttrScope) {\n    /**\n     * Attributes that affect generation of feature geometry and thus must be resolved at decoding\n     * time.\n     *\n     * @remarks\n     * They may have huge variancy as they are implemented as vertex attributes or embedded in\n     * generated meshes.\n     *\n     * These attributes are available only in decoding scope.\n     */\n    AttrScope[AttrScope[\"FeatureGeometry\"] = 0] = \"FeatureGeometry\";\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * These attributes affect generated geometry and  thus must be resolved at decoding time.\n     *\n     * @remarks\n     * They shouldn't have big variancy and evaluate to at least dozens of values as each\n     * combination of these attributes consitute new technique and material.\n     *\n     * These attributes are available in decoding and rendering scope.\n     */\n    AttrScope[AttrScope[\"TechniqueGeometry\"] = 1] = \"TechniqueGeometry\";\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     *\n     * @remarks\n     * Attributes that can be changed in resulting object/material from frame to frame. They are\n     * usually implemented as uniforms.\n     *\n     * These attributes may be available only at rendering scope.\n     */\n    AttrScope[AttrScope[\"TechniqueRendering\"] = 2] = \"TechniqueRendering\";\n})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));\n/**\n * @internal\n */\nfunction mergeTechniqueDescriptor(...descriptors) {\n    const result = {\n        attrDescriptors: {}\n    };\n    for (const descriptor of descriptors) {\n        if (descriptor.attrTransparencyColor !== undefined) {\n            result.attrTransparencyColor = descriptor.attrTransparencyColor;\n        }\n        if (descriptor.attrDescriptors !== undefined) {\n            result.attrDescriptors = Object.assign(Object.assign({}, result.attrDescriptors), descriptor.attrDescriptors);\n        }\n    }\n    return result;\n}\nconst baseTechniqueParamsDescriptor = {\n    // TODO: Choose which techniques should support color with transparency.\n    // For now we chosen all, but it maybe not suitable for text or line marker techniques.\n    attrTransparencyColor: \"color\",\n    attrDescriptors: {\n        enabled: AttrScope.FeatureGeometry,\n        fadeFar: AttrScope.TechniqueRendering,\n        fadeNear: AttrScope.TechniqueRendering,\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        side: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n};\nconst pointTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        size: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n});\nconst squaresTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);\nconst circlesTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);\nconst lineMarkerTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        text: AttrScope.FeatureGeometry,\n        label: AttrScope.FeatureGeometry,\n        useAbbreviation: AttrScope.FeatureGeometry,\n        useIsoCode: AttrScope.FeatureGeometry,\n        poiName: AttrScope.FeatureGeometry,\n        imageTexture: AttrScope.FeatureGeometry,\n        iconColor: AttrScope.TechniqueRendering,\n        iconBrightness: AttrScope.TechniqueRendering,\n        backgroundColor: AttrScope.TechniqueRendering,\n        backgroundSize: AttrScope.TechniqueRendering,\n        backgroundOpacity: AttrScope.TechniqueRendering,\n        color: AttrScope.TechniqueRendering,\n        opacity: AttrScope.TechniqueRendering,\n        size: AttrScope.TechniqueRendering\n    }\n});\nconst polygonalTechniqueDescriptor = {\n    attrDescriptors: {\n        polygonOffset: { scope: AttrScope.TechniqueRendering, automatic: true },\n        polygonOffsetFactor: { scope: AttrScope.TechniqueRendering, automatic: true },\n        polygonOffsetUnits: { scope: AttrScope.TechniqueRendering, automatic: true },\n        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineColor: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering\n    }\n};\nconst solidLineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {\n    attrDescriptors: {\n        lineWidth: AttrScope.TechniqueRendering,\n        secondaryWidth: AttrScope.TechniqueRendering,\n        secondaryColor: AttrScope.TechniqueRendering,\n        dashSize: AttrScope.TechniqueRendering,\n        gapSize: AttrScope.TechniqueRendering,\n        outlineColor: { scope: AttrScope.TechniqueRendering, automatic: true },\n        caps: { scope: AttrScope.TechniqueRendering, automatic: true },\n        drawRangeStart: { scope: AttrScope.TechniqueRendering, automatic: true },\n        drawRangeEnd: { scope: AttrScope.TechniqueRendering, automatic: true },\n        dashes: { scope: AttrScope.TechniqueRendering, automatic: true },\n        dashColor: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n});\nconst lineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        // TODO, check, which are really dynamic !\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineWidth: AttrScope.FeatureGeometry\n    }\n});\nconst fillTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {\n    attrDescriptors: {\n        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineWidth: AttrScope.TechniqueRendering\n    }\n});\nconst standardTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        color: AttrScope.FeatureGeometry,\n        vertexColors: { scope: AttrScope.TechniqueRendering, automatic: true },\n        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },\n        roughness: { scope: AttrScope.TechniqueRendering, automatic: true },\n        metalness: { scope: AttrScope.TechniqueRendering, automatic: true },\n        alphaTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        emissive: { scope: AttrScope.TechniqueRendering, automatic: true },\n        emissiveIntensity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        refractionRatio: { scope: AttrScope.TechniqueRendering, automatic: true },\n        normalMapType: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n});\nconst extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {\n    attrDescriptors: {\n        height: AttrScope.FeatureGeometry,\n        floorHeight: AttrScope.FeatureGeometry,\n        color: AttrScope.FeatureGeometry,\n        defaultColor: AttrScope.FeatureGeometry,\n        defaultHeight: AttrScope.FeatureGeometry,\n        constantHeight: AttrScope.FeatureGeometry,\n        boundaryWalls: AttrScope.FeatureGeometry,\n        footprint: AttrScope.FeatureGeometry,\n        maxSlope: AttrScope.FeatureGeometry,\n        animateExtrusion: AttrScope.TechniqueRendering,\n        lineWidth: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineColor: AttrScope.TechniqueRendering\n    }\n});\nconst textTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        text: AttrScope.FeatureGeometry,\n        label: AttrScope.FeatureGeometry,\n        useAbbreviation: AttrScope.FeatureGeometry,\n        useIsoCode: AttrScope.FeatureGeometry,\n        backgroundColor: AttrScope.TechniqueRendering,\n        backgroundSize: AttrScope.TechniqueRendering,\n        backgroundOpacity: AttrScope.TechniqueRendering,\n        color: AttrScope.TechniqueRendering,\n        opacity: AttrScope.TechniqueRendering,\n        priority: AttrScope.TechniqueRendering,\n        size: AttrScope.TechniqueRendering\n    }\n});\nconst shaderTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        params: AttrScope.TechniqueRendering\n    }\n});\nconst techniqueDescriptors = {\n    \"extruded-polygon\": extrudedPolygonTechniqueDescriptor,\n    \"line-marker\": lineMarkerTechniquePropTypes,\n    \"labeled-icon\": lineMarkerTechniquePropTypes,\n    \"solid-line\": solidLineTechniqueDescriptor,\n    \"dashed-line\": solidLineTechniqueDescriptor,\n    terrain: standardTechniqueDescriptor,\n    standard: standardTechniqueDescriptor,\n    squares: squaresTechniquePropTypes,\n    circles: circlesTechniquePropTypes,\n    line: lineTechniqueDescriptor,\n    segments: lineTechniqueDescriptor,\n    fill: fillTechniqueDescriptor,\n    text: textTechniqueDescriptor,\n    shader: shaderTechniqueDescriptor\n};\nfunction getTechniqueDescriptor(technique) {\n    if (typeof technique !== \"string\") {\n        technique = technique.name;\n    }\n    return techniqueDescriptors[technique];\n}\nexports.getTechniqueDescriptor = getTechniqueDescriptor;\nfunction getTechniqueAttributeDescriptor(technique, attrName) {\n    const techniqueDescriptor = getTechniqueDescriptor(technique);\n    const attrDescriptors = techniqueDescriptor === null || techniqueDescriptor === void 0 ? void 0 : techniqueDescriptor.attrDescriptors;\n    const descriptor = attrDescriptors === null || attrDescriptors === void 0 ? void 0 : attrDescriptors[attrName];\n    if (typeof descriptor === undefined) {\n        return undefined;\n    }\n    else if (typeof descriptor === \"object\") {\n        return descriptor;\n    }\n    return { scope: descriptor };\n}\nexports.getTechniqueAttributeDescriptor = getTechniqueAttributeDescriptor;\nconst automaticAttributeCache = new Map();\nfunction getTechniqueAutomaticAttrs(technique) {\n    var _a;\n    if (typeof technique !== \"string\") {\n        technique = technique.name;\n    }\n    if (automaticAttributeCache.has(technique)) {\n        return automaticAttributeCache.get(technique);\n    }\n    const descriptors = [];\n    const attrDescriptors = (_a = getTechniqueDescriptor(technique)) === null || _a === void 0 ? void 0 : _a.attrDescriptors;\n    if (attrDescriptors === undefined) {\n        return descriptors;\n    }\n    for (const attrName in attrDescriptors) {\n        if (!attrDescriptors.hasOwnProperty(attrName)) {\n            continue;\n        }\n        const descr = attrDescriptors[attrName];\n        if (descr === undefined || typeof descr === \"number\") {\n            continue;\n        }\n        if (descr.automatic === true) {\n            descriptors.push(attrName);\n        }\n    }\n    automaticAttributeCache.set(technique, descriptors);\n    return descriptors;\n}\nexports.getTechniqueAutomaticAttrs = getTechniqueAutomaticAttrs;\n//# sourceMappingURL=TechniqueDescriptors.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTextureBuffer = exports.PlacementToken = exports.PoiStackMode = exports.TextureCoordinateType = exports.GeometryKindSet = exports.GeometryKind = exports.StandardGeometryKind = void 0;\n/**\n * Standard kinds of geometry.\n */\nvar StandardGeometryKind;\n(function (StandardGeometryKind) {\n    /**\n     * Used in the enabledKinds/disabledKinds filter to match any kind.\n     */\n    StandardGeometryKind[\"All\"] = \"_all_\";\n    /**\n     * Background geometry.\n     */\n    StandardGeometryKind[\"Background\"] = \"background\";\n    /**\n     * Terrain geometry.\n     */\n    StandardGeometryKind[\"Terrain\"] = \"terrain\";\n    /**\n     * Default value for the FillTechnique.\n     */\n    StandardGeometryKind[\"Area\"] = \"area\";\n    /**\n     * Default value for all line techniques.\n     */\n    StandardGeometryKind[\"Line\"] = \"line\";\n    /**\n     * Default value for the FillTechnique.\n     */\n    StandardGeometryKind[\"Water\"] = \"water\";\n    /**\n     * Political borders.\n     */\n    StandardGeometryKind[\"Border\"] = \"border\";\n    /**\n     * Basis for all roads.\n     */\n    StandardGeometryKind[\"Road\"] = \"road\";\n    /**\n     * Default value for the ExtrudedPolygonTechnique.\n     */\n    StandardGeometryKind[\"Building\"] = \"building\";\n    /**\n     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.\n     */\n    StandardGeometryKind[\"Label\"] = \"label\";\n    /**\n     * Anything that may show up last.\n     */\n    StandardGeometryKind[\"Detail\"] = \"detail\";\n})(StandardGeometryKind = exports.StandardGeometryKind || (exports.StandardGeometryKind = {}));\n// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexports.GeometryKind = StandardGeometryKind;\n/**\n * A set of {@link GeometryKind}s.\n */\nclass GeometryKindSet extends Set {\n    /**\n     * Return `true` if the Set is a superset of the set 'subset'.\n     */\n    isSuperset(subset) {\n        for (const elem of subset) {\n            if (!this.has(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Return `true` if the Set intersects Set 'set'.\n     */\n    hasIntersection(set) {\n        for (const elem of set) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'\n     * if set is not a Set.\n     */\n    hasOrIntersects(set) {\n        if (set instanceof Set) {\n            return this.hasIntersection(set);\n        }\n        return this.has(set);\n    }\n    /**\n     * Return `true` if this set and the array of elements share at least a single element.\n     */\n    hasOrIntersectsArray(subset) {\n        for (const elem of subset) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.GeometryKindSet = GeometryKindSet;\nvar TextureCoordinateType;\n(function (TextureCoordinateType) {\n    /**\n     * Texture coordinates are in tile space.\n     *\n     * @remarks\n     * SW of the tile will have (0,0) and NE will have (1,1).\n     */\n    TextureCoordinateType[\"TileSpace\"] = \"tile-space\";\n    /**\n     * Texture coordinates are in equirectangular space.\n     *\n     * @remarks\n     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).\n     */\n    TextureCoordinateType[\"EquirectangularSpace\"] = \"equirectangular-space\";\n    /**\n     * Texture coordinates in feature space.\n     *\n     * @remarks\n     * To compute texture coordinates in feature space,\n     * the feature must have a property named `bbox` with value\n     * the tuple `[west, south, east, north]`.\n     */\n    TextureCoordinateType[\"FeatureSpace\"] = \"feature-space\";\n})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));\n/**\n * Define the stacking option. Enum values for theme file are in \"kebab-case\".\n */\nvar PoiStackMode;\n(function (PoiStackMode) {\n    /**\n     * Show in a stack.\n     */\n    PoiStackMode[\"Show\"] = \"show-in-stack\";\n    /**\n     * Do not show in a stack.\n     */\n    PoiStackMode[\"Hide\"] = \"hide-in-stack\";\n    /**\n     * Show category parent in the stack.\n     */\n    PoiStackMode[\"ShowParent\"] = \"show-parent\";\n})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));\n/**\n * Defines options (tokens) supported for text placements defined via [[placements]] attribute.\n *\n * @remarks\n * Possible values are defined as vertical placement letter and horizontal letter, where\n * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:\n * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),\n * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).\n * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:\n * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),\n * `SW` (south-west), `W` (west).\n */\nvar PlacementToken;\n(function (PlacementToken) {\n    PlacementToken[\"TopLeft\"] = \"TL\";\n    PlacementToken[\"Top\"] = \"T\";\n    PlacementToken[\"TopRight\"] = \"TR\";\n    PlacementToken[\"Right\"] = \"R\";\n    PlacementToken[\"BottomRight\"] = \"BR\";\n    PlacementToken[\"Bottom\"] = \"B\";\n    PlacementToken[\"BottomLeft\"] = \"BL\";\n    PlacementToken[\"Left\"] = \"L\";\n    PlacementToken[\"Center\"] = \"C\";\n    PlacementToken[\"NorthWest\"] = \"NW\";\n    PlacementToken[\"North\"] = \"N\";\n    PlacementToken[\"NorthEast\"] = \"NE\";\n    PlacementToken[\"East\"] = \"E\";\n    PlacementToken[\"SouthEast\"] = \"SE\";\n    PlacementToken[\"South\"] = \"S\";\n    PlacementToken[\"SouthWest\"] = \"SW\";\n    PlacementToken[\"West\"] = \"W\";\n})(PlacementToken = exports.PlacementToken || (exports.PlacementToken = {}));\n/**\n * Type guard to check if an object is an instance of `TextureBuffer`.\n */\nfunction isTextureBuffer(object) {\n    return object && object.buffer && typeof object.type === \"string\";\n}\nexports.isTextureBuffer = isTextureBuffer;\n//# sourceMappingURL=TechniqueParams.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Techniques.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setTechniqueRenderOrderOrPriority = exports.composeTechniqueTextureName = exports.addBuffersToTransferList = exports.textureCoordinateType = exports.needsVertexNormals = exports.isLabelRejectionLineTechnique = exports.isShaderTechnique = exports.isTextTechnique = exports.isTerrainTechnique = exports.isStandardTechnique = exports.isExtrudedPolygonTechnique = exports.isFillTechnique = exports.isStandardExtrudedLineTechnique = exports.isBasicExtrudedLineTechnique = exports.isExtrudedLineTechnique = exports.isSegmentsTechnique = exports.isSpecialDashesLineTechnique = exports.isSolidLineTechnique = exports.isLineTechnique = exports.isLineMarkerTechnique = exports.isPoiTechnique = exports.isSquaresTechnique = exports.isCirclesTechnique = exports.TRANSPARENCY_PROPERTY_KEYS = exports.TEXTURE_PROPERTY_KEYS = void 0;\nconst TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js\");\n/**\n * Names of the supported texture properties.\n * @internal\n */\nexports.TEXTURE_PROPERTY_KEYS = [\n    \"map\",\n    \"normalMap\",\n    \"displacementMap\",\n    \"roughnessMap\",\n    \"emissiveMap\",\n    \"alphaMap\",\n    \"metalnessMap\",\n    \"bumpMap\"\n];\n/**\n * Names of the properties controlling transparency.\n * @internal\n */\nexports.TRANSPARENCY_PROPERTY_KEYS = [\"opacity\", \"transparent\"];\n/**\n * Type guard to check if an object is an instance of `CirclesTechnique`.\n */\nfunction isCirclesTechnique(technique) {\n    return technique.name === \"circles\";\n}\nexports.isCirclesTechnique = isCirclesTechnique;\n/**\n * Type guard to check if an object is an instance of `SquaresTechnique`.\n */\nfunction isSquaresTechnique(technique) {\n    return technique.name === \"squares\";\n}\nexports.isSquaresTechnique = isSquaresTechnique;\n/**\n * Type guard to check if an object is an instance of `PoiTechnique`.\n */\nfunction isPoiTechnique(technique) {\n    return technique.name === \"labeled-icon\";\n}\nexports.isPoiTechnique = isPoiTechnique;\n/**\n * Type guard to check if an object is an instance of `LineMarkerTechnique`.\n */\nfunction isLineMarkerTechnique(technique) {\n    return technique.name === \"line-marker\";\n}\nexports.isLineMarkerTechnique = isLineMarkerTechnique;\n/**\n * Type guard to check if an object is an instance of `LineTechnique`.\n */\nfunction isLineTechnique(technique) {\n    return technique.name === \"line\";\n}\nexports.isLineTechnique = isLineTechnique;\n/**\n * Type guard to check if an object is an instance of `SolidLineTechnique`.\n */\nfunction isSolidLineTechnique(technique) {\n    return technique.name === \"solid-line\" || technique.name === \"dashed-line\";\n}\nexports.isSolidLineTechnique = isSolidLineTechnique;\n/**\n * Type guard to check if an object is an instance of `SolidLineTechnique` and is a kind that\n * has special dashes.\n * @note Lines with special dashes need line caps to render properly.\n */\nfunction isSpecialDashesLineTechnique(technique) {\n    return ((technique.name === \"solid-line\" || technique.name === \"dashed-line\") &&\n        technique.dashes !== undefined &&\n        technique.dashes !== \"Square\");\n}\nexports.isSpecialDashesLineTechnique = isSpecialDashesLineTechnique;\n/**\n * Type guard to check if an object is an instance of `SegmentsTechnique`.\n */\nfunction isSegmentsTechnique(technique) {\n    return technique.name === \"segments\";\n}\nexports.isSegmentsTechnique = isSegmentsTechnique;\n/**\n * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`\n * or `StandardExtrudedLineTechnique`.\n */\nfunction isExtrudedLineTechnique(technique) {\n    return technique.name === \"extruded-line\";\n}\nexports.isExtrudedLineTechnique = isExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`.\n */\nfunction isBasicExtrudedLineTechnique(technique) {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"basic\";\n}\nexports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of `StandardExtrudedLineTechnique`.\n */\nfunction isStandardExtrudedLineTechnique(technique) {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"standard\";\n}\nexports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of `FillTechnique`.\n */\nfunction isFillTechnique(technique) {\n    return technique.name === \"fill\";\n}\nexports.isFillTechnique = isFillTechnique;\n/**\n * Type guard to check if an object is an instance of `ExtrudedPolygonTechnique`.\n */\nfunction isExtrudedPolygonTechnique(technique) {\n    return technique.name === \"extruded-polygon\";\n}\nexports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;\n/**\n * Type guard to check if an object is an instance of `StandardTechnique`.\n */\nfunction isStandardTechnique(technique) {\n    return technique.name === \"standard\";\n}\nexports.isStandardTechnique = isStandardTechnique;\n/**\n * Type guard to check if an object is an instance of `TerrainTechnique`.\n */\nfunction isTerrainTechnique(technique) {\n    return technique.name === \"terrain\";\n}\nexports.isTerrainTechnique = isTerrainTechnique;\n/**\n * Type guard to check if an object is an instance of `TextTechnique`.\n */\nfunction isTextTechnique(technique) {\n    return technique.name === \"text\";\n}\nexports.isTextTechnique = isTextTechnique;\n/**\n * Type guard to check if an object is an instance of `ShaderTechnique`.\n */\nfunction isShaderTechnique(technique) {\n    return technique.name === \"shader\";\n}\nexports.isShaderTechnique = isShaderTechnique;\nfunction isLabelRejectionLineTechnique(technique) {\n    return technique.name === \"label-rejection-line\";\n}\nexports.isLabelRejectionLineTechnique = isLabelRejectionLineTechnique;\n/**\n * Check if vertex normals should be generated for this technique (if no normals are in the data).\n * @param technique - Technique to check.\n */\nfunction needsVertexNormals(technique) {\n    return (isExtrudedPolygonTechnique(technique) ||\n        isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isStandardExtrudedLineTechnique(technique));\n}\nexports.needsVertexNormals = needsVertexNormals;\n/**\n * Get the texture coordinate type if the technique supports it.\n */\nfunction textureCoordinateType(technique) {\n    if (isStandardTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isExtrudedPolygonTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isTerrainTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isShaderTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.textureCoordinateType = textureCoordinateType;\n/**\n * Add all the buffers of the technique to the transfer list.\n */\nfunction addBuffersToTransferList(technique, transferList) {\n    if (isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)) {\n        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {\n            const textureProperty = technique[texturePropertyKey];\n            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {\n                if (textureProperty.buffer instanceof ArrayBuffer) {\n                    transferList.push(textureProperty.buffer);\n                }\n            }\n        }\n    }\n}\nexports.addBuffersToTransferList = addBuffersToTransferList;\n/**\n * Compose full texture name for given image name with technique specified.\n * Some techniques allows to add prefix/postfix to icons names specified, this\n * function uses technique information to create fully qualified texture name.\n * @param imageName - base name of the marker icon.\n * @param technique - the technique describing POI or line marker.\n * @returns fully qualified texture name for loading from atlas (without extension).\n */\nfunction composeTechniqueTextureName(imageName, technique) {\n    let textureName = imageName;\n    if (typeof technique.imageTexturePrefix === \"string\") {\n        textureName = technique.imageTexturePrefix + textureName;\n    }\n    if (typeof technique.imageTexturePostfix === \"string\") {\n        textureName = textureName + technique.imageTexturePostfix;\n    }\n    return textureName;\n}\nexports.composeTechniqueTextureName = composeTechniqueTextureName;\n/**\n * Sets a technique's render order (or priority for screen-space techniques) depending on its\n * category and the priorities specified in a given theme.\n * @param technique- The technique whose render order or priority will be set.\n * @param theme - The theme from which the category priorities will be taken.\n */\nfunction setTechniqueRenderOrderOrPriority(technique, priorities, labelPriorities) {\n    if (isTextTechnique(technique) ||\n        isPoiTechnique(technique) ||\n        isLineMarkerTechnique(technique)) {\n        // for screen-space techniques the `category` is used to assign\n        // priorities.\n        if (labelPriorities && typeof technique._category === \"string\") {\n            // override the `priority` when the technique uses `category`.\n            const priority = labelPriorities.indexOf(technique._category);\n            if (priority !== -1) {\n                technique.priority = labelPriorities.length - priority;\n            }\n        }\n    }\n    else if (priorities && technique._styleSet !== undefined) {\n        // Compute the render order based on the style category and styleSet.\n        const computeRenderOrder = (category) => {\n            const priority = priorities === null || priorities === void 0 ? void 0 : priorities.findIndex(entry => entry.group === technique._styleSet && entry.category === category);\n            return priority !== undefined && priority !== -1 ? (priority + 1) * 10 : undefined;\n        };\n        if (typeof technique._category === \"string\") {\n            // override the renderOrder when the technique is using categories.\n            const renderOrder = computeRenderOrder(technique._category);\n            if (renderOrder !== undefined) {\n                technique.renderOrder = renderOrder;\n            }\n        }\n        if (typeof technique._secondaryCategory === \"string\") {\n            // override the secondaryRenderOrder when the technique is using categories.\n            const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);\n            if (secondaryRenderOrder !== undefined) {\n                technique.secondaryRenderOrder = secondaryRenderOrder;\n            }\n        }\n    }\n}\nexports.setTechniqueRenderOrderOrPriority = setTechniqueRenderOrderOrPriority;\n//# sourceMappingURL=Techniques.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Techniques.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Theme.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isJsonExprReference = void 0;\n/**\n * Checks if the given value is a reference to a definition.\n *\n * @param value - The value of a technique property.\n */\nfunction isJsonExprReference(value) {\n    return (Array.isArray(value) &&\n        value.length === 2 &&\n        value[0] === \"ref\" &&\n        typeof value[1] === \"string\");\n}\nexports.isJsonExprReference = isJsonExprReference;\n//# sourceMappingURL=Theme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Theme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThemeVisitor = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * The ThemeVisitor visits every style in the theme in a depth-first fashion.\n */\nclass ThemeVisitor {\n    constructor(theme) {\n        this.theme = theme;\n    }\n    /**\n     * Applies a function to every style in the theme.\n     *\n     * @param visitFunc - Function to be called with `style` as an argument. Function should return\n     *                  `true` to cancel visitation.\n     * @returns `true` if function has finished prematurely.\n     */\n    visitStyles(visitFunc) {\n        const visit = (style) => {\n            if (Expr_1.isJsonExpr(style)) {\n                return false;\n            }\n            if (visitFunc(style)) {\n                return true;\n            }\n            return false;\n        };\n        if (this.theme.styles !== undefined) {\n            for (const styleSetName in this.theme.styles) {\n                if (this.theme.styles[styleSetName] !== undefined) {\n                    for (const style of this.theme.styles[styleSetName]) {\n                        if (visit(style)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\nexports.ThemeVisitor = ThemeVisitor;\n//# sourceMappingURL=ThemeVisitor.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeBufferUtils = void 0;\nconst DecodedTile_1 = __webpack_require__(/*! ./DecodedTile */ \"./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js\");\n/**\n * Collection of helper methods to convert\n * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}\n * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.\n * See also [[CustomDatasourceExample]].\n */\nvar ThreeBufferUtils;\n(function (ThreeBufferUtils) {\n    function getBufferElementType(buffer) {\n        if (buffer instanceof Int8Array) {\n            return \"int8\";\n        }\n        else if (buffer instanceof Uint8Array) {\n            return \"uint8\";\n        }\n        else if (buffer instanceof Int16Array) {\n            return \"int16\";\n        }\n        else if (buffer instanceof Uint16Array) {\n            return \"uint16\";\n        }\n        else if (buffer instanceof Int32Array) {\n            return \"int32\";\n        }\n        else if (buffer instanceof Uint32Array) {\n            return \"uint32\";\n        }\n        else if (buffer instanceof Float32Array) {\n            return \"float\";\n        }\n        throw new Error(`Unsupported buffer type ${name}`);\n    }\n    ThreeBufferUtils.getBufferElementType = getBufferElementType;\n    function fromThreeBufferAttribute(bufferAttribute) {\n        const buffer = bufferAttribute.array;\n        return {\n            name: bufferAttribute.name,\n            buffer: buffer.buffer,\n            type: getBufferElementType(buffer),\n            itemCount: bufferAttribute.itemSize,\n            normalized: bufferAttribute.normalized\n        };\n    }\n    ThreeBufferUtils.fromThreeBufferAttribute = fromThreeBufferAttribute;\n    function fromThreeInterleavedBufferAttribute(bufferAttribute) {\n        throw new Error(\"Not implemented yet\");\n    }\n    ThreeBufferUtils.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;\n    function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {\n        const vertexAttributes = [];\n        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);\n        for (const name of attributeNames) {\n            const attribute = bufferGeometry.attributes[name];\n            // FIXME: Also support InterleavedBufferAttribute\n            const vertexAttribute = fromThreeBufferAttribute(attribute);\n            vertexAttribute.name = name;\n            vertexAttributes.push(vertexAttribute);\n        }\n        const index = bufferGeometry.index !== null\n            ? fromThreeBufferAttribute(bufferGeometry.index)\n            : undefined;\n        let count = 0;\n        if (index !== undefined) {\n            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;\n        }\n        else {\n            // If there is no index buffer, try to deduce the count from the position attribute.\n            const posAttr = bufferGeometry.attributes.position;\n            if (posAttr === undefined) {\n                throw new Error(\"Missing position attibute to deduce item count\");\n            }\n            count = posAttr.count;\n        }\n        return {\n            type: DecodedTile_1.GeometryType.Unspecified,\n            vertexAttributes,\n            index,\n            groups: [{ start: 0, count, technique: techniqueIndex }]\n        };\n    }\n    ThreeBufferUtils.fromThreeBufferGeometry = fromThreeBufferGeometry;\n})(ThreeBufferUtils = exports.ThreeBufferUtils || (exports.ThreeBufferUtils = {}));\n//# sourceMappingURL=ThreeBufferUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=TileInfo.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerDecoderProtocol = exports.RequestController = void 0;\n/**\n * Allows to cancel and prioritize requests inside the requestQueue.\n *\n * @remarks\n * Useful to optimize the order of decoding tiles during animations and camera movements.\n *\n * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.\n */\nclass RequestController {\n    /**\n     * Creates an instance of `RequestController`.\n     *\n     * @param {number} priority\n     * @param {AbortController} abortController Optional [[AbortController]] used internally, since\n     *      [[AbortController]]s should not be subclassed.\n     */\n    constructor(priority = 0, abortController = new AbortController()) {\n        this.priority = priority;\n        this.abortController = abortController;\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.RequestController = RequestController;\n/**\n * Communication protocol with [[ITileDecoder]].\n */\nvar WorkerDecoderProtocol;\n(function (WorkerDecoderProtocol) {\n    /**\n     * Define possible names of messages exchanged with decoder services within `WebWorker`.\n     */\n    let DecoderMessageName;\n    (function (DecoderMessageName) {\n        DecoderMessageName[\"Configuration\"] = \"configuration\";\n    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));\n    /**\n     * Type guard to check if an object is an instance of `ConfigurationMessage`.\n     */\n    function isConfigurationMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === DecoderMessageName.Configuration);\n    }\n    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;\n    /**\n     * Define possible names of requests called on decoder services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"DecodeTileRequest\"] = \"decode-tile-request\";\n        Requests[\"TileInfoRequest\"] = \"tile-info-request\";\n    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));\n    /**\n     * Type guard to check if an object is a decoded tile object sent to a worker.\n     */\n    function isDecodeTileRequest(message) {\n        return (message &&\n            typeof message.type === \"string\" &&\n            message.type === Requests.DecodeTileRequest);\n    }\n    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;\n    /**\n     * Type guard to check if an object is an info tile object sent to a worker.\n     */\n    function isTileInfoRequest(message) {\n        return (message && typeof message.type === \"string\" && message.type === Requests.TileInfoRequest);\n    }\n    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;\n})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));\n//# sourceMappingURL=WorkerDecoderProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerServiceProtocol = void 0;\n/**\n * Common communication protocol for [[WorkerService]].\n */\nvar WorkerServiceProtocol;\n(function (WorkerServiceProtocol) {\n    /**\n     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service\n     * instances in workers.\n     */\n    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = \"worker-service-manager\";\n    /**\n     * Define possible names of messages exchanged with services within `WebWorker`.\n     */\n    let ServiceMessageName;\n    (function (ServiceMessageName) {\n        ServiceMessageName[\"Initialized\"] = \"initialized\";\n        ServiceMessageName[\"Request\"] = \"request\";\n        ServiceMessageName[\"Response\"] = \"response\";\n    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));\n    /**\n     * Type guard to check if an object is a signal message from worker.\n     */\n    function isInitializedMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Initialized);\n    }\n    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;\n    /**\n     * Define possible names of requests called on services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"CreateService\"] = \"create-service\";\n        Requests[\"DestroyService\"] = \"destroy-service\";\n    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));\n    /**\n     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.\n     */\n    function isUnknownServiceError(error) {\n        return error.message.includes(\"unknown targetServiceType requested: \");\n    }\n    WorkerServiceProtocol.isUnknownServiceError = isUnknownServiceError;\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    function isRequestMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Request);\n    }\n    WorkerServiceProtocol.isRequestMessage = isRequestMessage;\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    function isResponseMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Response);\n    }\n    WorkerServiceProtocol.isResponseMessage = isResponseMessage;\n})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));\n//# sourceMappingURL=WorkerServiceProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerTilerProtocol = void 0;\n/**\n * Communication protocol with {@link ITiler}.\n */\nvar WorkerTilerProtocol;\n(function (WorkerTilerProtocol) {\n    /**\n     * Define possible names of requests called on tiler services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"RegisterIndex\"] = \"register-index\";\n        Requests[\"UpdateIndex\"] = \"update-index\";\n        Requests[\"TileRequest\"] = \"tile-request\";\n    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));\n    /**\n     * Type guard to check if an object is an index registration request sent to a worker.\n     */\n    function isRegisterIndexRequest(message) {\n        return (message && typeof message.type === \"string\" && message.type === Requests.RegisterIndex);\n    }\n    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;\n    /**\n     * Type guard to check if an object is an update request for the index registration.\n     */\n    function isUpdateIndexRequest(message) {\n        return message && typeof message.type === \"string\" && message.type === Requests.UpdateIndex;\n    }\n    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;\n    /**\n     * Type guard to check if an object is a tile request sent to a worker.\n     */\n    function isTileRequest(message) {\n        return message && typeof message.type === \"string\" && message.type === Requests.TileRequest;\n    }\n    WorkerTilerProtocol.isTileRequest = isTileRequest;\n})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));\n//# sourceMappingURL=WorkerTilerProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayOperators = void 0;\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst VALID_ELEMENT_TYPES = [\"boolean\", \"number\", \"string\"];\nfunction checkElementTypes(arg, array) {\n    if (!(arg instanceof Expr_1.StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {\n        throw new Error(`expected \"boolean\", \"number\" or \"string\" instead of '${JSON.stringify(arg)}'`);\n    }\n    const ty = arg.value;\n    array.forEach((element, index) => {\n        if (typeof element !== ty) {\n            throw new Error(`expected array element at index ${index} to have type '${ty}'`);\n        }\n    });\n}\nfunction checkArrayLength(arg, array) {\n    if (!(arg instanceof Expr_1.NumberLiteralExpr)) {\n        throw new Error(`missing expected number of elements`);\n    }\n    const length = arg.value;\n    if (array.length !== length) {\n        throw new Error(`the array must have ${length} element(s)`);\n    }\n}\nfunction checkArray(context, arg) {\n    const value = context.evaluate(arg);\n    if (!Array.isArray(value)) {\n        throw new Error(`'${value}' is not an array`);\n    }\n    return value;\n}\nconst operators = {\n    array: {\n        call: (context, call) => {\n            switch (call.args.length) {\n                case 0:\n                    throw new Error(\"not enough arguments\");\n                case 1:\n                    return checkArray(context, call.args[0]);\n                case 2: {\n                    const array = checkArray(context, call.args[1]);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                case 3: {\n                    const array = checkArray(context, call.args[2]);\n                    checkArrayLength(call.args[1], array);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n        }\n    },\n    \"make-array\": {\n        call: (context, call) => {\n            if (call.args.length === 0) {\n                throw new Error(\"not enough arguments\");\n            }\n            return [...call.args.map(arg => context.evaluate(arg))];\n        }\n    },\n    at: {\n        call: (context, call) => {\n            const args = call.args;\n            const index = context.evaluate(args[0]);\n            if (typeof index !== \"number\") {\n                throw new Error(`expected the index of the element to retrieve`);\n            }\n            const value = context.evaluate(args[1]);\n            if (!Array.isArray(value)) {\n                throw new Error(`expected an array`);\n            }\n            return index >= 0 && index < value.length ? value[index] : null;\n        }\n    },\n    slice: {\n        call: (context, call) => {\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            }\n            const input = context.evaluate(call.args[0]);\n            if (!(typeof input === \"string\" || Array.isArray(input))) {\n                throw new Error(\"input must be a string or an array\");\n            }\n            const start = context.evaluate(call.args[1]);\n            if (typeof start !== \"number\") {\n                throw new Error(\"expected an index\");\n            }\n            let end;\n            if (call.args.length > 2) {\n                end = context.evaluate(call.args[2]);\n                if (typeof end !== \"number\") {\n                    throw new Error(\"expected an index\");\n                }\n            }\n            return input.slice(start, end);\n        }\n    }\n};\nexports.ArrayOperators = operators;\n//# sourceMappingURL=ArrayOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CastOperators = void 0;\nconst operators = {\n    \"to-boolean\": {\n        call: (context, call) => {\n            return Boolean(context.evaluate(call.args[0]));\n        }\n    },\n    \"to-string\": {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0]));\n        }\n    },\n    \"to-number\": {\n        call: (context, call) => {\n            for (const arg of call.args) {\n                const value = Number(context.evaluate(arg));\n                if (!isNaN(value)) {\n                    return value;\n                }\n            }\n            throw new Error(\"cannot convert the value to a number\");\n        }\n    }\n};\nexports.CastOperators = operators;\n//# sourceMappingURL=CastOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorOperators = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! ../ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ../StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\nconst operators = {\n    alpha: {\n        call: (context, call) => {\n            let color = context.evaluate(call.args[0]);\n            if (typeof color === \"string\") {\n                color = StringEncodedNumeral_1.parseStringEncodedColor(color);\n            }\n            const alpha = typeof color === \"number\" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;\n            return alpha;\n        }\n    },\n    rgba: {\n        call: (context, call) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            const a = context.evaluate(call.args[3]);\n            if (typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                typeof a === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0 &&\n                a >= 0 &&\n                a <= 1) {\n                return rgbaToHex(r, g, b, a);\n            }\n            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);\n        }\n    },\n    rgb: {\n        call: (context, call) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            if (typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0) {\n                return rgbToHex(r, g, b);\n            }\n            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);\n        }\n    },\n    // Hsl operator contains angle modulated to <0, 360> range, percent of\n    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)\n    hsl: {\n        call: (context, call) => {\n            const h = context.evaluate(call.args[0]);\n            const s = context.evaluate(call.args[1]);\n            const l = context.evaluate(call.args[2]);\n            if (typeof h === \"number\" &&\n                typeof s === \"number\" &&\n                typeof l === \"number\" &&\n                h >= 0 &&\n                s >= 0 &&\n                l >= 0) {\n                return hslToHex(h, s, l);\n            }\n            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);\n        }\n    }\n};\nfunction rgbaToHex(r, g, b, a) {\n    // We decode rgba color channels using custom hex format with transparency.\n    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255, THREE.MathUtils.clamp(a, 0, 1));\n}\nfunction rgbToHex(r, g, b) {\n    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255);\n}\nfunction hslToHex(h, s, l) {\n    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.MathUtils.euclideanModulo(h, 360) / 360, THREE.MathUtils.clamp(s, 0, 100) / 100, THREE.MathUtils.clamp(l, 0, 100) / 100);\n}\nexports.ColorOperators = operators;\n//# sourceMappingURL=ColorOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComparisonOperators = void 0;\nfunction compare(context, call, strict = false) {\n    const left = context.evaluate(call.args[0]);\n    const right = context.evaluate(call.args[1]);\n    if (!((typeof left === \"number\" && typeof right === \"number\") ||\n        (typeof left === \"string\" && typeof right === \"string\"))) {\n        if (strict) {\n            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);\n        }\n    }\n    switch (call.op) {\n        case \"<\":\n            return left < right;\n        case \">\":\n            return left > right;\n        case \"<=\":\n            return left <= right;\n        case \">=\":\n            return left >= right;\n        default:\n            throw new Error(`invalid comparison operator '${call.op}'`);\n    }\n}\nconst operators = {\n    \"!\": {\n        call: (context, call) => {\n            return !context.evaluate(call.args[0]);\n        }\n    },\n    \"==\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left === right;\n        }\n    },\n    \"!=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left !== right;\n        }\n    },\n    \"<\": { call: (context, call) => compare(context, call) },\n    \">\": { call: (context, call) => compare(context, call) },\n    \"<=\": { call: (context, call) => compare(context, call) },\n    \">=\": { call: (context, call) => compare(context, call) }\n};\nexports.ComparisonOperators = operators;\n//# sourceMappingURL=ComparisonOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FeatureOperators = void 0;\nconst Env_1 = __webpack_require__(/*! ../Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst operators = {\n    \"geometry-type\": {\n        call: (context, call) => {\n            const geometryType = context.env.lookup(\"$geometryType\");\n            switch (geometryType) {\n                case \"point\":\n                    return \"Point\";\n                case \"line\":\n                    return \"LineString\";\n                case \"polygon\":\n                    return \"Polygon\";\n                default:\n                    return null;\n            }\n        }\n    },\n    \"feature-state\": {\n        isDynamicOperator: () => true,\n        call: (context, call) => {\n            var _a, _b;\n            if (context.scope !== Expr_1.ExprScope.Dynamic) {\n                throw new Error(\"feature-state cannot be used in this context\");\n            }\n            const property = context.evaluate(call.args[0]);\n            if (typeof property !== \"string\") {\n                throw new Error(`expected the name of the property of the feature state`);\n            }\n            const state = context.env.lookup(\"$state\");\n            if (Env_1.Env.isEnv(state)) {\n                return (_a = state.lookup(property)) !== null && _a !== void 0 ? _a : null;\n            }\n            else if (state instanceof Map) {\n                return (_b = state.get(property)) !== null && _b !== void 0 ? _b : null;\n            }\n            return null;\n        }\n    },\n    id: {\n        call: (context, call) => {\n            var _a;\n            return (_a = context.env.lookup(\"$id\")) !== null && _a !== void 0 ? _a : null;\n        }\n    }\n};\nexports.FeatureOperators = operators;\n//# sourceMappingURL=FeatureOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlowOperators = void 0;\nfunction conditionalCast(context, type, args) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            for (const childExpr of args) {\n                const value = context.evaluate(childExpr);\n                if (typeof value === type) {\n                    return value;\n                }\n            }\n            throw new Error(`expected a '${type}'`);\n        default:\n            throw new Error(`invalid type '${type}'`);\n    } // switch\n}\nconst operators = {\n    all: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (!context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n    any: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n    none: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n    boolean: {\n        call: (context, call) => {\n            return conditionalCast(context, \"boolean\", call.args);\n        }\n    },\n    number: {\n        call: (context, call) => {\n            return conditionalCast(context, \"number\", call.args);\n        }\n    },\n    string: {\n        call: (context, call) => {\n            return conditionalCast(context, \"string\", call.args);\n        }\n    }\n};\nexports.FlowOperators = operators;\n//# sourceMappingURL=FlowOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapOperators = void 0;\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst operators = {\n    \"ppi-scale\": {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            return value * scaleFactor;\n        }\n    },\n    \"world-ppi-scale\": {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            const pixels = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            const zoom = context.env.lookup(\"$zoom\");\n            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);\n            const v = pixels * zoomWidth * scaleFactor;\n            return v;\n        }\n    },\n    \"world-discrete-ppi-scale\": {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            const pixels = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            const zoom = context.env.lookup(\"$zoom\");\n            const zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));\n            const v = pixels * zoomWidthDiscrete * scaleFactor;\n            return v;\n        }\n    },\n    ppi: {\n        call: (context) => {\n            const ppi = context.env.lookup(\"$ppi\");\n            if (typeof ppi === \"number\") {\n                return ppi;\n            }\n            return 72;\n        }\n    },\n    zoom: {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            var _a;\n            if (context.scope === Expr_1.ExprScope.Value) {\n                return call;\n            }\n            return (_a = context.env.lookup(\"$zoom\")) !== null && _a !== void 0 ? _a : null;\n        }\n    }\n};\nexports.MapOperators = operators;\n//# sourceMappingURL=MapOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathOperators = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst operators = {\n    \"^\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);\n            }\n            return Math.pow(a, b);\n        }\n    },\n    \"-\": {\n        call: (context, call) => {\n            if (call.args.length === 1) {\n                const value = context.evaluate(call.args[0]);\n                if (typeof value !== \"number\") {\n                    throw new Error(`ìnvalid operand '${typeof value} for operator '-'`);\n                }\n                return -value;\n            }\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);\n            }\n            return a - b;\n        }\n    },\n    \"/\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);\n            }\n            return a / b;\n        }\n    },\n    \"%\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);\n            }\n            return a % b;\n        }\n    },\n    \"+\": {\n        call: (context, call) => {\n            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);\n        }\n    },\n    \"*\": {\n        call: (context, call) => {\n            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);\n        }\n    },\n    abs: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'abs'`);\n            }\n            return Math.abs(value);\n        }\n    },\n    acos: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'acos'`);\n            }\n            return Math.acos(value);\n        }\n    },\n    asin: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'asin'`);\n            }\n            return Math.asin(value);\n        }\n    },\n    atan: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'atan'`);\n            }\n            return Math.atan(value);\n        }\n    },\n    ceil: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ceil'`);\n            }\n            return Math.ceil(value);\n        }\n    },\n    cos: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'cos'`);\n            }\n            return Math.cos(value);\n        }\n    },\n    e: {\n        call: () => {\n            return Math.E;\n        }\n    },\n    floor: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'floor'`);\n            }\n            return Math.floor(value);\n        }\n    },\n    ln: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln'`);\n            }\n            return Math.log(value);\n        }\n    },\n    ln2: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln2'`);\n            }\n            return Math.log2(value);\n        }\n    },\n    log10: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'log10'`);\n            }\n            return Math.log10(value);\n        }\n    },\n    max: {\n        call: (context, call) => {\n            return Math.max(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n    min: {\n        call: (context, call) => {\n            return Math.min(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n    /**\n     * Clamp numeric value to given range, inclusive.\n     *\n     * Synopsis:\n     * ```\n     * [\"clamp\", v: number, min: number, max: number]`\n     * ```\n     */\n    clamp: {\n        call: (context, call) => {\n            const v = context.evaluate(call.args[0]);\n            const min = context.evaluate(call.args[1]);\n            const max = context.evaluate(call.args[2]);\n            if (typeof v !== \"number\" || typeof min !== \"number\" || typeof max !== \"number\") {\n                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);\n            }\n            return THREE.MathUtils.clamp(v, min, max);\n        }\n    },\n    pi: {\n        call: () => {\n            return Math.PI;\n        }\n    },\n    round: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'round'`);\n            }\n            return Math.round(value);\n        }\n    },\n    sin: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sin'`);\n            }\n            return Math.sin(value);\n        }\n    },\n    sqrt: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);\n            }\n            return Math.sqrt(value);\n        }\n    },\n    tan: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'tan'`);\n            }\n            return Math.tan(value);\n        }\n    }\n};\nexports.MathOperators = operators;\n//# sourceMappingURL=MathOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MiscOperators = void 0;\nconst operators = {\n    length: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (Array.isArray(value) || typeof value === \"string\") {\n                return value.length;\n            }\n            throw new Error(`invalid operand '${value}' for operator 'length'`);\n        }\n    },\n    coalesce: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                const value = context.evaluate(childExpr);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        }\n    }\n};\nexports.MiscOperators = operators;\n//# sourceMappingURL=MiscOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObjectOperators = void 0;\nconst Env_1 = __webpack_require__(/*! ../Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nvar LookupMode;\n(function (LookupMode) {\n    LookupMode[LookupMode[\"get\"] = 0] = \"get\";\n    LookupMode[LookupMode[\"has\"] = 1] = \"has\";\n})(LookupMode || (LookupMode = {}));\nfunction lookupMember(context, args, lookupMode) {\n    var _a;\n    const memberName = context.evaluate(args[0]);\n    if (typeof memberName !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    const object = context.evaluate(args[1]);\n    if (object && typeof object === \"object\") {\n        if (Env_1.Env.isEnv(object)) {\n            const value = (_a = object.lookup(memberName)) !== null && _a !== void 0 ? _a : null;\n            return lookupMode === LookupMode.get ? value : value !== null;\n        }\n        if (hasOwnProperty.call(object, memberName)) {\n            return lookupMode === LookupMode.get ? object[memberName] : true;\n        }\n    }\n    return lookupMode === LookupMode.get ? null : false;\n}\nconst operators = {\n    in: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            const object = context.evaluate(call.args[1]);\n            if (typeof value === \"string\" && typeof object === \"string\") {\n                return object.includes(value);\n            }\n            else if (Array.isArray(object)) {\n                return object.includes(value);\n            }\n            return false;\n        }\n    },\n    get: {\n        call: (context, call) => lookupMember(context, call.args, LookupMode.get)\n    },\n    has: {\n        call: (context, call) => lookupMember(context, call.args, LookupMode.has)\n    },\n    \"dynamic-properties\": {\n        isDynamicOperator: () => true,\n        call: (context, call) => {\n            if (context.scope === Expr_1.ExprScope.Dynamic) {\n                return context.env;\n            }\n            return call;\n        }\n    }\n};\nexports.ObjectOperators = operators;\n//# sourceMappingURL=ObjectOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringOperators = void 0;\nconst operators = {\n    concat: {\n        call: (context, call) => {\n            return \"\".concat(...call.args.map(a => String(context.evaluate(a))));\n        }\n    },\n    downcase: {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0])).toLocaleLowerCase();\n        }\n    },\n    upcase: {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0])).toLocaleUpperCase();\n        }\n    },\n    \"~=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.includes(right);\n            }\n            return false;\n        }\n    },\n    \"^=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.startsWith(right);\n            }\n            return false;\n        }\n    },\n    \"$=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.endsWith(right);\n            }\n            return false;\n        }\n    }\n};\nexports.StringOperators = operators;\n//# sourceMappingURL=StringOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeOperators = void 0;\nconst operators = {\n    typeof: {\n        call: (context, call) => {\n            return typeof context.evaluate(call.args[0]);\n        }\n    }\n};\nexports.TypeOperators = operators;\n//# sourceMappingURL=TypeOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorOperators = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nfunction isVector(context, call, type) {\n    let ctor;\n    switch (type) {\n        case \"vector2\":\n            ctor = THREE.Vector2;\n            break;\n        case \"vector3\":\n            ctor = THREE.Vector3;\n            break;\n        case \"vector4\":\n            ctor = THREE.Vector4;\n            break;\n    }\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof ctor) {\n            return value;\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\nfunction toVector(context, call, type) {\n    let VectorCtor;\n    let components;\n    switch (type) {\n        case \"vector2\":\n            VectorCtor = THREE.Vector2;\n            components = 2;\n            break;\n        case \"vector3\":\n            VectorCtor = THREE.Vector3;\n            components = 3;\n            break;\n        case \"vector4\":\n            VectorCtor = THREE.Vector4;\n            components = 4;\n            break;\n    }\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof VectorCtor) {\n            return value;\n        }\n        else if (Array.isArray(value) &&\n            value.length === components &&\n            value.every(v => typeof v === \"number\")) {\n            return new VectorCtor().fromArray(value);\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\nconst operators = {\n    \"make-vector\": {\n        call: (context, call) => {\n            if (call._value !== undefined) {\n                return call._value;\n            }\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            }\n            else if (call.args.length > 4) {\n                throw new Error(\"too many arguments\");\n            }\n            const components = call.args.map(arg => context.evaluate(arg));\n            components.forEach((element, index) => {\n                if (typeof element !== \"number\") {\n                    throw new Error(`expected vector component at index ${index} to have type \"number\"`);\n                }\n            });\n            let result;\n            switch (components.length) {\n                case 2:\n                    result = new THREE.Vector2().fromArray(components);\n                    break;\n                case 3:\n                    result = new THREE.Vector3().fromArray(components);\n                    break;\n                case 4:\n                    result = new THREE.Vector4().fromArray(components);\n                    break;\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n            if (call.args.every(arg => arg instanceof Expr_1.NumberLiteralExpr)) {\n                call._value = result;\n            }\n            return result;\n        }\n    },\n    vector2: {\n        call: (context, call) => isVector(context, call, \"vector2\")\n    },\n    vector3: {\n        call: (context, call) => isVector(context, call, \"vector3\")\n    },\n    vector4: {\n        call: (context, call) => isVector(context, call, \"vector4\")\n    },\n    \"to-vector2\": {\n        call: (context, call) => toVector(context, call, \"vector2\")\n    },\n    \"to-vector3\": {\n        call: (context, call) => toVector(context, call, \"vector3\")\n    },\n    \"to-vector4\": {\n        call: (context, call) => toVector(context, call, \"vector4\")\n    }\n};\nexports.VectorOperators = operators;\n//# sourceMappingURL=VectorOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/ClipLineString.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/ClipLineString.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapLineString = exports.clipLineString = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\n/**\n * A clipping edge.\n *\n * @remarks\n * Clip lines using the Sutherland-Hodgman algorithm.\n *\n * @internal\n */\nclass ClipEdge {\n    /**\n     * Creates a clipping edge.\n     *\n     * @param x1 - The x coordinate of the first point of this ClipEdge.\n     * @param y1 - The y coordinate of the first point of this ClipEdge.\n     * @param x2 - The x coordinate of the second point of this ClipEdge.\n     * @param y2 - The y coordinate of the second point of this ClipEdge.\n     * @param isInside - The function used to test points against this ClipEdge.\n     */\n    constructor(x1, y1, x2, y2, isInside) {\n        this.isInside = isInside;\n        this.p0 = new three_1.Vector2(x1, y1);\n        this.p1 = new three_1.Vector2(x2, y2);\n    }\n    /**\n     * Tests if the given point is inside this clipping edge.\n     */\n    inside(point) {\n        return this.isInside(point);\n    }\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     *    | line-line intersection}.\n     */\n    computeIntersection(a, b) {\n        const result = new three_1.Vector2();\n        harp_utils_1.Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);\n        return result;\n    }\n    /**\n     * Clip the input line against this edge.\n     */\n    clipLine(lineString) {\n        const inputList = lineString;\n        const result = [];\n        lineString = [];\n        result.push(lineString);\n        const pushPoint = (point) => {\n            if (lineString.length === 0 || !lineString[lineString.length - 1].equals(point)) {\n                lineString.push(point);\n            }\n        };\n        for (let i = 0; i < inputList.length; ++i) {\n            const currentPoint = inputList[i];\n            const prevPoint = i > 0 ? inputList[i - 1] : undefined;\n            if (this.inside(currentPoint)) {\n                if (prevPoint !== undefined && !this.inside(prevPoint)) {\n                    if (lineString.length > 0) {\n                        lineString = [];\n                        result.push(lineString);\n                    }\n                    pushPoint(this.computeIntersection(prevPoint, currentPoint));\n                }\n                pushPoint(currentPoint);\n            }\n            else if (prevPoint !== undefined && this.inside(prevPoint)) {\n                pushPoint(this.computeIntersection(prevPoint, currentPoint));\n            }\n        }\n        if (result[result.length - 1].length === 0) {\n            result.length = result.length - 1;\n        }\n        return result;\n    }\n    /**\n     * Clip the input lines against this edge.\n     */\n    clipLines(lineStrings) {\n        const reuslt = [];\n        lineStrings.forEach(lineString => {\n            this.clipLine(lineString).forEach(clippedLine => {\n                reuslt.push(clippedLine);\n            });\n        });\n        return reuslt;\n    }\n}\n/**\n * Clip the input line against the given bounds.\n *\n * @param lineString - The line to clip.\n * @param minX - The minimum x coordinate.\n * @param minY - The minimum y coordinate.\n * @param maxX - The maxumum x coordinate.\n * @param maxY - The maxumum y coordinate.\n */\nfunction clipLineString(lineString, minX, minY, maxX, maxY) {\n    const clipEdge0 = new ClipEdge(minX, minY, minX, maxY, p => p.x > minX); // left\n    const clipEdge1 = new ClipEdge(minX, maxY, maxX, maxY, p => p.y < maxY); // bottom\n    const clipEdge2 = new ClipEdge(maxX, maxY, maxX, minY, p => p.x < maxX); // right\n    const clipEdge3 = new ClipEdge(maxX, minY, minX, minY, p => p.y > minY); // top\n    let lines = clipEdge0.clipLine(lineString);\n    lines = clipEdge1.clipLines(lines);\n    lines = clipEdge2.clipLines(lines);\n    lines = clipEdge3.clipLines(lines);\n    return lines;\n}\nexports.clipLineString = clipLineString;\n/**\n * Helper function to wrap a line string projected in web mercator.\n *\n * @param multiLineString The input to wrap\n * @param edges The clipping edges used to wrap the input.\n * @param offset The x-offset used to displace the result\n *\n * @internal\n */\nfunction wrapMultiLineStringHelper(multiLineString, edges, offset) {\n    for (const clip of edges) {\n        multiLineString = clip.clipLines(multiLineString);\n    }\n    const worldP = new three_1.Vector3();\n    const coordinates = [];\n    multiLineString.forEach(lineString => {\n        if (lineString.length === 0) {\n            return;\n        }\n        const coords = lineString.map(({ x, y }) => {\n            worldP.set(x, y, 0);\n            const geoPoint = harp_geoutils_1.webMercatorProjection.unprojectPoint(worldP);\n            geoPoint.longitude += offset;\n            return geoPoint;\n        });\n        coordinates.push(coords);\n    });\n    return coordinates.length > 0 ? coordinates : undefined;\n}\n/**\n * Wrap the given line string.\n *\n * @remarks\n * This function splits this input line string in three parts.\n *\n * The `left` member of the result contains the part of the line string with longitude less than `-180`.\n *\n * The `middle` member contains the part of the line string with longitude in the range `[-180, 180]`.\n *\n * The `right` member contains the part of the line string with longitude greater than `180`.\n *\n * @param coordinates The coordinates of the line string to wrap.\n */\nfunction wrapLineString(coordinates) {\n    const worldP = new three_1.Vector3();\n    const lineString = coordinates.map(g => {\n        const { x, y } = harp_geoutils_1.webMercatorProjection.projectPoint(g, worldP);\n        return new three_1.Vector2(x, y);\n    });\n    const multiLineString = [lineString];\n    return {\n        left: wrapMultiLineStringHelper(multiLineString, WRAP_LEFT_CLIP_EDGES, 360),\n        middle: wrapMultiLineStringHelper(multiLineString, WRAP_MIDDLE_CLIP_EDGES, 0),\n        right: wrapMultiLineStringHelper(multiLineString, WRAP_RIGHT_CLIP_EDGES, -360)\n    };\n}\nexports.wrapLineString = wrapLineString;\nconst ec = harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE;\nconst border = 0;\nconst WRAP_MIDDLE_CLIP_EDGES = [\n    new ClipEdge(0 - border, ec, 0 - border, 0, p => p.x > 0 - border),\n    new ClipEdge(ec + border, 0, ec + border, ec, p => p.x < ec + border)\n];\nconst WRAP_LEFT_CLIP_EDGES = [\n    new ClipEdge(-ec - border, ec, -ec - border, 0, p => p.x > -ec - border),\n    new ClipEdge(0 + border, 0, 0 + border, ec, p => p.x < 0 + border)\n];\nconst WRAP_RIGHT_CLIP_EDGES = [\n    new ClipEdge(ec - border, ec, ec - border, 0, p => p.x > ec - border),\n    new ClipEdge(ec * 2 + border, 0, ec * 2 + border, ec, p => p.x < ec * 2 + border)\n];\n//# sourceMappingURL=ClipLineString.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/ClipLineString.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/ClipPolygon.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/ClipPolygon.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clipPolygon = exports.ClippingEdge = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\n/**\n * Abstract helper class used to implement the Sutherland-Hodgman clipping algorithm.\n *\n * @remarks\n * Concrete implementation of this class are used to clip a polygon\n * against one edge of a bounding box.\n *\n * @internal\n */\nclass ClippingEdge {\n    /**\n     * Clip the polygon against this clipping edge.\n     *\n     * @param polygon Clip the polygon against this edge.\n     * @param extent The extent of the bounding box.\n     */\n    clipPolygon(polygon, extent) {\n        const inputList = polygon;\n        polygon = [];\n        const pushPoint = (point) => {\n            const lastAddedPoint = polygon[polygon.length - 1];\n            if (!(lastAddedPoint === null || lastAddedPoint === void 0 ? void 0 : lastAddedPoint.equals(point)) ||\n                (point.isClipped === true && !(lastAddedPoint === null || lastAddedPoint === void 0 ? void 0 : lastAddedPoint.isClipped)) ||\n                (!point.isClipped && (lastAddedPoint === null || lastAddedPoint === void 0 ? void 0 : lastAddedPoint.isClipped) === true)) {\n                polygon.push(point);\n            }\n        };\n        for (let i = 0; i < inputList.length; ++i) {\n            const currentPoint = inputList[i];\n            const prevPoint = inputList[(i + inputList.length - 1) % inputList.length];\n            if (this.inside(currentPoint, extent)) {\n                if (!this.inside(prevPoint, extent)) {\n                    const p = this.computeIntersection(prevPoint, currentPoint, extent);\n                    p.isClipped = true;\n                    pushPoint(p);\n                }\n                pushPoint(currentPoint);\n            }\n            else if (this.inside(prevPoint, extent)) {\n                const p = this.computeIntersection(prevPoint, currentPoint, extent);\n                p.isClipped = true;\n                pushPoint(p);\n            }\n        }\n        return polygon;\n    }\n}\nexports.ClippingEdge = ClippingEdge;\nclass TopClippingEdge extends ClippingEdge {\n    /** @override */\n    inside(point) {\n        return point.y >= 0;\n    }\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(0, 0)` and `(0, extent)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a, b) {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v = new three_1.Vector2((x1 * y2 - y1 * x2) / -(y1 - y2), 0).round();\n        return v;\n    }\n}\nclass RightClippingEdge extends ClippingEdge {\n    /** @override */\n    inside(point, extent) {\n        return point.x <= extent;\n    }\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(extent, 0)` and `(extent, extent)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a, b, extent) {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v = new three_1.Vector2(extent, (x1 * y2 - y1 * x2 - (y1 - y2) * -extent) / (x1 - x2)).round();\n        return v;\n    }\n}\nclass BottomClipEdge extends ClippingEdge {\n    /** @override */\n    inside(point, extent) {\n        return point.y <= extent;\n    }\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(extent, extent)` and `(0, extent)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a, b, extent) {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v = new three_1.Vector2((x1 * y2 - y1 * x2 - (x1 - x2) * extent) / -(y1 - y2), extent).round();\n        return v;\n    }\n}\nclass LeftClippingEdge extends ClippingEdge {\n    /** @override */\n    inside(point) {\n        return point.x >= 0;\n    }\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(0, extent)` and `(0, 0)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a, b) {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v = new three_1.Vector2(0, (x1 * y2 - y1 * x2) / (x1 - x2)).round();\n        return v;\n    }\n}\nconst clipEdges = [\n    new TopClippingEdge(),\n    new RightClippingEdge(),\n    new BottomClipEdge(),\n    new LeftClippingEdge()\n];\n/**\n * Clip the given polygon using the Sutherland-Hodgman algorithm.\n *\n * @remarks\n * The coordinates of the polygon must be integer numbers.\n *\n * @param polygon The vertices of the polygon to clip.\n * @param extent The extents of the rectangle to clip against.\n */\nfunction clipPolygon(polygon, extent) {\n    if (polygon.length === 0) {\n        return polygon;\n    }\n    if (!polygon[0].equals(polygon[polygon.length - 1])) {\n        // close the polygon if needed.\n        polygon = [...polygon, polygon[0]];\n    }\n    for (const clip of clipEdges) {\n        polygon = clip.clipPolygon(polygon, extent);\n    }\n    if (polygon.length < 3) {\n        return [];\n    }\n    return polygon;\n}\nexports.clipPolygon = clipPolygon;\n//# sourceMappingURL=ClipPolygon.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/ClipPolygon.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EdgeLengthGeometrySubdivisionModifier = exports.SubdivisionMode = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js\");\nconst VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3()];\nvar SubdivisionMode;\n(function (SubdivisionMode) {\n    /**\n     * Subdivide all edges\n     */\n    SubdivisionMode[SubdivisionMode[\"All\"] = 0] = \"All\";\n    /**\n     * Only subdivide horizontal and vertical edges\n     */\n    SubdivisionMode[SubdivisionMode[\"NoDiagonals\"] = 1] = \"NoDiagonals\";\n})(SubdivisionMode = exports.SubdivisionMode || (exports.SubdivisionMode = {}));\n/**\n * The [[EdgeLengthGeometrySubdivisionModifier]] subdivides triangle mesh depending on\n * length of edges.\n */\nclass EdgeLengthGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {\n    /**\n     * Constructs a new [[EdgeLengthGeometrySubdivisionModifier]].\n     *\n     * @param subdivision - The subdivision factor\n     * @param geoBox - The geo bounding box of a tile\n     * @param subdivisionMode - Configures what edges to divide\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(subdivision, geoBox, subdivisionMode = SubdivisionMode.All, projection) {\n        super();\n        this.subdivision = subdivision;\n        this.geoBox = geoBox;\n        this.subdivisionMode = subdivisionMode;\n        this.projection = projection;\n        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Planar, \"EdgeLengthGeometrySubdivisionModifier only supports planar projections\");\n        const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);\n        const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);\n        this.m_projectedBox = {\n            min: {\n                x: Math.min(northEast.x, southWest.x),\n                y: Math.min(northEast.y, southWest.y),\n                z: Math.min(northEast.z, southWest.z)\n            },\n            max: {\n                x: Math.max(northEast.x, southWest.x),\n                y: Math.max(northEast.y, southWest.y),\n                z: Math.max(northEast.z, southWest.z)\n            }\n        };\n        this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;\n        this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;\n        // Increase max length slightly to account for precision errors\n        if (this.subdivisionMode === SubdivisionMode.All) {\n            this.m_maxLengthX *= 1.1;\n            this.m_maxLengthY *= 1.1;\n        }\n        this.m_maxLength = Math.sqrt(this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY);\n    }\n    /**\n     * Return upper bound for length of diagonal edges\n     */\n    get maxLength() {\n        return this.m_maxLength;\n    }\n    /**\n     * Return upper bound for edge length in x direction\n     */\n    get maxLengthX() {\n        return this.m_maxLengthX;\n    }\n    /**\n     * Return upper bound for edge length in y direction\n     */\n    get maxLengthY() {\n        return this.m_maxLengthY;\n    }\n    /** @override */\n    shouldSplitTriangle(a, b, c) {\n        const shouldSplitAB = this.shouldSplitEdge(a, b);\n        const shouldSplitBC = this.shouldSplitEdge(b, c);\n        const shouldSplitCA = this.shouldSplitEdge(c, a);\n        const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;\n        if (!shouldSplit) {\n            return;\n        }\n        const ab = a.distanceTo(b);\n        const bc = b.distanceTo(c);\n        const ca = c.distanceTo(a);\n        const maxDistance = Math.max(shouldSplitAB ? ab : 0, shouldSplitBC ? bc : 0, shouldSplitCA ? ca : 0);\n        if (ab === maxDistance) {\n            return 0;\n        }\n        else if (bc === maxDistance) {\n            return 1;\n        }\n        else if (ca === maxDistance) {\n            return 2;\n        }\n        throw new Error(\"Could not split triangle.\");\n    }\n    shouldSplitEdge(a, b) {\n        switch (this.subdivisionMode) {\n            case SubdivisionMode.All:\n                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY) ||\n                    a.distanceTo(b) > this.m_maxLength);\n            case SubdivisionMode.NoDiagonals:\n                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY));\n        }\n    }\n}\nexports.EdgeLengthGeometrySubdivisionModifier = EdgeLengthGeometrySubdivisionModifier;\n//# sourceMappingURL=EdgeLengthGeometrySubdivisionModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SphericalGeometrySubdivisionModifier = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js\");\nconst VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];\n/**\n * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned\n * on the surface of a sphere centered at `(0, 0, 0)`.\n */\nclass SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {\n    /**\n     * Constructs a new [[SphericalGeometrySubdivisionModifier]].\n     *\n     * @param angle - The maximum angle in radians between two vertices and the origin.\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(angle, projection = harp_geoutils_1.sphereProjection) {\n        super();\n        this.angle = angle;\n        this.projection = projection;\n    }\n    /** @override */\n    shouldSplitTriangle(a, b, c) {\n        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);\n        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);\n        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);\n        const alpha = aa.angleTo(bb);\n        const beta = bb.angleTo(cc);\n        const gamma = cc.angleTo(aa);\n        // find the maximum angle\n        const m = Math.max(alpha, Math.max(beta, gamma));\n        // split the triangle if needed.\n        if (m < this.angle) {\n            return undefined;\n        }\n        if (m === alpha) {\n            return 0;\n        }\n        else if (m === beta) {\n            return 1;\n        }\n        else if (m === gamma) {\n            return 2;\n        }\n        throw new Error(\"failed to split triangle\");\n    }\n}\nexports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;\n//# sourceMappingURL=SphericalGeometrySubdivisionModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubdivisionModifier = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst tmpVectorA = new three_1.Vector3();\nconst tmpVectorB = new three_1.Vector3();\nconst tmpVectorC = new three_1.Vector3();\n/**\n * The [[SubdivisionModifier]] subdivides triangle mesh geometries.\n */\nclass SubdivisionModifier {\n    /**\n     * Constructs a new [[SubdivisionModifier]].\n     */\n    constructor() {\n        // nothing to do\n    }\n    /**\n     * Subdivides the faces of the given [[THREE.BufferGeometry]].\n     *\n     * This method modifies (in-place) the vertices and the faces of the geometry.\n     * Please note that only the vertex position and their UV coordinates are subdivided.\n     * Normals, vertex colors and other attributes are left unmodified.\n     *\n     * @param geometry - The [[THREE.BufferGeometry]] to subdivide.\n     */\n    modify(geometry) {\n        const positionAttr = geometry.getAttribute(\"position\");\n        const position = Array.from(positionAttr.array);\n        const uvAttr = geometry.getAttribute(\"uv\");\n        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;\n        const edgeAttr = geometry.getAttribute(\"edge\");\n        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;\n        const wallAttr = geometry.getAttribute(\"wall\");\n        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;\n        const indexAttr = geometry.getIndex();\n        const indices = Array.from(indexAttr.array);\n        // A cache containing the indices of the vertices added\n        // when subdiving the faces of the geometry.\n        const cache = new Map();\n        /**\n         * Returns the index of the vertex positioned in the middle of the given vertices.\n         */\n        function middleVertex(i, j) {\n            // Build a unique `key` for the pair of indices `(i, j)`.\n            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;\n            const h = cache.get(key);\n            if (h !== undefined) {\n                // Nothing to do, a vertex in the middle of (i, j) was already created.\n                return h;\n            }\n            // The position of the new vertex.\n            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);\n            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n            // The index of the new vertex.\n            const index = position.length / 3;\n            position.push(...tmpVectorC.toArray());\n            // Cache the position of the new vertex.\n            cache.set(key, index);\n            // The uvs of the new vertex.\n            if (uv !== undefined) {\n                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);\n                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);\n                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n                uv.push(tmpVectorC.x, tmpVectorC.y);\n            }\n            // The edge and wall attributes of the new vertex.\n            // If a new vertex has been introduced between i and j, connect the elements\n            // accordingly.\n            if (edge !== undefined) {\n                if (edge[i] === j) {\n                    edge.push(j);\n                    edge[i] = index;\n                }\n                else if (edge[j] === i) {\n                    edge.push(i);\n                    edge[j] = index;\n                }\n                else {\n                    edge.push(-1);\n                }\n            }\n            if (wall !== undefined) {\n                if (wall[i] === j) {\n                    wall.push(j);\n                    wall[i] = index;\n                }\n                else if (wall[j] === i) {\n                    wall.push(i);\n                    wall[j] = index;\n                }\n                else {\n                    wall.push(-1);\n                }\n            }\n            return index;\n        }\n        const newIndices = [];\n        while (indices.length >= 3) {\n            const v0 = indices.shift();\n            const v1 = indices.shift();\n            const v2 = indices.shift();\n            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);\n            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);\n            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);\n            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);\n            switch (edgeToSplit) {\n                case 0: {\n                    const v3 = middleVertex(v0, v1);\n                    indices.push(v0, v3, v2, v3, v1, v2);\n                    break;\n                }\n                case 1: {\n                    const v3 = middleVertex(v1, v2);\n                    indices.push(v0, v1, v3, v0, v3, v2);\n                    break;\n                }\n                case 2: {\n                    const v3 = middleVertex(v2, v0);\n                    indices.push(v0, v1, v3, v3, v1, v2);\n                    break;\n                }\n                case undefined: {\n                    newIndices.push(v0, v1, v2);\n                    break;\n                }\n                default:\n                    throw new Error(\"failed to subdivide the given geometry\");\n            }\n        }\n        positionAttr.array =\n            positionAttr.array instanceof Float32Array\n                ? new Float32Array(position)\n                : new Float64Array(position);\n        positionAttr.count = position.length / positionAttr.itemSize;\n        positionAttr.needsUpdate = true;\n        geometry.setIndex(newIndices);\n        if (uv !== undefined) {\n            uvAttr.array = new Float32Array(uv);\n            uvAttr.count = uv.length / uvAttr.itemSize;\n            uvAttr.needsUpdate = true;\n        }\n        if (edge !== undefined) {\n            edgeAttr.array = new Float32Array(edge);\n            edgeAttr.count = edge.length / edgeAttr.itemSize;\n            edgeAttr.needsUpdate = true;\n        }\n        return geometry;\n    }\n}\nexports.SubdivisionModifier = SubdivisionModifier;\n//# sourceMappingURL=SubdivisionModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Utility classes for working with geospatial data.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBoxExtentLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPolygonLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPolygon */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/IdentityProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/TransverseMercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/SphereProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ \"./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTree */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/SubTiles */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/SubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/PolarTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/Vector2Like */ \"./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/Vector3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/TransformLike */ \"./node_modules/@here/harp-geoutils/lib/math/TransformLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3 */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoBox = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\n/**\n * `GeoBox` is used to represent a bounding box in geo coordinates.\n */\nclass GeoBox {\n    /**\n     * Constructs a new `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    constructor(southWest, northEast) {\n        this.southWest = southWest;\n        this.northEast = northEast;\n        if (this.west > this.east) {\n            this.northEast.longitude += 360;\n        }\n    }\n    /**\n     * Returns a `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    static fromCoordinates(southWest, northEast) {\n        return new GeoBox(southWest, northEast);\n    }\n    /**\n     * Returns a `GeoBox` with the given center and dimensions.\n     *\n     * @param center - The center position of geo box.\n     * @param extent - Box latitude and logitude span\n     */\n    static fromCenterAndExtents(center, extent) {\n        return new GeoBox(new GeoCoordinates_1.GeoCoordinates(center.latitude - extent.latitudeSpan / 2, center.longitude - extent.longitudeSpan / 2), new GeoCoordinates_1.GeoCoordinates(center.latitude + extent.latitudeSpan / 2, center.longitude + extent.longitudeSpan / 2));\n    }\n    /**\n     * Returns the minimum altitude or `undefined`.\n     */\n    get minAltitude() {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.min(this.southWest.altitude, this.northEast.altitude);\n    }\n    /**\n     * Returns the maximum altitude or `undefined`.\n     */\n    get maxAltitude() {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.max(this.southWest.altitude, this.northEast.altitude);\n    }\n    /**\n     * Returns the south latitude in degrees of this `GeoBox`.\n     */\n    get south() {\n        return this.southWest.latitude;\n    }\n    /**\n     * Returns the north altitude in degrees of this `GeoBox`.\n     */\n    get north() {\n        return this.northEast.latitude;\n    }\n    /**\n     * Returns the west longitude in degrees of this `GeoBox`.\n     */\n    get west() {\n        return this.southWest.longitude;\n    }\n    /**\n     * Returns the east longitude in degrees of this `GeoBox`.\n     */\n    get east() {\n        return this.northEast.longitude;\n    }\n    /**\n     * Returns the center of this `GeoBox`.\n     */\n    get center() {\n        const latitude = (this.south + this.north) * 0.5;\n        const { west, east } = this;\n        const { minAltitude, altitudeSpan } = this;\n        let altitude;\n        if (minAltitude !== undefined && altitudeSpan !== undefined) {\n            altitude = minAltitude + altitudeSpan * 0.5;\n        }\n        if (west <= east) {\n            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);\n        }\n        let longitude = (360 + east + west) * 0.5;\n        if (longitude > 360) {\n            longitude -= 360;\n        }\n        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);\n    }\n    /**\n     * Returns the latitude span in radians.\n     */\n    get latitudeSpanInRadians() {\n        return THREE.MathUtils.degToRad(this.latitudeSpan);\n    }\n    /**\n     * Returns the longitude span in radians.\n     */\n    get longitudeSpanInRadians() {\n        return THREE.MathUtils.degToRad(this.longitudeSpan);\n    }\n    /**\n     * Returns the latitude span in degrees.\n     */\n    get latitudeSpan() {\n        return this.north - this.south;\n    }\n    get altitudeSpan() {\n        if (this.maxAltitude === undefined || this.minAltitude === undefined) {\n            return undefined;\n        }\n        return this.maxAltitude - this.minAltitude;\n    }\n    /**\n     * Returns the longitude span in degrees.\n     */\n    get longitudeSpan() {\n        let width = this.northEast.longitude - this.southWest.longitude;\n        if (width < 0) {\n            width += 360;\n        }\n        return width;\n    }\n    /**\n     * Returns the latitude span in degrees.\n     * @deprecated Use [[latitudeSpan]] instead.\n     */\n    get latitudeSpanInDegrees() {\n        return this.latitudeSpan;\n    }\n    /**\n     * Returns the longitude span in degrees.\n     * @deprecated Use [[longitudeSpan]] instead.\n     */\n    get longitudeSpanInDegrees() {\n        return this.longitudeSpan;\n    }\n    /**\n     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.\n     *\n     * @param point - The geo coordinates.\n     */\n    contains(point) {\n        if (point.altitude === undefined ||\n            this.minAltitude === undefined ||\n            this.maxAltitude === undefined) {\n            return this.containsHelper(point);\n        }\n        const isFlat = this.minAltitude === this.maxAltitude;\n        const isSameAltitude = this.minAltitude === point.altitude;\n        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;\n        // If box is flat, we should check the altitude and containment,\n        // otherwise we should check also altitude difference where we consider\n        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!\n        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {\n            return this.containsHelper(point);\n        }\n        return false;\n    }\n    /**\n     * Clones this `GeoBox` instance.\n     */\n    clone() {\n        return new GeoBox(this.southWest.clone(), this.northEast.clone());\n    }\n    /**\n     * Update the bounding box by considering a given point.\n     *\n     * @param point - The point that may expand the bounding box.\n     */\n    growToContain(point) {\n        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);\n        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);\n        this.southWest.altitude =\n            this.southWest.altitude !== undefined && point.altitude !== undefined\n                ? Math.min(this.southWest.altitude, point.altitude)\n                : this.southWest.altitude !== undefined\n                    ? this.southWest.altitude\n                    : point.altitude !== undefined\n                        ? point.altitude\n                        : undefined;\n        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);\n        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);\n        this.northEast.altitude =\n            this.northEast.altitude !== undefined && point.altitude !== undefined\n                ? Math.max(this.northEast.altitude, point.altitude)\n                : this.northEast.altitude !== undefined\n                    ? this.northEast.altitude\n                    : point.altitude !== undefined\n                        ? point.altitude\n                        : undefined;\n    }\n    containsHelper(point) {\n        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {\n            return false;\n        }\n        const { west, east } = this;\n        let longitude = point.longitude;\n        if (east > GeoCoordinates_1.MAX_LONGITUDE) {\n            while (longitude < west) {\n                longitude = longitude + 360;\n            }\n        }\n        if (longitude > east) {\n            while (longitude > west + 360) {\n                longitude = longitude - 360;\n            }\n        }\n        return longitude >= west && longitude < east;\n    }\n}\nexports.GeoBox = GeoBox;\n//# sourceMappingURL=GeoBox.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoBoxExtentLike = void 0;\n/**\n * Type guard to assert that `object` conforms to {@link GeoBoxExtentLike} interface.\n */\nfunction isGeoBoxExtentLike(obj) {\n    return (obj &&\n        typeof obj === \"object\" &&\n        typeof obj.latitudeSpan === \"number\" &&\n        typeof obj.longitudeSpan === \"number\");\n}\nexports.isGeoBoxExtentLike = isGeoBoxExtentLike;\n//# sourceMappingURL=GeoBoxExtentLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoCoordLike = exports.geoCoordLikeToGeoPointLike = exports.geoCoordLikeToGeoCoordinatesLike = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\");\nconst LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\");\nfunction geoCoordLikeToGeoCoordinatesLike(coord) {\n    return GeoCoordinatesLike_1.isGeoCoordinatesLike(coord)\n        ? coord\n        : LatLngLike_1.isLatLngLike(coord)\n            ? { latitude: coord.lat, longitude: coord.lng }\n            : { latitude: coord[1], longitude: coord[0] };\n}\nexports.geoCoordLikeToGeoCoordinatesLike = geoCoordLikeToGeoCoordinatesLike;\nfunction geoCoordLikeToGeoPointLike(coord) {\n    return GeoPointLike_1.isGeoPointLike(coord)\n        ? coord\n        : LatLngLike_1.isLatLngLike(coord)\n            ? [coord.lng, coord.lat]\n            : [coord.longitude, coord.latitude];\n}\nexports.geoCoordLikeToGeoPointLike = geoCoordLikeToGeoPointLike;\nfunction isGeoCoordLike(object) {\n    return GeoCoordinatesLike_1.isGeoCoordinatesLike(object) || LatLngLike_1.isLatLngLike(object) || !GeoPointLike_1.isGeoPointLike(object);\n}\nexports.isGeoCoordLike = isGeoCoordLike;\n//# sourceMappingURL=GeoCoordLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoCoordinates = exports.MIN_LONGITUDE = exports.MAX_LONGITUDE = exports.MIN_LATITUDE = exports.MAX_LATITUDE = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\");\nconst LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\");\nexports.MAX_LATITUDE = 90;\nexports.MIN_LATITUDE = -90;\nexports.MAX_LONGITUDE = 180;\nexports.MIN_LONGITUDE = -180;\nconst tmpV0 = new THREE.Vector3();\nconst tmpV1 = new THREE.Vector3();\n/**\n * Compute the modulo.\n *\n * @internal\n */\nfunction mod(dividend, divisor) {\n    const modulo = dividend % divisor;\n    const modulo_sign = modulo < 0;\n    const divisor_sign = divisor < 0;\n    return modulo_sign === divisor_sign ? modulo : modulo + divisor;\n}\n/**\n * `GeoCoordinates` is used to represent geo positions.\n */\nclass GeoCoordinates {\n    /**\n     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    constructor(latitude, longitude, altitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.altitude = altitude;\n    }\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    static fromDegrees(latitude, longitude, altitude) {\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in radians.\n     * @param longitude - Longitude in radians.\n     * @param altitude - Altitude in meters.\n     */\n    static fromRadians(latitude, longitude, altitude) {\n        return new GeoCoordinates(THREE.MathUtils.radToDeg(latitude), THREE.MathUtils.radToDeg(longitude), altitude);\n    }\n    /**\n     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.\n     * ```typescript\n     * const center = { lat: 53.3, lng: 13.4 };\n     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);\n     * ```\n     * @param latLng - A {@link LatLngLike} object literal.\n     */\n    static fromLatLng(latLng) {\n        return new GeoCoordinates(latLng.lat, latLng.lng);\n    }\n    /**\n     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.\n     *\n     * Example:\n     * ```typescript\n     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);\n     *\n     * let geoCoords: number[] = ...;\n     *\n     * if (isGeoPointLike(geoCoords)) {\n     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);\n     * }\n     * ```\n     * @param geoPoint - An [[Array]] of at least two elements following the order\n     * longitude, latitude, altitude.\n     */\n    static fromGeoPoint(geoPoint) {\n        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);\n    }\n    /**\n     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.\n     *\n     * Example:\n     * ```typescript\n     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);\n     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });\n     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));\n     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });\n     * ```\n     *\n     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}\n     * or {@link LatLngLike} object literal.\n     */\n    static fromObject(geoPoint) {\n        if (GeoPointLike_1.isGeoPointLike(geoPoint)) {\n            return GeoCoordinates.fromGeoPoint(geoPoint);\n        }\n        else if (GeoCoordinatesLike_1.isGeoCoordinatesLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);\n        }\n        else if (LatLngLike_1.isLatLngLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);\n        }\n        throw new Error(\"Invalid input coordinate format.\");\n    }\n    /**\n     * Returns a `GeoCoordinates` resulting from the linear interpolation of other two.\n     * @param geoCoords0 - One of the `GeoCoordinates` used for interpolation.\n     * @param geoCoords1 - The other `GeoCoordinates` used for interpolation.\n     * @param factor - Interpolation factor. If `0` result will be equal to `geoCoords0`, if `1`\n     * it'll be equal to `geoCoords1`.\n     * @param wrap - If `true`, interpolation will be done across the antimeridian, otherwise it's\n     * done across the Greenwich meridian. Supported only if longitude span is less than 360 deg.\n     * @default false\n     * @param normalize - If `true`, interpolation result will be normalized. @default false\n     */\n    static lerp(geoCoords0, geoCoords1, factor, wrap = false, normalize = false) {\n        var _a, _b;\n        if (wrap) {\n            if (geoCoords0.lng < geoCoords1.lng) {\n                const geoCoordsEnd = geoCoords0.clone();\n                geoCoordsEnd.longitude += 360;\n                return this.lerp(geoCoords1, geoCoordsEnd, 1 - factor);\n            }\n            else {\n                const geoCoordsEnd = geoCoords1.clone();\n                geoCoordsEnd.longitude += 360;\n                return this.lerp(geoCoords0, geoCoordsEnd, factor);\n            }\n        }\n        const v0 = tmpV0.set(geoCoords0.lat, geoCoords0.lng, (_a = geoCoords0.altitude) !== null && _a !== void 0 ? _a : 0);\n        const v1 = tmpV1.set(geoCoords1.lat, geoCoords1.lng, (_b = geoCoords1.altitude) !== null && _b !== void 0 ? _b : 0);\n        v0.lerp(v1, factor);\n        const result = new GeoCoordinates(v0.x, v0.y, v0.z);\n        return normalize ? result.normalized() : result;\n    }\n    /**\n     * Returns the latitude in radians.\n     */\n    get latitudeInRadians() {\n        return THREE.MathUtils.degToRad(this.latitude);\n    }\n    /**\n     * Returns the longitude in radians.\n     */\n    get longitudeInRadians() {\n        return THREE.MathUtils.degToRad(this.longitude);\n    }\n    /**\n     * Returns the latitude in degrees.\n     * @deprecated Use the [[latitude]] property instead.\n     */\n    get latitudeInDegrees() {\n        return this.latitude;\n    } // compat api\n    /**\n     * Returns the longitude in degrees.\n     * @deprecated Use the [[longitude]] property instead.\n     */\n    get longitudeInDegrees() {\n        return this.longitude;\n    } // compat api\n    /**\n     * The latitude in the degrees.\n     */\n    get lat() {\n        return this.latitude;\n    }\n    /**\n     * The longitude in the degrees.\n     */\n    get lng() {\n        return this.longitude;\n    }\n    /**\n     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.\n     */\n    isValid() {\n        return !isNaN(this.latitude) && !isNaN(this.longitude);\n    }\n    /**\n     * Returns the normalized `GeoCoordinates`.\n     */\n    normalized() {\n        let { latitude, longitude } = this;\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return this;\n        }\n        if (longitude < -180 || longitude > 180) {\n            longitude = mod(longitude + 180, 360) - 180;\n        }\n        latitude = THREE.MathUtils.clamp(latitude, -90, 90);\n        return new GeoCoordinates(latitude, longitude, this.altitude);\n    }\n    /**\n     * Returns `true` if this `GeoCoordinates` is equal to the other.\n     *\n     * @param other - GeoCoordinatesLike to compare to.\n     */\n    equals(other) {\n        return (this.latitude === other.latitude &&\n            this.longitude === other.longitude &&\n            this.altitude === other.altitude);\n    }\n    /**\n     * Copy values from the other.\n     *\n     * @param other - GeoCoordinatesLike to copy all values from.\n     */\n    copy(other) {\n        this.latitude = other.latitude;\n        this.longitude = other.longitude;\n        this.altitude = other.altitude;\n        return this;\n    }\n    /**\n     * Clones this `GeoCoordinates`.\n     */\n    clone() {\n        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);\n    }\n    /**\n     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.\n     */\n    toLatLng() {\n        return { lat: this.latitude, lng: this.longitude };\n    }\n    /**\n     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].\n     */\n    toGeoPoint() {\n        return this.altitude !== undefined\n            ? [this.longitude, this.latitude, this.altitude]\n            : [this.longitude, this.latitude];\n    }\n    /**\n     * Returns the minimum longitude span from this `GeoCoordinates` to another.\n     *\n     * @param other - The other GeoCoordinatesLike defining the longitude span.\n     */\n    minLongitudeSpanTo(other) {\n        const minLongitude = Math.min(this.longitude, other.longitude);\n        const maxLongitude = Math.max(this.longitude, other.longitude);\n        return Math.min(maxLongitude - minLongitude, 360 + minLongitude - maxLongitude);\n    }\n}\nexports.GeoCoordinates = GeoCoordinates;\n//# sourceMappingURL=GeoCoordinates.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoCoordinatesLike = void 0;\n/**\n * Type guard to assert that `object` conforms to {@link GeoCoordinatesLike} data interface.\n */\nfunction isGeoCoordinatesLike(object) {\n    return (object &&\n        typeof object.latitude === \"number\" &&\n        typeof object.longitude === \"number\" &&\n        (typeof object.altitude === \"number\" || typeof object.altitude === \"undefined\"));\n}\nexports.isGeoCoordinatesLike = isGeoCoordinatesLike;\n//# sourceMappingURL=GeoCoordinatesLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoPointLike = void 0;\n/**\n * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.\n */\nfunction isGeoPointLike(geoPoint) {\n    if (Array.isArray(geoPoint)) {\n        const [longitude, latitude, altitude] = geoPoint;\n        return (typeof longitude === \"number\" &&\n            typeof latitude === \"number\" &&\n            (altitude === undefined || typeof altitude === \"number\"));\n    }\n    return false;\n}\nexports.isGeoPointLike = isGeoPointLike;\n//# sourceMappingURL=GeoPointLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoPolygon = exports.isAntimeridianCrossing = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ./GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst GeoCoordLike_1 = __webpack_require__(/*! ./GeoCoordLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js\");\nfunction computeLonSpanAcrossGreewich(lonA, lonB) {\n    return Math.max(lonA, lonB) - Math.min(lonA, lonB);\n}\nfunction isLeftToRightAntimeridianCrossing(lonStart, lonEnd) {\n    return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;\n}\nfunction isRightToLeftAntimeridianCrossing(lonStart, lonEnd) {\n    return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);\n}\nfunction isAntimeridianCrossing(lonStart, lonEnd) {\n    return (Math.sign(lonStart) === -Math.sign(lonEnd) &&\n        computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180);\n}\nexports.isAntimeridianCrossing = isAntimeridianCrossing;\n/**\n * A GeoPolygon in 2D Space (altitudes will be ignored).\n * Coordinates are expected in counter-clockwise order, for convex polygons a sorting is\n * available.\n * Clockwise ordered or selfintersecting Polygons might lead to no or unexpected results.\n *\n * @beta @internal\n */\nclass GeoPolygon {\n    /**\n     * Creates a GeoPolygon instance\n     *\n     * @param coordinates An array of GeoCoordinates acting as the Vertices of the Polygon.\n     * @param needsSort  If `true` it will sort the coordinates in ccw order, this will only\n     *  result correctly for convex polygons @default false\n     * @param needsWrapping  If `true` it will wrap around coordinates crossing the antemeridian.\n     * Only supported for polygons with sides that don't span more than 180 degrees longitude.\n     * @default false\n     */\n    constructor(coordinates, needsSort = false, needsWrapping = false) {\n        this.m_coordinates = coordinates.map(coord => {\n            return GeoCoordLike_1.geoCoordLikeToGeoCoordinatesLike(coord);\n        });\n        if (needsSort) {\n            this.sortCCW();\n        }\n        if (needsWrapping) {\n            this.wrapCoordinatesAround();\n        }\n    }\n    get coordinates() {\n        return this.m_coordinates;\n    }\n    /**\n     * Gets a BoundingBox for the Polygon\n     *\n     * Might have unexpected results for twisted or concave Polygons\n     */\n    getGeoBoundingBox() {\n        const centroid = this.getCentroid();\n        if (centroid === undefined) {\n            //return a BBox without extend if the centroid could not be generated\n            return GeoBox_1.GeoBox.fromCoordinates(this.coordinates[0], this.coordinates[0]);\n        }\n        const { east, west } = this.getEastAndWest(centroid);\n        const { north, south } = this.getNorthAndSouth();\n        return GeoBox_1.GeoBox.fromCoordinates(new GeoCoordinates_1.GeoCoordinates(south, west), new GeoCoordinates_1.GeoCoordinates(north, east));\n    }\n    /**\n     * Gets the Centroid for the Polygon\n     *\n     * Might be undefined or with unexpected results for twisted or concave Polygons.\n     */\n    getCentroid() {\n        const area = this.getArea();\n        if (area === 0) {\n            return undefined;\n        }\n        let latitude = 0;\n        let longitude = 0;\n        let f;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            f =\n                coordinate.latitude * previousCoordinate.longitude -\n                    previousCoordinate.latitude * coordinate.longitude;\n            latitude += (coordinate.latitude + previousCoordinate.latitude) * f;\n            longitude += (coordinate.longitude + previousCoordinate.longitude) * f;\n            previousIndex = index;\n        });\n        f = area * 6;\n        return new GeoCoordinates_1.GeoCoordinates(latitude / f, area < 0 /* antimeridian crossing */ ? -180 + longitude / f : longitude / f);\n    }\n    sortCCW() {\n        const polyCenter = this.getPolyAverageCenter();\n        if (!polyCenter) {\n            return;\n        }\n        //sorts by angle from x-axis\n        this.m_coordinates.sort((a, b) => {\n            const veca = new three_1.Vector2(a.latitude - polyCenter.latitude, a.longitude - polyCenter.longitude).normalize();\n            const vecb = new three_1.Vector2(b.latitude - polyCenter.latitude, b.longitude - polyCenter.longitude).normalize();\n            return vecb.angle() - veca.angle();\n        });\n    }\n    wrapCoordinatesAround() {\n        const firstAntimerCrossIndex = this.m_coordinates.findIndex((val, index) => {\n            const prevLonIndex = index === 0 ? this.m_coordinates.length - 1 : index - 1;\n            const prevLon = this.m_coordinates[prevLonIndex].longitude;\n            const lon = val.longitude;\n            return isLeftToRightAntimeridianCrossing(prevLon, lon);\n        });\n        if (firstAntimerCrossIndex < 0) {\n            return;\n        }\n        let wrapAround = true;\n        for (let i = 0; i < this.m_coordinates.length; i++) {\n            const index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;\n            const currentLon = this.m_coordinates[index].longitude;\n            const nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;\n            if (wrapAround) {\n                this.m_coordinates[index].longitude += 360;\n            }\n            if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {\n                wrapAround = false;\n            }\n            else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {\n                wrapAround = true;\n            }\n        }\n    }\n    getPolyAverageCenter() {\n        const polySum = this.m_coordinates.reduce((prev, curr) => {\n            return new GeoCoordinates_1.GeoCoordinates(prev.latitude + curr.latitude, prev.longitude + curr.longitude);\n        });\n        //create an average center point\n        return new GeoCoordinates_1.GeoCoordinates(polySum.latitude / this.m_coordinates.length, polySum.longitude / this.m_coordinates.length);\n    }\n    getArea() {\n        let area = 0;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            area += coordinate.latitude * previousCoordinate.longitude;\n            area -= coordinate.longitude * previousCoordinate.latitude;\n            previousIndex = index;\n        });\n        return (area /= 2);\n    }\n    getEastAndWest(center) {\n        let west = center.longitude;\n        let east = center.longitude;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            previousIndex = index;\n            const veca = new three_1.Vector2(coordinate.latitude - center.latitude, coordinate.longitude - center.longitude).normalize();\n            const vecb = new three_1.Vector2(previousCoordinate.latitude - center.latitude, previousCoordinate.longitude - center.longitude).normalize();\n            let ccw = Math.sign(vecb.angle() - veca.angle()) === 1;\n            // overwrite in case of angle over axis\n            if (vecb.y >= 0 && veca.y < 0) {\n                ccw = true;\n            }\n            const long = coordinate.longitude;\n            if (long < center.longitude) {\n                if (ccw) {\n                    west = Math.min(west, long);\n                }\n                else {\n                    east = Math.min(east, long);\n                }\n            }\n            else {\n                if (ccw) {\n                    east = Math.max(east, long);\n                }\n                else {\n                    west = Math.max(west, long);\n                }\n            }\n        });\n        return { east, west };\n    }\n    getNorthAndSouth() {\n        let north = GeoCoordinates_1.MIN_LATITUDE;\n        let south = GeoCoordinates_1.MAX_LATITUDE;\n        this.m_coordinates.forEach((coordinate, index) => {\n            north = Math.max(north, coordinate.latitude);\n            south = Math.min(south, coordinate.latitude);\n        });\n        return { north, south };\n    }\n}\nexports.GeoPolygon = GeoPolygon;\n//# sourceMappingURL=GeoPolygon.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoPolygonLike = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GeoCoordLike_1 = __webpack_require__(/*! ./GeoCoordLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js\");\n/**\n * Type guard to assert that `object` conforms to {@link GeoPolygonLike} data interface.\n *\n * @beta, @internal\n */\nfunction isGeoPolygonLike(object) {\n    if (!object || (!Array.isArray(object.coordinates) && object.coordinates.length > 2)) {\n        return false;\n    }\n    let isValid = true;\n    //TODO: this might take a while, not sure this should be that extensive\n    object.coordinates.forEach((coord) => {\n        if (!GeoCoordLike_1.isGeoCoordLike(object)) {\n            isValid = false;\n        }\n    });\n    return isValid;\n}\nexports.isGeoPolygonLike = isGeoPolygonLike;\n//# sourceMappingURL=GeoPolygonLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLatLngLike = void 0;\n/**\n * Type guard to assert that `object` conforms to {@link LatLngLike} interface.\n */\nfunction isLatLngLike(object) {\n    return object && typeof object.lat === \"number\" && typeof object.lng === \"number\";\n}\nexports.isLatLngLike = isLatLngLike;\n//# sourceMappingURL=LatLngLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Box3Like.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBox3Like = void 0;\n/**\n * Returns true if the given object implements the {@link Box3Like} interface.\n *\n * @param object - A valid object.\n */\nfunction isBox3Like(object) {\n    const box3 = object;\n    return box3.min !== undefined && box3.max !== undefined;\n}\nexports.isBox3Like = isBox3Like;\n//# sourceMappingURL=Box3Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Box3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/MathUtils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathUtils = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nvar MathUtils;\n(function (MathUtils) {\n    /**\n     * Creates a new empty bounding box.\n     *\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/Box3 | THREE.Box3} instead.\n     */\n    function newEmptyBox3() {\n        return {\n            min: { x: Infinity, y: Infinity, z: Infinity },\n            max: { x: -Infinity, y: -Infinity, z: -Infinity }\n        };\n    }\n    MathUtils.newEmptyBox3 = newEmptyBox3;\n    /**\n     * Set the components of the given [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param v - The [Vector3Like]\n     */\n    function newVector3(x, y, z, v) {\n        if (v === undefined) {\n            return { x, y, z };\n        }\n        v.x = x;\n        v.y = y;\n        v.z = z;\n        return v;\n    }\n    MathUtils.newVector3 = newVector3;\n    /**\n     * Copies the vector across.\n     *\n     * @param from - The vector to copy from.\n     * @param to - The resulting [Vector3Like] instance, with the contents copied from from\n     */\n    function copyVector3(from, to) {\n        to.x = from.x;\n        to.y = from.y;\n        to.z = from.z;\n        return to;\n    }\n    MathUtils.copyVector3 = copyVector3;\n    /**\n     * Converts an angle measured in degrees to an equivalent value in radians.\n     *\n     * @param degrees - Value in degrees.\n     * @returns Value in radians.\n     * @deprecated use THREE.MathUtils.degToRad instead\n     */\n    MathUtils.degToRad = THREE.MathUtils.degToRad;\n    /**\n     * Converts an angle measured in radians to an equivalent value in degrees.\n     *\n     * @param degrees - Value in radians.\n     * @returns Value in degrees.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.radToDeg\n     *                | THREE.MathUtils.radToDeg}.\n     */\n    MathUtils.radToDeg = THREE.MathUtils.radToDeg;\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     * @returns Clamped value.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.clamp\n     *                | THREE.MathUtils.clamp}.\n     */\n    MathUtils.clamp = THREE.MathUtils.clamp;\n    /**\n     * Normalize angle in degrees to range `[0, 360)`.\n     *\n     * @param a - Angle in degrees.\n     * @returns Angle in degrees in range `[0, 360)`.\n     */\n    function normalizeAngleDeg(a) {\n        a = a % 360;\n        if (a < 0) {\n            a = a + 360;\n        }\n        return a;\n    }\n    MathUtils.normalizeAngleDeg = normalizeAngleDeg;\n    /**\n     * Normalize latitude angle in degrees to range `[-180, 180]`.\n     *\n     * @param a - Latitude angle in degrees.\n     * @returns Latitude angle in degrees in range `[-180, 180]`.\n     */\n    function normalizeLongitudeDeg(a) {\n        a = normalizeAngleDeg(a);\n        if (a > 180) {\n            a = a - 360;\n        }\n        return a;\n    }\n    MathUtils.normalizeLongitudeDeg = normalizeLongitudeDeg;\n    /**\n     * Return the minimal delta between angles `a` and `b` given in degrees.\n     *\n     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed\n     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.\n     *\n     * Useful when interpolating between `b` and `a` in angle space.\n     *\n     * @param a - Start angle in degrees.\n     * @param b - End angle in degrees.\n     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.\n     */\n    function angleDistanceDeg(a, b) {\n        a = normalizeAngleDeg(a);\n        b = normalizeAngleDeg(b);\n        const d = a - b;\n        if (d > 180) {\n            return d - 360;\n        }\n        else if (d <= -180) {\n            return d + 360;\n        }\n        else {\n            return d;\n        }\n    }\n    MathUtils.angleDistanceDeg = angleDistanceDeg;\n    /**\n     * Interpolate linearly between two angles given in degrees.\n     *\n     * @param p0 - Angle from in degrees\n     * @param p1 - Angle to in degrees\n     * @param t - Interpolation factor (alpha), in range `0-1`.\n     */\n    function interpolateAnglesDeg(p0, p1, t) {\n        // hand crafted version,\n        // see stack for maybe better versions:\n        //    https://stackoverflow.com/questions/2708476/rotation-interpolation\n        const d = angleDistanceDeg(p1, p0);\n        const r = (p0 + d * t) % 360;\n        return r;\n    }\n    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;\n})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));\n//# sourceMappingURL=MathUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/MathUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OrientedBox3 = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nfunction intersectsSlab(rayDir, p, axis, extent, t) {\n    const epsilon = 1e-20;\n    const e = axis.dot(p);\n    const f = axis.dot(rayDir);\n    if (Math.abs(f) < epsilon) {\n        // ray parallel to near/far slab lines.\n        return Math.abs(e) <= extent;\n    }\n    // ray intersects near/far slab lines.\n    const finv = 1 / f;\n    const t1 = (e + extent) * finv;\n    const t2 = (e - extent) * finv;\n    if (t1 > t2) {\n        // t1 is far intersect, t2 is near.\n        if (t2 > t.min) {\n            t.min = t2;\n        }\n        if (t1 < t.max) {\n            t.max = t1;\n        }\n    }\n    else {\n        // t1 is near intersect, t2 is far.\n        if (t1 > t.min) {\n            t.min = t1;\n        }\n        if (t2 < t.max) {\n            t.max = t2;\n        }\n    }\n    return t.min <= t.max && t.max >= 0;\n}\nconst tmpVec = new three_1.Vector3();\nconst tmpT = { min: -Infinity, max: Infinity };\nclass OrientedBox3 {\n    /**\n     * Creates a new `OrientedBox3`.\n     *\n     * @hideconstructor\n     */\n    constructor(position, rotationMatrix, extents) {\n        /**\n         * The position of the center of this `OrientedBox3`.\n         */\n        this.position = new three_1.Vector3();\n        /**\n         * The x-axis of this `OrientedBox3`.\n         */\n        this.xAxis = new three_1.Vector3(1, 0, 0);\n        /**\n         * The y-axis of this `OrientedBox3`.\n         */\n        this.yAxis = new three_1.Vector3(0, 1, 0);\n        /**\n         * The z-axis of this `OrientedBox3`.\n         */\n        this.zAxis = new three_1.Vector3(0, 0, 1);\n        /**\n         * The extents of this `OrientedBox3`.\n         */\n        this.extents = new three_1.Vector3();\n        if (position !== undefined) {\n            this.position.copy(position);\n        }\n        if (rotationMatrix !== undefined) {\n            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);\n        }\n        if (extents !== undefined) {\n            this.extents.copy(extents);\n        }\n    }\n    /**\n     * Create a copy of this [[OrientedBoundingBox]].\n     */\n    clone() {\n        const newBox = new OrientedBox3();\n        newBox.copy(this);\n        return newBox;\n    }\n    /**\n     * Copies the values of `other` to this {@link OrientedBox3}.\n     * @param other - The other {@link OrientedBox3} to copy.\n     */\n    copy(other) {\n        this.position.copy(other.position);\n        this.xAxis.copy(other.xAxis);\n        this.yAxis.copy(other.yAxis);\n        this.zAxis.copy(other.zAxis);\n        this.extents.copy(other.extents);\n    }\n    /**\n     * Gets the center position of this {@link OrientedBox3}.\n     *\n     * @param center - The returned center position.\n     */\n    getCenter(center = new three_1.Vector3()) {\n        return center.copy(this.position);\n    }\n    /**\n     * Gets the size of this {@link OrientedBox3}.\n     *\n     * @param size - The returned size.\n     */\n    getSize(size = new three_1.Vector3()) {\n        return size.copy(this.extents).multiplyScalar(2);\n    }\n    /**\n     * Gets the orientation matrix of this `OrientedBox3`.\n     * @param matrix - The output orientation matrix.\n     */\n    getRotationMatrix(matrix = new three_1.Matrix4()) {\n        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);\n    }\n    /**\n     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.\n     *\n     * @param frustumOrPlanes - Frustum or array of planes.\n     */\n    intersects(frustumOrPlanes) {\n        const planes = Array.isArray(frustumOrPlanes)\n            ? frustumOrPlanes\n            : frustumOrPlanes.planes;\n        for (const plane of planes) {\n            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +\n                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +\n                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);\n            const d = plane.distanceToPoint(this.position);\n            if (d + r < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks intersection with the given ray.\n     *\n     * @param ray - The ray to test.\n     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.\n     */\n    intersectsRay(ray) {\n        // Slabs intersection algorithm.\n        tmpT.min = -Infinity;\n        tmpT.max = Infinity;\n        tmpVec.copy(this.position).sub(ray.origin);\n        if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {\n            return undefined;\n        }\n        return tmpT.min > 0 ? tmpT.min : tmpT.max;\n    }\n    /**\n     * Returns true if this {@link OrientedBox3} contains the given point.\n     *\n     * @param point - A valid point.\n     */\n    contains(point) {\n        const dx = point.x - this.position.x;\n        const dy = point.y - this.position.y;\n        const dz = point.z - this.position.z;\n        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);\n        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);\n        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);\n        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPoint(point) {\n        return Math.sqrt(this.distanceToPointSquared(point));\n    }\n    /**\n     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPointSquared(point) {\n        const d = new three_1.Vector3();\n        d.subVectors(point, this.position);\n        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];\n        let result = 0;\n        for (let i = 0; i < 3; ++i) {\n            const length = lengths[i];\n            const extent = this.extents.getComponent(i);\n            if (length < -extent) {\n                const dd = extent + length;\n                result += dd * dd;\n            }\n            else if (length > extent) {\n                const dd = length - extent;\n                result += dd * dd;\n            }\n        }\n        return result;\n    }\n}\nexports.OrientedBox3 = OrientedBox3;\n//# sourceMappingURL=OrientedBox3.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isOrientedBox3Like = void 0;\n/**\n * Returns true if the given object implements the interface {@link OrientedBox3Like}.\n *\n * @param object - The object.\n */\nfunction isOrientedBox3Like(object) {\n    const obb = object;\n    return (obb.position !== undefined &&\n        obb.xAxis !== undefined &&\n        obb.yAxis !== undefined &&\n        obb.zAxis !== undefined &&\n        obb.extents !== undefined);\n}\nexports.isOrientedBox3Like = isOrientedBox3Like;\n//# sourceMappingURL=OrientedBox3Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/TransformLike.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/TransformLike.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTransformLike = void 0;\n/**\n * Returns true if the given object implements the interface {@link TransformLike}.\n *\n * @param object - The object.\n */\nfunction isTransformLike(object) {\n    const transform = object;\n    return (transform.position !== undefined &&\n        transform.xAxis !== undefined &&\n        transform.yAxis !== undefined &&\n        transform.zAxis !== undefined);\n}\nexports.isTransformLike = isTransformLike;\n//# sourceMappingURL=TransformLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/TransformLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVector2Like = void 0;\nfunction isVector2Like(v) {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\";\n}\nexports.isVector2Like = isVector2Like;\n//# sourceMappingURL=Vector2Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVector3Like = void 0;\nfunction isVector3Like(v) {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\nexports.isVector3Like = isVector3Like;\n//# sourceMappingURL=Vector3Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EarthConstants = void 0;\nclass EarthConstants {\n}\nexports.EarthConstants = EarthConstants;\n/** The equatorial circumference in meters. */\nEarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;\n/** The equatorial radius in meters. */\nEarthConstants.EQUATORIAL_RADIUS = 6378137.0;\n/** The lowest point on earth (Dead Sea) in meters. */\nEarthConstants.MIN_ELEVATION = -433.0;\n/** The highest point on earth (Mt. Everest) in meters. */\nEarthConstants.MAX_ELEVATION = 8848.0;\n/** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */\nEarthConstants.MAX_BUILDING_HEIGHT = 828;\n//# sourceMappingURL=EarthConstants.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.equirectangularProjection = exports.normalizedEquirectangularProjection = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass EquirectangularProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = 0.0;\n        result.min.y = 0.0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale / 2;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        var _a;\n        if (result === undefined) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x =\n            (THREE.MathUtils.degToRad(geoPoint.longitude) + Math.PI) *\n                EquirectangularProjection.geoToWorldScale *\n                this.unitScale;\n        result.y =\n            (THREE.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) *\n                EquirectangularProjection.geoToWorldScale *\n                this.unitScale;\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -\n            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));\n        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;\n        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;\n            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;\n            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;\n            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            }\n            else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = sizeX * 0.5 * this.unitScale;\n            result.extents.y = sizeY * 0.5 * this.unitScale;\n            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan !== null && altitudeSpan !== void 0 ? altitudeSpan : 0) * 0.5);\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\nEquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);\nEquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to unit coordinates and vice\n * versa.\n */\nexports.normalizedEquirectangularProjection = new EquirectangularProjection(1);\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to world coordinates and vice\n * versa.\n */\nexports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n//# sourceMappingURL=EquirectangularProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.identityProjection = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass IdentityProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = -Math.PI;\n        result.min.y = -Math.PI * 0.5;\n        result.min.z = minAltitude;\n        result.max.x = Math.PI;\n        result.max.y = Math.PI * 0.5;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        var _a;\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = THREE.MathUtils.degToRad(geoPoint.longitude);\n        result.y = THREE.MathUtils.degToRad(geoPoint.latitude);\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));\n        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = min.x;\n            result.min.y = min.y;\n            result.min.z = min.z;\n            result.max.x = max.x;\n            result.max.y = max.y;\n            result.max.z = max.z;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (min.x + max.x) * 0.5;\n            result.position.y = (min.y + max.y) * 0.5;\n            result.position.z = (min.z + max.z) * 0.5;\n            result.extents.x = (max.x - min.x) * 0.5;\n            result.extents.y = (max.y - min.y) * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n/**\n * Identity {@link Projection} used to convert geo coordinates to unit coordinates and vice versa.\n */\nexports.identityProjection = new IdentityProjection(1);\n//# sourceMappingURL=IdentityProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webMercatorProjection = exports.mercatorProjection = exports.MercatorConstants = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass MercatorProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    static clamp(val, min, max) {\n        return Math.min(Math.max(min, val), max);\n    }\n    static latitudeClamp(latitude) {\n        return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);\n    }\n    static latitudeProject(latitude) {\n        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;\n    }\n    static latitudeClampProject(latitude) {\n        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));\n    }\n    static unprojectLatitude(y) {\n        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;\n    }\n    /** @override */\n    getScaleFactor(worldPoint) {\n        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPointLike, result) {\n        var _a;\n        let geoPoint;\n        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {\n            geoPoint = geoPointLike;\n        }\n        else {\n            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);\n        }\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        result.y =\n            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *\n                this.unitScale;\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        var _a;\n        const worldCenter = this.projectPoint(geoBox.center);\n        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +\n            0.5) *\n            this.unitScale;\n        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +\n            0.5) *\n            this.unitScale;\n        const worldYCenter = (worldNorth + worldSouth) * 0.5;\n        worldCenter.y = worldYCenter;\n        const latitudeSpan = worldNorth - worldSouth;\n        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = worldCenter.x - longitudeSpan * 0.5;\n            result.min.y = worldCenter.y - latitudeSpan * 0.5;\n            result.max.x = worldCenter.x + longitudeSpan * 0.5;\n            result.max.y = worldCenter.y + latitudeSpan * 0.5;\n            const altitudeSpan = geoBox.altitudeSpan;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            }\n            else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = longitudeSpan * 0.5;\n            result.extents.y = latitudeSpan * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, ((_a = geoBox.altitudeSpan) !== null && _a !== void 0 ? _a : 0) * 0.5);\n        }\n        else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n    /** @override */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        // this implementation of [[reprojectPoint]] supports both\n        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only\n        // difference betweeen these two variants of WEB Mercator\n        // is in the orientation of the Y axis, so we just flip Y coordinates\n        // when reprojecting between them.\n        if (sourceProjection !== this &&\n            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {\n            if (result === undefined) {\n                result = {};\n            }\n            result.x = worldPos.x;\n            result.y = this.unitScale - worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return super.reprojectPoint(sourceProjection, worldPos, result);\n    }\n}\nclass WebMercatorProjection extends MercatorProjection {\n    /** @override */\n    projectPoint(geoPointLike, result) {\n        var _a;\n        let geoPoint;\n        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {\n            geoPoint = geoPointLike;\n        }\n        else {\n            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);\n        }\n        /*\n         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n         * might be a concrete class which is not available at runtime.\n         * Consider the following example:\n         *\n         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n         *\n         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n         */\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));\n        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const x = worldPoint.x / this.unitScale - 0.5;\n        const y = 0.5 - worldPoint.y / this.unitScale;\n        const longitude = 360 * x;\n        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;\n        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const r = super.projectBox(geoBox, result);\n        if (Box3Like_1.isBox3Like(r)) {\n            // Invert the y axis for web mercator, this means that max => min & min => max\n            const maxY = r.max.y;\n            r.max.y = this.unitScale - r.min.y;\n            r.min.y = this.unitScale - maxY;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);\n            r.position.y = this.unitScale - r.position.y;\n        }\n        return r;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));\n        return geoBox;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n    /** @override */\n    localTangentSpace(point, result) {\n        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        }\n        else {\n            MathUtils_1.MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);\n        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);\n        return result;\n    }\n}\nclass MercatorConstants {\n}\nexports.MercatorConstants = MercatorConstants;\n// Math.atan(Math.sinh(Math.PI))\nMercatorConstants.MAXIMUM_LATITUDE = 1.4844222297453323;\n/**\n * Mercator {@link Projection} used to convert geo coordinates to world coordinates and vice versa.\n */\nexports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n/**\n * Web Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n//# sourceMappingURL=MercatorProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/Projection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Projection = exports.ProjectionType = void 0;\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\n/**\n * The type of projection.\n */\nvar ProjectionType;\n(function (ProjectionType) {\n    /**\n     * A type of [Projection] with zero curvature.\n     */\n    ProjectionType[ProjectionType[\"Planar\"] = 0] = \"Planar\";\n    /**\n     * A spherical [Projection].\n     */\n    ProjectionType[ProjectionType[\"Spherical\"] = 1] = \"Spherical\";\n})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));\n/**\n * `Projection` is used to convert positions from geo coordinates to world coordinates and vice\n * versa.\n */\nclass Projection {\n    /**\n     * Constructs the Projection\n     *\n     * @param unitScale - How to transform the projected coordinates to world units.\n     */\n    constructor(unitScale) {\n        this.unitScale = unitScale;\n        //Prevent empty constructor error.\n    }\n    /**\n     * Gets the {@link TransformLike} of the local tangent space at the given point.\n     *\n     * @param point - The geo / world coordinates.\n     * @param result - The {@link TransformLike}.\n     */\n    localTangentSpace(point, result) {\n        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        }\n        else {\n            MathUtils_1.MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n        return result;\n    }\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     * Implementations should be aware of worldPos and result may be one object\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid position in the world space defined by the source projection.\n     * @param result - The resulting position reprojected using this {@link Projection}.\n     * @hidden\n     */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        if (sourceProjection === this) {\n            if (result === undefined) {\n                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n            }\n            result.x = worldPos.x;\n            result.y = worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);\n    }\n}\nexports.Projection = Projection;\n//# sourceMappingURL=Projection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/Projection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sphereProjection = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\n/**\n * Transforms the given vector using the provided basis.\n */\nfunction apply(xAxis, yAxis, zAxis, v) {\n    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;\n    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;\n    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n/**\n * Returns the quadrants for the given longitude. The quadrant is defined as:\n *  - quadrant(+Math.PI * -1.0) = 0\n *  - quadrant(+Math.PI * -0.5) = 1\n *  - quadrant(+Math.PI *  0.0) = 2\n *  - quadrant(+Math.PI *  0.5) = 3\n *  - quadrant(+Math.PI *  1.0) = 4\n *\n * @param longitude - The longitude in radians.\n */\nfunction getLongitudeQuadrant(longitude) {\n    const oneOverPI = 1 / Math.PI;\n    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));\n    return THREE.MathUtils.clamp(quadrantIndex, 0, 4);\n}\nfunction lengthOfVector3(worldPoint) {\n    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);\n    return d;\n}\n/**\n * Creates a Box3 enclosing the geobox.\n *\n * @param geoBox - Ghe given geobox\n * @param worldBox - The resulting axis aligned bounding box.\n */\nfunction makeBox3(geoBox, worldBox, unitScale) {\n    var _a;\n    const halfEquatorialRadius = (unitScale + ((_a = geoBox.maxAltitude) !== null && _a !== void 0 ? _a : 0)) * 0.5;\n    const minLongitude = THREE.MathUtils.degToRad(geoBox.west);\n    const maxLongitude = THREE.MathUtils.degToRad(geoBox.east);\n    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);\n    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);\n    let xMin = Math.cos(minLongitude);\n    let xMax = xMin;\n    let yMin = Math.sin(minLongitude);\n    let yMax = yMin;\n    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {\n        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);\n        xMin = Math.min(x, xMin);\n        xMax = Math.max(x, xMax);\n        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);\n        yMin = Math.min(y, yMin);\n        yMax = Math.max(y, yMax);\n    }\n    const cosMaxLongitude = Math.cos(maxLongitude);\n    xMin = Math.min(cosMaxLongitude, xMin);\n    xMax = Math.max(cosMaxLongitude, xMax);\n    const sinMaxLongitude = Math.sin(maxLongitude);\n    yMin = Math.min(sinMaxLongitude, yMin);\n    yMax = Math.max(sinMaxLongitude, yMax);\n    const xCenter = (xMax + xMin) * halfEquatorialRadius;\n    const xExtent = (xMax - xMin) * halfEquatorialRadius;\n    const yCenter = (yMax + yMin) * halfEquatorialRadius;\n    const yExtent = (yMax - yMin) * halfEquatorialRadius;\n    // Calculate Z boundaries.\n    const minLatitude = THREE.MathUtils.degToRad(geoBox.south);\n    const maxLatutide = THREE.MathUtils.degToRad(geoBox.north);\n    const zMax = Math.sin(maxLatutide);\n    const zMin = Math.sin(minLatitude);\n    const zCenter = (zMax + zMin) * halfEquatorialRadius;\n    const zExtent = (zMax - zMin) * halfEquatorialRadius;\n    worldBox.min.x = xCenter - xExtent;\n    worldBox.min.y = yCenter - yExtent;\n    worldBox.min.z = zCenter - zExtent;\n    worldBox.max.x = xCenter + xExtent;\n    worldBox.max.y = yCenter + yExtent;\n    worldBox.max.z = zCenter + zExtent;\n    return worldBox;\n}\n/**\n * Computes the spherical projection of the given geo coordinates.\n *\n * @param geoPoint - The geo coordinates.\n * @param worldpoint - The resulting world coordinates.\n */\nfunction project(geoPoint, worldpoint, unitScale) {\n    var _a;\n    const radius = unitScale + ((_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0);\n    const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n    const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n    const cosLatitude = Math.cos(latitude);\n    worldpoint.x = radius * cosLatitude * Math.cos(longitude);\n    worldpoint.y = radius * cosLatitude * Math.sin(longitude);\n    worldpoint.z = radius * Math.sin(latitude);\n    return worldpoint;\n}\nclass SphereProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Spherical;\n    }\n    /** @override */\n    worldExtent(_minElevation, maxElevation, result = new THREE.Box3()) {\n        const radius = this.unitScale + maxElevation;\n        result.min.x = -radius;\n        result.min.y = -radius;\n        result.min.z = -radius;\n        result.max.x = radius;\n        result.max.y = radius;\n        result.max.z = radius;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {\n        return project(geoPoint, result, this.unitScale);\n    }\n    /** @override */\n    unprojectPoint(point) {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y;\n        const parallelRadius = Math.sqrt(parallelRadiusSq);\n        const v = point.z / parallelRadius;\n        if (isNaN(v)) {\n            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);\n        }\n        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);\n        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);\n    }\n    /** @override */\n    unprojectAltitude(point) {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;\n        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;\n    }\n    /** @override */\n    projectBox(geoBox, result = new THREE.Box3()) {\n        var _a, _b;\n        if (Box3Like_1.isBox3Like(result)) {\n            return makeBox3(geoBox, result, this.unitScale);\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            if (geoBox.longitudeSpan >= 90) {\n                const bounds = makeBox3(geoBox, new THREE.Box3(), this.unitScale);\n                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;\n                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;\n                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;\n                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;\n                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;\n                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;\n                return result;\n            }\n            const { south, west, north, east, center: mid } = geoBox;\n            const midX = mid.longitude;\n            const midY = mid.latitude;\n            const cosSouth = Math.cos(THREE.MathUtils.degToRad(south));\n            const sinSouth = Math.sin(THREE.MathUtils.degToRad(south));\n            const cosWest = Math.cos(THREE.MathUtils.degToRad(west));\n            const sinWest = Math.sin(THREE.MathUtils.degToRad(west));\n            const cosNorth = Math.cos(THREE.MathUtils.degToRad(north));\n            const sinNorth = Math.sin(THREE.MathUtils.degToRad(north));\n            const cosEast = Math.cos(THREE.MathUtils.degToRad(east));\n            const sinEast = Math.sin(THREE.MathUtils.degToRad(east));\n            const cosMidX = Math.cos(THREE.MathUtils.degToRad(midX));\n            const sinMidX = Math.sin(THREE.MathUtils.degToRad(midX));\n            const cosMidY = Math.cos(THREE.MathUtils.degToRad(midY));\n            const sinMidY = Math.sin(THREE.MathUtils.degToRad(midY));\n            // Build the orientation of the OBB using the normal vector and its partial derivates.\n            // the sperical coordinates of the mid point of the geobox.\n            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);\n            // the partial derivates of the normal vector.\n            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);\n            let width;\n            let minY;\n            let maxY;\n            if (south >= 0) {\n                // abs(dot(southWest - southEast, xAxis))\n                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));\n                // dot(south, yAxis)\n                minY = cosMidY * sinSouth - sinMidY * cosSouth;\n                // dot(northEast, zAxis)\n                maxY =\n                    cosMidY * sinNorth -\n                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n            else {\n                if (north <= 0) {\n                    // abs(dot(northWest - northEast, xAxis))\n                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));\n                    // dot(north, yAxis)\n                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;\n                }\n                else {\n                    // abs(dot(west - east, xAxis))\n                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));\n                    // dot(northEast, yAxis)\n                    maxY =\n                        cosMidY * sinNorth -\n                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);\n                }\n                // dot(southEast, yAxis)\n                minY =\n                    cosMidY * sinSouth -\n                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n            const rMax = (this.unitScale + ((_a = geoBox.maxAltitude) !== null && _a !== void 0 ? _a : 0)) * 0.5;\n            const rMin = (this.unitScale + ((_b = geoBox.minAltitude) !== null && _b !== void 0 ? _b : 0)) * 0.5;\n            // min(dot(southEast, zAxis), dot(northEast, zAxis))\n            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);\n            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);\n            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);\n            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);\n            apply(result.xAxis, result.yAxis, result.zAxis, result.position);\n            result.position.x = result.position.x - result.zAxis.x * result.extents.z;\n            result.position.y = result.position.y - result.zAxis.y * result.extents.z;\n            result.position.z = result.position.z - result.zAxis.z * result.extents.z;\n            return result;\n        }\n        throw new Error(\"Invalid bounding box\");\n    }\n    /** @override */\n    unprojectBox(_worldBox) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return lengthOfVector3(worldPoint) - this.unitScale;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);\n        worldPoint.x *= scale;\n        worldPoint.y *= scale;\n        worldPoint.z *= scale;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 0 };\n        }\n        const scale = 1 / (lengthOfVector3(worldPoint) || 1);\n        normal.x = worldPoint.x * scale;\n        normal.y = worldPoint.y * scale;\n        normal.z = worldPoint.z * scale;\n        return normal;\n    }\n    /** @override */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {\n            const { x, y, z } = worldPos;\n            const r = this.unitScale;\n            const mx = x / r - Math.PI;\n            const my = y / r - Math.PI;\n            const w = Math.exp(my);\n            const d = w * w;\n            const gx = (2 * w) / (d + 1);\n            const gy = (d - 1) / (d + 1);\n            const scale = r + z;\n            if (result === undefined) {\n                result = {};\n            }\n            result.x = Math.cos(mx) * gx * scale;\n            result.y = Math.sin(mx) * gx * scale;\n            result.z = gy * scale;\n            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {\n                result.z = -result.z;\n            }\n            return result;\n        }\n        return super.reprojectPoint(sourceProjection, worldPos, result);\n    }\n    /** @override */\n    localTangentSpace(point, result) {\n        let geoPoint;\n        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n            geoPoint = point;\n        }\n        else {\n            MathUtils_1.MathUtils.copyVector3(point, result.position);\n            geoPoint = this.unprojectPoint(point);\n        }\n        const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n        const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n        const cosLongitude = Math.cos(longitude);\n        const sinLongitude = Math.sin(longitude);\n        const cosLatitude = Math.cos(latitude);\n        const sinLatitude = Math.sin(latitude);\n        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);\n        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);\n        return result;\n    }\n}\nexports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);\n//# sourceMappingURL=SphereProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transverseMercatorProjection = exports.TransverseMercatorUtils = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\n/**\n *\n * https://en.wikipedia.org/wiki/Transverse_Mercator_projection\n * http://mathworld.wolfram.com/MercatorProjection.html\n *\n */\nclass TransverseMercatorProjection extends Projection_1.Projection {\n    constructor(unitScale) {\n        super(unitScale);\n        this.unitScale = unitScale;\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n        this.m_phi0 = 0;\n        this.m_lambda0 = 0;\n    }\n    /**\n     * Like in regular Mercator projection, there are two points on sphere\n     * with radius about 5 degrees, that is out of projected space.\n     *\n     *\n     * in regular Mercator these points are:\n     *     (90, any), (-90, any)\n     *\n     * and in transverse Mercator:\n     *     (0, 90), (0, -90)\n     *\n     * So, in transverse we need to compute distnce to poles, and clamp if\n     * radius is exceeded\n     */\n    static clampGeoPoint(geoPoint, _unitScale) {\n        const lat = geoPoint.latitude;\n        const lon = geoPoint.longitude;\n        const r = TransverseMercatorUtils.POLE_RADIUS;\n        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;\n        const nearestQuarter = Math.round(lon / 90);\n        const deltaLon = nearestQuarter * 90 - lon;\n        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {\n            return geoPoint;\n        }\n        const deltaLat = lat - 0;\n        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;\n        if (distanceToPoleSq < rsq) {\n            const distanceToPole = Math.sqrt(distanceToPoleSq);\n            const scale = (r - distanceToPole) / distanceToPole;\n            // const quarter = ((nearestQuarter % 4) + 4) % 4;\n            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;\n            const dir = 1;\n            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;\n            return new GeoCoordinates_1.GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);\n        }\n        return geoPoint;\n    }\n    /** @override */\n    getScaleFactor(worldPoint) {\n        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        var _a;\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);\n        const normalLon = clamped.longitude / 360 + 0.5;\n        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);\n        const phi = THREE.MathUtils.degToRad(clamped.latitude);\n        const lambda = THREE.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;\n        const B = Math.cos(phi) * Math.sin(lambda);\n        // result.x = 1/2 * Math.log((1 + B) / (1 - B));\n        result.x = Math.atanh(B);\n        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;\n        const outScale = 0.5 / Math.PI;\n        result.x =\n            this.unitScale * (THREE.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);\n        result.y = this.unitScale * THREE.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const tau = Math.PI * 2;\n        const nx = worldPoint.x / this.unitScale;\n        const ny = worldPoint.y / this.unitScale;\n        const offset = nx === 1 ? 0 : Math.floor(nx);\n        const x = tau * (nx - 0.5 - offset);\n        const y = tau * (ny - 0.5);\n        const z = worldPoint.z || 0;\n        const D = y + this.m_phi0;\n        const phi = Math.asin(Math.sin(D) / Math.cosh(x));\n        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(phi, lambda, z);\n        return geoPoint;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const { north, south, east, west } = geoBox;\n        const pointsToCheck = [\n            geoBox.center,\n            geoBox.northEast,\n            geoBox.southWest,\n            new GeoCoordinates_1.GeoCoordinates(south, east),\n            new GeoCoordinates_1.GeoCoordinates(north, west)\n        ];\n        const E = TransverseMercatorUtils.POLE_EDGE_DEG;\n        const containsWestCut = west < -90 && east > -90;\n        const containsEastCut = west < 90 && east > 90;\n        const containsCenterX = west < 0 && east > 0;\n        const containsCenterY = west < E && east > -E && north > 0 && south < 0;\n        if (containsWestCut) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, -90));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, -90));\n        }\n        if (containsEastCut) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 90));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 90));\n        }\n        if (containsCenterX) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 0));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 0));\n        }\n        if (containsCenterY) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, west));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, east));\n        }\n        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);\n        const projected = pointsToCheck.map(p => this.projectPoint(p));\n        const vx = projected.map(p => p.x);\n        const vy = projected.map(p => p.y);\n        const vz = projected.map(p => p.z);\n        const minX = Math.min(...vx);\n        const minY = Math.min(...vy);\n        const minZ = Math.min(...vz);\n        const maxX = Math.max(...vx);\n        const maxY = Math.max(...vy);\n        const maxZ = Math.max(...vz);\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = minX;\n            result.min.y = minY;\n            result.min.z = minZ;\n            result.max.x = maxX;\n            result.max.y = maxY;\n            result.max.z = maxZ;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (minX + maxX) / 2;\n            result.position.y = (minY + maxY) / 2;\n            result.position.z = (minZ + maxZ) / 2;\n            result.extents.x = (maxX - minX) / 2;\n            result.extents.y = (maxY - minY) / 2;\n            result.extents.z = (maxZ - minZ) / 2;\n        }\n        else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n    /**\n     * There are 8 sub-regions on entire projection space\n     * where both longitude and latitude preserve direction.\n     * If bounding box hits more than one region, it should be splitted\n     * into sub-boxes by regions, (un)projected and then united again.\n     *\n     *\n     * directions in form [latitude / longitude]:\n     *    1 ┌─────────|─────────┐\n     *      │ dr / dl | dl / ul │\n     * 0.75 ----------|----------\n     *      │ ur / dr | ul / ur │\n     * 0.5  ----------|----------\n     *      │ ul / ur | ur / dr │\n     * 0.25 ----------|----------\n     *      │ dl / ul | dr / dl │\n     *      └─────────|─────────┘\n     *     0         0.5        1\n     *     @override\n     */\n    unprojectBox(worldBox) {\n        const s = this.unitScale;\n        const min = worldBox.min;\n        const max = worldBox.max;\n        const pointsToCheck = [\n            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },\n            min,\n            max,\n            { x: min.x, y: max.y, z: 0 },\n            { x: max.x, y: min.y, z: 0 }\n        ];\n        const center = 0.5 * s;\n        const lowerQ = 0.25 * s;\n        const upperQ = 0.75 * s;\n        const containsCenterX = min.x < center && max.x > center;\n        const containsCenterY = min.y < center && max.y > center;\n        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;\n        const containsUpperQY = min.y < upperQ && max.y > upperQ;\n        if (containsCenterY) {\n            pointsToCheck.push({ x: min.x, y: center, z: 0 });\n            pointsToCheck.push({ x: max.x, y: center, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: center, z: 0 });\n            }\n        }\n        if (containsLowerQY) {\n            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });\n            }\n        }\n        if (containsUpperQY) {\n            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: upperQ, z: 0 });\n            }\n        }\n        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));\n        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);\n        const latitudes = geoPoints.map(g => g.latitude);\n        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);\n        const altitudes = geoPoints.map(g => { var _a; return (_a = g.altitude) !== null && _a !== void 0 ? _a : 0; });\n        const minGeo = new GeoCoordinates_1.GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));\n        const maxGeo = new GeoCoordinates_1.GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));\n        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n}\nclass TransverseMercatorUtils {\n    /**\n     * There are two regions on projected space that have same geo coordinates,\n     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }\n     * they both have geo coordinates of   (0, [-90..+90])\n     * and should be aligned somehow to fall into first or second region\n     * to make proper bounding boxes, tile bounds, etc.\n     */\n    static alignLatitude(points, referencePoint) {\n        const EPSILON = 1e-9;\n        for (const point of points) {\n            if (point.latitude === 0) {\n                point.latitude = referencePoint.latitude * EPSILON;\n            }\n        }\n    }\n    /**\n     * There are two regions on projected plane,\n     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }\n     * that represent longitude edge where -180 and +180 met.\n     * Points falling in this regions should be aligned to get proper boxes etc.\n     */\n    static alignLongitude(points, referencePoint) {\n        const bad = referencePoint.longitude < 0 ? 180 : -180;\n        const good = referencePoint.longitude < 0 ? -180 : 180;\n        for (const point of points) {\n            if (point.longitude === bad) {\n                point.longitude = good;\n            }\n        }\n    }\n}\nexports.TransverseMercatorUtils = TransverseMercatorUtils;\nTransverseMercatorUtils.POLE_EDGE = 1.4844222297453323;\nTransverseMercatorUtils.POLE_EDGE_DEG = THREE.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);\nTransverseMercatorUtils.POLE_RADIUS = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;\nTransverseMercatorUtils.POLE_RADIUS_SQ = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);\n/**\n * Transverse Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexports.transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n//# sourceMappingURL=TransverseMercatorProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlatTileBoundingBoxGenerator = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given\n * TilingScheme.\n */\nclass FlatTileBoundingBoxGenerator {\n    /**\n     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given\n     * TilingScheme.\n     *\n     * @param tilingScheme - The {@link TilingScheme} used to compute bounding boxes.\n     * @param minElevation - The minimum elevation in meters.\n     * @param maxElevation - The maximum elevation in meters.\n     */\n    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {\n        this.tilingScheme = tilingScheme;\n        this.minElevation = minElevation;\n        this.maxElevation = maxElevation;\n        this.m_tilingScheme = tilingScheme;\n        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);\n        const { min, max } = this.m_worldBox;\n        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };\n    }\n    /**\n     * Returns the {@link Projection} of the {@link TilingScheme}.\n     */\n    get projection() {\n        return this.m_tilingScheme.projection;\n    }\n    /**\n     * Returns the {@link SubdivisionScheme} of the {@link TilingScheme}.\n     */\n    get subdivisionScheme() {\n        return this.m_tilingScheme.subdivisionScheme;\n    }\n    /**\n     * Returns the bounding box in world coordinates of the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const worldBounds = new THREE.Box3();\n     * generator.getWorldBox(geoBox, worldBounds);\n     * console.log(worldBounds.getCenter());\n     * ```\n     *\n     * @param tileKey - The TileKey.\n     * @param result - The optional object used to store the resulting bounding box in world\n     * coordinates.\n     */\n    getWorldBox(tileKey, result) {\n        const level = tileKey.level;\n        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);\n        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);\n        const sizeX = this.m_worldDimensions.x / levelDimensionX;\n        const sizeY = this.m_worldDimensions.y / levelDimensionY;\n        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;\n        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = originX;\n        result.min.y = originY;\n        result.min.z = this.m_worldBox.min.z;\n        result.max.x = originX + sizeX;\n        result.max.y = originY + sizeY;\n        result.max.z = this.m_worldBox.max.z;\n        return result;\n    }\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const geoBox = generator.getGeoBox(worldBounds);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tileKey - The {@link TileKey}.\n     */\n    getGeoBox(tileKey) {\n        const worldBox = this.getWorldBox(tileKey);\n        return this.projection.unprojectBox(worldBox);\n    }\n}\nexports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;\n//# sourceMappingURL=FlatTileBoundingBoxGenerator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.halfQuadTreeSubdivisionScheme = void 0;\nclass HalfQuadTreeSubdivisionScheme {\n    getSubdivisionX() {\n        return 2;\n    }\n    getSubdivisionY(level) {\n        return level === 0 ? 1 : 2;\n    }\n    getLevelDimensionX(level) {\n        return 1 << level;\n    }\n    getLevelDimensionY(level) {\n        return level !== 0 ? 1 << (level - 1) : 1;\n    }\n}\n/**\n * A {@link SubdivisionScheme} used to represent half quadtrees.\n * This particular subdivision scheme is\n * used by the HERE tiling scheme.\n */\nexports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();\n//# sourceMappingURL=HalfQuadTreeSubdivisionScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hereTilingScheme = void 0;\nconst EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js\");\nconst HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * {@link TilingScheme} used by most of the data published by HERE.\n *\n * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular\n * projection.\n */\nexports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);\n//# sourceMappingURL=HereTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mercatorTilingScheme = void 0;\nconst MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * The {@link TilingScheme} used by the HERE web tiles.\n *\n * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.\n */\nexports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);\n//# sourceMappingURL=MercatorTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.polarTilingScheme = void 0;\nconst TransverseMercatorProjection_1 = __webpack_require__(/*! ../projection/TransverseMercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and\n * transverse Mercator projection.\n */\nexports.polarTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, TransverseMercatorProjection_1.transverseMercatorProjection);\n//# sourceMappingURL=PolarTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuadTree = void 0;\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\n/**\n * A class used to represent a quadtree.\n */\nclass QuadTree {\n    /**\n     * Constructs a new `QuadTree` for the given {@link TilingScheme}.\n     *\n     * Example:\n     * ```typescript\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * const geoBox = quadTree.getGeoBox(tileKey);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tilingScheme - The TilingScheme used by this `QuadTree`.\n     */\n    constructor(tilingScheme) {\n        this.tilingScheme = tilingScheme;\n    }\n    /**\n     * Visits this `QuadTree` and invoke the given accept method\n     * with the current {@link TileKey} and\n     * its bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = new GeoCoordinates(latitude, longitude);\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * quadTree.visit((tileKey, geoBox) => {\n     *     if (geoBox.contains(geoPos)) {\n     *         console.log(\"tile\", tileKey, \"contains\", geoPos);\n     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.\n     *     }\n     *     return false; // stop visiting the quadtree,\n     *                   // the tile's geoBox doesn't contain the given coordinates.\n     * });\n     * ```\n     *\n     * @param accept - A function that takes a {@link TileKey}\n     * and its bounding box in geo coordinates\n     * and returns `true` if the visit of the `QuadTree`\n     * should continue; otherwise `false`.\n     */\n    visit(accept) {\n        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);\n    }\n    /**\n     * Visits the subtree starting from the given tile.\n     *\n     * @param tileKey - The root of the subtree that should be visited.\n     * @param accept - A function that takes a {@link TileKey}\n     *                 and its bounding box in geo coordinates\n     *                 and returns `true` if the visit of the\n     *                 `QuadTree` should continue; otherwise `false`.\n     */\n    visitTileKey(tileKey, accept) {\n        const geoBox = this.tilingScheme.getGeoBox(tileKey);\n        if (!accept(tileKey, geoBox)) {\n            return;\n        }\n        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {\n            this.visitTileKey(subTileKey, accept);\n        }\n    }\n}\nexports.QuadTree = QuadTree;\n//# sourceMappingURL=QuadTree.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.quadTreeSubdivisionScheme = void 0;\nclass QuadTreeSubdivisionScheme {\n    getSubdivisionX() {\n        return 2;\n    }\n    getSubdivisionY() {\n        return 2;\n    }\n    getLevelDimensionX(level) {\n        return 1 << level;\n    }\n    getLevelDimensionY(level) {\n        return 1 << level;\n    }\n}\n/**\n * {@link SubdivisionScheme} representing a quadtree.\n */\nexports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();\n//# sourceMappingURL=QuadTreeSubdivisionScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubTiles = void 0;\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\nclass SubTiles {\n    constructor(tileKey, sizeX, sizeY) {\n        this.tileKey = tileKey;\n        this.sizeX = sizeX;\n        this.sizeY = sizeY;\n    }\n    [Symbol.iterator]() {\n        return this.sizeX === 2 && this.sizeY === 2\n            ? SubTiles.ZCurveIterator(this.tileKey)\n            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);\n    }\n}\nexports.SubTiles = SubTiles;\n(function (SubTiles) {\n    function* RowColumnIterator(parentKey, sizeX, sizeY) {\n        for (let y = 0; y < sizeY; y++) {\n            for (let x = 0; x < sizeX; x++) {\n                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);\n            }\n        }\n    }\n    SubTiles.RowColumnIterator = RowColumnIterator;\n    function* ZCurveIterator(parentKey) {\n        for (let i = 0; i < 4; i++) {\n            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);\n        }\n    }\n    SubTiles.ZCurveIterator = ZCurveIterator;\n})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));\n//# sourceMappingURL=SubTiles.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SubdivisionScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileKey = void 0;\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.\n];\n/**\n * The `TileKey` instances are used to address a tile in a quadtree.\n *\n * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one\n * single tile. On every level, each tile is divided into four children (therefore the name\n * quadtree).\n *\n * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number\n * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only\n * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles\n * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.\n *\n * A tile key is usually created using [[fromRowColumnLevel]]() method.\n *\n * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not\n * modify the original object.\n *\n * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for\n * easy vertical navigation of the tree. The number of available rows and columns in the tile's\n * level is given with [[rowCount]]() and [[columnCount]]().\n *\n * Tile keys can be created from and converted into various alternative formats:\n *\n *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based\n *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based\n *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation\n *\n * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be\n * represented in the number representation returned by [[mortonCode]]().\n */\nclass TileKey {\n    /**\n     * Constructs a new immutable instance of a `TileKey`.\n     *\n     * For the better readability, {@link TileKey.fromRowColumnLevel} should be preferred.\n     *\n     * Note - row and column must not be greater than the maximum rows/columns for the given level.\n     *\n     * @param row - Represents the row in the quadtree.\n     * @param column - Represents the column in the quadtree.\n     * @param level - Represents the level in the quadtree.\n     */\n    constructor(row, column, level) {\n        this.row = row;\n        this.column = column;\n        this.level = level;\n    }\n    /**\n     * Creates a tile key.\n     *\n     * @param row - The requested row. Must be less than 2 to the power of level.\n     * @param column - The requested column. Must be less than 2 to the power of level.\n     * @param level - The requested level.\n     */\n    static fromRowColumnLevel(row, column, level) {\n        return new TileKey(row, column, level);\n    }\n    /**\n     * Creates a tile key from a quad string.\n     *\n     * The quad string can be created with [[toQuadKey]].\n     *\n     * @param quadkey - The quadkey to convert.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromQuadKey(quadkey) {\n        const level = quadkey.length;\n        let row = 0;\n        let column = 0;\n        for (let i = 0; i < quadkey.length; ++i) {\n            const mask = 1 << i;\n            const d = parseInt(quadkey.charAt(level - i - 1), 10);\n            if (d & 0x1) {\n                column |= mask;\n            }\n            if (d & 0x2) {\n                row |= mask;\n            }\n        }\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Creates a tile key from a numeric Morton code representation.\n     *\n     * You can convert a tile key into a numeric Morton code with [[mortonCode]].\n     *\n     * @param quadKey64 - The Morton code to be converted.\n     * @returns A new instance of {@link TileKey}.\n     */\n    static fromMortonCode(quadKey64) {\n        let level = 0;\n        let row = 0;\n        let column = 0;\n        let quadKey = quadKey64;\n        while (quadKey > 1) {\n            const mask = 1 << level;\n            if (quadKey & 0x1) {\n                column |= mask;\n            }\n            if (quadKey & 0x2) {\n                row |= mask;\n            }\n            level++;\n            quadKey = (quadKey - (quadKey & 0x3)) / 4;\n        }\n        const result = TileKey.fromRowColumnLevel(row, column, level);\n        result.m_mortonCode = quadKey64;\n        return result;\n    }\n    /**\n     * Creates a tile key from a heretile code string.\n     *\n     * The string can be created with [[toHereTile]].\n     *\n     * @param quadkey64 - The string representation of the HERE tile key.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromHereTile(quadkey64) {\n        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));\n        result.m_hereTile = quadkey64;\n        return result;\n    }\n    /**\n     * Returns the number of available columns at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of columns.\n     * @returns The available columns at the given level.\n     */\n    static columnsAtLevel(level) {\n        return Math.pow(2, level);\n    }\n    /**\n     * Returns the number of available rows at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of rows.\n     * @returns The available rows at the given level.\n     */\n    static rowsAtLevel(level) {\n        return Math.pow(2, level);\n    }\n    /**\n     * Returns the closest matching `TileKey` in a cartesian coordinate system.\n     *\n     * @param level - The level for the tile key.\n     * @param coordX - The X coordinate.\n     * @param coordY - The Y coordinate.\n     * @param totalWidth - The maximum X coordinate.\n     * @param totalHeight - The maximum Y coordinate.\n     * @returns A new tile key at the given level that includes the given coordinates.\n     */\n    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {\n        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);\n    }\n    /**\n     * Computes the Morton code of the parent tile key of the given Morton code.\n     *\n     * Note: The parent key of the root key is the root key itself.\n     *\n     * @param mortonCode - A Morton code, for example, obtained from [[mortonCode]].\n     * @returns The Morton code of the parent tile.\n     */\n    static parentMortonCode(mortonCode) {\n        return Math.floor(mortonCode / 4);\n    }\n    /**\n     * Returns a tile key representing the parent of the tile addressed by this tile key.\n     *\n     * Throws an exception is this tile is already the root.\n     */\n    parent() {\n        if (this.level === 0) {\n            throw new Error(\"Cannot get the parent of the root tile key\");\n        }\n        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);\n    }\n    /**\n     * Returns a new tile key at a level that differs from this tile's level by delta.\n     *\n     * Equivalent to `changedLevelTo(level() + delta)`.\n     *\n     * Note - root key is returned if `delta` is smaller than the level of this tile key.\n     *\n     * @param delta - The numeric difference between the current level and the requested level.\n     */\n    changedLevelBy(delta) {\n        const level = Math.max(0, this.level + delta);\n        let row = this.row;\n        let column = this.column;\n        if (delta >= 0) {\n            row <<= delta;\n            column <<= delta;\n        }\n        else {\n            row >>>= -delta;\n            column >>>= -delta;\n        }\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Returns a new tile key at the requested level.\n     *\n     * If the requested level is smaller than the tile's level, then the key of an ancestor of this\n     * tile is returned. If the requested level is larger than the tile's level, then the key of\n     * first child or grandchild of this tile is returned, for example, the child with the lowest\n     * row and column number. If the requested level equals this tile's level, then the tile key\n     * itself is returned. If the requested level is negative, the root tile key is returned.\n     *\n     * @param level - The requested level.\n     */\n    changedLevelTo(level) {\n        return this.changedLevelBy(level - this.level);\n    }\n    /**\n     * Converts the tile key to a numeric code representation.\n     *\n     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].\n     *\n     * Note - only levels <= 26 are supported.\n     */\n    mortonCode() {\n        if (this.m_mortonCode === undefined) {\n            let column = this.column;\n            let row = this.row;\n            let result = powerOfTwo[this.level << 1];\n            for (let i = 0; i < this.level; ++i) {\n                if (column & 0x1) {\n                    result += powerOfTwo[2 * i];\n                }\n                if (row & 0x1) {\n                    result += powerOfTwo[2 * i + 1];\n                }\n                column >>>= 1;\n                row >>>= 1;\n            }\n            this.m_mortonCode = result;\n        }\n        return this.m_mortonCode;\n    }\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * The string is a quadkey Morton code representation as a string.\n     *\n     * You can convert back from a quadkey string with [[fromHereTile]].\n     */\n    toHereTile() {\n        if (this.m_hereTile === undefined) {\n            this.m_hereTile = this.mortonCode().toString();\n        }\n        return this.m_hereTile;\n    }\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the\n     * base of 4, but without the leading 1, with the following properties:\n     *  1. the number of digits equals the level.\n     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3\n     *     to a quadkey string gives the tiles's children.\n     *\n     * You can convert back from a quadkey string with [[fromQuadKey]].\n     */\n    toQuadKey() {\n        let result = \"\";\n        for (let i = this.level; i > 0; --i) {\n            const mask = 1 << (i - 1);\n            const col = (this.column & mask) !== 0;\n            const row = (this.row & mask) !== 0;\n            if (col && row) {\n                result += \"3\";\n            }\n            else if (row) {\n                result += \"2\";\n            }\n            else if (col) {\n                result += \"1\";\n            }\n            else {\n                result += \"0\";\n            }\n        }\n        return result;\n    }\n    /**\n     * Equality operator.\n     *\n     * @param qnr - The tile key to compare to.\n     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.\n     */\n    equals(qnr) {\n        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;\n    }\n    /**\n     * Returns the absolute quadkey that is constructed from its sub quadkey.\n     *\n     * @param sub - The sub key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubKey(sub) {\n        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? \"-\" : sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);\n    }\n    /**\n     * Returns the absolute quadkey that is constructed from its sub HERE tile key.\n     *\n     * @param sub - The sub HERE key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubHereTile(sub) {\n        const subQuad = TileKey.fromHereTile(sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);\n    }\n    /**\n     * Returns a sub quadkey that is relative to its parent.\n     *\n     * This function can be used to generate sub keys that are relative to a parent that is delta\n     * levels up in the quadtree.\n     *\n     * This function can be used to create shortened keys for quads on lower levels if the parent is\n     * known.\n     *\n     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If\n     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.\n     *\n     * Deltas larger than 16 are not supported.\n     *\n     * @param delta - The number of levels relative to its parent quadkey. Must be greater or equal\n     * to 0 and smaller than 16.\n     * @returns The quadkey relative to its parent that is `delta` levels up the tree.\n     */\n    getSubHereTile(delta) {\n        const key = this.mortonCode();\n        const msb = 1 << (delta * 2);\n        const mask = msb - 1;\n        const result = (key & mask) | msb;\n        return result.toString();\n    }\n    /**\n     * Returns the number of available rows in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    rowCount() {\n        return TileKey.rowsAtLevel(this.level);\n    }\n    /**\n     * Returns the number of available columns in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    columnCount() {\n        return TileKey.columnsAtLevel(this.level);\n    }\n}\nexports.TileKey = TileKey;\n//# sourceMappingURL=TileKey.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileKeyUtils = void 0;\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\nclass TileKeyUtils {\n    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {\n        const projection = tilingScheme.projection;\n        const worldPoint = projection.projectPoint(geoPoint);\n        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);\n    }\n    static worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {\n        const projection = tilingScheme.projection;\n        const subdivisionScheme = tilingScheme.subdivisionScheme;\n        const cx = subdivisionScheme.getLevelDimensionX(level);\n        const cy = subdivisionScheme.getLevelDimensionY(level);\n        const { min, max } = projection.worldExtent(0, 0);\n        const worldSizeX = max.x - min.x;\n        const worldSizeY = max.y - min.y;\n        if (worldPoint.x < min.x || worldPoint.x > max.x) {\n            return null;\n        }\n        if (worldPoint.y < min.y || worldPoint.y > max.y) {\n            return null;\n        }\n        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));\n        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));\n        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);\n    }\n    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {\n        const wrap = (value, lower, upper) => {\n            if (value < lower) {\n                return upper - ((lower - value) % (upper - lower));\n            }\n            return lower + ((value - lower) % (upper - lower));\n        };\n        const clamp = (x, minVal, maxVal) => {\n            return Math.min(Math.max(x, minVal), maxVal);\n        };\n        // Clamp at the poles and wrap around the international date line.\n        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);\n        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);\n        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);\n        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);\n        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);\n        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);\n        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);\n        if (!minTileKey || !maxTileKey) {\n            throw new Error(\"Invalid coordinates\");\n        }\n        const minColumn = minTileKey.column;\n        let maxColumn = maxTileKey.column;\n        // wrap around case\n        if (southWestLongitude > northEastLongitude) {\n            if (maxColumn !== minColumn) {\n                maxColumn += columnCount;\n            }\n            else {\n                // do not duplicate\n                maxColumn += columnCount - 1;\n            }\n        }\n        const minRow = Math.min(minTileKey.row, maxTileKey.row);\n        const maxRow = Math.max(minTileKey.row, maxTileKey.row);\n        const keys = new Array();\n        for (let row = minRow; row <= maxRow; ++row) {\n            for (let column = minColumn; column <= maxColumn; ++column) {\n                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));\n            }\n        }\n        return keys;\n    }\n}\nexports.TileKeyUtils = TileKeyUtils;\n//# sourceMappingURL=TileKeyUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileTreeTraverse = void 0;\nconst SubTiles_1 = __webpack_require__(/*! ./SubTiles */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js\");\nclass TileTreeTraverse {\n    constructor(subdivisionScheme) {\n        this.m_subdivisionScheme = subdivisionScheme;\n    }\n    subTiles(tileKey) {\n        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);\n        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);\n        return new SubTiles_1.SubTiles(tileKey, divX, divY);\n    }\n}\nexports.TileTreeTraverse = TileTreeTraverse;\n//# sourceMappingURL=TileTreeTraverse.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TilingScheme = void 0;\nconst FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ \"./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js\");\nconst TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js\");\nconst TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js\");\n/**\n * The `TilingScheme` represents how the data is tiled.\n */\nclass TilingScheme {\n    /**\n     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.\n     *\n     * @param subdivisionScheme - The subdivision scheme used by this `TilingScheme`.\n     * @param projection - The projection used by this `TilingScheme`.\n     */\n    constructor(subdivisionScheme, projection) {\n        this.subdivisionScheme = subdivisionScheme;\n        this.projection = projection;\n        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);\n        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);\n    }\n    /**\n     * Returns the sub tile keys of the given tile.\n     *\n     * @param tileKey - The {@link TileKey}.\n     * @returns The list of the sub tile keys.\n     */\n    getSubTileKeys(tileKey) {\n        return this.tileTreeTraverse.subTiles(tileKey);\n    }\n    /**\n     * Gets the {@link TileKey} from the given geo position and level.\n     *\n     * @param geoPoint - The position in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKey(geoPoint, level) {\n        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);\n    }\n    /**\n     * Gets the list of {@link TileKey}s contained in the given {@link GeoBox}.\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKeys(geoBox, level) {\n        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);\n    }\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * @param tileKey - The `TileKey`.\n     */\n    getGeoBox(tileKey) {\n        return this.boundingBoxGenerator.getGeoBox(tileKey);\n    }\n    /**\n     * Returns the bounding box in world coordinates.\n     *\n     * @param tileKey - The `TileKey`.\n     * @param result - The optional object that will contain the resulting bounding box.\n     */\n    getWorldBox(tileKey, result) {\n        return this.boundingBoxGenerator.getWorldBox(tileKey, result);\n    }\n}\nexports.TilingScheme = TilingScheme;\n//# sourceMappingURL=TilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webMercatorTilingScheme = void 0;\nconst MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and web Mercator projection.\n */\nexports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);\n//# sourceMappingURL=WebMercatorTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/Lines.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/Lines.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LineGroup = exports.createSimpleLineGeometry = exports.createLineGeometry = exports.LineGeometry = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n// Preallocate temp variables used during line generation.\nconst tmpV = new THREE.Vector3();\nconst tmpNormal = new THREE.Vector3();\nconst tmpTangent0 = new THREE.Vector3();\nconst tmpTangent1 = new THREE.Vector3();\nconst tmpBitangent = new THREE.Vector3();\nconst SEGMENT_OFFSET = 0.1;\n/**\n * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].\n */\n/** Base line vertex attributes. */\nconst LINE_VERTEX_ATTRIBUTES = {\n    attributes: [\n        // The \"extrusionCoord\" is a vec4 which represents:\n        // xy: Extrusion coordinates\n        // sign(xy): Extrusion direction\n        // z: Line length\n        { name: \"extrusionCoord\", itemSize: 3, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 3 },\n        { name: \"tangent\", itemSize: 3, offset: 6 },\n        { name: \"bitangent\", itemSize: 4, offset: 9 }\n    ],\n    stride: 13\n};\n/** Optional normal and uv coordinates. */\nconst NORMAL_UV_VERTEX_ATTRIBUTES = {\n    attributes: [\n        { name: \"uv\", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },\n        { name: \"normal\", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }\n    ],\n    stride: 5\n};\n/** Base line vertex attributes plus normals and uv coordinates. */\nconst LINE_VERTEX_ATTRIBUTES_NUV = {\n    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],\n    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n/**\n * Declares all the vertex attributes used for rendering a line using the\n * [[HighPrecisionLineMaterial]].\n */\nconst HP_LINE_VERTEX_ATTRIBUTES = {\n    attributes: [\n        { name: \"extrusionCoord\", itemSize: 2, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 2 },\n        { name: \"positionLow\", itemSize: 3, offset: 5 },\n        { name: \"tangent\", itemSize: 3, offset: 8 },\n        { name: \"bitangent\", itemSize: 4, offset: 11 }\n    ],\n    stride: 15\n};\n/** High precision line vertex attributes plus normals and uv coordinates. */\nconst HP_LINE_VERTEX_ATTRIBUTES_NUV = {\n    attributes: [\n        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,\n        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes\n    ],\n    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n/**\n * Class that holds the vertex and index attributes for a [[Lines]] object.\n */\nclass LineGeometry {\n    constructor() {\n        this.vertices = [];\n        this.vertexColors = [];\n        this.indices = [];\n    }\n}\nexports.LineGeometry = LineGeometry;\nfunction getVertexDescriptor(hasNormalsAndUvs, highPrecision) {\n    if (highPrecision) {\n        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;\n    }\n    else {\n        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;\n    }\n}\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param center - Center of the polyline.\n * @param polyline - Array of `numbers` describing a polyline.\n * @param offsets - Array of `numbers` representing line segment offsets.\n * @param uvs - Array of `numbers` representing texture coordinates.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n * @param highPrecision - If `true` will create high-precision vertex information.\n */\nfunction createLineGeometry(center, polyline, projection, offsets, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;\n    const pointCount = polyline.length / 3;\n    const segments = new Array(pointCount);\n    const tangents = new Array(polyline.length - 3);\n    const baseVertex = geometry.vertices.length / stride;\n    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;\n    const hasTexCoords = uvs !== undefined && uvs.length > 0;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n    harp_utils_1.assert(!hasSegmentOffsets || offsets.length === pointCount);\n    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);\n    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);\n    // Compute segments and tangents.\n    let sum = SEGMENT_OFFSET;\n    segments[0] = sum;\n    for (let i = 0; i < pointCount - 1; ++i) {\n        let sqrLength = 0;\n        for (let j = 0; j < 3; ++j) {\n            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];\n            tangents[i * 3 + j] = d;\n            sqrLength += d * d;\n        }\n        const len = Math.sqrt(sqrLength);\n        sum = sum + len;\n        segments[i + 1] = sum;\n    }\n    const lineCoverage = hasSegmentOffsets\n        ? Math.abs(offsets[offsets.length - 1] - offsets[0])\n        : 1.0;\n    const lineLength = segments[segments.length - 1] / lineCoverage;\n    // Override the segments if offsets are explicitly provided.\n    if (hasSegmentOffsets) {\n        for (let i = 0; i < pointCount; ++i) {\n            segments[i] = offsets[i] * lineLength + SEGMENT_OFFSET;\n        }\n    }\n    // Check if we're working with a closed line.\n    let isClosed = true;\n    for (let j = 0; j < 3; ++j) {\n        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];\n    }\n    const tmpVertices = [];\n    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {\n        tmpVertices.length = 0;\n        // Store the segment and extrusionCoord attributes.\n        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);\n        tmpVertices.push(segment, extrusionCoord * 1, lineLength);\n        // Store the position attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            if (!highPrecision) {\n                geometry.vertices.push(polyline[i * 3 + j]);\n                tmpVertices.push(polyline[i * 3 + j]);\n            }\n            else {\n                const highComp = Math.fround(polyline[i * 3 + j]);\n                const lowComp = polyline[i * 3 + j] - highComp;\n                geometry.vertices.push(highComp, lowComp);\n                tmpVertices.push(highComp, lowComp);\n            }\n            tmpNormal.setComponent(j, polyline[i * 3 + j]);\n        }\n        // Store the bitangent attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            tmpTangent0.setComponent(j, tangents[T1 + j]);\n            tmpTangent1.setComponent(j, tangents[T2 + j]);\n        }\n        tmpTangent0.normalize();\n        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpNormal.add(center); // tmpNormal contains world position\n        projection.surfaceNormal(tmpNormal, tmpNormal);\n        const angle = computeBitangent(tmpNormal, tmpTangent0, tmpTangent1.normalize(), tmpBitangent);\n        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        if (hasTexCoords) {\n            // uvs\n            geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);\n            tmpVertices.push(uvs[i * 2], uvs[i * 2 + 1]);\n            // normals\n            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n        }\n        geometry.vertices.push(...tmpVertices);\n        // Add vertex colors (if supplied).\n        if (vertexColors) {\n            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);\n            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);\n        }\n    };\n    for (let i = 0; i < pointCount; ++i) {\n        // Retrieve the per-point tangents.\n        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;\n        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);\n        // Process v0 and v1.\n        if (i > 0) {\n            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);\n        }\n        // Process v2 and v3.\n        if (i + 1 < pointCount) {\n            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);\n        }\n    }\n    // Store the triangle indices in the final index buffer.\n    for (let i = 0; i < pointCount - 1; ++i) {\n        const base = baseVertex + i * 4;\n        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);\n    }\n    return geometry;\n}\nexports.createLineGeometry = createLineGeometry;\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param polyline - Array of `numbers` describing a polyline.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n */\nfunction createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n    const pointCount = polyline.length / 3;\n    let index = geometry.vertices.length / 3;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n    for (let i = 0; i < pointCount; ++i, index++) {\n        if (i > 0) {\n            geometry.indices.push(index);\n        }\n        if (i < pointCount - 1) {\n            geometry.indices.push(index);\n        }\n        for (let j = 0; j < 3; ++j) {\n            geometry.vertices.push(polyline[i * 3 + j]);\n            if (vertexColors) {\n                geometry.vertexColors.push(colors[i * 3 + j]);\n            }\n        }\n    }\n    return geometry;\n}\nexports.createSimpleLineGeometry = createSimpleLineGeometry;\n/**\n * Class used to render groups (or batches) of width-variable lines (in the same tile).\n */\nclass LineGroup {\n    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {\n        this.hasNormalsAndUvs = hasNormalsAndUvs;\n        this.highPrecision = highPrecision;\n        this.isSimple = isSimple;\n        this.m_geometry = new LineGeometry();\n    }\n    /**\n     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.\n     *\n     * @param vertices - Array of vertex attributes.\n     * @param colors - Array of vertex colors.\n     * @param indices - Array of vertex indices.\n     * @param geometry - [[BufferGeometry]] object which will store all the `Lines` attribute data.\n     * @param hasNormalsAnUvs - Whether vertices have normal and uv coordinates as attributes.\n     * @param highPrecision - If `true` will create high-precision vertex information.\n     * @param isSimple - `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.\n     */\n    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {\n        if (isSimple) {\n            geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(vertices), 3));\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\"color\", new THREE.BufferAttribute(new Float32Array(colors), 3));\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        }\n        else {\n            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);\n            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);\n            vertexDescriptor.attributes.forEach(descr => {\n                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);\n                geometry.setAttribute(descr.name, attribute);\n            });\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\"color\", new THREE.BufferAttribute(new Float32Array(colors), 3));\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        }\n    }\n    /**\n     * Clears the list of line strips.\n     */\n    clear() {\n        this.m_geometry.vertices = [];\n        this.m_geometry.vertexColors = [];\n        this.m_geometry.indices = [];\n    }\n    /**\n     * Add the given points to this line group.\n     *\n     * @param center - World center of the provided points.\n     * @param points - Sequence of (x,y,z) coordinates.\n     * @param offsets - Sequence of line segment offsets.\n     * @param uvs - Sequence of (u,v) texture coordinates.\n     * @param colors - Sequence of (r,g,b) color components.\n     */\n    add(center, points, projection, offsets, uvs, colors) {\n        if (!this.isSimple) {\n            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);\n            createLineGeometry(center, points, projection, offsets, uvs, colors, this.m_geometry, this.highPrecision);\n        }\n        else {\n            createSimpleLineGeometry(points, colors, this.m_geometry);\n        }\n        return this;\n    }\n    /**\n     * Returns the list of vertices.\n     */\n    get vertices() {\n        return this.m_geometry.vertices;\n    }\n    /**\n     * Returns the list of vertex colors.\n     */\n    get vertexColors() {\n        return this.m_geometry.vertexColors;\n    }\n    /**\n     * Returns the list of indices.\n     */\n    get indices() {\n        return this.m_geometry.indices;\n    }\n    /**\n     * Returns the list of [[VertexAttributeDescriptor]]s.\n     */\n    get vertexAttributes() {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;\n    }\n    /**\n     * Returns the vertex attribute stride.\n     */\n    get stride() {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;\n    }\n    /**\n     * Creates a three.js geometry.\n     */\n    createGeometry(geometry) {\n        if (geometry === undefined) {\n            geometry = new THREE.BufferGeometry();\n        }\n        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);\n    }\n}\nexports.LineGroup = LineGroup;\nfunction computeBitangent(n, t0, t1, bt) {\n    let angle = 0;\n    if (!t0.equals(t1)) {\n        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));\n        if (Number.isNaN(angle)) {\n            angle = 0;\n        }\n    }\n    bt.copy(t0).add(t1).normalize().cross(n).normalize();\n    return angle;\n}\n//# sourceMappingURL=Lines.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/Lines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/TriangulateLines.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/TriangulateLines.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructLineWidth = exports.reconstructLine = exports.triangulateLine = exports.numCirclePoints = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UNIT_Z = new THREE.Vector3(0, 0, 1);\nconst POINTS = [0, 1, 2, 1, 3, 2];\nconst BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];\nconst SECTORS_IN_CIRCLE = 8;\nconst STEP = Math.PI / SECTORS_IN_CIRCLE;\n/**\n * Adds a half-circle geometry to original line\n *\n * @param x - The line end X (used as circle center X)\n * @param y - The line end Y (used as circle center Y)\n * @param lineAngle - The cap incline angle\n * @param radius - The cap (circle) radius\n * @param vertices - The input vertex buffer (cap vertices are added there)\n * @param indices - The input index buffer (cap indices are is added there)\n */\nfunction addCircle(x, y, lineAngle, radius, vertices, indices) {\n    const baseVertex = vertices.length / 3;\n    // Add cap center to vertices directly (it doesn't need rotation)\n    vertices.push(x, y, 0);\n    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {\n        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg\n        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);\n        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);\n    }\n}\n/**\n * Returns the number of points in circle used for caps.\n *\n * @param lineWidth - Width of line.\n */\nfunction numCirclePoints(lineWidth) {\n    return SECTORS_IN_CIRCLE + 1;\n}\nexports.numCirclePoints = numCirclePoints;\n/**\n * Create a triangle mesh from the given polyline.\n *\n * @param points - Sequence of (x,y,z) coordinates.\n * @param width - The width of the extruded line.\n * @param vertices - The output vertex buffer.\n * @param indices - The output index buffer.\n * @param startWithCircle - `true` if the line should start will a circle.\n * @param endWithCircle - `true` if the line should end with a circle.\n */\nfunction triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {\n    if (points.length < 3) {\n        return;\n    }\n    // This vector is used for computing cap angle\n    const angleVec = new THREE.Vector2();\n    if (startWithCircle) {\n        // Define lineAngle as (direction - origin) vector angle to X axis\n        const lineAngle = points.length !== 3\n            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()\n            : 0;\n        addCircle(points[0], points[1], lineAngle, width, vertices, indices);\n    }\n    const baseVertex = vertices.length / 3;\n    // bt = Bitangent (i.e. extrusion vector)\n    const prevBt = new THREE.Vector3();\n    const p = new THREE.Vector3(); // current point\n    const n = new THREE.Vector3(); // next point\n    const bt = new THREE.Vector3();\n    const averageBt = new THREE.Vector3();\n    const p0 = new THREE.Vector3();\n    const p1 = new THREE.Vector3();\n    const p2 = new THREE.Vector3();\n    const p3 = new THREE.Vector3();\n    const N = points.length / 3;\n    let vertexOffset = 0;\n    for (let i = 0; i < N; ++i) {\n        let useBevel = false;\n        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);\n        if (i + 1 < N) {\n            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);\n            bt.copy(n).sub(p).normalize().cross(UNIT_Z);\n            averageBt.copy(bt);\n            if (i > 0) {\n                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));\n                useBevel = prevBt.angleTo(bt) > Math.PI / 2;\n                if (useBevel) {\n                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);\n                    p0.copy(bt).add(prevBt).normalize().multiplyScalar(-inclineWidth).add(p);\n                    p1.copy(prevBt).multiplyScalar(width).add(p);\n                    // p2 is used for \"miter\" connections\n                    p2.copy(bt).add(prevBt).normalize().multiplyScalar(inclineWidth).add(p);\n                    p3.copy(bt).multiplyScalar(width).add(p);\n                }\n            }\n            if (useBevel) {\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);\n            }\n            else {\n                p0.copy(averageBt).multiplyScalar(-width).add(p);\n                p1.copy(averageBt).multiplyScalar(width).add(p);\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n            }\n            prevBt.copy(bt);\n        }\n        else {\n            p0.copy(prevBt).multiplyScalar(-width).add(p);\n            p1.copy(prevBt).multiplyScalar(width).add(p);\n            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n        }\n        if (i !== N - 1) {\n            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));\n            vertexOffset += useBevel ? 4 : 2;\n        }\n    }\n    if (endWithCircle) {\n        const lineAngle = points.length !== 2\n            ? angleVec\n                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])\n                .angle()\n            : Math.PI;\n        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);\n    }\n}\nexports.triangulateLine = triangulateLine;\n/**\n * Reconstruct the original points of a line from the vertices of the triangulated line.\n *\n * @param inBuffer - Buffer with vertices.\n * @param startOffset - Start index, will differ from `0` if the line has caps.\n * @returns Buffer containing the original points of the triangulated line.\n */\nfunction reconstructLine(inBuffer, startOffset) {\n    const outBuffer = new Float32Array(inBuffer.length / 2);\n    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {\n        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;\n        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;\n        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;\n    }\n    return outBuffer;\n}\nexports.reconstructLine = reconstructLine;\n/**\n * Extract the line width from a triangulated line.\n *\n * @param inBuffer - Array of vertex elements of a triangulated line.\n * @param startIndex - Start index, will differ from `0` if the line has caps.\n */\nfunction reconstructLineWidth(inBuffer, startIndex) {\n    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];\n    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];\n    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];\n    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;\n}\nexports.reconstructLineWidth = reconstructLineWidth;\n//# sourceMappingURL=TriangulateLines.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/TriangulateLines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/index-worker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/index-worker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/ThemedTileDecoder */ \"./node_modules/@here/harp-mapview-decoder/lib/ThemedTileDecoder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TileDecoderService */ \"./node_modules/@here/harp-mapview-decoder/lib/TileDecoderService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TilerService */ \"./node_modules/@here/harp-mapview-decoder/lib/TilerService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerService */ \"./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerServiceManager */ \"./node_modules/@here/harp-mapview-decoder/lib/WorkerServiceManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonTiler */ \"./node_modules/@here/harp-mapview-decoder/lib/GeoJsonTiler.js\"), exports);\n//# sourceMappingURL=index-worker.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/index-worker.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/GeoJsonTiler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/GeoJsonTiler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoJsonTiler = void 0;\n// @ts-ignore\nconst geojsonvtExport = __webpack_require__(/*! geojson-vt */ \"./node_modules/geojson-vt/src/index.js\");\n// to be able to run tests on nodejs\nconst geojsonvt = (_a = geojsonvtExport.default) !== null && _a !== void 0 ? _a : geojsonvtExport;\nconst EXTENT = 4096;\n// the factor used to compute the size of the buffer.\nconst BUFFER_FACTOR = 0.05;\n// align the buffer to the next integer multiple of 2.\nconst BUFFER = -(-Math.ceil(EXTENT * BUFFER_FACTOR) & -2);\nclass GeoJsonTiler {\n    constructor() {\n        this.indexes = new Map();\n    }\n    dispose() {\n        /* */\n    }\n    async connect() {\n        return await Promise.resolve();\n    }\n    async registerIndex(indexId, input) {\n        if (this.indexes.has(indexId)) {\n            return;\n        }\n        return await this.updateIndex(indexId, input);\n    }\n    async updateIndex(indexId, input) {\n        if (input instanceof URL) {\n            const response = await fetch(input.href);\n            if (!response.ok) {\n                throw new Error(`GeoJsonTiler: Unable to fetch ${input.href}: ${response.statusText}`);\n            }\n            input = await response.json();\n        }\n        else {\n            input = input;\n        }\n        const index = geojsonvt(input, {\n            maxZoom: 20,\n            indexMaxZoom: 5,\n            indexMaxPoints: 100000,\n            tolerance: 3,\n            extent: EXTENT,\n            buffer: BUFFER,\n            lineMetrics: false,\n            promoteId: null,\n            generateId: true,\n            debug: 0 // logging level (0, 1 or 2)\n        });\n        index.geojson = input;\n        this.indexes.set(indexId, index);\n    }\n    async getTile(indexId, tileKey) {\n        const index = this.indexes.get(indexId);\n        if (index === undefined) {\n            throw new Error(\"Tile not found\");\n        }\n        const tile = index.getTile(tileKey.level, tileKey.column, tileKey.row);\n        if (tile !== null) {\n            tile.layer = indexId;\n            for (const feature of tile.features) {\n                feature.originalGeometry = this.getOriginalGeometry(feature, index.geojson);\n            }\n        }\n        return tile || {};\n    }\n    getOriginalGeometry(feature, geojson) {\n        switch (geojson.type) {\n            case \"Point\":\n            case \"MultiPoint\":\n            case \"LineString\":\n            case \"MultiLineString\":\n            case \"Polygon\":\n            case \"MultiPolygon\":\n            case \"GeometryCollection\":\n                return geojson;\n            case \"Feature\":\n                return geojson.geometry;\n            case \"FeatureCollection\":\n                return geojson.features[feature.id].geometry;\n        }\n    }\n}\nexports.GeoJsonTiler = GeoJsonTiler;\n//# sourceMappingURL=GeoJsonTiler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/GeoJsonTiler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/ThemedTileDecoder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/ThemedTileDecoder.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThemedTileDecoder = void 0;\nconst index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ \"./node_modules/@here/harp-datasource-protocol/index-decoder.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"ThemedTileDecoder\");\n/**\n * `ThemedTileDecoder` implements an [[ITileDecoder]] which uses a [[Theme]] to apply styles to the\n * objects displayed in the map.\n *\n * By default, decoders are executed in web workers (using [[TileDecoderService]]) for performance\n * reasons.\n */\nclass ThemedTileDecoder {\n    constructor() {\n        this.m_storageLevelOffset = 0;\n    }\n    dispose() {\n        // implemented in subclasses\n    }\n    decodeTile(data, tileKey, projection) {\n        if (this.m_styleSetEvaluator === undefined) {\n            logger.info(\"cannot decode tile, as there is not style available\");\n            return Promise.resolve(undefined);\n        }\n        return this.decodeThemedTile(data, tileKey, this.m_styleSetEvaluator, projection);\n    }\n    getTileInfo(data, tileKey, projection) {\n        return Promise.resolve(undefined);\n    }\n    configure(options, customOptions) {\n        if ((options === null || options === void 0 ? void 0 : options.styleSet) !== undefined) {\n            this.m_styleSetEvaluator = new index_decoder_1.StyleSetEvaluator(options);\n        }\n        if ((options === null || options === void 0 ? void 0 : options.languages) !== undefined) {\n            this.languages = options.languages;\n        }\n        if (customOptions !== undefined && customOptions.storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = customOptions.storageLevelOffset;\n        }\n    }\n}\nexports.ThemedTileDecoder = ThemedTileDecoder;\n//# sourceMappingURL=ThemedTileDecoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/ThemedTileDecoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileDecoderService.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileDecoderService.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileDecoderService = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst WorkerService_1 = __webpack_require__(/*! ./WorkerService */ \"./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileDecoderService\");\n/**\n * An extension to [[WorkerService]], the `TileDecoderService` implements an asynchronous\n * (message based) service to decode tile content in web workers. The `TileDecoderService` itself\n * lives in the web worker, and communicates with messages by means of a [[ConcurrentWorkerSet]]\n * with the application.\n *\n * The `TileDecoderService` handles a [[DecodeTileRequest]], which contains a tile and its freshly\n * loaded binary data, decodes the content with the [[ITileDecoder]] that the service is configured\n * to use, and sends the data back in form of a [[WorkerServiceResponse]].\n */\nclass TileDecoderService extends WorkerService_1.WorkerService {\n    /**\n     * Set up the `TileDecoderService`. The name of the service must be unique\n     *\n     * @param serviceId - Service id. Must be unique.\n     * @param m_decoder - Decoder to handle the decoding and info requests.\n     */\n    constructor(serviceId, m_decoder) {\n        super(serviceId);\n        this.serviceId = serviceId;\n        this.m_decoder = m_decoder;\n        this.m_decoder.connect();\n    }\n    /**\n     * Start a [[TileDecoderService]] with a given decoder.\n     *\n     * @param serviceId - Service id. Must be unique.\n     * @param decoder -   [[TileDecoder]] instance.\n     */\n    static start(serviceId, decoder) {\n        return new TileDecoderService(serviceId, decoder);\n    }\n    /**\n     * Handle incoming request messages. Identifies message type and processes the request.\n     *\n     * @param request - Message that is either a DecodeTileRequest or a TileInfoRequest.\n     * @returns A promise which resolves to a [[WorkerServiceResponse]].\n     * @override\n     */\n    handleRequest(request) {\n        if (harp_datasource_protocol_1.WorkerDecoderProtocol.isDecodeTileRequest(request)) {\n            return this.handleDecodeTileRequest(request);\n        }\n        else if (harp_datasource_protocol_1.WorkerDecoderProtocol.isTileInfoRequest(request)) {\n            return this.handleTileInfoRequest(request);\n        }\n        else {\n            return super.handleRequest(request);\n        }\n    }\n    /**\n     * Handle incoming configuration message. Configuration message is passed on to decoder.\n     *\n     * @param request - Message of type [[ConfigurationMessage]].\n     * @override\n     */\n    handleMessage(message) {\n        if (harp_datasource_protocol_1.WorkerDecoderProtocol.isConfigurationMessage(message)) {\n            this.handleConfigurationMessage(message);\n        }\n        else {\n            logger.error(`[${this.serviceId}]: invalid message ${message.type}`);\n        }\n    }\n    async handleDecodeTileRequest(request) {\n        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(request.tileKey);\n        const projection = harp_datasource_protocol_1.getProjection(request.projection);\n        const decodedTile = await this.m_decoder.decodeTile(request.data, tileKey, projection);\n        const transferList = [];\n        const transferBufferAttribute = (attribute) => {\n            if (attribute !== undefined &&\n                attribute.buffer.byteLength > 0 &&\n                !transferList.includes(attribute.buffer)) {\n                transferList.push(attribute.buffer);\n            }\n        };\n        decodedTile === null || decodedTile === void 0 ? void 0 : decodedTile.geometries.forEach(geom => {\n            var _a, _b, _c;\n            (_a = geom.vertexAttributes) === null || _a === void 0 ? void 0 : _a.forEach(attr => transferBufferAttribute(attr));\n            (_b = geom.interleavedVertexAttributes) === null || _b === void 0 ? void 0 : _b.forEach(attr => transferBufferAttribute(attr));\n            transferBufferAttribute(geom.index);\n            transferBufferAttribute(geom.edgeIndex);\n            if (Array.isArray(geom.objInfos) &&\n                geom.objInfos.length === 1 &&\n                typeof geom.objInfos[0] === \"object\" && ((_c = geom.objInfos[0]) === null || _c === void 0 ? void 0 : _c.hasOwnProperty(\"displacementMap\"))) {\n                const obj = geom.objInfos[0];\n                transferBufferAttribute(obj.displacementMap);\n            }\n            if (Array.isArray(geom.attachments)) {\n                geom.attachments.forEach(attachment => {\n                    transferBufferAttribute(attachment.index);\n                    transferBufferAttribute(attachment.edgeIndex);\n                });\n            }\n        });\n        decodedTile === null || decodedTile === void 0 ? void 0 : decodedTile.techniques.forEach(technique => {\n            harp_datasource_protocol_1.addBuffersToTransferList(technique, transferList);\n        });\n        return {\n            response: decodedTile,\n            transferList\n        };\n    }\n    handleTileInfoRequest(request) {\n        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(request.tileKey);\n        const projection = harp_datasource_protocol_1.getProjection(request.projection);\n        return this.m_decoder.getTileInfo(request.data, tileKey, projection).then(tileInfo => {\n            const transferList = tileInfo !== undefined && tileInfo.transferList !== undefined\n                ? tileInfo.transferList\n                : [];\n            return {\n                response: tileInfo,\n                transferList\n            };\n        });\n    }\n    handleConfigurationMessage(message) {\n        this.m_decoder.configure(message, message.options);\n    }\n}\nexports.TileDecoderService = TileDecoderService;\n//# sourceMappingURL=TileDecoderService.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/TileDecoderService.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TilerService.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TilerService.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TilerService = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst GeoJsonTiler_1 = __webpack_require__(/*! ./GeoJsonTiler */ \"./node_modules/@here/harp-mapview-decoder/lib/GeoJsonTiler.js\");\nconst WorkerService_1 = __webpack_require__(/*! ./WorkerService */ \"./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js\");\n/**\n * An extension to {@link WorkerService}, the `TilerService`\n * implements an asynchronous (message based)\n * service to tile untiled payloads in web workers.\n *\n * @remarks\n * The `TilerService` itself lives in the web\n * worker, and communicates with messages by means of a `ConcurrentWorkerSet` with the\n * application.\n *\n * The `TilerService` registers tile indices (parent tile to be subdivided) by handling a\n * `RegisterIndexRequest`, and can later retrieve tiled payloads from through the `TileRequest`.\n * The data is sent back in form of a {@link WorkerServiceResponse}.\n */\nclass TilerService extends WorkerService_1.WorkerService {\n    /**\n     * Set up the `TilerService`. The name of the service must be unique\n     *\n     * @param serviceId - Service id. Must be unique.\n     */\n    constructor(serviceId) {\n        super(serviceId);\n        this.serviceId = serviceId;\n        this.tiler = new GeoJsonTiler_1.GeoJsonTiler();\n    }\n    /**\n     * Start a `TilerService`.\n     *\n     * @param serviceId - Service id. Must be unique.\n     */\n    static start(serviceId) {\n        return new TilerService(serviceId);\n    }\n    /**\n     * Handle incoming request messages. Identifies message type and processes the request.\n     *\n     * @param request - {@link WorkerTilerProtocol} request.\n     * @returns A promise which resolves to a {@link WorkerServiceResponse}.\n     * @override\n     */\n    handleRequest(request) {\n        if (harp_datasource_protocol_1.WorkerTilerProtocol.isRegisterIndexRequest(request)) {\n            return this.handleRegisterIndexRequest(request);\n        }\n        else if (harp_datasource_protocol_1.WorkerTilerProtocol.isUpdateIndexRequest(request)) {\n            return this.handleUpdateIndexRequest(request);\n        }\n        else if (harp_datasource_protocol_1.WorkerTilerProtocol.isTileRequest(request)) {\n            return this.handleTileRequest(request);\n        }\n        else {\n            return super.handleRequest(request);\n        }\n    }\n    async handleTileRequest(request) {\n        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(request.tileKey);\n        const tile = await this.tiler.getTile(request.index, tileKey);\n        return { response: tile || {} };\n    }\n    async handleRegisterIndexRequest(message) {\n        const input = typeof message.input === \"string\" ? new URL(message.input) : message.input;\n        await this.tiler.registerIndex(message.id, input);\n        return { response: {} };\n    }\n    async handleUpdateIndexRequest(message) {\n        const input = typeof message.input === \"string\" ? new URL(message.input) : message.input;\n        this.tiler.updateIndex(message.id, input);\n        return { response: {} };\n    }\n}\nexports.TilerService = TilerService;\n//# sourceMappingURL=TilerService.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/TilerService.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerService = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"WorkerService\", { enabled: true });\n/**\n * Worker Service communication helper.\n *\n * @remarks\n * Listens to Web Worker messages from `entWorkerSet` and implements:\n *  - worker service initialization\n *  - request/response scheme\n *  - error handling.\n *\n * This class should be subclassed to provide concrete like `TileDecoderService`.\n *\n * Communication peer for `ConcurrentWorkerSet`.\n */\nclass WorkerService {\n    /**\n     * Sets up the `WorkerService` with the specified name, and starts processing messages.\n     *\n     * @param serviceId - The service id.\n     */\n    constructor(serviceId) {\n        this.serviceId = serviceId;\n        this.m_pendingRequests = new Map();\n        /**\n         * Central message handler for this service.\n         *\n         * Responsible for filtering message target and managing request/response sequence.\n         *\n         * @param message - Message to be dispatched.\n         */\n        this.onMessage = (message) => {\n            if (typeof message.data.service !== \"string\" || message.data.service !== this.serviceId) {\n                return;\n            }\n            try {\n                if (harp_datasource_protocol_1.WorkerServiceProtocol.isRequestMessage(message.data)) {\n                    const request = message.data;\n                    const requestEntry = {\n                        service: request.service,\n                        messageId: request.messageId,\n                        responseSent: false\n                    };\n                    this.m_pendingRequests.set(request.messageId, requestEntry);\n                    this.tryHandleRequest(request.request)\n                        .then(response => {\n                        this.doSendResponse(requestEntry, {\n                            service: this.serviceId,\n                            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Response,\n                            messageId: request.messageId,\n                            response: response.response\n                        }, response.transferList);\n                    })\n                        .catch(error => {\n                        this.doSendResponse(requestEntry, {\n                            service: this.serviceId,\n                            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Response,\n                            messageId: request.messageId,\n                            errorMessage: error.toString(),\n                            errorStack: error.stack\n                        });\n                    });\n                }\n                else {\n                    this.tryHandleMessage(message.data);\n                }\n            }\n            catch (err) {\n                logger.error(`[${this.serviceId}]: Unhandled exception when handling ${message.type}`);\n            }\n        };\n        self.addEventListener(\"message\", this.onMessage);\n        const isInitializedMessage = {\n            service: serviceId,\n            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Initialized\n        };\n        self.postMessage(isInitializedMessage);\n    }\n    /**\n     * Destroy the `WorkerService`. Cancels all pending requests ad removes itself from the message\n     * queue.\n     */\n    destroy() {\n        this.cancelAllPendingRequests();\n        self.removeEventListener(\"message\", this.onMessage);\n    }\n    /**\n     * Message handler to be overridden by implementation.\n     *\n     * @param message - `MessageEvent.data` as received by `WorkerService`.\n     */\n    handleMessage(message) {\n        logger.error(`[${this.serviceId}]: Invalid message ${message.type}`);\n    }\n    /**\n     * Call request handler to be overridden by implementation.\n     *\n     * @param request - `RequestMessage.request` as received by `WorkerService`.\n     */\n    handleRequest(request) {\n        throw new Error(`ServiceAdapter[${this.serviceId}]: Invalid request '${request.type}'`);\n    }\n    /**\n     * Safety belt over `handleMessage` for correct exception handling & logging.\n     */\n    tryHandleMessage(message) {\n        try {\n            this.handleMessage(message);\n        }\n        catch (error) {\n            logger.error(`[${this.serviceId}]: Failed, handling message ${message.type}`);\n        }\n    }\n    /**\n     * Safety belt over `handleRequest` for correct exception handling in promise chain.\n     */\n    tryHandleRequest(request) {\n        try {\n            return this.handleRequest(request);\n        }\n        catch (error) {\n            // we don't log exceptions here as they are propagated to client as responses\n            logger.error(`[${this.serviceId}]: Failure`, error);\n            return Promise.reject(error);\n        }\n    }\n    doSendResponse(requestEntry, response, transferList) {\n        if (requestEntry.responseSent) {\n            return;\n        }\n        if (transferList !== undefined) {\n            self.postMessage(response, transferList);\n        }\n        else {\n            self.postMessage(response);\n        }\n        requestEntry.responseSent = true;\n        this.m_pendingRequests.delete(requestEntry.messageId);\n    }\n    cancelAllPendingRequests() {\n        this.m_pendingRequests.forEach(requestEntry => {\n            this.doSendResponse(requestEntry, {\n                service: this.serviceId,\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Response,\n                messageId: requestEntry.messageId,\n                errorMessage: \"cancelled\"\n            });\n        });\n    }\n}\nexports.WorkerService = WorkerService;\n//# sourceMappingURL=WorkerService.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/WorkerServiceManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/WorkerServiceManager.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerServiceManager = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst WorkerService_1 = __webpack_require__(/*! ./WorkerService */ \"./node_modules/@here/harp-mapview-decoder/lib/WorkerService.js\");\n/**\n * Manages dynamic worker services in Web Worker context.\n *\n * Handles `CreateService` and `DestroyService` messages sent to Web Worker. Singleton (in scope of\n * one worker runtime!), starts automatically with first [[getInstance]] call.\n */\nclass WorkerServiceManager extends WorkerService_1.WorkerService {\n    constructor(serviceId = harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID) {\n        super(serviceId);\n        /**\n         * Contains all registered service factories indexed by `serviceType`.\n         */\n        this.m_factories = new Map();\n        /**\n         * Contains all managed worker services indexed by their `serviceId`.\n         */\n        this.m_services = new Map();\n    }\n    /**\n     * Gets the default instance of `WorkerServiceManager`. Starts the service when first called.\n     */\n    static getInstance() {\n        if (this.m_service === undefined) {\n            this.m_service = new WorkerServiceManager(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        }\n        return this.m_service;\n    }\n    /**\n     * Register [[WorkerService]] class to this manager.\n     *\n     * @param workerServiceDescriptor - service type and factory\n     */\n    register(workerServiceDescriptor) {\n        this.m_factories.set(workerServiceDescriptor.serviceType, workerServiceDescriptor.factory);\n    }\n    /** @override */\n    handleRequest(request) {\n        if (request.type === harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService) {\n            const existingService = this.m_services.get(request.targetServiceId);\n            if (existingService !== undefined) {\n                throw Error(`error - service with targetServiceId='${request.targetServiceId}' already running, ignoring CreateService request`);\n            }\n            const factory = this.m_factories.get(request.targetServiceType);\n            if (factory === undefined) {\n                throw Error(`unknown targetServiceType requested: '${request.targetServiceType}'`);\n            }\n            const service = factory(request.targetServiceId);\n            this.m_services.set(request.targetServiceId, service);\n        }\n        if (request.type === harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService) {\n            const service = this.m_services.get(request.targetServiceId);\n            if (service === undefined) {\n                throw Error(`unknown targetServiceId '${request.targetServiceId}'`);\n            }\n            service.destroy();\n            this.m_services.delete(request.targetServiceId);\n        }\n        return Promise.resolve({\n            response: {}\n        });\n    }\n}\nexports.WorkerServiceManager = WorkerServiceManager;\n//# sourceMappingURL=WorkerServiceManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/WorkerServiceManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtrusionFeatureDefs = void 0;\nvar ExtrusionFeatureDefs;\n(function (ExtrusionFeatureDefs) {\n    /**\n     * Minimum ratio value for extrusion effect\n     */\n    ExtrusionFeatureDefs.DEFAULT_RATIO_MIN = 0.0;\n    /**\n     * Maximum ratio value for extrusion effect\n     */\n    ExtrusionFeatureDefs.DEFAULT_RATIO_MAX = 1;\n    /**\n     * Buildings height used whenever no height-data is present or height is very small.\n     *\n     * Used to avoid z-fighting between ground plane and building.\n     */\n    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT = 0.01;\n})(ExtrusionFeatureDefs = exports.ExtrusionFeatureDefs || (exports.ExtrusionFeatureDefs = {}));\n//# sourceMappingURL=MapMeshMaterialsDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/index-worker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/index-worker.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvTilerService = exports.OmvTileDecoder = exports.OmvTileDecoderService = exports.OmvDecoder = void 0;\n__exportStar(__webpack_require__(/*! @here/harp-vectortile-datasource/index-worker */ \"./node_modules/@here/harp-vectortile-datasource/index-worker.js\"), exports);\nvar index_worker_1 = __webpack_require__(/*! @here/harp-vectortile-datasource/index-worker */ \"./node_modules/@here/harp-vectortile-datasource/index-worker.js\");\nObject.defineProperty(exports, \"OmvDecoder\", { enumerable: true, get: function () { return index_worker_1.VectorTileDataProcessor; } });\nObject.defineProperty(exports, \"OmvTileDecoderService\", { enumerable: true, get: function () { return index_worker_1.VectorTileDecoderService; } });\nObject.defineProperty(exports, \"OmvTileDecoder\", { enumerable: true, get: function () { return index_worker_1.VectorTileDecoder; } });\nObject.defineProperty(exports, \"OmvTilerService\", { enumerable: true, get: function () { return index_worker_1.GeoJsonTilerService; } });\n//# sourceMappingURL=index-worker.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/index-worker.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/index-common.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/index-common.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/GroupedPriorityList */ \"./node_modules/@here/harp-utils/lib/GroupedPriorityList.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Logger */ \"./node_modules/@here/harp-utils/lib/Logger/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Math2D */ \"./node_modules/@here/harp-utils/lib/Math2D.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MathUtils */ \"./node_modules/@here/harp-utils/lib/MathUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Mixins */ \"./node_modules/@here/harp-utils/lib/Mixins.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/assert */ \"./node_modules/@here/harp-utils/lib/assert.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/CachedResource */ \"./node_modules/@here/harp-utils/lib/CachedResource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ContextLogger */ \"./node_modules/@here/harp-utils/lib/ContextLogger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PerformanceTimer */ \"./node_modules/@here/harp-utils/lib/PerformanceTimer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ObjectUtils */ \"./node_modules/@here/harp-utils/lib/ObjectUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/OptionsUtils */ \"./node_modules/@here/harp-utils/lib/OptionsUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TaskQueue */ \"./node_modules/@here/harp-utils/lib/TaskQueue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/UriResolver */ \"./node_modules/@here/harp-utils/lib/UriResolver.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Functions */ \"./node_modules/@here/harp-utils/lib/Functions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/SampleBilinear */ \"./node_modules/@here/harp-utils/lib/SampleBilinear.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/AuthenticationUtils */ \"./node_modules/@here/harp-utils/lib/AuthenticationUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GlslUtils */ \"./node_modules/@here/harp-utils/lib/GlslUtils.js\"), exports);\n//# sourceMappingURL=index-common.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/index-common.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-utils/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./index-common */ \"./node_modules/@here/harp-utils/index-common.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/UrlPlatformUtils.web */ \"./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js\"), exports);\n//# sourceMappingURL=index.web.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/index.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/AuthenticationUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/AuthenticationUtils.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=AuthenticationUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/AuthenticationUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/CachedResource.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/CachedResource.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=CachedResource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/CachedResource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ContextLogger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ContextLogger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextLogger = void 0;\n/**\n * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`\n * before first actual log message.\n */\nclass ContextLogger {\n    /**\n     * Construct a context-aware logger that logs to `m_logger`.\n     */\n    constructor(m_logger, headerMessage) {\n        this.m_logger = m_logger;\n        this.headerMessage = headerMessage;\n        this.context = [];\n        this.m_headerLogged = false;\n        // They, are public member functions it's just tslint who doesn't understand this.\n        this.warn = this.createLogMethod(\"warn\");\n        this.info = this.createLogMethod(\"info\");\n        this.error = this.createLogMethod(\"error\");\n    }\n    /**\n     * Push \"attribute-like\" context.\n     *\n     * Following log messages will be prefixed with `name` or `.name` depending on current context.\n     */\n    pushAttr(name) {\n        this.context.push(`${this.context.length > 0 ? \".\" : \"\"}${name}`);\n    }\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index) {\n        this.context.push(`[${index}]`);\n    }\n    pop() {\n        this.context.pop();\n    }\n    createLogMethod(severity) {\n        return (message, ...rest) => {\n            if (!this.m_headerLogged) {\n                this.m_logger.info(this.headerMessage);\n                this.m_headerLogged = true;\n            }\n            this.m_logger[severity](`${this.context.join(\"\")}: ${message}`, ...rest);\n        };\n    }\n}\nexports.ContextLogger = ContextLogger;\n//# sourceMappingURL=ContextLogger.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/ContextLogger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Functions.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Functions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chainCallbacks = void 0;\n/**\n * Chains two functions for further assigning as one wrapped callback function\n */\nfunction chainCallbacks(f1, f2) {\n    return function (...args) {\n        if (f1) {\n            f1.apply(this, args);\n        }\n        return f2.apply(this, args);\n    };\n}\nexports.chainCallbacks = chainCallbacks;\n//# sourceMappingURL=Functions.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Functions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GlslUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GlslUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertFragmentShaderToWebGL2 = exports.convertVertexShaderToWebGL2 = void 0;\n/**\n * Converts webgl1-compatible vertex shader glsl code to webgl2.\n *\n * @param vertexShader - String containing the vertex shader glsl code.\n * @returns the converted glsl code.\n */\nfunction convertVertexShaderToWebGL2(vertexShader) {\n    return ([\"#define attribute in\", \"#define varying out\", \"#define texture2D texture\"].join(\"\\n\") +\n        \"\\n\" +\n        vertexShader);\n}\nexports.convertVertexShaderToWebGL2 = convertVertexShaderToWebGL2;\n/**\n * Converts webgl1-compatible fragment shader glsl code to webgl2.\n *\n * @param fragmentShader - String containing the fragment shader glsl code.\n * @returns the converted glsl code.\n */\nfunction convertFragmentShaderToWebGL2(fragmentShader) {\n    return ([\n        \"#define varying in\",\n        \"out highp vec4 pc_fragColor;\",\n        \"#define gl_FragColor pc_fragColor\",\n        \"#define gl_FragDepthEXT gl_FragDepth\",\n        \"#define texture2D texture\",\n        \"#define textureCube texture\",\n        \"#define texture2DProj textureProj\",\n        \"#define texture2DLodEXT textureLod\",\n        \"#define texture2DProjLodEXT textureProjLod\",\n        \"#define textureCubeLodEXT textureLod\",\n        \"#define texture2DGradEXT textureGrad\",\n        \"#define texture2DProjGradEXT textureProjGrad\",\n        \"#define textureCubeGradEXT textureGrad\"\n    ].join(\"\\n\") +\n        \"\\n\" +\n        fragmentShader);\n}\nexports.convertFragmentShaderToWebGL2 = convertFragmentShaderToWebGL2;\n//# sourceMappingURL=GlslUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/GlslUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GroupedPriorityList.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GroupedPriorityList = exports.PriorityListGroup = void 0;\n/**\n * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same\n * (integer) priority.\n */\nclass PriorityListGroup {\n    constructor(priority, elements = new Array()) {\n        this.priority = priority;\n        this.elements = elements;\n    }\n    /**\n     * Create and return a deep copy of the `PriorityListGroup<T>`.\n     *\n     * @returns A clone of the `PriorityListGroup<T>`.\n     */\n    clone() {\n        return new PriorityListGroup(this.priority, this.elements.slice());\n    }\n    /**\n     * Removes an element from the group.\n     * @param element - The element to remove.\n     * @returns true if the element was removed, false if it was not found in the group.\n     */\n    remove(element) {\n        const foundIndex = this.elements.indexOf(element);\n        if (foundIndex === -1) {\n            return false;\n        }\n        this.elements.splice(foundIndex, 1);\n        return true;\n    }\n}\nexports.PriorityListGroup = PriorityListGroup;\n/**\n * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items\n * in priority groups.\n */\nclass GroupedPriorityList {\n    constructor() {\n        this.groups = new Map();\n    }\n    /**\n     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.\n     *\n     * @param element - Element to be added.\n     */\n    add(element) {\n        this.getGroup(element.priority).elements.push(element);\n    }\n    /**\n     * Remove an element from the `GroupedPriorityList`.\n     *\n     * Note: It is required that the priority is the same as it was when the element has been added.\n     * Otherwise, the removal will fail.\n     *\n     * @param element - Element to be removed.\n     * @returns `True` if the element was removed, `false` otherwise.\n     */\n    remove(element) {\n        const group = this.findGroup(element.priority);\n        if (group !== undefined && group.remove(element)) {\n            if (group.elements.length === 0) {\n                this.groups.delete(group.priority);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Remove all internal {@link PriorityListGroup}s.\n     */\n    clear() {\n        this.groups.clear();\n    }\n    /**\n     * Merge another {@link GroupedPriorityList} into this one.\n     *\n     * @param other - Other group to merge.\n     */\n    merge(other) {\n        for (const otherGroup of other.groups) {\n            const group = this.findGroup(otherGroup[1].priority);\n            if (group === undefined) {\n                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());\n                continue;\n            }\n            group.elements = group.elements.concat(otherGroup[1].elements);\n        }\n        return this;\n    }\n    clone() {\n        const clone = new GroupedPriorityList();\n        for (const [priority, group] of this.groups) {\n            clone.groups.set(priority, group.clone());\n        }\n        return clone;\n    }\n    /**\n     * Apply function to all elements in this `GroupedPriorityList`.\n     *\n     * @param {(element: T) => void} fun Function to apply.\n     */\n    forEach(fun) {\n        for (const group of this.groups) {\n            group[1].elements.forEach(fun);\n        }\n    }\n    /**\n     * Count the number of elements in this `GroupedPriorityList`.\n     */\n    count() {\n        let n = 0;\n        for (const group of this.groups) {\n            n += group[1].elements.length;\n        }\n        return n;\n    }\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    findGroup(priority) {\n        const normalizedPriority = Math.floor(priority);\n        const group = this.groups.get(normalizedPriority);\n        return group;\n    }\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    getGroup(priority) {\n        let group = this.findGroup(priority);\n        if (group === undefined) {\n            const normalizedPriority = Math.floor(priority);\n            group = new PriorityListGroup(normalizedPriority);\n            this.groups.set(group.priority, group);\n        }\n        return group;\n    }\n}\nexports.GroupedPriorityList = GroupedPriorityList;\n//# sourceMappingURL=GroupedPriorityList.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/GroupedPriorityList.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConsoleChannel = void 0;\n/**\n * Class for the default console channel.\n */\nclass ConsoleChannel {\n    error(message, ...optionalParams) {\n        console.error(message, ...optionalParams);\n    }\n    debug(message, ...optionalParams) {\n        console.debug(message, ...optionalParams);\n    }\n    info(message, ...optionalParams) {\n        console.info(message, ...optionalParams);\n    }\n    log(message, ...optionalParams) {\n        console.log(message, ...optionalParams);\n    }\n    trace(message, ...optionalParams) {\n        console.trace(message, ...optionalParams);\n    }\n    warn(message, ...optionalParams) {\n        console.warn(message, ...optionalParams);\n    }\n}\nexports.ConsoleChannel = ConsoleChannel;\n//# sourceMappingURL=ConsoleChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/IChannel.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/IChannel.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/IChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ILogger.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggerOptions = exports.LogLevel = void 0;\n/**\n * Enum log levels\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Log\"] = 2] = \"Log\";\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 4] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n/**\n * Logger options to configure logger\n */\nclass LoggerOptions {\n}\nexports.LoggerOptions = LoggerOptions;\n//# sourceMappingURL=ILogger.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/ILogger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/Logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/Logger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Logger = void 0;\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\");\n/**\n * Logger class.\n */\nclass Logger {\n    constructor(name, m_channel, options) {\n        this.name = name;\n        this.m_channel = m_channel;\n        this.enabled = true;\n        this.level = ILogger_1.LogLevel.Trace;\n        if (options !== undefined) {\n            this.update(options);\n        }\n    }\n    error(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {\n            this.m_channel.error(this.prefix, message, ...optionalParams);\n        }\n    }\n    debug(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {\n            this.m_channel.debug(this.prefix, message, ...optionalParams);\n        }\n    }\n    info(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {\n            this.m_channel.info(this.prefix, message, ...optionalParams);\n        }\n    }\n    log(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {\n            this.m_channel.log(this.prefix, message, ...optionalParams);\n        }\n    }\n    trace(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {\n            this.m_channel.trace(this.prefix, message, ...optionalParams);\n        }\n    }\n    warn(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {\n            this.m_channel.warn(this.prefix, message, ...optionalParams);\n        }\n    }\n    update(options) {\n        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;\n        this.level = options.level === undefined ? this.level : options.level;\n    }\n    get prefix() {\n        return this.name + \":\";\n    }\n}\nexports.Logger = Logger;\n//# sourceMappingURL=Logger.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/Logger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggerManager = void 0;\nconst LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ \"./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js\");\n/**\n * The LoggerManager class implements a singleton object that handles logging.\n *\n * Example:\n *\n * ```typescript\n *\n * const logger = LoggerManager.instance.create(\"MyFontLoaderClass\");\n * if (missingFonts.length > 0) {\n *     logger.error(\"These fonts can not be loaded: \", missingFonts);\n * } else {\n *     logger.log(\"All fonts have been loaded.\");\n * }\n * ```\n */\nclass LoggerManager {\n    static get instance() {\n        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());\n    }\n}\nexports.LoggerManager = LoggerManager;\n//# sourceMappingURL=LoggerManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggerManagerImpl = void 0;\nconst ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ \"./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/@here/harp-utils/lib/Logger/Logger.js\");\nconst WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ \"./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js\");\n/**\n * LoggerManagerImpl is the class for the singleton instance of the logger manager.\n * It handles channels and loggers.\n */\nclass LoggerManagerImpl {\n    constructor() {\n        this.m_loggers = [];\n        this.channel =\n            typeof self === \"undefined\" || typeof self.document !== \"undefined\"\n                ? new ConsoleChannel_1.ConsoleChannel()\n                : new WorkerChannel_1.WorkerChannel();\n    }\n    getLoggerNames() {\n        return this.m_loggers.map(logger => logger.name);\n    }\n    getLogger(name) {\n        return this.m_loggers.find(logger => logger.name === name);\n    }\n    create(loggerName, options = {}) {\n        if (this.m_levelSetForAll !== undefined &&\n            (options.level === undefined || options.level < this.m_levelSetForAll)) {\n            options.level = this.m_levelSetForAll;\n        }\n        const logger = new Logger_1.Logger(loggerName, this.channel, options);\n        this.m_loggers.push(logger);\n        return logger;\n    }\n    dispose(logger) {\n        const found = this.m_loggers.indexOf(logger);\n        if (found < 0) {\n            throw new Error(`Cannot unregister \"${logger}\" : no such logger registered.`);\n        }\n        this.m_loggers.splice(found, 1);\n    }\n    updateAll(options) {\n        for (const logger of this.m_loggers) {\n            logger.update(options);\n        }\n    }\n    update(loggerName, config) {\n        for (const logger of this.m_loggers) {\n            if (logger.name === loggerName) {\n                logger.update(config);\n            }\n        }\n    }\n    enableAll(enabled) {\n        for (const logger of this.m_loggers) {\n            logger.enabled = enabled;\n        }\n    }\n    enable(loggerName, value) {\n        this.update(loggerName, { enabled: value });\n    }\n    setLogLevelForAll(level) {\n        this.m_levelSetForAll = level;\n        for (const logger of this.m_loggers) {\n            logger.level = level;\n        }\n    }\n    setLogLevel(loggerName, level) {\n        this.update(loggerName, { level });\n    }\n    setChannel(channel) {\n        this.channel = channel;\n    }\n}\nexports.LoggerManagerImpl = LoggerManagerImpl;\n//# sourceMappingURL=LoggerManagerImpl.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiChannel = void 0;\n/**\n * Class allowing mixing several channels.\n */\nclass MultiChannel {\n    constructor(...channels) {\n        this.channels = [];\n        this.channels = channels;\n    }\n    error(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.error(message, ...optionalParams);\n        }\n    }\n    debug(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.debug(message, ...optionalParams);\n        }\n    }\n    info(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.info(message, ...optionalParams);\n        }\n    }\n    log(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.log(message, ...optionalParams);\n        }\n    }\n    trace(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.trace(message, ...optionalParams);\n        }\n    }\n    warn(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.warn(message, ...optionalParams);\n        }\n    }\n}\nexports.MultiChannel = MultiChannel;\n//# sourceMappingURL=MultiChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerChannel = exports.WORKERCHANNEL_MSG_TYPE = void 0;\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\");\nexports.WORKERCHANNEL_MSG_TYPE = \"worker-channel-message\";\n/**\n * The class for the worker channel.\n */\nclass WorkerChannel {\n    error(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Error\n        };\n        self.postMessage(workerMessage);\n    }\n    debug(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Debug\n        };\n        self.postMessage(workerMessage);\n    }\n    info(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Info\n        };\n        self.postMessage(workerMessage);\n    }\n    log(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Log\n        };\n        self.postMessage(workerMessage);\n    }\n    trace(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Trace\n        };\n        self.postMessage(workerMessage);\n    }\n    warn(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Warn\n        };\n        self.postMessage(workerMessage);\n    }\n}\nexports.WorkerChannel = WorkerChannel;\n//# sourceMappingURL=WorkerChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ConsoleChannel */ \"./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IChannel */ \"./node_modules/@here/harp-utils/lib/Logger/IChannel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Logger */ \"./node_modules/@here/harp-utils/lib/Logger/Logger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./LoggerManager */ \"./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MultiChannel */ \"./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WorkerChannel */ \"./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Math2D.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Math2D.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Math2D = void 0;\nvar Math2D;\n(function (Math2D) {\n    /**\n     * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n     * objects with two numbers each). Should be faster.\n     */\n    class Box {\n        /**\n         * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n         * objects with two numbers each). Should be faster.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        constructor(x = 0, y = 0, w = 0, h = 0) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n        /**\n         * Set new values to all properties of the box.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        set(x, y, w, h) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n        /**\n         * Copy values from another box.\n         *\n         * @param box - Another box.\n         */\n        copy(box) {\n            this.x = box.x;\n            this.y = box.y;\n            this.w = box.w;\n            this.h = box.h;\n        }\n        /**\n         * Test box for inclusion of point.\n         *\n         * @param x - X coordinate of point.\n         * @param y - Y coordinate of point.\n         */\n        contains(x, y) {\n            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;\n        }\n        /**\n         * Test box for inclusion of another box.\n         *\n         * @param other - Box 2 to test for inclusion.\n         */\n        containsBox(other) {\n            const xmax = other.x + other.w;\n            const ymax = other.y + other.h;\n            return (this.contains(other.x, other.y) &&\n                this.contains(xmax, other.y) &&\n                this.contains(other.x, ymax) &&\n                this.contains(xmax, ymax));\n        }\n        /**\n         * Test two boxes for intersection.\n         *\n         * @param other - Box 2 to test for intersection.\n         */\n        intersects(other) {\n            return (this.x <= other.x + other.w &&\n                this.x + this.w >= other.x &&\n                this.y <= other.y + other.h &&\n                this.y + this.h >= other.y);\n        }\n    }\n    Math2D.Box = Box;\n    /**\n     * Compute squared distance between two 2D points `a` and `b`.\n     *\n     * @param ax - Point a.x\n     * @param ay - Point a.y\n     * @param bx - Point b.x\n     * @param by - Point b.y\n     * @returns Squared distance between the two points\n     */\n    function distSquared(ax, ay, bx, by) {\n        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);\n    }\n    Math2D.distSquared = distSquared;\n    /**\n     * Computes the squared length of a line.\n     *\n     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.\n     */\n    function computeSquaredLineLength(line) {\n        let squaredLineLength = 0;\n        const length = line.length - 4;\n        for (let i = 0; i < length; i += 3) {\n            const xDiff = line[i + 3] - line[i];\n            const yDiff = line[i + 4] - line[i + 1];\n            squaredLineLength += xDiff * xDiff + yDiff * yDiff;\n        }\n        return squaredLineLength;\n    }\n    Math2D.computeSquaredLineLength = computeSquaredLineLength;\n    /**\n     * Compute squared distance between a 2D point and a 2D line segment.\n     *\n     * @param px - Test point X\n     * @param py - Test point y\n     * @param l0x - Line segment start X\n     * @param l0y - Line segment start Y\n     * @param l1x - Line segment end X\n     * @param l1y - Line segment end Y\n     * @returns Squared distance between point and line segment\n     */\n    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {\n        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);\n        if (lineLengthSuared === 0) {\n            return distSquared(px, py, l0x, l0y);\n        }\n        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;\n        t = Math.max(0, Math.min(1, t));\n        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));\n    }\n    Math2D.distToSegmentSquared = distToSegmentSquared;\n    /**\n     * Finds the intersections of a line and a circle.\n     *\n     * @param xLine1 - abscissa of first line point.\n     * @param yLine1 - ordinate of second line point.\n     * @param xLine2 - abscissa of second line point.\n     * @param yLine2 - ordinate of second line point.\n     * @param radius - circle radius.\n     * @param xCenter - abscissa of circle center.\n     * @param yCenter - ordinate of circle center.\n     * @returns coordinates of the intersections (1 if the line is tangent to the circle, 2\n     * if it's secant) or undefined if there's no intersection.\n     */\n    function intersectLineAndCircle(xLine1, yLine1, xLine2, yLine2, radius, xCenter = 0, yCenter = 0) {\n        // Line equation: dy*x - dx*y = c, c = dy*x1 - dx*y1 = x1*y2 - x2*y1\n        // Circle equation: (x-xCenter)^2 + (y-yCenter)^2 = r^2\n        // 1. Translate circle center to origin of coordinates:\n        // u = x - xCenter\n        // v = y - yCenter\n        // circle: u^2 + v^2 = r^2\n        // line: dy*u - dx*v = cp, cp = c - dy*xCenter - dx*yCenter\n        // 2. Intersections are solutions of a quadratic equation:\n        // ui = (cp*dy +/- sign(dy)*dx*discriminant / dSq\n        // vi = (-cp*dx +/- |dy|*discriminant / dSq\n        // discriminant = r^2*dSq - cp^2, dSq = dx^2 + dy^2\n        // The sign of the discriminant indicates the number of intersections.\n        // 3. Translate intersection coordinates back to original space:\n        // xi = xCenter + ui\n        // yi = yCenter + yi\n        const epsilon = 1e-10;\n        const dx = xLine2 - xLine1;\n        const dy = yLine2 - yLine1;\n        const dSq = dx * dx + dy * dy;\n        const rSq = radius * radius;\n        const c = xLine1 * yLine2 - xLine2 * yLine1;\n        const cp = c - dy * xCenter + dx * yCenter;\n        const discriminantSquared = rSq * dSq - cp * cp;\n        if (discriminantSquared < -epsilon) {\n            // no intersection\n            return undefined;\n        }\n        const xMid = cp * dy;\n        const yMid = -cp * dx;\n        if (discriminantSquared < epsilon) {\n            // 1 intersection (tangent line)\n            return { x1: xCenter + xMid / dSq, y1: yCenter + yMid / dSq };\n        }\n        const discriminant = Math.sqrt(discriminantSquared);\n        // 2 intersections (secant line)\n        const signDy = dy < 0 ? -1 : 1;\n        const absDy = Math.abs(dy);\n        const xDist = signDy * dx * discriminant;\n        const yDist = absDy * discriminant;\n        return {\n            x1: xCenter + (xMid + xDist) / dSq,\n            y1: yCenter + (yMid + yDist) / dSq,\n            x2: xCenter + (xMid - xDist) / dSq,\n            y2: yCenter + (yMid - yDist) / dSq\n        };\n    }\n    Math2D.intersectLineAndCircle = intersectLineAndCircle;\n    /**\n     * Computes the intersection point between two lines.\n     *\n     * @remarks\n     * This functions computes the\n     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     *    | line-line intersection} of two lines given two points on each line.\n     *\n     * @param x1 - x coordinate of the first point of the first line.\n     * @param y1 - y coordinate of the first point of the first line.\n     * @param x2 - x coordinate of the second point of the first line.\n     * @param y2 - y coordinate of the second point of the first line.\n     * @param x3 - x coordinate of the first point of the second line.\n     * @param y3 - y coordinate of the first point of the second line.\n     * @param x4 - x coordinate of the second point of the second line.\n     * @param y4 - y coordinate of the second point of the second line.\n     * @param result - The resulting point.\n     */\n    function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4, result = { x: 0, y: 0 }) {\n        const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (d === 0) {\n            return undefined;\n        }\n        const px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n        const py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n        result.x = px;\n        result.y = py;\n        return result;\n    }\n    Math2D.intersectLines = intersectLines;\n})(Math2D = exports.Math2D || (exports.Math2D = {}));\n//# sourceMappingURL=Math2D.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Math2D.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/MathUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/MathUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathUtils = void 0;\nvar MathUtils;\n(function (MathUtils) {\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     *\n     * @returns Clamped value.\n     */\n    function clamp(value, min, max) {\n        return value < min ? min : value > max ? max : value;\n    }\n    MathUtils.clamp = clamp;\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    function smoothStep(edge0, edge1, x) {\n        // Scale, bias and saturate x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n    }\n    MathUtils.smoothStep = smoothStep;\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     *\n     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and\n     * `x = 1`:\n     *\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    function smootherStep(edge0, edge1, x) {\n        // Scale, and clamp x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n    MathUtils.smootherStep = smootherStep;\n    /**\n     * Maps a number from one range to another.\n     *\n     * @param val - The incoming value to be converted.\n     * @param inMin - Lower bound of the value's current range.\n     * @param inMax - Upper bound of the value's current range.\n     * @param outMin - Lower bound of the value's target range.\n     * @param outMax - Upper bound of the value's target range.\n     */\n    function map(val, inMin, inMax, outMin, outMax) {\n        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n    }\n    MathUtils.map = map;\n    /**\n     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    function min2(a, b) {\n        let result;\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.min(result, b);\n        }\n        return result;\n    }\n    MathUtils.min2 = min2;\n    /**\n     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    function max2(a, b) {\n        let result;\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.max(result, b);\n        }\n        return result;\n    }\n    MathUtils.max2 = max2;\n    /**\n     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be\n     * undefined, in which case their value is ignored.\n     *\n     * @param value - Value to check.\n     * @param lowerBound - The lower bound to check the value against.\n     * @param upperBound - The upper bound to check the value against.\n     *\n     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`\n     *          otherwise.\n     */\n    function isClamped(value, lowerBound, upperBound) {\n        if (lowerBound !== undefined && value < lowerBound) {\n            return false;\n        }\n        if (upperBound !== undefined && value > upperBound) {\n            return false;\n        }\n        return true;\n    }\n    MathUtils.isClamped = isClamped;\n    /**\n     * Smoothly interpolates between two values using cubic formula\n     *\n     * @param startValue -\n     * @param endValue -\n     * @param time -\n     * @returns Result of the interpolation within the range of `[startValue, endValue]`\n     */\n    function easeInOutCubic(startValue, endValue, time) {\n        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n        return startValue + (endValue - startValue) * timeValue;\n    }\n    MathUtils.easeInOutCubic = easeInOutCubic;\n})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));\n//# sourceMappingURL=MathUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/MathUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Mixins.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Mixins.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyMixinsWithoutProperties = exports.applyMixins = void 0;\n/**\n * Copy methods and properties from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods and properties into.\n * @param baseCtors - Class to take all methods and properties from.\n */\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\nexports.applyMixins = applyMixins;\n/**\n * Copy methods from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods into.\n * @param baseCtors - Class to take all methods from.\n */\nfunction applyMixinsWithoutProperties(derivedCtor, baseCtors) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);\n            if (descriptor !== undefined &&\n                descriptor.get === undefined &&\n                name !== \"constructor\") {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\nexports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;\n//# sourceMappingURL=Mixins.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Mixins.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ObjectUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ObjectUtils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pick = exports.cloneDeep = void 0;\n/**\n * Deep clone of object.\n *\n * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,\n * object), `Date` and `RegExp`s and cycles.\n *\n * Throws error if enounters object with `prototype` assuming that in general class instances\n * cannot be reliably cloned by generic algorithm.\n */\nfunction cloneDeep(obj) {\n    const cache = new Map();\n    function cloneInternal(src) {\n        if (src === null) {\n            return null;\n        }\n        else if (typeof src === \"object\") {\n            const cached = cache.get(src);\n            if (cached !== undefined) {\n                return cached;\n            }\n            if (Array.isArray(src)) {\n                const result = [];\n                cache.set(src, result);\n                result.length = src.length;\n                for (let i = 0; i < result.length; ++i) {\n                    result[i] = cloneInternal(src[i]);\n                }\n                return result;\n            }\n            else if (src instanceof Date) {\n                const result = new Date(src.getTime());\n                cache.set(src, result);\n                return result;\n            }\n            else if (src instanceof RegExp) {\n                const result = new RegExp(src.source, src.flags);\n                cache.set(src, result);\n                return result;\n            }\n            else if (src.constructor !== Object) {\n                throw new Error(\"cloneDeep doesn't support objects with custom prototypes\");\n            }\n            else {\n                const result = {};\n                cache.set(src, result);\n                for (const key in src) {\n                    if (src.hasOwnProperty(key)) {\n                        result[key] = cloneInternal(src[key]);\n                    }\n                }\n                return result;\n            }\n        }\n        else {\n            // string, number, boolean, undefined and functions are returned as is\n            return src;\n        }\n    }\n    const r = cloneInternal(obj);\n    cache.clear();\n    return r;\n}\nexports.cloneDeep = cloneDeep;\n/**\n * Pick `props` from `object.\n *\n * Runtime version of `Pick<T,K>`.\n */\nfunction pick(object, props) {\n    const result = {};\n    for (const propName of props) {\n        if (object.hasOwnProperty(propName)) {\n            result[propName] = object[propName];\n        }\n    }\n    return result;\n}\nexports.pick = pick;\n//# sourceMappingURL=ObjectUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/ObjectUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/OptionsUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/OptionsUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOptionValue = void 0;\nfunction getOptionValue(...values) {\n    for (const candidate of values) {\n        if (candidate !== undefined && candidate !== null) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\nexports.getOptionValue = getOptionValue;\n//# sourceMappingURL=OptionsUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/OptionsUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/PerformanceTimer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceTimer = void 0;\n/**\n * See:\n * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now\n */\nclass PerformanceTimer {\n    /**\n     * Returns timestamp in milliseconds since page load.\n     *\n     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,\n     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two\n     * samples.\n     *\n     * Example:\n     * ```typescript\n     * const now = PerformanceTimer.now();\n     * // call some expensive function for which you want to check the duration.\n     * const end = PerformanceTimer.now();\n     * const elapsedTime = end - now;\n     * ```\n     */\n    static now() {\n        return PerformanceTimer.nowFunc();\n    }\n    static getNowFunc() {\n        if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            return () => performance.now();\n        }\n        // fall back to Date.getTime()\n        return () => {\n            return new Date().getTime();\n        };\n    }\n}\nexports.PerformanceTimer = PerformanceTimer;\nPerformanceTimer.instance = new PerformanceTimer();\nPerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();\n//# sourceMappingURL=PerformanceTimer.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/PerformanceTimer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/SampleBilinear.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/SampleBilinear.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sampleBilinear = void 0;\n/**\n * Returns a bilinear-interpolated texture sample for a given texture.\n * @param texture - Two-dimensional texture to sample.\n * @param width - Texture width.\n * @param height - Texture height.\n * @param u - Number between 0 and 1 representing the location to sample in the width dimension.\n * @param v - Number between 0 and 1 representing the location to sample in the height dimension.\n */\nfunction sampleBilinear(texture, width, height, u, v) {\n    const maxXIndex = width - 1;\n    const maxYIndex = height - 1;\n    // Compute the x and y coordinates relative to the mesh size.\n    const xIndex = u * maxXIndex;\n    const xIndexFloor = Math.floor(xIndex);\n    const yIndex = v * maxYIndex;\n    const yIndexFloor = Math.floor(yIndex);\n    const swIndex = yIndexFloor * width + xIndexFloor;\n    const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;\n    const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;\n    const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;\n    const swElevation = texture[swIndex];\n    const seElevation = texture[seIndex];\n    const nwElevation = texture[nwIndex];\n    const neElevation = texture[neIndex];\n    // Get the fractional components to do bilinear interpolation.\n    const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;\n    const xFracInverse = 1 - xFrac;\n    const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;\n    const yFracInverse = 1 - yFrac;\n    // The interpolation is the sum of the four closest neighbours each\n    // multiplied by the diagonal areas.\n    const result = swElevation * xFracInverse * yFracInverse +\n        seElevation * xFrac * yFracInverse +\n        nwElevation * xFracInverse * yFrac +\n        neElevation * xFrac * yFrac;\n    return result;\n}\nexports.sampleBilinear = sampleBilinear;\n//# sourceMappingURL=SampleBilinear.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/SampleBilinear.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/TaskQueue.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/TaskQueue.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TaskQueue = void 0;\n/**\n * A Pull-TaskQueue sorted by priority and group-able {@link Task}s by {@link Task.group}.\n *\n * @remarks\n *\n * @example\n * Sample Usage\n * ```\n *  const taskQueue = new TaskQueue({\n *      group: [\"group1\"]\n *  })\n *  taskQueue.add({\n *     group: \"group1\",\n *     execute: () => {\n *         console.log(\"task of group1 executed\");\n *     },\n *     getPrio: () => {\n *         return 0;\n *     }\n *   });\n *\n * taskQueue.update();\n * taskQueue.processNext(\"group1\");\n *\n *  ```\n */\nclass TaskQueue {\n    constructor(m_options) {\n        var _a;\n        this.m_options = m_options;\n        this.m_taskLists = new Map();\n        (_a = this.m_options.groups) === null || _a === void 0 ? void 0 : _a.forEach(group => {\n            this.m_taskLists.set(group, []);\n        });\n        if (this.m_options.prioSortFn) {\n            this.sort = this.m_options.prioSortFn;\n        }\n    }\n    /**\n     * Updates the lists in the queue depending on their priority functions and removes\n     * expired Tasks, based on their isExpired functions result.\n     *\n     * @param group The Group to update, if not set all groups will be updated.\n     */\n    update(group) {\n        if (group === undefined) {\n            this.m_taskLists.forEach(taskList => {\n                this.updateTaskList(taskList);\n            });\n        }\n        else {\n            const taskList = this.getTaskList(group);\n            if (taskList) {\n                this.updateTaskList(taskList);\n            }\n        }\n    }\n    /**\n     * Adds a Task to the Queue\n     *\n     * @param task\n     * @returns true if succesfully added, otherwise false\n     */\n    add(task) {\n        var _a;\n        if (this.m_taskLists.has(task.group)) {\n            const taskList = this.m_taskLists.get(task.group);\n            if (!(taskList === null || taskList === void 0 ? void 0 : taskList.includes(task))) {\n                (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.push(task);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes a Task from the Queue\n     *\n     * @param task\n     * @returns true if succesfully removed, otherwise false\n     */\n    remove(task) {\n        var _a, _b;\n        if (this.m_taskLists.has(task.group)) {\n            const index = (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.indexOf(task);\n            if (index !== -1) {\n                (_b = this.m_taskLists.get(task.group)) === null || _b === void 0 ? void 0 : _b.splice(index, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns the number of remaining tasks.\n     *\n     * @param group if group is set, it will return only the remaining tasks for this group,\n     * otherwise it will return the complete amount of tasks left.\n     */\n    numItemsLeft(group) {\n        var _a, _b;\n        let numLeft = 0;\n        if (group === undefined) {\n            this.m_taskLists.forEach(tasklist => {\n                numLeft += tasklist.length;\n            });\n        }\n        else {\n            numLeft += (_b = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n        }\n        return numLeft;\n    }\n    /**\n     * Processes the next Tasks for a group\n     *\n     * @param group The group the Tasks are pulled from.\n     * @param shouldProcess A condition that, if set will be executed before the task is processed,\n     * if returns true, the task will run\n     * @param n The amount of tasks that should be pulled, @defaults to 1\n     * @returns false if thte list was empty\n     */\n    processNext(group, shouldProcess, n = 1) {\n        if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {\n            return false;\n        }\n        for (let i = 0; i < n && this.numItemsLeft(group) > 0; i++) {\n            const nextTask = this.pull(group, true);\n            if (nextTask !== undefined) {\n                //if a condition is set, execute it\n                if (!shouldProcess || (shouldProcess === null || shouldProcess === void 0 ? void 0 : shouldProcess(nextTask))) {\n                    nextTask.execute();\n                }\n                else {\n                    //as the task was not executed but already pulled, add it back\n                    //TODO: dont even pull it if it will not execute, this currently\n                    // interferes with the skipping and removal of expired tasks on this.pull\n                    this.add(nextTask);\n                }\n            }\n        }\n        return true;\n    }\n    clear() {\n        this.m_taskLists.clear();\n    }\n    pull(group, checkIfExpired = false) {\n        var _a, _b;\n        const taskList = this.getTaskList(group);\n        let nextTask;\n        if (taskList) {\n            nextTask = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.pop();\n            if (checkIfExpired && nextTask && ((_b = nextTask.isExpired) === null || _b === void 0 ? void 0 : _b.call(nextTask))) {\n                return this.pull(group, checkIfExpired);\n            }\n        }\n        return nextTask;\n    }\n    sort(a, b) {\n        // the highest number in the beginning as the last in the array with\n        // highest priority which equals 0 will start to be processed\n        return b.getPriority() - a.getPriority();\n    }\n    getTaskList(group) {\n        return this.m_taskLists.get(group);\n    }\n    updateTaskList(taskList) {\n        var _a;\n        for (let i = 0; i < taskList.length; i++) {\n            const task = taskList[i];\n            if ((_a = task === null || task === void 0 ? void 0 : task.isExpired) === null || _a === void 0 ? void 0 : _a.call(task)) {\n                taskList.splice(i, 1);\n                i--;\n            }\n        }\n        taskList.sort(this.sort);\n    }\n}\nexports.TaskQueue = TaskQueue;\n//# sourceMappingURL=TaskQueue.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/TaskQueue.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UriResolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UriResolver.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.composeUriResolvers = exports.RelativeUriResolver = exports.PrefixMapUriResolver = void 0;\nconst UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\");\n/**\n * Basic, import-map like {@link UriResolver}.\n *\n * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.\n *\n * In definitions, `key` is matched against input uri with following strategy:\n *  - `key` without trailing `/` -> `key` and input `uri` must be identical\n *  - `key` with trailing `/`, -> `key` is treated as \"package prefix\", so `uri` must start with\n *    `key`\n *\n * Example:\n * ```\n * {\n *     \"local://poiMasterList\": \"/assets/poiMasterList.json\"\n *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`\n *     \"local://icons/\": \"/assets/icons/\"\n *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to\n *        // `/assets/icons/ANYPATH\n * }\n * ```\n * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).\n */\nclass PrefixMapUriResolver {\n    constructor(definitions) {\n        this.definitions = definitions;\n    }\n    resolveUri(uri) {\n        return Object.keys(this.definitions).reduce((r, key) => {\n            if (key.endsWith(\"/\") && r.startsWith(key)) {\n                const newPrefix = this.definitions[key];\n                return newPrefix + r.substr(key.length);\n            }\n            else if (r === key) {\n                return this.definitions[key];\n            }\n            return r;\n        }, uri);\n    }\n}\nexports.PrefixMapUriResolver = PrefixMapUriResolver;\n/**\n * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.\n */\nclass RelativeUriResolver {\n    constructor(parentUri) {\n        this.parentUri = parentUri;\n    }\n    resolveUri(uri) {\n        return UrlUtils_1.resolveReferenceUri(this.parentUri, uri);\n    }\n}\nexports.RelativeUriResolver = RelativeUriResolver;\n/**\n * Compose URI resolvers.\n *\n * Creates new {@link UriResolver} that applies resolvers in orders or arguments.\n *\n * Example:\n *\n *     const themeUrl = ...; // url of parent object\n *     const childUrlResolver = composeUrlResolvers(\n *           new RelativeUriResolver(themeUrl),\n *           defaultUrlResolver\n *     );\n */\nfunction composeUriResolvers(...resolvers) {\n    return {\n        resolveUri(originalUrl) {\n            return resolvers.reduce((url, resolver) => {\n                if (resolver !== undefined) {\n                    return resolver.resolveUri(url);\n                }\n                else {\n                    return url;\n                }\n            }, originalUrl);\n        }\n    };\n}\nexports.composeUriResolvers = composeUriResolvers;\n//# sourceMappingURL=UriResolver.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UriResolver.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAppBaseUrl = void 0;\nconst UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\");\n/**\n * Get base URL for from where relative URLs will be loaded.\n *\n * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL\n * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n *\n * * In node, it resolves to `file://${process.cwd()}`.\n */\nfunction getAppBaseUrl() {\n    return UrlUtils_1.baseUrl(window.location.href);\n}\nexports.getAppBaseUrl = getAppBaseUrl;\n//# sourceMappingURL=UrlPlatformUtils.web.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlUtils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getUrlHostAndProtocol = exports.getUrlOrigin = exports.baseUrl = exports.resolveReferenceUri = void 0;\n/**\n * Resolve URI of referenced object w.r.t parent URI.\n *\n * Resolves `childUri` as it would be loaded from location specified by `parentUri`.\n *\n * If `childUri` is absolute, then it is returned unchanged.\n * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.\n *\n * See [[baseUri]] for reference how base URL of `parentUri` is determined.\n *\n * Supports `http:`, `https:`, `file:`, `data:` schemes.\n *\n * Examples:\n *\n *     // normal case, child is sibling\n *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent is \"folder\", so child is just located in this folder\n *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent looks like leaf, so last component is stripped\n *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png\n *\n *     // origin-absolute URL, takes only origin from parent\n *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json\n *\n * @param parentUri - URI of parent resource\n * @param childUri - URI of child as referenced from parent resource\n * @return `childUrl` as if anchored in location of `parentUrl`\n */\nfunction resolveReferenceUri(parentUri, childUri) {\n    if (absoluteUrlWithOriginRe.test(childUri)) {\n        return childUri;\n    }\n    else if (childUri.startsWith(\"/\")) {\n        const origin = getUrlOrigin(parentUri);\n        return origin + childUri;\n    }\n    else {\n        if (childUri.startsWith(\"./\")) {\n            childUri = childUri.substr(2);\n        }\n        const parentBaseUrl = baseUrl(parentUri);\n        return parentBaseUrl + childUri;\n    }\n}\nexports.resolveReferenceUri = resolveReferenceUri;\nconst absoluteUrlWithOriginRe = new RegExp(\"^(((?:[a-z]+:)?//)|(file:/)|(data:))\", \"i\");\n/**\n * Returns base URL of given resource URL.\n *\n * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if\n * `url` ends with name component it is treated as \"leaf\", so last path component is removed.\n *\n * Standalone files (without any folder structure) are considered relative to `./`.\n *\n * Examples:\n * ```\n *     https://foo.com/themes/a.json -> https://foo.com/themes/\n *     https://foo.com/themes/ -> https://foo.com/themes/\n *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf\n *     themes/day.json -> themes/\n *     themes -> ./\n * ```\n */\nfunction baseUrl(url) {\n    if (url === undefined) {\n        return \"./\";\n    }\n    let idx = url.indexOf(\"#\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.indexOf(\"?\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.lastIndexOf(\"/\");\n    if (idx === -1) {\n        return \"./\";\n    }\n    else {\n        return url.substring(0, idx + 1);\n    }\n}\nexports.baseUrl = baseUrl;\n/**\n * Get `origin` part of URL.\n *\n * @example\n *    https://example.com/foo -> https://example.com\n *    //example.com:8080/ -> //example.com:8080\n *    file:///etc/hosts ->\n *\n * @param url - input URL\n * @return origin of given URL\n */\nfunction getUrlOrigin(url) {\n    if (url === undefined) {\n        return \"\";\n    }\n    const parsed = getUrlHostAndProtocol(url);\n    if (parsed.protocol === \"file:\") {\n        return \"file://\";\n    }\n    else if (parsed.host && parsed.protocol) {\n        return parsed.protocol + \"//\" + parsed.host;\n    }\n    else if (parsed.host) {\n        return \"//\" + parsed.host;\n    }\n    else if (parsed.protocol) {\n        return parsed.protocol + \"//\";\n    }\n    else {\n        return \"\";\n    }\n}\nexports.getUrlOrigin = getUrlOrigin;\n/**\n * Parse `host` and `protocol` part from URL.\n */\nfunction getUrlHostAndProtocol(url) {\n    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\\/\\/([^\\/]*)/, \"i\");\n    const match = url.match(urlOriginRe);\n    if (!match) {\n        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);\n    }\n    return {\n        protocol: match[1],\n        host: match[2]\n    };\n}\nexports.getUrlHostAndProtocol = getUrlHostAndProtocol;\n//# sourceMappingURL=UrlUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UrlUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/assert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertExists = exports.assert = void 0;\n// cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = \"development\" === \"production\";\n//TODO: Make assertHandler configurable\n/**\n * Implementation of assert as a development help\n *\n * Note - this is deliberately a global function so that minimizers remove the\n * entire call when building for production.\n *\n * @hidden\n * @param condition - Condition to match, if false, throws an Error(message)\n * @param message - Optional message, defaults to \"ASSERTION failed\"\n */\nfunction assert(condition, message) {\n    if (!isProduction) {\n        if (!condition) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed\");\n        }\n    }\n}\nexports.assert = assert;\nfunction assertExists(element, message) {\n    if (!isProduction) {\n        if (element === undefined || element === null) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed: Element is undefined or null\");\n        }\n    }\n    return element;\n}\nexports.assertExists = assertExists;\n//# sourceMappingURL=assert.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/assert.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/index-worker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/index-worker.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/VectorTileDecoder */ \"./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDecoder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonTilerService */ \"./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonTilerService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\"), exports);\n//# sourceMappingURL=index-worker.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/index-worker.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/DecodeInfo.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/DecodeInfo.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecodeInfo = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nclass DecodeInfo {\n    /**\n     * Constructs a new [[DecodeInfo]].\n     *\n     * @param adapterId - The id of the [[OmvDataAdapter]] used for decoding.\n     * @param targetProjection - The [[Projection]]\n     * @param tileKey - The [[TileKey]] of the Tile to decode.\n     * @param storageLevelOffset - The storage level offset.\n     */\n    constructor(adapterId, targetProjection, tileKey, storageLevelOffset = 0) {\n        this.adapterId = adapterId;\n        this.targetProjection = targetProjection;\n        this.tileKey = tileKey;\n        this.storageLevelOffset = storageLevelOffset;\n        this.projectedBoundingBox = new harp_geoutils_1.OrientedBox3();\n        /**\n         * The tile bounds in the OMV tile space [[webMercatorTilingScheme]].\n         */\n        this.tileBounds = new THREE.Box3();\n        /**\n         * The tile size in the OMV tile space [[webMercatorTilingScheme]].\n         */\n        this.tileSize = new THREE.Vector3();\n        /**\n         * The center of the Tile in the target [[Projection]] space.\n         * Geometries generated by decoding the OMV tile must be relative\n         * to this position.\n         */\n        this.center = new THREE.Vector3();\n        this.geoBox = this.tilingScheme.getGeoBox(tileKey);\n        this.targetProjection.projectBox(this.geoBox, this.projectedBoundingBox);\n        this.projectedBoundingBox.getCenter(this.center);\n        this.tilingScheme.getWorldBox(tileKey, this.tileBounds);\n        this.tileBounds.getSize(this.tileSize);\n        this.tileSizeOnScreen = 256 * Math.pow(2, -this.storageLevelOffset);\n        this.columnCount = harp_geoutils_1.webMercatorTilingScheme.subdivisionScheme.getLevelDimensionX(this.tileKey.level);\n        this.rowCount = harp_geoutils_1.webMercatorTilingScheme.subdivisionScheme.getLevelDimensionY(this.tileKey.level);\n    }\n    /**\n     * The [[TilingScheme]] of the OMV data, currenly it is defined\n     * to be [[webMercatorTilingScheme]].\n     */\n    get tilingScheme() {\n        return harp_geoutils_1.webMercatorTilingScheme;\n    }\n    /**\n     * The [[Projection]] of OMV tiled data, currenly it is defined\n     * to be [[webMercatorProjection]].\n     */\n    get sourceProjection() {\n        return this.tilingScheme.projection;\n    }\n}\nexports.DecodeInfo = DecodeInfo;\n//# sourceMappingURL=DecodeInfo.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/DecodeInfo.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonTilerService.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonTilerService.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoJsonTilerService = void 0;\nconst index_worker_1 = __webpack_require__(/*! @here/harp-mapview-decoder/index-worker */ \"./node_modules/@here/harp-mapview-decoder/index-worker.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\n/**\n * GeoJson tiler service.\n *\n * @remarks\n * This services instantiates the geojson-vt based tiler\n * service that is responsible to create small tiles from\n * large GeoJson datasets.\n *\n * @example\n * ```typescript\n * // decoder.ts\n * GeoJsonTilerService.start();\n * ```\n */\nclass GeoJsonTilerService {\n    /**\n     * Register a vector data tiler service with\n     * {@link @here/harp-mapview-decoder#WorkerServiceManager}.\n     *\n     * @remarks\n     * Has to be called during initialization of decoder bundle.\n     */\n    static start() {\n        index_worker_1.WorkerServiceManager.getInstance().register({\n            serviceType: OmvDecoderDefs_1.GEOJSON_TILER_SERVICE_TYPE,\n            factory: (serviceId) => index_worker_1.TilerService.start(serviceId)\n        });\n    }\n}\nexports.GeoJsonTilerService = GeoJsonTilerService;\n//# sourceMappingURL=GeoJsonTilerService.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonTilerService.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvGenericFeatureModifier = exports.ComposedDataFilter = exports.OmvGenericFeatureFilter = exports.OmvFeatureFilterDescriptionBuilder = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\n/**\n * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well\n * as an [[OmvFeatureModifier]].\n *\n */\nclass OmvFeatureFilterDescriptionBuilder {\n    /**\n     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as\n     * well as an [[OmvFeatureModifier]].\n     *\n     * @param processLayersDefault - If `true`, all unspecified layers will be processed.\n     * If `false`, all unspecified layers will be ignored.\n     * @param processPointsDefault - If `true`, all unspecified point features will be processed. If\n     * `false`, all unspecified point features will be ignored.\n     * @param processLinesDefault - If `true`, all unspecified line features will be processed. If\n     * `false`, all unspecified line features will be ignored.\n     * @param processPolygonsDefault - If `true`, all unspecified polygon features will be\n     * processed. If `false`, all unspecified polygon features will be ignored.\n     */\n    constructor(options) {\n        this.m_processLayersDefault = true;\n        this.m_processPointsDefault = true;\n        this.m_processLinesDefault = true;\n        this.m_processPolygonsDefault = true;\n        this.m_layersToProcess = new Array();\n        this.m_layersToIgnore = new Array();\n        this.m_pointsToProcess = new Array();\n        this.m_ignoredPoints = new Array();\n        this.m_linesToProcess = new Array();\n        this.m_linesToIgnore = new Array();\n        this.m_polygonsToProcess = new Array();\n        this.m_polygonsToIgnore = new Array();\n        this.m_kindsToProcess = [];\n        this.m_kindsToIgnore = [];\n        if (options) {\n            this.m_processLayersDefault =\n                options.processLayersDefault !== undefined ? options.processLayersDefault : true;\n            this.m_processPointsDefault =\n                options.processPointsDefault !== undefined ? options.processPointsDefault : true;\n            this.m_processLinesDefault =\n                options.processLinesDefault !== undefined ? options.processLinesDefault : true;\n            this.m_processPolygonsDefault =\n                options.processPolygonsDefault !== undefined\n                    ? options.processPolygonsDefault\n                    : true;\n        }\n    }\n    /**\n     * Add a layer that should be processed.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {\n        this.m_layersToProcess.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n    /**\n     * Add a layer that should be ignored.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {\n        this.m_layersToIgnore.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n    /**\n     * Add a valid point feature.\n     *\n     * @param options - Feature options.\n     */\n    processPoint(options) {\n        this.addItem(this.m_pointsToProcess, options);\n    }\n    /**\n     * Add valid point features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPoints(options) {\n        this.addItems(this.m_pointsToProcess, options);\n    }\n    /**\n     * Add a point feature that should be ignored.\n     *\n     * @param options - Feature options.\n     */\n    ignorePoint(options) {\n        this.addItem(this.m_ignoredPoints, options);\n    }\n    /**\n     * Add point features that should be ignored.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePoints(options) {\n        this.addItems(this.m_ignoredPoints, options);\n    }\n    /**\n     * Add a valid line feature.\n     *\n     * @param options - Feature options.\n     */\n    processLine(options) {\n        this.addItem(this.m_linesToProcess, options);\n    }\n    /**\n     * Add valid line features.\n     *\n     * @param options - Multi feature options.\n     */\n    processLines(options) {\n        this.addItems(this.m_linesToProcess, options);\n    }\n    /**\n     * Ignore a line feature.\n     *\n     * @param options - Feature options.\n     */\n    ignoreLine(options) {\n        this.addItem(this.m_linesToIgnore, options);\n    }\n    /**\n     * Ignore line features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignoreLines(options) {\n        this.addItems(this.m_linesToIgnore, options);\n    }\n    /**\n     * Add a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    processPolygon(options) {\n        this.addItem(this.m_polygonsToProcess, options);\n    }\n    /**\n     * Add valid polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPolygons(options) {\n        this.addItems(this.m_polygonsToProcess, options);\n    }\n    /**\n     * Ignore a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    ignorePolygon(options) {\n        this.addItem(this.m_polygonsToIgnore, options);\n    }\n    /**\n     * Ignore polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePolygons(options) {\n        this.addItems(this.m_polygonsToIgnore, options);\n    }\n    /**\n     * Add all the specified strings as \"enabledKinds\".\n     *\n     * @param {string[]} enabledKinds List of kinds that should be generated.\n     */\n    processKinds(enabledKinds) {\n        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);\n    }\n    /**\n     * Add all the specified strings as \"disabledKinds\".\n     *\n     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.\n     */\n    ignoreKinds(disabledKinds) {\n        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);\n    }\n    /**\n     * Create a filter description that can be passed as an option to the [[OmvDataSource]].\n     */\n    createDescription() {\n        return {\n            processLayersDefault: this.m_processLayersDefault,\n            processPointsDefault: this.m_processPointsDefault,\n            processLinesDefault: this.m_processLinesDefault,\n            processPolygonsDefault: this.m_processPolygonsDefault,\n            layersToProcess: this.m_layersToProcess,\n            layersToIgnore: this.m_layersToIgnore,\n            pointsToProcess: this.m_pointsToProcess,\n            pointsToIgnore: this.m_ignoredPoints,\n            linesToProcess: this.m_linesToProcess,\n            linesToIgnore: this.m_linesToIgnore,\n            polygonsToProcess: this.m_polygonsToProcess,\n            polygonsToIgnore: this.m_polygonsToIgnore,\n            kindsToProcess: this.m_kindsToProcess,\n            kindsToIgnore: this.m_kindsToIgnore\n        };\n    }\n    addItem(items, options) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n        const item = {\n            layerName: {\n                value: options.layer,\n                match: options.matchLayer === undefined\n                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                    : options.matchLayer\n            },\n            geometryTypes: options.geomType !== undefined\n                ? Array.isArray(options.geomType)\n                    ? options.geomType\n                    : [options.geomType]\n                : undefined,\n            classes: [\n                {\n                    value: options.featureClass,\n                    match: options.matchClass === undefined\n                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                        : options.matchClass\n                }\n            ],\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n        items.push(item);\n    }\n    addItems(items, options) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n        const item = {\n            layerName: {\n                value: options.layer,\n                match: options.matchLayer === undefined\n                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                    : options.matchLayer\n            },\n            geometryTypes: options.geomTypes !== undefined\n                ? Array.isArray(options.geomTypes)\n                    ? options.geomTypes\n                    : [options.geomTypes]\n                : undefined,\n            classes: options.featureClasses,\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n        items.push(item);\n    }\n}\nexports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;\n/**\n * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`\n * features before they are completely decoded.\n *\n * @internal\n */\nclass OmvGenericFeatureFilter {\n    constructor(description) {\n        this.description = description;\n        if (this.description.kindsToProcess.length > 0) {\n            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToProcess);\n        }\n        if (this.description.kindsToIgnore.length > 0) {\n            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToIgnore);\n        }\n    }\n    static matchLayer(layer, layerItems, level) {\n        for (const layerItem of layerItems) {\n            if (level < layerItem.minLevel || level > layerItem.maxLevel) {\n                continue;\n            }\n            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    wantsLayer(layer, level) {\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {\n            return true;\n        }\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {\n            return false;\n        }\n        return this.description.processLayersDefault;\n    }\n    wantsPointFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);\n    }\n    wantsLineFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);\n    }\n    wantsPolygonFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);\n    }\n    wantsKind(kind) {\n        // undefined -> no way to filter\n        if (kind === undefined) {\n            return true;\n        }\n        return (!(this.disabledKinds !== undefined &&\n            this.disabledKinds.hasOrIntersects(kind)) ||\n            (this.enabledKinds !== undefined &&\n                this.enabledKinds.hasOrIntersects(kind)));\n    }\n    get hasKindFilter() {\n        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;\n    }\n    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {\n        for (const item of itemsToProcess) {\n            if (level < item.minLevel || level > item.maxLevel) {\n                continue;\n            }\n            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {\n                return true;\n            }\n        }\n        for (const item of itemsToIgnore) {\n            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {\n                return false;\n            }\n        }\n        return defaultResult;\n    }\n}\nexports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;\n/**\n * An [[OmvFeatureFilter]] implementation that delegates all filter decision\n * returning `true` for any predicate if all delegates return `true`.\n *\n * @internal\n */\nclass ComposedDataFilter {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    get hasKindFilter() {\n        return this.filters.reduce((result, filter) => result && filter.hasKindFilter, true);\n    }\n    wantsLayer(layer, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsLayer(layer, level), true);\n    }\n    wantsPointFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsPointFeature(layer, geometryType, level), true);\n    }\n    wantsLineFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsLineFeature(layer, geometryType, level), true);\n    }\n    wantsPolygonFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level), true);\n    }\n    wantsKind(kind) {\n        return this.filters.reduce((result, filter) => result && filter.wantsKind(kind), true);\n    }\n}\nexports.ComposedDataFilter = ComposedDataFilter;\n/**\n * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter\n * `TileData` features before they are completely decoded.\n *\n * @internal\n */\nclass OmvGenericFeatureModifier {\n    constructor(description) {\n        this.description = description;\n    }\n    static matchItems(layerName, featureClass, items) {\n        for (const item of items) {\n            if (item.classes !== undefined) {\n                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {\n                    continue;\n                }\n                for (const matchClass of item.classes) {\n                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    static matchAttribute(layerName, env, items) {\n        for (const item of items) {\n            if (item.featureAttribute !== undefined) {\n                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&\n                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    doProcessPointFeature(layer, env) {\n        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);\n    }\n    doProcessLineFeature(layer, env) {\n        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);\n    }\n    doProcessPolygonFeature(layer, env) {\n        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);\n    }\n    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {\n        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {\n            return defaultResult;\n        }\n        let featureClass;\n        const featureClassThing = env.lookup(\"class\");\n        if (featureClassThing !== undefined && featureClassThing !== null) {\n            featureClass = featureClassThing.toString();\n        }\n        if (featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {\n            return true;\n        }\n        if (featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {\n            return false;\n        }\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {\n            return true;\n        }\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {\n            return false;\n        }\n        return defaultResult;\n    }\n}\nexports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;\n//# sourceMappingURL=OmvDataFilter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GEOJSON_TILER_SERVICE_TYPE = exports.VECTOR_TILE_DECODER_SERVICE_TYPE = exports.OmvGeometryType = exports.OmvFilterString = exports.FeatureModifierId = void 0;\n/**\n * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.\n */\nvar FeatureModifierId;\n(function (FeatureModifierId) {\n    /**\n     * Generic feature modifier used when no other modifiers are defined.\n     *\n     * @note You do not need to specify it in [[OmvDataSourceParameters]] as it is added by default\n     * if no other feature modifier is used.\n     */\n    FeatureModifierId[FeatureModifierId[\"default\"] = 0] = \"default\";\n})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));\n/**\n * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.\n */\nvar OmvFilterString;\n(function (OmvFilterString) {\n    /**\n     * Match condition.\n     */\n    let StringMatch;\n    (function (StringMatch) {\n        /** Matches any. */\n        StringMatch[StringMatch[\"Any\"] = 0] = \"Any\";\n        /** Exact match. */\n        StringMatch[StringMatch[\"Match\"] = 1] = \"Match\";\n        /** Matches if a test string starts with a filter string. */\n        StringMatch[StringMatch[\"StartsWith\"] = 2] = \"StartsWith\";\n        /** Matches if a test string contains a filter string. */\n        StringMatch[StringMatch[\"Contains\"] = 3] = \"Contains\";\n        /** Matches if a test string ends with a filter string. */\n        StringMatch[StringMatch[\"EndsWith\"] = 4] = \"EndsWith\";\n    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));\n    /**\n     * Check for a string against a filter.\n     *\n     * @param str - The string to check against a filter.\n     * @param filterString - The filter containing the match condition.\n     * @returns `true` if the match condition is satisfied.\n     *\n     * @internal\n     */\n    function matchString(str, filterString) {\n        switch (filterString.match) {\n            case OmvFilterString.StringMatch.Any:\n                return true;\n            case OmvFilterString.StringMatch.Match:\n                return str === filterString.value;\n            case OmvFilterString.StringMatch.StartsWith:\n                return filterString.value.startsWith(str);\n            case OmvFilterString.StringMatch.EndsWith:\n                return filterString.value.endsWith(str);\n            default:\n                return str.includes(filterString.value);\n        }\n    }\n    OmvFilterString.matchString = matchString;\n})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));\nvar OmvGeometryType;\n(function (OmvGeometryType) {\n    OmvGeometryType[OmvGeometryType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    OmvGeometryType[OmvGeometryType[\"POINT\"] = 1] = \"POINT\";\n    OmvGeometryType[OmvGeometryType[\"LINESTRING\"] = 2] = \"LINESTRING\";\n    OmvGeometryType[OmvGeometryType[\"POLYGON\"] = 3] = \"POLYGON\";\n})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));\n/**\n * Vector tile decoder service type id.\n *\n * @remarks\n * Used for requesting decoder services using `WorkerServiceManager`.\n *\n * @internal\n */\nexports.VECTOR_TILE_DECODER_SERVICE_TYPE = \"vector-tile-decoder\";\n/**\n * GeoJson tiler service type id.\n *\n * @remarks\n * Used for requesting tiler services using `WorkerServiceManager`.\n *\n * @internal\n */\nexports.GEOJSON_TILER_SERVICE_TYPE = \"geojson-tiler\";\n//# sourceMappingURL=OmvDecoderDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvPoliticalViewFeatureModifier.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvPoliticalViewFeatureModifier.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvPoliticalViewFeatureModifier = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"OmvPoliticalViewFeatureModifier\");\n/**\n * Modifies the MapEnv of the Vector Tiles in Tilezen format with different POV.\n *\n * This feature modifier updates feature properties according to different political\n * point of view.\n * Political views (or alternate point of views) are supported in Tilezen by adding\n * country posix (lower-case ISO 3166-1 alpha-2 compliant) to __default__ property name.\n * For example country borders (__boundaries__ layer) may have both __kind__ property for\n * default (commonly accepted point of view) and __kind:xx__ for alternate points of view.\n * This way disputed borders may be visible or not for certain regions and different\n * users (clients).\n *\n * @hidden\n */\nclass OmvPoliticalViewFeatureModifier {\n    /**\n     * C-tor.\n     *\n     * @param pov - The code of the country (in lower-case ISO 3166-1 alpha-2 format) which\n     * point of view should be taken into account.\n     */\n    constructor(pov) {\n        this.m_countryCode = pov;\n    }\n    /**\n     * Simply passes all points to rendering, points features does not support PoliticalView.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of point feature.\n     * @param level - Level of tile.\n     * @returns always `true` to pass feature.\n     */\n    doProcessPointFeature(layer, env, level) {\n        return true;\n    }\n    /**\n     * Implements line features processing changing \"kind\" attribute depending on point of view.\n     *\n     * Currently only line features support different point of view.\n     * @param layer - The name of the layer.\n     * @param env - The environment to use.\n     * @returns always `true` to pass lines for rendering.\n     */\n    doProcessLineFeature(layer, env, level) {\n        this.rewriteEnvironment(layer, env);\n        return true;\n    }\n    /**\n     * Simply pass all polygons to rendering, this feature does not support PoliticalView yet.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of polygon feature.\n     * @param level - Level of tile.\n     * @returns `true` to pass feature.\n     */\n    doProcessPolygonFeature(layer, env, level) {\n        return true;\n    }\n    /**\n     * Rewrites the Environment to match the different points of view.\n     *\n     * @param layer - The layer name.\n     * @param env - The environment to use.\n     */\n    rewriteEnvironment(layer, env) {\n        // For now we need to rewrite \"boundaries\" layer only.\n        if (this.isPoliticalViewLayer(layer)) {\n            this.updateEnvironment(env, this.m_countryCode, \"kind\");\n        }\n    }\n    updateEnvironment(env, countryCode, propName) {\n        const value = this.getAlternativePov(env, countryCode, propName);\n        if (value !== undefined) {\n            env.entries[propName] = value;\n        }\n    }\n    getAlternativePov(env, countryCode, propName) {\n        logger.log(\"Get alternate POV: \", JSON.stringify(env));\n        const cc = countryCode;\n        const value = env.lookup(`${propName}:${cc}`);\n        logger.log(\"Lookup POV: \", `${propName}:${cc}`, value);\n        if (typeof value === \"string\" && value.length > 0) {\n            logger.log(\"Found POV: \", `${propName}:${cc}`, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    isPoliticalViewLayer(layer) {\n        return layer === \"boundaries\";\n    }\n}\nexports.OmvPoliticalViewFeatureModifier = OmvPoliticalViewFeatureModifier;\n//# sourceMappingURL=OmvPoliticalViewFeatureModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvPoliticalViewFeatureModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webMercatorTile2TargetTile = exports.webMercatorTile2TargetWorld = exports.world2tile = exports.tile2world = exports.createWorldTileTransformationCookie = exports.tile2lat = exports.lat2tile = exports.isArrayBufferLike = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\n/**\n * @hidden\n */\nfunction isArrayBufferLike(data) {\n    if (typeof SharedArrayBuffer !== \"undefined\") {\n        return data instanceof ArrayBuffer || data instanceof SharedArrayBuffer;\n    }\n    else {\n        return data instanceof ArrayBuffer;\n    }\n}\nexports.isArrayBufferLike = isArrayBufferLike;\n/**\n * @hidden\n */\nfunction lat2tile(lat, zoom) {\n    return Math.round(((1 -\n        Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) /\n            Math.PI) /\n        2) *\n        Math.pow(2, zoom));\n}\nexports.lat2tile = lat2tile;\n/**\n * @hidden\n */\nfunction tile2lat(y, level) {\n    const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, level);\n    return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n}\nexports.tile2lat = tile2lat;\nfunction createWorldTileTransformationCookie(extents, decodeInfo) {\n    const { north, west } = decodeInfo.geoBox;\n    const N = Math.log2(extents);\n    const scale = Math.pow(2, decodeInfo.tileKey.level + N);\n    return {\n        extents,\n        scale,\n        top: lat2tile(north, decodeInfo.tileKey.level + N),\n        left: Math.round(((west + 180) / 360) * scale)\n    };\n}\nexports.createWorldTileTransformationCookie = createWorldTileTransformationCookie;\n/**\n * @hidden\n */\nfunction tile2world(extents, decodeInfo, position, flipY = false, target) {\n    if (decodeInfo.worldTileProjectionCookie === undefined ||\n        decodeInfo.worldTileProjectionCookie.extents !== extents) {\n        decodeInfo.worldTileProjectionCookie = createWorldTileTransformationCookie(extents, decodeInfo);\n    }\n    const { top, left, scale } = decodeInfo.worldTileProjectionCookie;\n    const R = harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE;\n    target.x = ((left + position.x) / scale) * R;\n    target.y = ((top + (flipY ? -position.y : position.y)) / scale) * R;\n    target.z = harp_geoutils_1.isVector3Like(position) ? position.z : 0;\n    return target;\n}\nexports.tile2world = tile2world;\n/**\n * @hidden\n */\nfunction world2tile(extents, decodeInfo, position, flipY = false, target) {\n    if (decodeInfo.worldTileProjectionCookie === undefined ||\n        decodeInfo.worldTileProjectionCookie.extents !== extents) {\n        decodeInfo.worldTileProjectionCookie = createWorldTileTransformationCookie(extents, decodeInfo);\n    }\n    const { top, left, scale } = decodeInfo.worldTileProjectionCookie;\n    const R = harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE;\n    target.x = (position.x / R) * scale - left;\n    target.y = (flipY ? -1 : 1) * ((position.y / R) * scale - top);\n    if (harp_geoutils_1.isVector3Like(target)) {\n        target.z = position.z;\n    }\n    return target;\n}\nexports.world2tile = world2tile;\nfunction webMercatorTile2TargetWorld(extents, decodeInfo, position, target, flipY = false) {\n    tile2world(extents, decodeInfo, position, flipY, target);\n    decodeInfo.targetProjection.reprojectPoint(harp_geoutils_1.webMercatorProjection, target, target);\n}\nexports.webMercatorTile2TargetWorld = webMercatorTile2TargetWorld;\nfunction webMercatorTile2TargetTile(extents, decodeInfo, position, target, flipY = false) {\n    webMercatorTile2TargetWorld(extents, decodeInfo, position, target, flipY);\n    target.sub(decodeInfo.center);\n}\nexports.webMercatorTile2TargetTile = webMercatorTile2TargetTile;\n//# sourceMappingURL=OmvUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/Ring.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/Ring.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Ring = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\n/**\n * A class representing a ring of a polygon geometry.\n */\nclass Ring {\n    /**\n     * Creates a new `Ring`.\n     *\n     * @param points The coordinates of the rings.\n     * @param textureCoords The optional `Array` of texture coordinates.\n     * @param extents The extents of the tile bounds.\n     * @param hasClipInfo A flag indicating that vertices of this `Ring` may be clipped.\n     */\n    constructor(points, textureCoords, extents = 4 * 1024, hasClipInfo = false) {\n        this.points = points;\n        this.textureCoords = textureCoords;\n        this.extents = extents;\n        this.hasClipInfo = hasClipInfo;\n        if (textureCoords !== undefined && textureCoords.length !== points.length) {\n            throw new Error(`the array of texture coordinates must have the same number of elements of the array of points`);\n        }\n        this.vertexStride = 2;\n        if (textureCoords !== undefined) {\n            this.vertexStride = this.vertexStride + 2;\n        }\n        this.area = three_1.ShapeUtils.area(this.points);\n        this.winding = this.area < 0;\n    }\n    /**\n     * Returns a flattened `Array` containing the position and texture coordinates of this `Ring`.\n     *\n     * @param array The target `Array`.\n     * @param offset Optional offset into the array.\n     */\n    toArray(array = [], offset = 0) {\n        var _a;\n        this.points.forEach((p, i) => p.toArray(array, offset + this.vertexStride * i));\n        (_a = this.textureCoords) === null || _a === void 0 ? void 0 : _a.forEach((p, i) => p.toArray(array, offset + this.vertexStride * i + 2));\n        return array;\n    }\n    /**\n     * Tests if the edge connecting the vertex at `index` with\n     * the vertex at `index+1` should be connected by a line\n     * when stroking the polygon.\n     *\n     * @param index The index of the first vertex of the outline edge.\n     */\n    isProperEdge(index) {\n        const extents = this.extents;\n        const nextIdx = (index + 1) % this.points.length;\n        const curr = this.points[index];\n        const next = this.points[nextIdx];\n        if (this.hasClipInfo) {\n            if (curr.x !== next.x && curr.y !== next.y) {\n                // `curr` and `next` must be connected with a line\n                // because they don't form a vertical or horizontal lines.\n                return true;\n            }\n            const currAtEdge = curr.x % this.extents === 0 || curr.y % this.extents === 0;\n            if (!currAtEdge) {\n                // the points are connected with a line\n                // because at least one of the points is not on\n                // the tile boundary.\n                return true;\n            }\n            const nextAtEdge = next.x % this.extents === 0 || next.y % this.extents === 0;\n            if (!nextAtEdge) {\n                // the points are connected with a line\n                // because at least one of the points is not on\n                // the tile boundary.\n                return true;\n            }\n            const currWasClipped = curr.isClipped === true;\n            const nextWasClipped = next.isClipped === true;\n            return !currWasClipped && !nextWasClipped;\n        }\n        return !((curr.x <= 0 && next.x <= 0) ||\n            (curr.x >= extents && next.x >= extents) ||\n            (curr.y <= 0 && next.y <= 0) ||\n            (curr.y >= extents && next.y >= extents));\n    }\n}\nexports.Ring = Ring;\n//# sourceMappingURL=Ring.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/Ring.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/StyleSetDataFilter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/StyleSetDataFilter.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StyleSetDataFilter = void 0;\n/**\n * An [[OmvFeatureFilter]] implementation that queries [[StyleSetEvaluator]]\n * if given layers/features should be processed.\n *\n * Used in [[OmvDecoder]] to skip processing of layers/features that doesn't\n * have associated rules in style.\n *\n * @see [[StyleSetEvaluator.wantsFeature]]\n * @see [[StyleSetEvaluator.wantsLayer]]\n */\nclass StyleSetDataFilter {\n    constructor(styleSetEvaluator) {\n        this.styleSetEvaluator = styleSetEvaluator;\n        this.hasKindFilter = false;\n    }\n    wantsLayer(layer, level) {\n        return this.styleSetEvaluator.wantsLayer(layer);\n    }\n    wantsPointFeature(layer) {\n        return this.styleSetEvaluator.wantsFeature(layer, \"point\");\n    }\n    wantsLineFeature(layer) {\n        return this.styleSetEvaluator.wantsFeature(layer, \"line\");\n    }\n    wantsPolygonFeature(layer) {\n        return this.styleSetEvaluator.wantsFeature(layer, \"polygon\");\n    }\n    wantsKind() {\n        return true;\n    }\n}\nexports.StyleSetDataFilter = StyleSetDataFilter;\n//# sourceMappingURL=StyleSetDataFilter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/StyleSetDataFilter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataEmitter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataEmitter.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorTileDataEmitter = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst TechniqueAttr_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/TechniqueAttr */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js\");\nconst ClipPolygon_1 = __webpack_require__(/*! @here/harp-geometry/lib/ClipPolygon */ \"./node_modules/@here/harp-geometry/lib/ClipPolygon.js\");\nconst EdgeLengthGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js\");\nconst SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst Lines_1 = __webpack_require__(/*! @here/harp-lines/lib/Lines */ \"./node_modules/@here/harp-lines/lib/Lines.js\");\nconst TriangulateLines_1 = __webpack_require__(/*! @here/harp-lines/lib/TriangulateLines */ \"./node_modules/@here/harp-lines/lib/TriangulateLines.js\");\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! @here/harp-materials/lib/MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst earcut_1 = __webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst OmvUtils_1 = __webpack_require__(/*! ./OmvUtils */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js\");\nconst Ring_1 = __webpack_require__(/*! ./Ring */ \"./node_modules/@here/harp-vectortile-datasource/lib/Ring.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"OmvDecodedTileEmitter\");\nconst tempTileOrigin = new THREE.Vector3();\nconst tempVertOrigin = new THREE.Vector3();\nconst tempVertNormal = new THREE.Vector3();\nconst tempFootDisp = new THREE.Vector3();\nconst tempRoofDisp = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector2();\nconst tmpV2r = new THREE.Vector2();\nconst tmpV3 = new THREE.Vector3();\nconst tmpV3r = new THREE.Vector3();\nconst tmpV4 = new THREE.Vector3();\nconst tempP0 = new THREE.Vector2();\nconst tempP1 = new THREE.Vector2();\nconst tempPreviousTangent = new THREE.Vector2();\nconst tmpPointA = new THREE.Vector3();\nconst tmpPointB = new THREE.Vector3();\nconst tmpPointC = new THREE.Vector3();\nconst tmpPointD = new THREE.Vector3();\nconst tmpPointE = new THREE.Vector3();\nconst tmpLine = new THREE.Line3();\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text. Based on the estimated screen size of a tile.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n/**\n * Estimation \"fudge factor\", tweaking the size estimation to\n *\n * a) allow room for zooming in to the tile, and\n *\n * b) allow for some tilting, where the edge of a tile closer to the camera has more space.\n *\n * Useful values are between 0 (allow all labels), 0.5 (allow labels at twice the default display\n * size of the tile) and 1.0 (skip labels that would normally not be displayed at default tile\n * size).\n */\nconst SIZE_ESTIMATION_FACTOR = 0.5;\n/**\n * Maximum allowed corner angle inside a label path.\n */\nconst MAX_CORNER_ANGLE = Math.PI / 8;\n/**\n * Used to identify an invalid (or better: unused) array index.\n */\nconst INVALID_ARRAY_INDEX = -1;\nfunction createIndexBufferAttribute(elements, maxValue, name = \"index\") {\n    const type = maxValue > 65535 ? \"uint32\" : \"uint16\";\n    const storage = type === \"uint32\" ? new Uint32Array(elements) : new Uint16Array(elements);\n    const buffer = storage.buffer;\n    return {\n        itemCount: 1,\n        name,\n        buffer,\n        type\n    };\n}\n// for tilezen by default extrude all buildings even those without height data\nclass MeshBuffers {\n    constructor(type) {\n        this.type = type;\n        this.positions = [];\n        this.normals = [];\n        this.textureCoordinates = [];\n        this.colors = [];\n        this.extrusionAxis = [];\n        this.indices = [];\n        this.edgeIndices = [];\n        this.groups = [];\n        this.texts = [];\n        this.pathLengths = [];\n        this.stringCatalog = [];\n        this.imageTextures = [];\n        /**\n         * Optional list of feature start indices. The indices point into the index attribute.\n         */\n        this.featureStarts = [];\n        /**\n         * Optional list of edge feature start indices. The indices point into the edge index attribute.\n         */\n        this.edgeFeatureStarts = [];\n        /**\n         * An optional list of additional data that can be used as additional data for the object\n         * picking.\n         */\n        this.objInfos = [];\n        /**\n         * Angle in degrees from north clockwise which represents the direction the icons can be\n         * shifted.\n         */\n        this.offsetDirections = [];\n    }\n    addText(text) {\n        let index = this.stringCatalog.indexOf(text);\n        if (index < 0) {\n            index = this.stringCatalog.length;\n            this.stringCatalog.push(text);\n        }\n        return index;\n    }\n}\nvar LineType;\n(function (LineType) {\n    LineType[LineType[\"Simple\"] = 0] = \"Simple\";\n    LineType[LineType[\"Complex\"] = 1] = \"Complex\";\n})(LineType || (LineType = {}));\nconst tmpColor = new THREE.Color();\nclass VectorTileDataEmitter {\n    constructor(m_decodeInfo, m_styleSetEvaluator, m_gatherFeatureAttributes, m_skipShortLabels, m_enableElevationOverlay, m_languages) {\n        this.m_decodeInfo = m_decodeInfo;\n        this.m_styleSetEvaluator = m_styleSetEvaluator;\n        this.m_gatherFeatureAttributes = m_gatherFeatureAttributes;\n        this.m_skipShortLabels = m_skipShortLabels;\n        this.m_enableElevationOverlay = m_enableElevationOverlay;\n        this.m_languages = m_languages;\n        // mapping from style index to mesh buffers\n        this.m_meshBuffers = new Map();\n        this.m_geometries = [];\n        this.m_textGeometries = [];\n        this.m_textPathGeometries = [];\n        this.m_pathGeometries = [];\n        this.m_poiGeometries = [];\n        this.m_simpleLines = [];\n        this.m_solidLines = [];\n        this.m_sources = [];\n        this.m_maxGeometryHeight = 0;\n        this.m_minGeometryHeight = 0;\n    }\n    get projection() {\n        return this.m_decodeInfo.targetProjection;\n    }\n    get center() {\n        return this.m_decodeInfo.center;\n    }\n    /**\n     * Creates the Point of Interest geometries for the given feature.\n     *\n     * @param layer - Tile's layer to be processed.\n     * @param extents - Tile's layer extents.\n     * @param geometry - The feature geometry in local webMercator coordinates.\n     * @param env - The [[MapEnv]] containing the environment information for the map.\n     * @param techniques - The array of [[Technique]] that will be applied to the geometry.\n     */\n    processPointFeature(layer, extents, geometry, context, techniques) {\n        var _a;\n        const env = context.env;\n        this.processFeatureCommon(env);\n        const { tileKey, columnCount, rowCount } = this.m_decodeInfo;\n        // adjust the extents to ensure that points on the right and bottom edges\n        // of the tile are discarded.\n        const xextent = tileKey.column + 1 < columnCount ? extents - 1 : extents;\n        const yextent = tileKey.row + 1 < rowCount ? extents - 1 : extents;\n        // get the point positions (in tile space) that are inside the tile bounds.\n        const tilePositions = geometry.filter(p => {\n            return p.x >= 0 && p.x <= xextent && p.y >= 0 && p.y <= yextent;\n        });\n        if (tilePositions.length === 0) {\n            // nothing to do, no geometry within the tile bound.\n            return;\n        }\n        for (const technique of techniques) {\n            if (technique === undefined) {\n                continue;\n            }\n            const techniqueIndex = technique._index;\n            const meshBuffers = this.findOrCreateMeshBuffers(techniqueIndex, harp_datasource_protocol_1.GeometryType.Point);\n            if (meshBuffers === undefined) {\n                continue;\n            }\n            const { positions, texts, imageTextures, objInfos, offsetDirections } = meshBuffers;\n            const shouldCreateTextGeometries = harp_datasource_protocol_1.isTextTechnique(technique) || harp_datasource_protocol_1.isPoiTechnique(technique);\n            let imageTexture;\n            const wantsPoi = harp_datasource_protocol_1.isPoiTechnique(technique);\n            if (wantsPoi) {\n                const poiTechnique = technique;\n                imageTexture = TechniqueAttr_1.evaluateTechniqueAttr(context, poiTechnique.imageTexture);\n                // TODO: Move to decoder independent parts of code.\n                if (poiTechnique.poiName !== undefined) {\n                    imageTexture = TechniqueAttr_1.evaluateTechniqueAttr(context, poiTechnique.poiName);\n                }\n                else if (typeof poiTechnique.poiNameField === \"string\") {\n                    const poiNameFieldValue = env.lookup(poiTechnique.poiNameField);\n                    imageTexture = poiNameFieldValue;\n                }\n                else if (typeof poiTechnique.imageTextureField === \"string\") {\n                    const imageTextureValue = env.lookup(poiTechnique.imageTextureField);\n                    imageTexture = harp_datasource_protocol_1.composeTechniqueTextureName(imageTextureValue, poiTechnique);\n                }\n            }\n            const featureId = harp_datasource_protocol_1.getFeatureId(env.entries);\n            for (const pos of tilePositions) {\n                if (shouldCreateTextGeometries) {\n                    const textTechnique = technique;\n                    const text = harp_datasource_protocol_1.getFeatureText(context, textTechnique, this.m_languages);\n                    if (text !== undefined && text.length > 0) {\n                        texts.push(meshBuffers.addText(text));\n                    }\n                    else {\n                        texts.push(INVALID_ARRAY_INDEX);\n                    }\n                }\n                // Always store the position, otherwise the following POIs will be\n                // misplaced.\n                if (shouldCreateTextGeometries) {\n                    OmvUtils_1.webMercatorTile2TargetWorld(extents, this.m_decodeInfo, pos, tmpV3);\n                }\n                else {\n                    OmvUtils_1.webMercatorTile2TargetTile(extents, this.m_decodeInfo, pos, tmpV3);\n                }\n                positions.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                objInfos.push(this.m_gatherFeatureAttributes ? env.entries : featureId);\n                offsetDirections.push((_a = env.lookup(\"offset_direction\")) !== null && _a !== void 0 ? _a : 0);\n                if (wantsPoi) {\n                    if (imageTexture === undefined) {\n                        imageTextures.push(INVALID_ARRAY_INDEX);\n                    }\n                    else {\n                        imageTextures.push(meshBuffers.addText(imageTexture));\n                    }\n                }\n            }\n        }\n    }\n    /**\n     *\n     * Creates the line geometries for the given feature.\n     *\n     * @param layer - Tile's layer to be processed.\n     * @param extents - Tile's layer extents.\n     * @param geometry - The current feature containing the main geometry.\n     * @param env - The [[MapEnv]] containing the environment information for the map.\n     * @param techniques - The array of [[Technique]] that will be applied to the geometry.\n     * @param featureId - The id of the feature.\n     */\n    processLineFeature(layer, extents, geometry, context, techniques, featureId) {\n        const env = context.env;\n        this.processFeatureCommon(env);\n        const localLines = []; // lines in target tile space.\n        const worldLines = []; // lines in world space.\n        const uvs = [];\n        const offsets = [];\n        const projectedBoundingBox = this.m_decodeInfo.projectedBoundingBox;\n        let localLineSegments; // lines in target tile space for special dashes.\n        const tileWidth = projectedBoundingBox.extents.x * 2;\n        const tileHeight = projectedBoundingBox.extents.y * 2;\n        const tileSizeWorld = Math.max(tileWidth, tileHeight);\n        let computeTexCoords;\n        let texCoordinateType;\n        const hasUntiledLines = geometry[0].untiledPositions !== undefined;\n        // If true, special handling for dashes is required (round and diamond shaped dashes).\n        let hasIndividualLineSegments = false;\n        let hasContinuousLineSegments = false;\n        // Check if any of the techniques needs texture coordinates\n        for (const technique of techniques) {\n            if (technique === undefined) {\n                continue;\n            }\n            if (!computeTexCoords) {\n                computeTexCoords = this.getComputeTexCoordsFunc(technique);\n                texCoordinateType = this.getTextureCoordinateType(technique);\n            }\n            else {\n                // Support generation of only one type of texture coordinates.\n                const otherTexCoordType = this.getTextureCoordinateType(technique);\n                harp_utils_1.assert(otherTexCoordType === undefined || texCoordinateType === otherTexCoordType);\n            }\n            hasIndividualLineSegments =\n                hasIndividualLineSegments || harp_datasource_protocol_1.isSpecialDashesLineTechnique(technique);\n            hasContinuousLineSegments = hasContinuousLineSegments || !hasIndividualLineSegments;\n        }\n        for (const polyline of geometry) {\n            // Compute the world position of the untiled line and its distance to the origin of the\n            // line to properly join lines.\n            const untiledLine = [];\n            let lineDist = 0;\n            if (hasUntiledLines) {\n                this.m_decodeInfo.targetProjection.projectPoint(polyline.untiledPositions[0], tmpV3r);\n                polyline.untiledPositions.forEach(pos => {\n                    // Calculate the distance to the next un-normalized point.\n                    this.m_decodeInfo.targetProjection.projectPoint(pos, tmpV3);\n                    lineDist += tmpV3.distanceTo(tmpV3r);\n                    tmpV3r.copy(tmpV3);\n                    // Pushed the normalized point for line matching.\n                    this.m_decodeInfo.targetProjection.projectPoint(pos.normalized(), tmpV3);\n                    untiledLine.push(tmpV3.x, tmpV3.y, tmpV3.z, lineDist);\n                });\n            }\n            // Add continuous line as individual segments to improve special dashes by overlapping\n            // their connecting vertices. The technique/style should defined round or rectangular\n            // caps.\n            if (hasIndividualLineSegments) {\n                localLineSegments = [];\n                // Compute length of whole line and offsets of individual segments.\n                let lineLength = 0;\n                const pointCount = polyline.positions.length;\n                if (pointCount > 1) {\n                    let lastSegmentOffset = 0;\n                    for (let i = 0; i < pointCount - 1; i++) {\n                        const localLine = [];\n                        const worldLine = [];\n                        const lineUvs = [];\n                        const segmentOffsets = [];\n                        const pos1 = polyline.positions[i];\n                        const pos2 = polyline.positions[i + 1];\n                        OmvUtils_1.webMercatorTile2TargetWorld(extents, this.m_decodeInfo, pos1, tmpV3);\n                        worldLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                        OmvUtils_1.webMercatorTile2TargetWorld(extents, this.m_decodeInfo, pos2, tmpV4);\n                        worldLine.push(tmpV4.x, tmpV4.y, tmpV4.z);\n                        if (computeTexCoords) {\n                            computeTexCoords(pos1, extents).toArray(lineUvs, lineUvs.length);\n                            computeTexCoords(pos2, extents).toArray(lineUvs, lineUvs.length);\n                        }\n                        if (hasUntiledLines) {\n                            // Find where in the [0...1] range relative to the line our current\n                            // vertex lies.\n                            let offset = this.findRelativePositionInLine(tmpV3, untiledLine) / lineDist;\n                            segmentOffsets.push(offset);\n                            offset = this.findRelativePositionInLine(tmpV4, untiledLine) / lineDist;\n                            segmentOffsets.push(offset);\n                        }\n                        else {\n                            segmentOffsets.push(lastSegmentOffset);\n                            // Compute length of segment and whole line to scale down later.\n                            const segmentLength = tmpV3.distanceTo(tmpV4);\n                            lineLength += segmentLength;\n                            lastSegmentOffset += segmentLength;\n                            segmentOffsets.push(lastSegmentOffset);\n                        }\n                        tmpV3.sub(this.m_decodeInfo.center);\n                        localLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                        tmpV4.sub(this.m_decodeInfo.center);\n                        localLine.push(tmpV4.x, tmpV4.y, tmpV4.z);\n                        localLineSegments.push(localLine);\n                        worldLines.push(worldLine);\n                        uvs.push(lineUvs);\n                        offsets.push(segmentOffsets);\n                    }\n                }\n                if (!hasUntiledLines && lineLength > 0) {\n                    // Scale down each individual segment to range [0..1] for whole line.\n                    for (const segOffsets of offsets) {\n                        segOffsets.forEach((offs, index) => {\n                            segOffsets[index] = offs / lineLength;\n                        });\n                    }\n                }\n            }\n            // Add continuous lines\n            if (hasContinuousLineSegments) {\n                const localLine = [];\n                const worldLine = [];\n                const lineUvs = [];\n                const lineOffsets = [];\n                polyline.positions.forEach(pos => {\n                    OmvUtils_1.webMercatorTile2TargetWorld(extents, this.m_decodeInfo, pos, tmpV3);\n                    worldLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                    if (computeTexCoords) {\n                        computeTexCoords(pos, extents).toArray(lineUvs, lineUvs.length);\n                    }\n                    if (hasUntiledLines) {\n                        // Find where in the [0...1] range relative to the line our current vertex\n                        // lines.\n                        const offset = this.findRelativePositionInLine(tmpV3, untiledLine) / lineDist;\n                        lineOffsets.push(offset);\n                    }\n                    tmpV3.sub(this.m_decodeInfo.center);\n                    localLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                });\n                localLines.push(localLine);\n                worldLines.push(worldLine);\n                uvs.push(lineUvs);\n                offsets.push(lineOffsets);\n            }\n        }\n        const wantCircle = this.m_decodeInfo.tileKey.level >= 11;\n        for (const technique of techniques) {\n            if (technique === undefined) {\n                continue;\n            }\n            const techniqueIndex = technique._index;\n            const techniqueName = technique.name;\n            if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSolidLineTechnique(technique)) {\n                const lineGeometry = harp_datasource_protocol_1.isLineTechnique(technique)\n                    ? this.m_simpleLines\n                    : this.m_solidLines;\n                const lineType = harp_datasource_protocol_1.isLineTechnique(technique) ? LineType.Simple : LineType.Complex;\n                if (hasIndividualLineSegments) {\n                    harp_utils_1.assert(localLineSegments !== undefined, \"OmvDecodedTileEmitter#processLineFeature: \" +\n                        \"Internal error - No localLineSegments\");\n                    this.applyLineTechnique(lineGeometry, technique, techniqueIndex, lineType, env.entries, localLineSegments, context, this.getTextureCoordinateType(technique) ? uvs : undefined, offsets);\n                }\n                if (localLines.length > 0) {\n                    this.applyLineTechnique(lineGeometry, technique, techniqueIndex, lineType, env.entries, localLines, context, this.getTextureCoordinateType(technique) ? uvs : undefined, hasUntiledLines ? offsets : undefined);\n                }\n            }\n            else if (harp_datasource_protocol_1.isTextTechnique(technique) ||\n                harp_datasource_protocol_1.isPoiTechnique(technique) ||\n                harp_datasource_protocol_1.isLineMarkerTechnique(technique)) {\n                const textTechnique = technique;\n                const text = harp_datasource_protocol_1.getFeatureText(context, textTechnique, this.m_languages);\n                if (text === undefined || text.length === 0) {\n                    continue;\n                }\n                let validLines = [];\n                if (this.m_skipShortLabels) {\n                    // Filter the lines, keep only those that are long enough for labelling. Also,\n                    // split jagged label paths to keep processing and rendering only those that\n                    // have no sharp corners, which would not be rendered anyway.\n                    const worldUnitsPerPixel = tileSizeWorld / this.m_decodeInfo.tileSizeOnScreen;\n                    const minEstimatedLabelLength = MIN_AVERAGE_CHAR_WIDTH *\n                        text.length *\n                        worldUnitsPerPixel *\n                        SIZE_ESTIMATION_FACTOR;\n                    const minEstimatedLabelLengthSqr = minEstimatedLabelLength * minEstimatedLabelLength;\n                    validLines = this.splitJaggyLines(worldLines, minEstimatedLabelLengthSqr, MAX_CORNER_ANGLE);\n                }\n                else {\n                    validLines = worldLines;\n                }\n                if (validLines.length === 0) {\n                    continue;\n                }\n                if (harp_datasource_protocol_1.isTextTechnique(technique)) {\n                    if (text === undefined) {\n                        continue;\n                    }\n                    for (const path of validLines) {\n                        const pathLengthSqr = harp_utils_1.Math2D.computeSquaredLineLength(path);\n                        this.m_textPathGeometries.push({\n                            technique: techniqueIndex,\n                            path,\n                            pathLengthSqr,\n                            text: String(text),\n                            objInfos: this.m_gatherFeatureAttributes\n                                ? env.entries\n                                : harp_datasource_protocol_1.getFeatureId(env.entries)\n                        });\n                    }\n                }\n                else {\n                    const lineMarkerTechnique = technique;\n                    let imageTexture = TechniqueAttr_1.evaluateTechniqueAttr(context, lineMarkerTechnique.imageTexture);\n                    // TODO: `imageTextureField` and `imageTexturePrefix` and `imageTexturePostfix`\n                    // are now deprecated\n                    // TODO: Move to decoder independent parts of code.\n                    if (typeof lineMarkerTechnique.imageTextureField === \"string\") {\n                        const imageTextureValue = env.lookup(lineMarkerTechnique.imageTextureField);\n                        imageTexture = imageTextureValue;\n                        if (typeof lineMarkerTechnique.imageTexturePrefix === \"string\") {\n                            imageTexture = lineMarkerTechnique.imageTexturePrefix + imageTexture;\n                        }\n                        if (typeof lineMarkerTechnique.imageTexturePostfix === \"string\") {\n                            imageTexture = imageTexture + lineMarkerTechnique.imageTexturePostfix;\n                        }\n                    }\n                    for (const aLine of validLines) {\n                        this.m_poiGeometries.push({\n                            technique: techniqueIndex,\n                            positions: {\n                                name: \"position\",\n                                type: \"float\",\n                                buffer: new Float32Array(aLine).buffer,\n                                itemCount: 3\n                            },\n                            texts: [0],\n                            stringCatalog: [text, imageTexture],\n                            imageTextures: [1],\n                            objInfos: this.m_gatherFeatureAttributes\n                                ? [env.entries]\n                                : [harp_datasource_protocol_1.getFeatureId(env.entries)]\n                        });\n                    }\n                }\n            }\n            else if (harp_datasource_protocol_1.isLabelRejectionLineTechnique(technique)) {\n                for (const path of worldLines) {\n                    const worldPath = [];\n                    for (let i = 0; i < path.length; i += 3) {\n                        worldPath.push(new THREE.Vector3().fromArray(path, i));\n                    }\n                    this.m_pathGeometries.push({\n                        path: worldPath\n                    });\n                }\n            }\n            else if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                const meshBuffers = this.findOrCreateMeshBuffers(techniqueIndex, harp_datasource_protocol_1.GeometryType.ExtrudedLine);\n                if (meshBuffers === undefined) {\n                    continue;\n                }\n                const { positions, indices, groups, featureStarts, objInfos } = meshBuffers;\n                const start = indices.length;\n                const lineWidth = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.lineWidth);\n                if (lineWidth === undefined) {\n                    continue;\n                }\n                const techniqueCaps = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.caps, \"Circle\");\n                const addCircle = wantCircle && techniqueCaps === \"Circle\";\n                localLines.forEach(aLine => {\n                    TriangulateLines_1.triangulateLine(aLine, lineWidth, positions, indices, addCircle);\n                    featureStarts.push(start);\n                    objInfos.push(this.m_gatherFeatureAttributes ? env.entries : harp_datasource_protocol_1.getFeatureId(env.entries));\n                });\n                const count = indices.length - start;\n                groups.push({ start, count, technique: techniqueIndex });\n            }\n            else {\n                logger.warn(`OmvDecodedTileEmitter#processLineFeature: Invalid line technique\n                     ${techniqueName} for layer: ${env.entries.$layer} `);\n            }\n        }\n    }\n    /**\n     * Creates the polygons geometries for the given feature.\n     *\n     * @param layer - Tile's layer to be processed.\n     * @param extents - Tile's layer extents.\n     * @param geometry - The current feature containing the main geometry.\n     * @param feature - The [[MapEnv]] containing the environment information for the map.\n     * @param techniques - The array of [[Technique]] that will be applied to the geometry.\n     * @param featureId - The id of the feature.\n     */\n    processPolygonFeature(layer, extents, geometry, context, techniques, featureId) {\n        const env = context.env;\n        this.processFeatureCommon(env);\n        techniques.forEach(technique => {\n            if (technique === undefined) {\n                return;\n            }\n            const techniqueIndex = technique._index;\n            if (techniqueIndex === undefined) {\n                throw new Error(\"OmvDecodedTileEmitter#processPolygonFeature: \" +\n                    \"Internal error - No technique index\");\n            }\n            let objectBounds;\n            const bbox = env.lookup(\"bbox\");\n            if (Array.isArray(bbox)) {\n                const [west, south, east, north] = bbox;\n                const geoBox = new harp_geoutils_1.GeoBox(new harp_geoutils_1.GeoCoordinates(south, west), new harp_geoutils_1.GeoCoordinates(north, east));\n                objectBounds = new THREE.Box3();\n                harp_geoutils_1.webMercatorProjection.projectBox(geoBox, objectBounds);\n            }\n            const polygons = [];\n            const isExtruded = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique);\n            const isFilled = harp_datasource_protocol_1.isFillTechnique(technique);\n            const isStandard = harp_datasource_protocol_1.isStandardTechnique(technique);\n            const isPolygon = isExtruded ||\n                isFilled ||\n                isStandard ||\n                (harp_datasource_protocol_1.isShaderTechnique(technique) && technique.primitive === \"mesh\");\n            const computeTexCoords = this.getComputeTexCoordsFunc(technique, objectBounds);\n            const shouldClipPolygons = isPolygon && !isExtruded;\n            for (const polygon of geometry) {\n                const rings = [];\n                for (const outline of polygon.rings) {\n                    let coords = outline;\n                    // disable clipping for the polygon geometries\n                    // rendered using the extruded-polygon technique.\n                    // We can't clip these polygons for now because\n                    // otherwise we could break the current assumptions\n                    // used to add oultines around the extruded geometries.\n                    if (shouldClipPolygons) {\n                        // quick test to avoid clipping if all the coords\n                        // of the current polygon are inside the tile bounds.\n                        const hasCoordsOutsideTileBounds = coords.some(p => p.x < 0 || p.x > extents || p.y < 0 || p.y > extents);\n                        if (hasCoordsOutsideTileBounds) {\n                            coords = ClipPolygon_1.clipPolygon(coords, extents);\n                        }\n                    }\n                    if (coords.length === 0) {\n                        continue;\n                    }\n                    let textureCoords;\n                    if (computeTexCoords !== undefined) {\n                        textureCoords = coords.map(coord => computeTexCoords(coord, extents));\n                    }\n                    rings.push(new Ring_1.Ring(coords, textureCoords, extents, shouldClipPolygons));\n                }\n                if (rings.length === 0) {\n                    continue;\n                }\n                polygons.push(rings);\n            }\n            const isLine = harp_datasource_protocol_1.isSolidLineTechnique(technique) || harp_datasource_protocol_1.isLineTechnique(technique);\n            if (isPolygon) {\n                this.applyPolygonTechnique(polygons, technique, techniqueIndex, featureId, context, extents);\n            }\n            else if (isLine) {\n                const lineGeometry = technique.name === \"line\" ? this.m_simpleLines : this.m_solidLines;\n                const lineType = technique.name === \"line\" ? LineType.Simple : LineType.Complex;\n                // Use individual line segments instead of a continuous line in special cases (round\n                // and diamond shaped dashes).\n                const needIndividualLineSegments = harp_datasource_protocol_1.isSpecialDashesLineTechnique(technique);\n                polygons.forEach(rings => {\n                    const lines = [];\n                    const offsets = needIndividualLineSegments\n                        ? []\n                        : undefined;\n                    rings.forEach(ring => {\n                        const length = ring.points.length;\n                        let line = [];\n                        // Compute length of whole line and offsets of individual segments.\n                        let ringLength = 0;\n                        let lastSegmentOffset = 0;\n                        let segmentOffsets = needIndividualLineSegments\n                            ? []\n                            : undefined;\n                        for (let i = 0; i < length; ++i) {\n                            if (needIndividualLineSegments && line.length > 0) {\n                                // Allocate a line for every segment.\n                                line = [];\n                                segmentOffsets = [];\n                            }\n                            const nextIdx = (i + 1) % length;\n                            const curr = ring.points[i];\n                            const next = ring.points[nextIdx];\n                            const properEdge = ring.isProperEdge(i);\n                            if (!properEdge && line.length !== 0) {\n                                lines.push(line);\n                                line = [];\n                            }\n                            else if (properEdge && line.length === 0) {\n                                OmvUtils_1.webMercatorTile2TargetTile(extents, this.m_decodeInfo, tmpV2.copy(curr), tmpV3);\n                                line.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                                if (needIndividualLineSegments) {\n                                    // Add next point as the end point of this line segment.\n                                    OmvUtils_1.webMercatorTile2TargetTile(extents, this.m_decodeInfo, tmpV2.copy(next), tmpV4);\n                                    line.push(tmpV4.x, tmpV4.y, tmpV4.z);\n                                    segmentOffsets.push(lastSegmentOffset);\n                                    // Compute length of segment and whole line to scale down later.\n                                    const segmentLength = tmpV3.distanceTo(tmpV4);\n                                    ringLength += segmentLength;\n                                    lastSegmentOffset += segmentLength;\n                                    segmentOffsets.push(lastSegmentOffset);\n                                }\n                            }\n                            if (properEdge && !needIndividualLineSegments) {\n                                OmvUtils_1.webMercatorTile2TargetTile(extents, this.m_decodeInfo, tmpV2.copy(next), tmpV3);\n                                line.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                            }\n                            if (needIndividualLineSegments && line.length > 0 && ringLength > 0) {\n                                // Scale down each individual segment to range [0..1] for the whole\n                                // line.\n                                segmentOffsets.forEach((offs, index) => {\n                                    segmentOffsets[index] = offs / ringLength;\n                                });\n                                // Close the line segment as a single line.\n                                lines.push(line);\n                                offsets.push(segmentOffsets);\n                            }\n                        }\n                        if (!needIndividualLineSegments && line.length > 0) {\n                            lines.push(line);\n                        }\n                    });\n                    if (lines.length === 0) {\n                        return;\n                    }\n                    this.applyLineTechnique(lineGeometry, technique, techniqueIndex, lineType, env.entries, lines, context, undefined, offsets);\n                });\n            }\n        });\n    }\n    /**\n     * Creates the geometries that belongs to the [[Tile].\n     *\n     * @returns The [[DecodedTile]]\n     */\n    getDecodedTile() {\n        this.createGeometries();\n        this.processSimpleLines(this.m_simpleLines);\n        this.processLines(this.m_solidLines);\n        const decodedTile = {\n            techniques: this.m_styleSetEvaluator.decodedTechniques,\n            geometries: this.m_geometries,\n            decodeTime: undefined\n        };\n        if (this.m_textGeometries.length > 0) {\n            decodedTile.textGeometries = this.m_textGeometries;\n        }\n        if (this.m_poiGeometries.length > 0) {\n            decodedTile.poiGeometries = this.m_poiGeometries;\n        }\n        if (this.m_textPathGeometries.length > 0) {\n            decodedTile.textPathGeometries = this.m_textPathGeometries;\n        }\n        if (this.m_pathGeometries.length > 0) {\n            decodedTile.pathGeometries = this.m_pathGeometries;\n        }\n        if (this.m_sources.length !== 0) {\n            decodedTile.copyrightHolderIds = this.m_sources;\n        }\n        decodedTile.maxGeometryHeight = this.m_maxGeometryHeight;\n        decodedTile.minGeometryHeight = this.m_minGeometryHeight;\n        return decodedTile;\n    }\n    /**\n     * Split the lines array into multiple parts if there are sharp corners. Reject parts that are\n     * too short to display the label text.\n     *\n     * @param {number[][]} lines Array containing the points of the paths.\n     * @param {number} minEstimatedLabelLengthSqr Minimum label size squared.\n     * @param {number} maxCornerAngle Maximum angle between consecutive path segments in radians.\n     * @returns The split and filtered lines array.\n     */\n    splitJaggyLines(lines, minEstimatedLabelLengthSqr, maxCornerAngle) {\n        const validLines = [];\n        const computeBoundingBoxSizeSqr = (aLine, startIndex, endIndex) => {\n            let minX = Number.MAX_SAFE_INTEGER;\n            let maxX = Number.MIN_SAFE_INTEGER;\n            let minY = Number.MAX_SAFE_INTEGER;\n            let maxY = Number.MIN_SAFE_INTEGER;\n            for (let i = startIndex; i < endIndex; i += 3) {\n                const x = aLine[i];\n                const y = aLine[i + 1];\n                if (x < minX) {\n                    minX = x;\n                }\n                if (x > maxX) {\n                    maxX = x;\n                }\n                if (y < minY) {\n                    minY = y;\n                }\n                if (y > maxY) {\n                    maxY = y;\n                }\n            }\n            return (maxX - minX) * (maxX - minX) + (maxY - minY) * (maxY - minY);\n        };\n        // Work on a copy of the path.\n        const pathsToCheck = lines.slice();\n        while (pathsToCheck.length > 0) {\n            const path = pathsToCheck.pop();\n            if (path === undefined || path.length < 6) {\n                continue;\n            }\n            let splitIndex = -1;\n            for (let i = 0; i < path.length - 3; i += 3) {\n                tempP0.set(path[i], path[i + 1]);\n                tempP1.set(path[i + 3], path[i + 4]);\n                const tangent = tempP1.sub(tempP0).normalize();\n                if (i > 0) {\n                    const theta = Math.atan2(tempPreviousTangent.x * tangent.y - tangent.x * tempPreviousTangent.y, tangent.dot(tempPreviousTangent));\n                    if (Math.abs(theta) > maxCornerAngle) {\n                        splitIndex = i;\n                        break;\n                    }\n                }\n                tempPreviousTangent.set(tangent.x, tangent.y);\n            }\n            if (splitIndex > 0) {\n                // Estimate if the first part of the path is long enough for the label.\n                const firstPathLengthSqr = computeBoundingBoxSizeSqr(path, 0, splitIndex + 3);\n                // Estimate if the second part of the path is long enough for the label.\n                const secondPathLengthSqr = computeBoundingBoxSizeSqr(path, splitIndex, path.length);\n                if (firstPathLengthSqr > minEstimatedLabelLengthSqr) {\n                    // Split off the valid first path points with a clone of the path.\n                    validLines.push(path.slice(0, splitIndex + 3));\n                }\n                if (secondPathLengthSqr > minEstimatedLabelLengthSqr) {\n                    // Now process the second part of the path, it may have to be split\n                    // again.\n                    pathsToCheck.push(path.slice(splitIndex));\n                }\n            }\n            else {\n                // Estimate if the path is long enough for the label, otherwise ignore\n                // it for rendering text. First, compute the bounding box in world\n                // coordinates.\n                const pathLengthSqr = computeBoundingBoxSizeSqr(path, 0, path.length);\n                if (pathLengthSqr > minEstimatedLabelLengthSqr) {\n                    validLines.push(path);\n                }\n            }\n        }\n        return validLines;\n    }\n    getTextureCoordinateType(technique) {\n        // Set TileSpace coordinate type to generate texture coordinates for the displacement map\n        // used in elevation overlay.\n        if ((harp_datasource_protocol_1.isFillTechnique(technique) ||\n            harp_datasource_protocol_1.isSolidLineTechnique(technique) ||\n            harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) &&\n            this.m_enableElevationOverlay) {\n            return harp_datasource_protocol_1.TextureCoordinateType.TileSpace;\n        }\n        return harp_datasource_protocol_1.textureCoordinateType(technique);\n    }\n    getComputeTexCoordsFunc(technique, objectBounds) {\n        const texCoordType = this.getTextureCoordinateType(technique);\n        switch (texCoordType) {\n            case harp_datasource_protocol_1.TextureCoordinateType.TileSpace:\n                return (tilePos, tileExtents) => {\n                    const uv = tilePos.clone().divideScalar(tileExtents);\n                    uv.y = 1 - uv.y;\n                    return uv;\n                };\n            case harp_datasource_protocol_1.TextureCoordinateType.EquirectangularSpace:\n                return (tilePos, extents) => {\n                    const worldPos = OmvUtils_1.tile2world(extents, this.m_decodeInfo, tilePos, false, tmpV3r);\n                    const uv = harp_geoutils_1.normalizedEquirectangularProjection.reprojectPoint(harp_geoutils_1.webMercatorProjection, worldPos);\n                    return new THREE.Vector2(uv.x, uv.y);\n                };\n            case harp_datasource_protocol_1.TextureCoordinateType.FeatureSpace:\n                if (!objectBounds) {\n                    return undefined;\n                }\n                return (tilePos, extents) => {\n                    const worldPos = OmvUtils_1.tile2world(extents, this.m_decodeInfo, tilePos, false, tmpV3r);\n                    const uv = new THREE.Vector2(worldPos.x, worldPos.y);\n                    if (objectBounds) {\n                        uv.x -= objectBounds.min.x;\n                        uv.y -= objectBounds.min.y;\n                        uv.x /= objectBounds.max.x - objectBounds.min.x;\n                        uv.y /= objectBounds.max.y - objectBounds.min.y;\n                    }\n                    uv.y = 1 - uv.y;\n                    return uv;\n                };\n            default:\n                return undefined;\n        }\n    }\n    applyLineTechnique(linesGeometry, technique, techniqueIndex, lineType = LineType.Complex, featureAttributes, lines, context, uvs, offsets) {\n        let lineGroup;\n        const lineGroupGeometries = linesGeometry.find(aLine => aLine.technique === techniqueIndex);\n        const hasNormalsAndUvs = uvs !== undefined;\n        if (lineGroupGeometries === undefined) {\n            lineGroup = new Lines_1.LineGroup(hasNormalsAndUvs, undefined, lineType === LineType.Simple);\n            const aLine = {\n                type: lineType === LineType.Complex ? harp_datasource_protocol_1.GeometryType.SolidLine : harp_datasource_protocol_1.GeometryType.Line,\n                technique: techniqueIndex,\n                lines: lineGroup\n            };\n            if (this.m_gatherFeatureAttributes) {\n                aLine.objInfos = [featureAttributes];\n                aLine.featureStarts = [0];\n            }\n            linesGeometry.push(aLine);\n        }\n        else {\n            lineGroup = lineGroupGeometries.lines;\n            if (this.m_gatherFeatureAttributes &&\n                lineGroupGeometries.objInfos &&\n                lineGroupGeometries.featureStarts) {\n                // Add ID to tag the geometry, also provide the current length of the index\n                // attribute\n                lineGroupGeometries.objInfos.push(featureAttributes);\n                lineGroupGeometries.featureStarts.push(lineGroup.indices.length);\n            }\n        }\n        let i = 0;\n        lines.forEach(aLine => {\n            lineGroup.add(this.m_decodeInfo.center, aLine, this.projection, offsets ? offsets[i] : undefined, uvs ? uvs[i] : undefined);\n            i++;\n        });\n    }\n    applyPolygonTechnique(polygons, technique, techniqueIndex, featureId, context, extents) {\n        var _a, _b;\n        if (polygons.length === 0) {\n            return;\n        }\n        const isExtruded = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique);\n        const geometryType = isExtruded ? harp_datasource_protocol_1.GeometryType.ExtrudedPolygon : harp_datasource_protocol_1.GeometryType.Polygon;\n        const meshBuffers = this.findOrCreateMeshBuffers(techniqueIndex, geometryType);\n        if (meshBuffers === undefined) {\n            return;\n        }\n        const extrudedPolygonTechnique = technique;\n        const fillTechnique = technique;\n        const boundaryWalls = extrudedPolygonTechnique.boundaryWalls === true;\n        const isFilled = harp_datasource_protocol_1.isFillTechnique(technique);\n        const texCoordType = this.getTextureCoordinateType(technique);\n        let height = TechniqueAttr_1.evaluateTechniqueAttr(context, extrudedPolygonTechnique.height);\n        let floorHeight = TechniqueAttr_1.evaluateTechniqueAttr(context, extrudedPolygonTechnique.floorHeight);\n        if (height === undefined) {\n            // Get the height values for the footprint and extrusion.\n            const featureHeight = context.env.lookup(\"height\");\n            const styleSetDefaultHeight = TechniqueAttr_1.evaluateTechniqueAttr(context, extrudedPolygonTechnique.defaultHeight);\n            height =\n                featureHeight !== undefined\n                    ? featureHeight\n                    : styleSetDefaultHeight !== undefined\n                        ? styleSetDefaultHeight\n                        : 0;\n        }\n        if (floorHeight === undefined) {\n            const featureMinHeight = context.env.lookup(\"min_height\");\n            floorHeight = featureMinHeight !== undefined && !isFilled ? featureMinHeight : 0;\n        }\n        // Prevent that extruded buildings are completely flat (can introduce errors in normal\n        // computation and extrusion).\n        height = Math.max(floorHeight + MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT, height);\n        const tileLevel = this.m_decodeInfo.tileKey.level;\n        const SCALED_EXTRUSION_MIN_STORAGE_LEVEL = 12;\n        // Unless explicitly defined do not apply the projection\n        // scale factor to convert meters to world space units\n        // if the tile's level is less than `SCALED_EXTRUSION_MIN_STORAGE_LEVEL`.\n        const styleSetConstantHeight = TechniqueAttr_1.evaluateTechniqueAttr(context, extrudedPolygonTechnique.constantHeight, tileLevel < SCALED_EXTRUSION_MIN_STORAGE_LEVEL);\n        this.m_decodeInfo.tileBounds.getCenter(tempTileOrigin);\n        const { positions, normals, textureCoordinates, colors, extrusionAxis, indices, edgeIndices, groups } = meshBuffers;\n        const isSpherical = this.m_decodeInfo.targetProjection.type === harp_geoutils_1.ProjectionType.Spherical;\n        const edgeWidth = isExtruded\n            ? (_a = extrudedPolygonTechnique.lineWidth) !== null && _a !== void 0 ? _a : 0.0 : isFilled\n            ? (_b = fillTechnique.lineWidth) !== null && _b !== void 0 ? _b : 0.0 : 0.0;\n        const hasEdges = typeof edgeWidth === \"number\" ? edgeWidth > 0.0 : true;\n        let color;\n        if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n            if (harp_utils_1.getOptionValue(technique.vertexColors, false)) {\n                let colorValue = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.color);\n                if (colorValue === undefined) {\n                    const featureColor = context.env.lookup(\"color\");\n                    if (this.isColorStringValid(featureColor)) {\n                        colorValue = String(featureColor);\n                    }\n                }\n                if (colorValue === undefined) {\n                    colorValue = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.defaultColor, 0x000000);\n                }\n                if (colorValue === undefined) {\n                    colorValue = 0x000000;\n                }\n                tmpColor.set(colorValue);\n                color = tmpColor;\n            }\n        }\n        for (const polygon of polygons) {\n            const startIndexCount = indices.length;\n            const edgeStartIndexCount = edgeIndices.length;\n            for (let ringIndex = 0; ringIndex < polygon.length;) {\n                const vertices = [];\n                const polygonBaseVertex = positions.length / 3;\n                const ring = polygon[ringIndex++];\n                const featureStride = ring.vertexStride;\n                const vertexStride = featureStride + 2;\n                const winding = ring.winding;\n                for (let i = 0; i < ring.points.length; ++i) {\n                    const point = ring.points[i];\n                    // Invert the Y component to preserve the correct winding without transforming\n                    // from webMercator's local to global space.\n                    vertices.push(point.x, -point.y);\n                    if (ring.textureCoords !== undefined) {\n                        vertices.push(ring.textureCoords[i].x, ring.textureCoords[i].y);\n                    }\n                    const nextIdx = (i + 1) % ring.points.length;\n                    const properEdge = ring.isProperEdge(i);\n                    // Calculate nextEdge and nextWall.\n                    vertices.push(properEdge ? nextIdx : -1, boundaryWalls || properEdge ? nextIdx : -1);\n                }\n                // Iterate over the inner rings. The inner rings have the opposite winding\n                // of the outer rings.\n                const holes = [];\n                while (ringIndex < polygon.length && polygon[ringIndex].winding !== winding) {\n                    const vertexOffset = vertices.length / vertexStride;\n                    holes.push(vertexOffset);\n                    const hole = polygon[ringIndex++];\n                    for (let i = 0; i < hole.points.length; ++i) {\n                        const nextIdx = (i + 1) % hole.points.length;\n                        const point = hole.points[i];\n                        // Invert the Y component to preserve the correct winding without\n                        // transforming from webMercator's local to global space.\n                        vertices.push(point.x, -point.y);\n                        if (hole.textureCoords !== undefined) {\n                            vertices.push(hole.textureCoords[i].x, hole.textureCoords[i].y);\n                        }\n                        // Calculate nextEdge and nextWall.\n                        const insideExtents = hole.isProperEdge(i);\n                        vertices.push(insideExtents ? vertexOffset + nextIdx : -1, boundaryWalls || insideExtents ? vertexOffset + nextIdx : -1);\n                    }\n                }\n                try {\n                    // Triangulate the footprint polyline.\n                    const triangles = earcut_1.default(vertices, holes, vertexStride);\n                    const originalVertexCount = vertices.length / vertexStride;\n                    // Subdivide for spherical projections if needed.\n                    if (isSpherical) {\n                        const geom = new THREE.BufferGeometry();\n                        const positionArray = [];\n                        const uvArray = [];\n                        const edgeArray = [];\n                        const wallArray = [];\n                        // Transform to global webMercator coordinates to be able to reproject to\n                        // sphere.\n                        for (let i = 0; i < vertices.length; i += vertexStride) {\n                            const worldPos = OmvUtils_1.tile2world(extents, this.m_decodeInfo, tmpV2.set(vertices[i], vertices[i + 1]), true, tmpV3r);\n                            positionArray.push(worldPos.x, worldPos.y, 0);\n                            if (texCoordType !== undefined) {\n                                uvArray.push(vertices[i + 2], vertices[i + 3]);\n                            }\n                            edgeArray.push(vertices[i + featureStride]);\n                            wallArray.push(vertices[i + featureStride + 1]);\n                        }\n                        // Create the temporary geometry used for subdivision.\n                        const posAttr = new THREE.BufferAttribute(new Float32Array(positionArray), 3);\n                        geom.setAttribute(\"position\", posAttr);\n                        let uvAttr;\n                        if (texCoordType !== undefined) {\n                            uvAttr = new THREE.BufferAttribute(new Float32Array(uvArray), 2);\n                            geom.setAttribute(\"uv\", uvAttr);\n                        }\n                        const edgeAttr = new THREE.BufferAttribute(new Float32Array(edgeArray), 1);\n                        geom.setAttribute(\"edge\", edgeAttr);\n                        const wallAttr = new THREE.BufferAttribute(new Float32Array(wallArray), 1);\n                        geom.setAttribute(\"wall\", edgeAttr);\n                        const index = createIndexBufferAttribute(triangles, posAttr.count - 1);\n                        const indexAttr = index.type === \"uint32\"\n                            ? new THREE.Uint32BufferAttribute(index.buffer, 1)\n                            : new THREE.Uint16BufferAttribute(index.buffer, 1);\n                        geom.setIndex(indexAttr);\n                        // Increase tesselation of polygons for certain zoom levels\n                        // to remove mixed LOD cracks\n                        const zoomLevel = this.m_decodeInfo.tileKey.level;\n                        if (zoomLevel >= 3 && zoomLevel < 9) {\n                            const subdivision = Math.pow(2, 9 - zoomLevel);\n                            const { geoBox } = this.m_decodeInfo;\n                            const edgeModifier = new EdgeLengthGeometrySubdivisionModifier_1.EdgeLengthGeometrySubdivisionModifier(subdivision, geoBox, EdgeLengthGeometrySubdivisionModifier_1.SubdivisionMode.NoDiagonals, harp_geoutils_1.webMercatorProjection);\n                            edgeModifier.modify(geom);\n                        }\n                        // FIXME(HARP-5700): Subdivision modifier ignores texture coordinates.\n                        const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.MathUtils.degToRad(10), harp_geoutils_1.webMercatorProjection);\n                        modifier.modify(geom);\n                        // Reassemble the vertex buffer, transforming the subdivided global\n                        // webMercator points back to local space.\n                        vertices.length = 0;\n                        triangles.length = 0;\n                        for (let i = 0; i < posAttr.array.length; i += 3) {\n                            const tilePos = OmvUtils_1.world2tile(extents, this.m_decodeInfo, tmpV3.set(posAttr.array[i], posAttr.array[i + 1], 0), true, tmpV2r);\n                            vertices.push(tilePos.x, tilePos.y);\n                            if (texCoordType !== undefined) {\n                                vertices.push(uvAttr.array[(i / 3) * 2]);\n                                vertices.push(uvAttr.array[(i / 3) * 2 + 1]);\n                            }\n                            vertices.push(edgeAttr.array[i / 3]);\n                            vertices.push(wallAttr.array[i / 3]);\n                        }\n                        const geomIndex = geom.getIndex();\n                        if (geomIndex !== null) {\n                            triangles.push(...geomIndex.array);\n                        }\n                    }\n                    // Add the footprint/roof vertices to the position buffer.\n                    tempVertNormal.set(0, 0, 1);\n                    // Assemble the vertex buffer.\n                    for (let i = 0; i < vertices.length; i += vertexStride) {\n                        OmvUtils_1.webMercatorTile2TargetTile(extents, this.m_decodeInfo, tmpV2.set(vertices[i], vertices[i + 1]), tmpV3, true);\n                        let scaleFactor = 1.0;\n                        if (isExtruded && styleSetConstantHeight !== true) {\n                            tempVertOrigin.set(tempTileOrigin.x + tmpV3.x, tempTileOrigin.y + tmpV3.y, tempTileOrigin.z + tmpV3.z);\n                            scaleFactor = this.m_decodeInfo.targetProjection.getScaleFactor(tempVertOrigin);\n                        }\n                        this.m_maxGeometryHeight = Math.max(this.m_maxGeometryHeight, scaleFactor * height);\n                        this.m_minGeometryHeight = Math.min(this.m_minGeometryHeight, scaleFactor * height);\n                        if (isSpherical) {\n                            tempVertNormal\n                                .set(tmpV3.x, tmpV3.y, tmpV3.z)\n                                .add(this.center)\n                                .normalize();\n                        }\n                        tempFootDisp.copy(tempVertNormal).multiplyScalar(floorHeight * scaleFactor);\n                        positions.push(tmpV3.x + tempFootDisp.x, tmpV3.y + tempFootDisp.y, tmpV3.z + tempFootDisp.z);\n                        if (texCoordType !== undefined) {\n                            textureCoordinates.push(vertices[i + 2], vertices[i + 3]);\n                        }\n                        if (this.m_enableElevationOverlay) {\n                            normals.push(...tempVertNormal.toArray());\n                        }\n                        if (isExtruded) {\n                            tempRoofDisp.copy(tempVertNormal).multiplyScalar(height * scaleFactor);\n                            positions.push(tmpV3.x + tempRoofDisp.x, tmpV3.y + tempRoofDisp.y, tmpV3.z + tempRoofDisp.z);\n                            extrusionAxis.push(0.0, 0.0, 0.0, 0.0, tempRoofDisp.x - tempFootDisp.x, tempRoofDisp.y - tempFootDisp.y, tempRoofDisp.z - tempFootDisp.z, 1.0);\n                            if (texCoordType !== undefined) {\n                                textureCoordinates.push(vertices[i + 2], vertices[i + 3]);\n                            }\n                            if (this.m_enableElevationOverlay) {\n                                normals.push(...tempVertNormal.toArray());\n                            }\n                            if (color !== undefined) {\n                                colors.push(color.r, color.g, color.b, color.r, color.g, color.b);\n                            }\n                        }\n                    }\n                    // Add the footprint/roof indices to the index buffer.\n                    for (let i = 0; i < triangles.length; i += 3) {\n                        if (isExtruded) {\n                            // When extruding we duplicate the vertices, so that all even vertices\n                            // belong to the bottom and all odd vertices belong to the top.\n                            const i0 = polygonBaseVertex + triangles[i + 0] * 2 + 1;\n                            const i1 = polygonBaseVertex + triangles[i + 1] * 2 + 1;\n                            const i2 = polygonBaseVertex + triangles[i + 2] * 2 + 1;\n                            indices.push(i0, i1, i2);\n                        }\n                        else {\n                            const i0 = polygonBaseVertex + triangles[i + 0];\n                            const i1 = polygonBaseVertex + triangles[i + 1];\n                            const i2 = polygonBaseVertex + triangles[i + 2];\n                            indices.push(i0, i1, i2);\n                        }\n                    }\n                    // Assemble the index buffer for edges (follow vertices as linked list).\n                    if (hasEdges) {\n                        this.addEdges(polygonBaseVertex, originalVertexCount, vertexStride, featureStride, positions, vertices, edgeIndices, isExtruded, extrudedPolygonTechnique.footprint, extrudedPolygonTechnique.maxSlope);\n                    }\n                    if (isExtruded) {\n                        this.addWalls(polygonBaseVertex, originalVertexCount, vertexStride, featureStride, vertices, indices);\n                    }\n                }\n                catch (err) {\n                    logger.error(`cannot triangulate geometry`, err);\n                }\n            }\n            if (this.m_gatherFeatureAttributes) {\n                meshBuffers.objInfos.push(context.env.entries);\n                meshBuffers.featureStarts.push(startIndexCount);\n                meshBuffers.edgeFeatureStarts.push(edgeStartIndexCount);\n            }\n            const count = indices.length - startIndexCount;\n            if (count > 0) {\n                groups.push({\n                    start: startIndexCount,\n                    count,\n                    technique: techniqueIndex\n                });\n            }\n        }\n    }\n    createGeometries() {\n        this.m_meshBuffers.forEach((meshBuffers, techniqueIdx) => {\n            if (meshBuffers.positions.length === 0) {\n                return;\n            } // nothing to do\n            if (!this.m_styleSetEvaluator.techniques ||\n                this.m_styleSetEvaluator.techniques.length <= techniqueIdx) {\n                throw new Error(\"Invalid technique index\");\n            }\n            const technique = this.m_styleSetEvaluator.techniques[techniqueIdx];\n            if (technique === undefined) {\n                return;\n            }\n            const positionElements = new Float32Array(meshBuffers.positions);\n            if (meshBuffers.texts.length > 0 && harp_datasource_protocol_1.isTextTechnique(technique)) {\n                this.m_textGeometries.push({\n                    positions: {\n                        name: \"position\",\n                        type: \"float\",\n                        buffer: positionElements.buffer,\n                        itemCount: 3\n                    },\n                    texts: meshBuffers.texts,\n                    technique: techniqueIdx,\n                    stringCatalog: meshBuffers.stringCatalog,\n                    objInfos: meshBuffers.objInfos\n                });\n                return;\n            }\n            if (meshBuffers.texts.length > 0 && harp_datasource_protocol_1.isPoiTechnique(technique)) {\n                this.m_poiGeometries.push({\n                    positions: {\n                        name: \"position\",\n                        type: \"float\",\n                        buffer: positionElements.buffer,\n                        itemCount: 3\n                    },\n                    texts: meshBuffers.texts,\n                    technique: techniqueIdx,\n                    stringCatalog: meshBuffers.stringCatalog,\n                    imageTextures: meshBuffers.imageTextures,\n                    objInfos: meshBuffers.objInfos,\n                    offsetDirections: meshBuffers.offsetDirections\n                });\n                return;\n            }\n            if (meshBuffers.groups.length === 0) {\n                // create a default group containing all the vertices in the position attribute.\n                meshBuffers.groups.push({\n                    start: 0,\n                    count: positionElements.length / 3,\n                    technique: techniqueIdx\n                });\n            }\n            const vertexAttributes = [\n                {\n                    name: \"position\",\n                    buffer: positionElements.buffer,\n                    itemCount: 3,\n                    type: \"float\"\n                }\n            ];\n            const geometry = {\n                type: meshBuffers.type,\n                vertexAttributes,\n                groups: meshBuffers.groups\n            };\n            if (meshBuffers.normals.length > 0) {\n                const normals = new Float32Array(meshBuffers.normals);\n                harp_utils_1.assert(normals.length === positionElements.length, \"length of normals buffer is different than the length of the \" +\n                    \"position buffer\");\n                vertexAttributes.push({\n                    name: \"normal\",\n                    buffer: normals.buffer,\n                    itemCount: 3,\n                    type: \"float\"\n                });\n            }\n            if (meshBuffers.colors.length > 0) {\n                const colors = new Float32Array(meshBuffers.colors);\n                harp_utils_1.assert(colors.length === positionElements.length, \"length of colors buffer is different than the length of the \" +\n                    \"position buffer\");\n                vertexAttributes.push({\n                    name: \"color\",\n                    buffer: colors.buffer,\n                    itemCount: 3,\n                    type: \"float\"\n                });\n            }\n            const positionCount = meshBuffers.positions.length / 3;\n            if (meshBuffers.textureCoordinates.length > 0) {\n                const texCoordCount = meshBuffers.textureCoordinates.length / 2;\n                harp_utils_1.assert(texCoordCount === positionCount, \"length of textureCoordinates buffer is different than the length of the\" +\n                    \"position buffer\");\n                const textureCoordinates = new Float32Array(meshBuffers.textureCoordinates);\n                vertexAttributes.push({\n                    name: \"uv\",\n                    buffer: textureCoordinates.buffer,\n                    itemCount: 2,\n                    type: \"float\"\n                });\n            }\n            if (meshBuffers.extrusionAxis.length > 0) {\n                const extrusionAxis = new Float32Array(meshBuffers.extrusionAxis);\n                harp_utils_1.assert(extrusionAxis.length / 4 === positionElements.length / 3, \"length of extrusionAxis buffer is different than the length of the \" +\n                    \"position buffer\");\n                vertexAttributes.push({\n                    name: \"extrusionAxis\",\n                    buffer: extrusionAxis.buffer,\n                    itemCount: 4,\n                    type: \"float\"\n                });\n            }\n            if (meshBuffers.indices.length > 0) {\n                geometry.index = createIndexBufferAttribute(meshBuffers.indices, positionCount - 1);\n            }\n            if (meshBuffers.edgeIndices.length > 0) {\n                geometry.edgeIndex = createIndexBufferAttribute(meshBuffers.edgeIndices, positionCount - 1, \"edgeIndex\");\n            }\n            geometry.featureStarts = meshBuffers.featureStarts;\n            geometry.edgeFeatureStarts = meshBuffers.edgeFeatureStarts;\n            geometry.objInfos = meshBuffers.objInfos;\n            this.m_geometries.push(geometry);\n        });\n    }\n    processLines(linesArray) {\n        linesArray.forEach(linesGeometry => {\n            const { vertices, indices } = linesGeometry.lines;\n            const technique = linesGeometry.technique;\n            const buffer = new Float32Array(vertices).buffer;\n            const index = createIndexBufferAttribute(indices, vertices.length / linesGeometry.lines.stride - 1);\n            const attr = {\n                type: \"float\",\n                stride: linesGeometry.lines.stride,\n                buffer,\n                attributes: linesGeometry.lines.vertexAttributes\n            };\n            const geometry = {\n                type: harp_datasource_protocol_1.GeometryType.SolidLine,\n                index,\n                interleavedVertexAttributes: [attr],\n                groups: [{ start: 0, count: indices.length, technique }],\n                vertexAttributes: [],\n                featureStarts: linesGeometry.featureStarts,\n                objInfos: linesGeometry.objInfos\n            };\n            this.m_geometries.push(geometry);\n        });\n    }\n    processSimpleLines(linesArray) {\n        linesArray.forEach(linesGeometry => {\n            const { vertices, indices } = linesGeometry.lines;\n            const technique = linesGeometry.technique;\n            const buffer = new Float32Array(vertices).buffer;\n            const attr = {\n                buffer,\n                itemCount: 3,\n                type: \"float\",\n                name: \"position\"\n            };\n            const geometry = {\n                type: harp_datasource_protocol_1.GeometryType.Line,\n                index: createIndexBufferAttribute(indices, vertices.length / attr.itemCount - 1),\n                vertexAttributes: [attr],\n                groups: [{ start: 0, count: indices.length, technique }],\n                featureStarts: linesGeometry.featureStarts,\n                objInfos: linesGeometry.objInfos\n            };\n            this.m_geometries.push(geometry);\n        });\n    }\n    findOrCreateMeshBuffers(index, type) {\n        let buffers = this.m_meshBuffers.get(index);\n        if (buffers !== undefined) {\n            if (buffers.type !== type) {\n                logger.error(`MeshBuffer has been created with wrong type \"${harp_datasource_protocol_1.GeometryType[type]}\"\n                instead of \"${harp_datasource_protocol_1.GeometryType[buffers.type]}\"`);\n                return undefined;\n            }\n            return buffers;\n        }\n        buffers = new MeshBuffers(type);\n        this.m_meshBuffers.set(index, buffers);\n        return buffers;\n    }\n    processFeatureCommon(env) {\n        const source = env.lookup(\"source\");\n        if (typeof source === \"string\" && source !== \"\") {\n            if (!this.m_sources.includes(source)) {\n                this.m_sources.push(source);\n            }\n        }\n    }\n    isColorStringValid(color) {\n        return typeof color === \"string\" && color.length > 0;\n    }\n    addEdges(featureBaseVertex, featureVertexCount, vertexStride, featureStride, positions, vertices, indices, isExtruded, hasFootprint, maxSlope) {\n        const tmpEdgeA = new THREE.Vector3();\n        const tmpEdgeB = new THREE.Vector3();\n        let firstRingVertex;\n        let prevRingVertex;\n        let currRingVertex = 0;\n        let maxRingVertex = 0;\n        while (currRingVertex < featureVertexCount) {\n            while (currRingVertex !== firstRingVertex) {\n                if (firstRingVertex === undefined) {\n                    firstRingVertex = currRingVertex;\n                }\n                if (currRingVertex < featureVertexCount) {\n                    maxRingVertex = Math.max(maxRingVertex, currRingVertex);\n                }\n                const nextRingVertex = vertices[currRingVertex * vertexStride + featureStride];\n                if (nextRingVertex < 0) {\n                    break;\n                }\n                else {\n                    if (!isExtruded) {\n                        indices.push(featureBaseVertex + currRingVertex, featureBaseVertex + nextRingVertex);\n                    }\n                    else {\n                        if (hasFootprint === true) {\n                            indices.push(featureBaseVertex + currRingVertex * 2, featureBaseVertex + nextRingVertex * 2);\n                        }\n                        indices.push(featureBaseVertex + currRingVertex * 2 + 1, featureBaseVertex + nextRingVertex * 2 + 1);\n                        if (maxSlope !== undefined) {\n                            if (prevRingVertex !== undefined) {\n                                const prevPos = (featureBaseVertex + prevRingVertex * 2) * 3;\n                                const currPos = (featureBaseVertex + currRingVertex * 2) * 3;\n                                const nextPos = (featureBaseVertex + nextRingVertex * 2) * 3;\n                                tmpEdgeA\n                                    .set(positions[currPos] - positions[prevPos], positions[currPos + 1] - positions[prevPos + 1], positions[currPos + 2] - positions[prevPos + 2])\n                                    .normalize();\n                                tmpEdgeB\n                                    .set(positions[nextPos] - positions[currPos], positions[nextPos + 1] - positions[currPos + 1], positions[nextPos + 2] - positions[currPos + 2])\n                                    .normalize();\n                                if (tmpEdgeA.dot(tmpEdgeB) <= maxSlope) {\n                                    indices.push(featureBaseVertex + currRingVertex * 2, featureBaseVertex + currRingVertex * 2 + 1);\n                                }\n                            }\n                        }\n                        else {\n                            indices.push(featureBaseVertex + currRingVertex * 2, featureBaseVertex + currRingVertex * 2 + 1);\n                        }\n                    }\n                    prevRingVertex = currRingVertex;\n                    currRingVertex = nextRingVertex;\n                }\n            }\n            currRingVertex = maxRingVertex + 1;\n            firstRingVertex = undefined;\n            prevRingVertex = undefined;\n        }\n    }\n    addWalls(featureBaseVertex, featureVertexCount, vertexStride, featureStride, vertices, indices) {\n        let firstRingVertex;\n        let currRingVertex = 0;\n        let maxRingVertex = 0;\n        while (currRingVertex < featureVertexCount) {\n            while (currRingVertex !== firstRingVertex) {\n                if (firstRingVertex === undefined) {\n                    firstRingVertex = currRingVertex;\n                }\n                if (currRingVertex < featureVertexCount) {\n                    maxRingVertex = Math.max(maxRingVertex, currRingVertex);\n                }\n                const nextRingVertex = vertices[currRingVertex * vertexStride + featureStride + 1];\n                if (nextRingVertex < 0) {\n                    break;\n                }\n                else {\n                    indices.push(featureBaseVertex + currRingVertex * 2, featureBaseVertex + currRingVertex * 2 + 1, featureBaseVertex + nextRingVertex * 2 + 1, featureBaseVertex + nextRingVertex * 2 + 1, featureBaseVertex + nextRingVertex * 2, featureBaseVertex + currRingVertex * 2);\n                }\n                currRingVertex = nextRingVertex;\n            }\n            currRingVertex = maxRingVertex + 1;\n            firstRingVertex = undefined;\n        }\n    }\n    findRelativePositionInLine(p, line) {\n        let lineDist = Infinity;\n        let lineOffset = 0;\n        for (let i = 0; i < line.length; i += 4) {\n            // Find the closest point C in segment AB to point P.\n            tmpLine.set(tmpPointA.set(line[i], line[i + 1], line[i + 2]), tmpPointB.set(line[i + 4], line[i + 5], line[i + 6]));\n            tmpLine.closestPointToPoint(p, true, tmpPointC);\n            // If P is in AB (or really close), save A as anchor point and C (to estimate distance\n            // from segment origin).\n            const dist = tmpPointC.distanceTo(p);\n            if (dist < lineDist) {\n                tmpPointD.copy(tmpPointC);\n                tmpPointE.copy(tmpPointA);\n                lineDist = dist;\n                lineOffset = line[i + 3];\n            }\n        }\n        // Return the relative position of P inside the line.\n        return lineOffset + tmpPointD.distanceTo(tmpPointE);\n    }\n}\nexports.VectorTileDataEmitter = VectorTileDataEmitter;\n//# sourceMappingURL=VectorTileDataEmitter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataEmitter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDecoder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDecoder.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorTileDecoderService = exports.VectorTileDecoder = exports.VectorTileDataProcessor = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst index_worker_1 = __webpack_require__(/*! @here/harp-mapview-decoder/index-worker */ \"./node_modules/@here/harp-mapview-decoder/index-worker.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst GeoJsonDataAdapter_1 = __webpack_require__(/*! ./adapters/geojson/GeoJsonDataAdapter */ \"./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson/GeoJsonDataAdapter.js\");\nconst GeoJsonVtDataAdapter_1 = __webpack_require__(/*! ./adapters/geojson-vt/GeoJsonVtDataAdapter */ \"./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson-vt/GeoJsonVtDataAdapter.js\");\nconst OmvDataAdapter_1 = __webpack_require__(/*! ./adapters/omv/OmvDataAdapter */ \"./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvDataAdapter.js\");\nconst DecodeInfo_1 = __webpack_require__(/*! ./DecodeInfo */ \"./node_modules/@here/harp-vectortile-datasource/lib/DecodeInfo.js\");\nconst OmvDataFilter_1 = __webpack_require__(/*! ./OmvDataFilter */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\nconst OmvPoliticalViewFeatureModifier_1 = __webpack_require__(/*! ./OmvPoliticalViewFeatureModifier */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvPoliticalViewFeatureModifier.js\");\nconst StyleSetDataFilter_1 = __webpack_require__(/*! ./StyleSetDataFilter */ \"./node_modules/@here/harp-vectortile-datasource/lib/StyleSetDataFilter.js\");\nconst VectorTileDataEmitter_1 = __webpack_require__(/*! ./VectorTileDataEmitter */ \"./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataEmitter.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"VectorTileDecoder\", { enabled: false });\nclass VectorTileDataProcessor {\n    constructor(m_projection, m_styleSetEvaluator, m_showMissingTechniques, m_dataFilter, m_featureModifiers, m_gatherFeatureAttributes = false, m_skipShortLabels = true, m_storageLevelOffset = 0, m_enableElevationOverlay = false, m_roundUpCoordinatesIfNeeded = false, m_languages) {\n        this.m_projection = m_projection;\n        this.m_styleSetEvaluator = m_styleSetEvaluator;\n        this.m_showMissingTechniques = m_showMissingTechniques;\n        this.m_dataFilter = m_dataFilter;\n        this.m_featureModifiers = m_featureModifiers;\n        this.m_gatherFeatureAttributes = m_gatherFeatureAttributes;\n        this.m_skipShortLabels = m_skipShortLabels;\n        this.m_storageLevelOffset = m_storageLevelOffset;\n        this.m_enableElevationOverlay = m_enableElevationOverlay;\n        this.m_roundUpCoordinatesIfNeeded = m_roundUpCoordinatesIfNeeded;\n        this.m_languages = m_languages;\n        this.m_dataAdapters = [];\n        const styleSetDataFilter = new StyleSetDataFilter_1.StyleSetDataFilter(m_styleSetEvaluator);\n        const dataPreFilter = m_dataFilter\n            ? new OmvDataFilter_1.ComposedDataFilter([styleSetDataFilter, m_dataFilter])\n            : styleSetDataFilter;\n        // Register the default adapters.\n        const omvDataAdapter = new OmvDataAdapter_1.OmvDataAdapter(this, dataPreFilter, logger);\n        omvDataAdapter.roundUpCoordinatesIfNeeded = m_roundUpCoordinatesIfNeeded;\n        this.m_dataAdapters.push(omvDataAdapter);\n        this.m_dataAdapters.push(new GeoJsonVtDataAdapter_1.GeoJsonVtDataAdapter(this, dataPreFilter, logger));\n        this.m_dataAdapters.push(new GeoJsonDataAdapter_1.GeoJsonDataAdapter(this, dataPreFilter, logger));\n    }\n    get storageLevelOffset() {\n        return this.m_storageLevelOffset;\n    }\n    /**\n     * Given a tile and a protobuffer, it returns a decoded tile and it creates the geometries that\n     * belong to it.\n     *\n     * @param tileKey - The tile to be decoded.\n     * @param data - The protobuffer to decode from.\n     * @returns A [[DecodedTile]]\n     */\n    getDecodedTile(tileKey, data) {\n        let dataAdapter;\n        for (const adapter of this.m_dataAdapters.values()) {\n            if (adapter.canProcess(data)) {\n                dataAdapter = adapter;\n                break;\n            }\n        }\n        if (dataAdapter === undefined) {\n            return {\n                techniques: [],\n                geometries: []\n            };\n        }\n        this.m_styleSetEvaluator.resetTechniques();\n        const decodeInfo = new DecodeInfo_1.DecodeInfo(dataAdapter.id, this.m_projection, tileKey, this.m_storageLevelOffset);\n        this.m_decodedTileEmitter = new VectorTileDataEmitter_1.VectorTileDataEmitter(decodeInfo, this.m_styleSetEvaluator, this.m_gatherFeatureAttributes, this.m_skipShortLabels, this.m_enableElevationOverlay, this.m_languages);\n        dataAdapter.process(data, decodeInfo);\n        return this.m_decodedTileEmitter.getDecodedTile();\n    }\n    /** @override */\n    processPointFeature(layer, extents, geometry, env, storageLevel) {\n        if (this.m_featureModifiers !== undefined) {\n            if (this.m_featureModifiers.find(fm => {\n                // TODO: The logic of feature ignore should be actually in the feature filtering\n                // mechanism - see OmvFeatureFilter.\n                return !fm.doProcessPointFeature(layer, env, storageLevel);\n            }) !== undefined) {\n                return;\n            }\n        }\n        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, \"point\"), harp_datasource_protocol_1.GeometryKind.Label);\n        if (techniques.length === 0) {\n            if (this.m_showMissingTechniques) {\n                logger.log(\"OmvDecoder#processPointFeature: no techniques for object:\", JSON.stringify(env.unmap()));\n            }\n            return;\n        }\n        const context = {\n            env,\n            cachedExprResults: new Map()\n        };\n        if (this.m_decodedTileEmitter) {\n            this.m_decodedTileEmitter.processPointFeature(layer, extents, geometry, context, techniques);\n        }\n    }\n    /** @override */\n    processLineFeature(layer, extents, geometry, env, storageLevel) {\n        if (this.m_featureModifiers !== undefined) {\n            if (this.m_featureModifiers.find(fm => {\n                return !fm.doProcessLineFeature(layer, env, storageLevel);\n            }) !== undefined) {\n                return;\n            }\n        }\n        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, \"line\"), harp_datasource_protocol_1.GeometryKind.Line);\n        if (techniques.length === 0) {\n            if (this.m_showMissingTechniques) {\n                logger.log(\"OmvDecoder#processLineFeature: no techniques for object:\", JSON.stringify(env.unmap()));\n            }\n            return;\n        }\n        const context = {\n            env,\n            cachedExprResults: new Map()\n        };\n        const featureId = env.lookup(\"$id\");\n        if (this.m_decodedTileEmitter) {\n            this.m_decodedTileEmitter.processLineFeature(layer, extents, geometry, context, techniques, featureId);\n        }\n    }\n    /** @override */\n    processPolygonFeature(layer, extents, geometry, env, storageLevel) {\n        if (this.m_featureModifiers !== undefined) {\n            if (this.m_featureModifiers.find(fm => {\n                return !fm.doProcessPolygonFeature(layer, env, storageLevel);\n            }) !== undefined) {\n                return;\n            }\n        }\n        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, \"polygon\"), harp_datasource_protocol_1.GeometryKind.Area);\n        if (techniques.length === 0) {\n            if (this.m_showMissingTechniques) {\n                logger.log(\"OmvDecoder#processPolygonFeature: no techniques for object:\", JSON.stringify(env.unmap()));\n            }\n            return;\n        }\n        const context = {\n            env,\n            cachedExprResults: new Map()\n        };\n        const featureId = env.lookup(\"$id\");\n        if (this.m_decodedTileEmitter) {\n            this.m_decodedTileEmitter.processPolygonFeature(layer, extents, geometry, context, techniques, featureId);\n        }\n    }\n    applyKindFilter(techniques, defaultKind) {\n        if (this.m_dataFilter !== undefined && this.m_dataFilter.hasKindFilter) {\n            techniques = techniques.filter(technique => {\n                const kind = technique.kind === undefined ? defaultKind : technique.kind;\n                return this.m_dataFilter.wantsKind(kind);\n            });\n        }\n        return techniques;\n    }\n}\nexports.VectorTileDataProcessor = VectorTileDataProcessor;\n/**\n * The vector tile decoder.\n */\nclass VectorTileDecoder extends index_worker_1.ThemedTileDecoder {\n    constructor() {\n        super(...arguments);\n        this.m_showMissingTechniques = false;\n        this.m_gatherFeatureAttributes = false;\n        this.m_skipShortLabels = true;\n        this.m_enableElevationOverlay = false;\n        this.m_roundUpCoordinatesIfNeeded = false;\n    }\n    /** @override */\n    connect() {\n        return Promise.resolve();\n    }\n    /** @override */\n    decodeThemedTile(data, tileKey, styleSetEvaluator, projection) {\n        const startTime = harp_utils_1.PerformanceTimer.now();\n        const decoder = new VectorTileDataProcessor(projection, styleSetEvaluator, this.m_showMissingTechniques, this.m_featureFilter, this.m_featureModifiers, this.m_gatherFeatureAttributes, this.m_skipShortLabels, this.m_storageLevelOffset, this.m_enableElevationOverlay, this.m_roundUpCoordinatesIfNeeded, this.languages);\n        const decodedTile = decoder.getDecodedTile(tileKey, data);\n        decodedTile.decodeTime = harp_utils_1.PerformanceTimer.now() - startTime;\n        return Promise.resolve(decodedTile);\n    }\n    /** @override */\n    configure(options, customOptions) {\n        super.configure(options, customOptions);\n        if (customOptions) {\n            const omvOptions = customOptions;\n            if (omvOptions.showMissingTechniques !== undefined) {\n                this.m_showMissingTechniques = omvOptions.showMissingTechniques === true;\n            }\n            if (omvOptions.filterDescription !== undefined) {\n                if (omvOptions.filterDescription !== null) {\n                    // TODO: Feature modifier is always used only with feature filter.\n                    // At best the filtering feature should be excluded from other feature\n                    // modifiers and be performed solely via OmvGenericFeature modifier or filter.\n                    const filterDescription = omvOptions.filterDescription;\n                    const featureModifiersIds = omvOptions.featureModifiers;\n                    // Create new filter from description.\n                    this.m_featureFilter = new OmvDataFilter_1.OmvGenericFeatureFilter(filterDescription);\n                    // Create feature modifiers.\n                    const featureModifiers = [];\n                    if (featureModifiersIds !== undefined) {\n                        featureModifiersIds.forEach(fmId => {\n                            featureModifiers.push(this.createFeatureModifier(filterDescription, fmId));\n                        });\n                    }\n                    else {\n                        featureModifiers.push(this.createFeatureModifier(filterDescription, OmvDecoderDefs_1.FeatureModifierId.default));\n                    }\n                    this.m_featureModifiers = featureModifiers;\n                }\n                else {\n                    // null is the signal to clear the filter/modifier\n                    this.m_featureFilter = undefined;\n                    this.m_featureModifiers = undefined;\n                }\n            }\n            if (omvOptions.politicalView !== undefined) {\n                const politicalView = omvOptions.politicalView;\n                let featureModifiers = this.m_featureModifiers;\n                // Remove existing political view modifiers, this actually setups default,\n                // commonly accepted point of view - without feature modifier.\n                if (featureModifiers) {\n                    featureModifiers = featureModifiers.filter(fm => !(fm instanceof OmvPoliticalViewFeatureModifier_1.OmvPoliticalViewFeatureModifier));\n                }\n                // If political view is indeed requested append feature modifier at the end of list.\n                if (politicalView.length !== 0) {\n                    harp_utils_1.assert(politicalView.length === 2, \"The political view must be specified as two letters ISO 3166-1 standard!\");\n                    const povFeatureModifier = new OmvPoliticalViewFeatureModifier_1.OmvPoliticalViewFeatureModifier(politicalView);\n                    if (featureModifiers) {\n                        featureModifiers.push(povFeatureModifier);\n                    }\n                    else {\n                        featureModifiers = [povFeatureModifier];\n                    }\n                }\n                // Reset modifiers if nothing was added.\n                this.m_featureModifiers =\n                    featureModifiers && featureModifiers.length > 0 ? featureModifiers : undefined;\n            }\n            if (omvOptions.gatherFeatureAttributes !== undefined) {\n                this.m_gatherFeatureAttributes = omvOptions.gatherFeatureAttributes === true;\n            }\n            if (omvOptions.skipShortLabels !== undefined) {\n                this.m_skipShortLabels = omvOptions.skipShortLabels;\n            }\n            if (omvOptions.enableElevationOverlay !== undefined) {\n                this.m_enableElevationOverlay = omvOptions.enableElevationOverlay;\n            }\n            if (omvOptions.roundUpCoordinatesIfNeeded !== undefined) {\n                this.m_roundUpCoordinatesIfNeeded = omvOptions.roundUpCoordinatesIfNeeded;\n            }\n        }\n        if ((options === null || options === void 0 ? void 0 : options.languages) !== undefined) {\n            this.languages = options.languages;\n        }\n    }\n    createFeatureModifier(filterDescription, featureModifierId) {\n        switch (featureModifierId) {\n            case OmvDecoderDefs_1.FeatureModifierId.default:\n                return new OmvDataFilter_1.OmvGenericFeatureModifier(filterDescription);\n            default:\n                harp_utils_1.assert(!\"Unrecognized feature modifier id, using default!\");\n                return new OmvDataFilter_1.OmvGenericFeatureModifier(filterDescription);\n        }\n    }\n}\nexports.VectorTileDecoder = VectorTileDecoder;\n/**\n * Vector Tile Decoder Service.\n */\nclass VectorTileDecoderService {\n    /**\n     * Register a vector tile decoder service.\n     *\n     * @remarks\n     * Has to be called during initialization of decoder bundle.\n     */\n    static start() {\n        index_worker_1.WorkerServiceManager.getInstance().register({\n            serviceType: OmvDecoderDefs_1.VECTOR_TILE_DECODER_SERVICE_TYPE,\n            factory: (serviceId) => index_worker_1.TileDecoderService.start(serviceId, new VectorTileDecoder())\n        });\n    }\n}\nexports.VectorTileDecoderService = VectorTileDecoderService;\n//# sourceMappingURL=VectorTileDecoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDecoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson-vt/GeoJsonVtDataAdapter.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson-vt/GeoJsonVtDataAdapter.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoJsonVtDataAdapter = exports.VTJsonDataAdapterId = void 0;\nconst index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ \"./node_modules/@here/harp-datasource-protocol/index-decoder.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst OmvUtils_1 = __webpack_require__(/*! ../../OmvUtils */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js\");\nconst VT_JSON_EXTENTS = 4096;\nvar VTJsonGeometryType;\n(function (VTJsonGeometryType) {\n    VTJsonGeometryType[VTJsonGeometryType[\"Unknown\"] = 0] = \"Unknown\";\n    VTJsonGeometryType[VTJsonGeometryType[\"Point\"] = 1] = \"Point\";\n    VTJsonGeometryType[VTJsonGeometryType[\"LineString\"] = 2] = \"LineString\";\n    VTJsonGeometryType[VTJsonGeometryType[\"Polygon\"] = 3] = \"Polygon\";\n})(VTJsonGeometryType || (VTJsonGeometryType = {}));\nconst worldPos = new three_1.Vector3();\n/**\n * Unique ID of {@link VTJsonDataAdapter}.\n */\nexports.VTJsonDataAdapterId = \"vt-json\";\n/**\n * The class `GeoJsonVtDataAdapter` converts VT-json data to geometries for the given\n * {@link IGeometryProcessor}.\n */\nclass GeoJsonVtDataAdapter {\n    constructor(m_processor, m_dataFilter, m_logger) {\n        this.m_processor = m_processor;\n        this.m_dataFilter = m_dataFilter;\n        this.m_logger = m_logger;\n        this.id = exports.VTJsonDataAdapterId;\n    }\n    get dataFilter() {\n        return this.m_dataFilter;\n    }\n    set dataFilter(dataFilter) {\n        this.m_dataFilter = dataFilter;\n    }\n    canProcess(data) {\n        if (OmvUtils_1.isArrayBufferLike(data)) {\n            return false;\n        }\n        const tile = data;\n        if (tile.features === undefined ||\n            tile.source === undefined ||\n            tile.x === undefined ||\n            tile.y === undefined ||\n            tile.z === undefined) {\n            return false;\n        }\n        return true;\n    }\n    process(tile, decodeInfo) {\n        var _a;\n        const { tileKey } = decodeInfo;\n        for (const feature of tile.features) {\n            const env = new index_decoder_1.MapEnv(Object.assign({ $layer: tile.layer, $geometryType: this.convertGeometryType(feature.type), $level: tileKey.level, $zoom: Math.max(0, tileKey.level - ((_a = this.m_processor.storageLevelOffset) !== null && _a !== void 0 ? _a : 0)), $id: feature.id }, feature.tags));\n            switch (feature.type) {\n                case VTJsonGeometryType.Point: {\n                    for (const pointGeometry of feature.geometry) {\n                        const x = pointGeometry[0];\n                        const y = pointGeometry[1];\n                        const position = new three_1.Vector3(x, y, 0);\n                        this.m_processor.processPointFeature(tile.layer, VT_JSON_EXTENTS, [position], env, tileKey.level);\n                    }\n                    break;\n                }\n                case VTJsonGeometryType.LineString: {\n                    const lineGeometries = feature.geometry;\n                    let lastLine;\n                    const lines = [];\n                    lineGeometries.forEach(lineGeometry => {\n                        const lastPos = lastLine === null || lastLine === void 0 ? void 0 : lastLine.positions[lastLine.positions.length - 1];\n                        const [startx, starty] = lineGeometry[0];\n                        if ((lastPos === null || lastPos === void 0 ? void 0 : lastPos.x) === startx && (lastPos === null || lastPos === void 0 ? void 0 : lastPos.y) === starty) {\n                            // continue the last line\n                            for (let i = 1; i < lineGeometry.length; ++i) {\n                                const [x, y] = lineGeometry[i];\n                                lastLine === null || lastLine === void 0 ? void 0 : lastLine.positions.push(new three_1.Vector2(x, y));\n                            }\n                        }\n                        else {\n                            // start a new line\n                            const positions = lineGeometry.map(([x, y]) => new three_1.Vector2(x, y));\n                            lines.push({ positions });\n                            lastLine = lines[lines.length - 1];\n                        }\n                    });\n                    lines.forEach(line => {\n                        line.untiledPositions = line.positions.map(tilePos => {\n                            OmvUtils_1.tile2world(VT_JSON_EXTENTS, decodeInfo, tilePos, false, worldPos);\n                            return harp_geoutils_1.webMercatorProjection.unprojectPoint(worldPos);\n                        });\n                    });\n                    this.m_processor.processLineFeature(tile.layer, VT_JSON_EXTENTS, lines, env, tileKey.level);\n                    break;\n                }\n                case VTJsonGeometryType.Polygon: {\n                    const polygon = { rings: [] };\n                    for (const outline of feature.geometry) {\n                        const ring = [];\n                        for (const [currX, currY] of outline) {\n                            const position = new three_1.Vector2(currX, currY);\n                            ring.push(position);\n                        }\n                        polygon.rings.push(ring);\n                    }\n                    this.m_processor.processPolygonFeature(tile.layer, VT_JSON_EXTENTS, [polygon], env, tileKey.level);\n                    break;\n                }\n                case VTJsonGeometryType.Unknown: {\n                    break;\n                }\n            }\n        }\n    }\n    convertGeometryType(type) {\n        switch (type) {\n            case VTJsonGeometryType.Point:\n                return \"point\";\n            case VTJsonGeometryType.LineString:\n                return \"line\";\n            case VTJsonGeometryType.Polygon:\n                return \"polygon\";\n            default:\n                return \"unknown\";\n        }\n    }\n}\nexports.GeoJsonVtDataAdapter = GeoJsonVtDataAdapter;\n//# sourceMappingURL=GeoJsonVtDataAdapter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson-vt/GeoJsonVtDataAdapter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson/GeoJsonDataAdapter.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson/GeoJsonDataAdapter.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoJsonDataAdapter = void 0;\nconst Env_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst ClipLineString_1 = __webpack_require__(/*! @here/harp-geometry/lib/ClipLineString */ \"./node_modules/@here/harp-geometry/lib/ClipLineString.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst OmvUtils_1 = __webpack_require__(/*! ../../OmvUtils */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js\");\nconst DEFAULT_EXTENTS = 4 * 1024;\nfunction convertGeometryType(type) {\n    switch (type) {\n        case \"LineString\":\n            return \"line\";\n        case \"MultiLineString\":\n            return \"line\";\n        case \"Polygon\":\n            return \"polygon\";\n        case \"MultiPolygon\":\n            return \"polygon\";\n        case \"Point\":\n            return \"point\";\n        case \"MultiPoint\":\n            return \"point\";\n        default:\n            return \"unknown\";\n    } // switch\n}\nconst worldP = new three_1.Vector3();\n/**\n * Converts a `geoPoint` to local tile space.\n *\n * @param geoPoint - The input [[GeoPointLike]].\n * @param decodeInfo - The [[DecodeInfo]].\n * @param target - A [[VectorLike]] used as target of the converted coordinates.\n * @return A [[VectorLike]] with the converted point.\n * @hidden\n */\nfunction convertPoint(geoPoint, decodeInfo, target) {\n    harp_geoutils_1.webMercatorProjection.projectPoint(harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint), worldP);\n    return OmvUtils_1.world2tile(DEFAULT_EXTENTS, decodeInfo, worldP, false, target);\n}\nfunction convertLineStringGeometry(coordinates, decodeInfo) {\n    const untiledPositions = coordinates.map(geoPoint => {\n        return harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint);\n    });\n    const positions = coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new three_1.Vector2()));\n    return { untiledPositions, positions };\n}\nfunction convertLineGeometry(geometry, decodeInfo) {\n    if (geometry.type === \"LineString\") {\n        return [convertLineStringGeometry(geometry.coordinates, decodeInfo)];\n    }\n    return geometry.coordinates.map(lineString => convertLineStringGeometry(lineString, decodeInfo));\n}\nfunction signedPolygonArea(contour) {\n    const n = contour.length;\n    let area = 0.0;\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n        area += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];\n    }\n    return area * 0.5;\n}\nfunction convertRings(coordinates, decodeInfo) {\n    let outerWinding;\n    const rings = coordinates.map((ring, i) => {\n        const { positions } = convertLineStringGeometry(ring, decodeInfo);\n        const winding = signedPolygonArea(ring) < 0;\n        if (i === 0) {\n            outerWinding = winding;\n        }\n        else if (winding === outerWinding) {\n            positions.reverse();\n        }\n        return positions;\n    });\n    return { rings };\n}\nfunction convertPolygonGeometry(geometry, decodeInfo) {\n    if (geometry.type === \"Polygon\") {\n        return [convertRings(geometry.coordinates, decodeInfo)];\n    }\n    return geometry.coordinates.map(polygon => convertRings(polygon, decodeInfo));\n}\nfunction convertPointGeometry(geometry, decodeInfo) {\n    if (geometry.type === \"Point\") {\n        return [convertPoint(geometry.coordinates, decodeInfo, new three_1.Vector3())];\n    }\n    return geometry.coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new three_1.Vector3()));\n}\nclass GeoJsonDataAdapter {\n    constructor(m_processor, dataFilter, m_logger) {\n        this.m_processor = m_processor;\n        this.dataFilter = dataFilter;\n        this.m_logger = m_logger;\n        this.id = \"GeoJsonDataAdapter\";\n    }\n    canProcess(featureCollection) {\n        return (featureCollection &&\n            featureCollection.type === \"FeatureCollection\" &&\n            Array.isArray(featureCollection.features));\n    }\n    process(featureCollection, decodeInfo) {\n        var _a;\n        if (!Array.isArray(featureCollection.features) || featureCollection.features.length === 0) {\n            return;\n        }\n        const { tileKey } = decodeInfo;\n        const $level = tileKey.level;\n        const $zoom = Math.max(0, tileKey.level - ((_a = this.m_processor.storageLevelOffset) !== null && _a !== void 0 ? _a : 0));\n        const $layer = \"geojson\";\n        for (const feature of featureCollection.features) {\n            const $geometryType = convertGeometryType(feature.geometry.type);\n            const env = new Env_1.MapEnv(Object.assign(Object.assign({}, feature.properties), { $layer,\n                $level,\n                $zoom,\n                $geometryType }));\n            switch (feature.geometry.type) {\n                case \"LineString\":\n                case \"MultiLineString\": {\n                    let geometry = convertLineGeometry(feature.geometry, decodeInfo);\n                    const clippedGeometries = [];\n                    const DEFAULT_BORDER = 100;\n                    geometry.forEach(g => {\n                        const clipped = ClipLineString_1.clipLineString(g.positions, -DEFAULT_BORDER, -DEFAULT_BORDER, DEFAULT_EXTENTS + DEFAULT_BORDER, DEFAULT_EXTENTS + DEFAULT_BORDER);\n                        clipped.forEach(positions => {\n                            clippedGeometries.push({ positions });\n                        });\n                    });\n                    geometry = clippedGeometries;\n                    if (geometry.length > 0) {\n                        this.m_processor.processLineFeature($layer, DEFAULT_EXTENTS, clippedGeometries, env, $level);\n                    }\n                    break;\n                }\n                case \"Polygon\":\n                case \"MultiPolygon\": {\n                    const geometry = convertPolygonGeometry(feature.geometry, decodeInfo);\n                    this.m_processor.processPolygonFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);\n                    break;\n                }\n                case \"Point\":\n                case \"MultiPoint\": {\n                    const geometry = convertPointGeometry(feature.geometry, decodeInfo);\n                    this.m_processor.processPointFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);\n                    break;\n                }\n            }\n        }\n    }\n}\nexports.GeoJsonDataAdapter = GeoJsonDataAdapter;\n//# sourceMappingURL=GeoJsonDataAdapter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/adapters/geojson/GeoJsonDataAdapter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvData.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvData.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeometryCommands = exports.FeatureAttributes = exports.visitOmvLayer = exports.visitOmv = exports.isClosePathCommand = exports.isLineToCommand = exports.isMoveToCommand = exports.CommandKind = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst vector_tile_1 = __webpack_require__(/*! ./proto/vector_tile */ \"./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/proto/vector_tile.js\");\n/**\n * @hidden\n */\nvar CommandKind;\n(function (CommandKind) {\n    CommandKind[CommandKind[\"MoveTo\"] = 1] = \"MoveTo\";\n    CommandKind[CommandKind[\"LineTo\"] = 2] = \"LineTo\";\n    CommandKind[CommandKind[\"ClosePath\"] = 7] = \"ClosePath\";\n})(CommandKind = exports.CommandKind || (exports.CommandKind = {}));\n/**\n * @hidden\n */\nfunction isMoveToCommand(command) {\n    return command.kind === CommandKind.MoveTo;\n}\nexports.isMoveToCommand = isMoveToCommand;\n/**\n * @hidden\n */\nfunction isLineToCommand(command) {\n    return command.kind === CommandKind.LineTo;\n}\nexports.isLineToCommand = isLineToCommand;\n/**\n * @hidden\n */\nfunction isClosePathCommand(command) {\n    return command.kind === CommandKind.ClosePath;\n}\nexports.isClosePathCommand = isClosePathCommand;\n/**\n * @hidden\n */\nfunction visitOmv(vectorTile, visitor) {\n    if (!vectorTile.layers) {\n        return;\n    }\n    for (const layer of vectorTile.layers) {\n        if (!visitor.visitLayer || visitor.visitLayer(layer)) {\n            visitOmvLayer(layer, visitor);\n        }\n        if (visitor.endVisitLayer) {\n            visitor.endVisitLayer(layer);\n        }\n    }\n}\nexports.visitOmv = visitOmv;\n/**\n * @hidden\n */\nfunction visitOmvLayer(layer, visitor) {\n    if (!visitor.visitLayer || visitor.visitLayer(layer)) {\n        if (layer.features) {\n            for (const feature of layer.features) {\n                switch (feature.type) {\n                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.UNKNOWN:\n                        break;\n                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.POINT:\n                        if (visitor.visitPointFeature) {\n                            visitor.visitPointFeature(feature);\n                        }\n                        break;\n                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.LINESTRING:\n                        if (visitor.visitLineFeature) {\n                            visitor.visitLineFeature(feature);\n                        }\n                        break;\n                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.POLYGON:\n                        if (visitor.visitPolygonFeature) {\n                            visitor.visitPolygonFeature(feature);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    if (visitor.endVisitLayer) {\n        visitor.endVisitLayer(layer);\n    }\n}\nexports.visitOmvLayer = visitOmvLayer;\n/**\n * @hidden\n */\nclass FeatureAttributes {\n    accept(layer, feature, visitor) {\n        const { keys, values } = layer;\n        const tags = feature.tags;\n        if (!tags || !keys || !values) {\n            return;\n        }\n        for (let i = 0; i < tags.length; i += 2) {\n            const key = keys[tags[i]];\n            const value = values[tags[i + 1]];\n            if (!visitor.visitAttribute(key, value)) {\n                break;\n            }\n        }\n    }\n}\nexports.FeatureAttributes = FeatureAttributes;\n/**\n * @hidden\n */\nclass GeometryCommands {\n    accept(geometry, visitor) {\n        if (!geometry) {\n            return;\n        }\n        const geometryCount = geometry.length;\n        let currX = 0;\n        let currY = 0;\n        const xCoords = [];\n        const yCoords = [];\n        const commands = [];\n        for (let cmdIndex = 0; cmdIndex < geometryCount;) {\n            const kind = (geometry[cmdIndex] & 0x7);\n            const count = geometry[cmdIndex] >> 0x3;\n            ++cmdIndex;\n            if (kind === CommandKind.MoveTo || kind === CommandKind.LineTo) {\n                for (let n = 0; n < count; ++n) {\n                    const xx = geometry[cmdIndex++];\n                    const yy = geometry[cmdIndex++];\n                    currX += (xx >> 1) ^ -(xx & 1);\n                    currY += (yy >> 1) ^ -(yy & 1);\n                    if (visitor.type === \"Polygon\") {\n                        xCoords.push(currX);\n                        yCoords.push(currY);\n                    }\n                    const position = new three_1.Vector2(currX, currY);\n                    commands.push({ kind, position });\n                }\n            }\n            else {\n                for (const command of commands) {\n                    visitor.visitCommand(command);\n                }\n                visitor.visitCommand({ kind });\n                xCoords.length = 0;\n                yCoords.length = 0;\n                commands.length = 0;\n            }\n        }\n        if (commands.length > 0) {\n            for (const command of commands) {\n                visitor.visitCommand(command);\n            }\n        }\n    }\n}\nexports.GeometryCommands = GeometryCommands;\n//# sourceMappingURL=OmvData.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvData.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvDataAdapter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvDataAdapter.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvDataAdapter = exports.asGeometryType = exports.createFeatureEnv = void 0;\nconst index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ \"./node_modules/@here/harp-datasource-protocol/index-decoder.js\");\nconst Long = __webpack_require__(/*! long */ \"./node_modules/long/src/long.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ../../OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\nconst OmvUtils_1 = __webpack_require__(/*! ../../OmvUtils */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvUtils.js\");\nconst OmvData_1 = __webpack_require__(/*! ./OmvData */ \"./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvData.js\");\nconst vector_tile_1 = __webpack_require__(/*! ./proto/vector_tile */ \"./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/proto/vector_tile.js\");\nconst propertyCategories = [\n    \"stringValue\",\n    \"floatValue\",\n    \"doubleValue\",\n    \"intValue\",\n    \"uintValue\",\n    \"sintValue\",\n    \"boolValue\"\n];\nfunction simplifiedValue(value) {\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    for (const category of propertyCategories) {\n        if (hasOwnProperty.call(value, category)) {\n            const v = value[category];\n            if (v === undefined) {\n                throw new Error(\"unpexted undefined value\");\n            }\n            return Long.isLong(v) ? v.toNumber() : v;\n        }\n    }\n    throw new Error(\"not happening\");\n}\nfunction replaceReservedName(name) {\n    switch (name) {\n        case \"id\":\n            return \"$id\";\n        default:\n            return name;\n    } // switch\n}\nfunction decodeFeatureId(feature, logger) {\n    if (feature.hasOwnProperty(\"id\")) {\n        const id = feature.id;\n        if (typeof id === \"number\") {\n            return id;\n        }\n        else if (id) {\n            if (logger !== undefined && id.greaterThan(Number.MAX_SAFE_INTEGER)) {\n                logger.error(\"Invalid ID: Larger than largest available Number in feature: \", feature);\n            }\n            return id.toNumber();\n        }\n    }\n    return undefined;\n}\nfunction readAttributes(layer, feature, defaultAttributes = {}) {\n    const attrs = new OmvData_1.FeatureAttributes();\n    const attributes = defaultAttributes || {};\n    attrs.accept(layer, feature, {\n        visitAttribute: (name, value) => {\n            attributes[replaceReservedName(name)] = simplifiedValue(value);\n            return true;\n        }\n    });\n    return attributes;\n}\nfunction createFeatureEnv(layer, feature, geometryType, storageLevel, storageLevelOffset, logger, parent) {\n    const attributes = {\n        $layer: layer.name,\n        $level: storageLevel,\n        $zoom: Math.max(0, storageLevel - (storageLevelOffset !== null && storageLevelOffset !== void 0 ? storageLevelOffset : 0)),\n        $geometryType: geometryType\n    };\n    // Some sources serve `id` directly as `IFeature` property ...\n    const featureId = decodeFeatureId(feature, logger);\n    if (featureId !== undefined) {\n        attributes.$id = featureId;\n    }\n    readAttributes(layer, feature, attributes);\n    return new index_decoder_1.MapEnv(attributes, parent);\n}\nexports.createFeatureEnv = createFeatureEnv;\nfunction asGeometryType(feature) {\n    if (feature === undefined) {\n        return OmvDecoderDefs_1.OmvGeometryType.UNKNOWN;\n    }\n    switch (feature.type) {\n        case vector_tile_1.com.mapbox.pb.Tile.GeomType.UNKNOWN:\n            return OmvDecoderDefs_1.OmvGeometryType.UNKNOWN;\n        case vector_tile_1.com.mapbox.pb.Tile.GeomType.POINT:\n            return OmvDecoderDefs_1.OmvGeometryType.POINT;\n        case vector_tile_1.com.mapbox.pb.Tile.GeomType.LINESTRING:\n            return OmvDecoderDefs_1.OmvGeometryType.LINESTRING;\n        case vector_tile_1.com.mapbox.pb.Tile.GeomType.POLYGON:\n            return OmvDecoderDefs_1.OmvGeometryType.POLYGON;\n        default:\n            return OmvDecoderDefs_1.OmvGeometryType.UNKNOWN;\n    } // switch\n}\nexports.asGeometryType = asGeometryType;\n// Ensures ring winding follows Mapbox Vector Tile specification: outer rings must be clockwise,\n// inner rings counter-clockwise.\nfunction checkWinding(multipolygon) {\n    if (multipolygon.length === 0) {\n        return;\n    }\n    const firstPolygon = multipolygon[0];\n    if (firstPolygon.rings.length === 0) {\n        return;\n    }\n    // Opposite sign to ShapeUtils.isClockWise, since webMercator tile space has top-left origin.\n    const isOuterRingClockWise = three_1.ShapeUtils.area(firstPolygon.rings[0]) > 0;\n    if (isOuterRingClockWise) {\n        return;\n    }\n    for (const polygon of multipolygon) {\n        for (const ring of polygon.rings) {\n            ring.reverse();\n        }\n    }\n}\nfunction roundUpCoordinates(coordinates, layerExtents) {\n    coordinates.forEach(p => {\n        if (p.x === layerExtents - 1) {\n            p.x = layerExtents;\n        }\n    });\n}\nfunction roundUpPolygonCoordinates(geometry, layerExtents) {\n    geometry.forEach(polygon => polygon.rings.forEach(r => roundUpCoordinates(r, layerExtents)));\n}\nfunction roundUpLineCoordinates(geometry, layerExtents) {\n    geometry.forEach(line => roundUpCoordinates(line.positions, layerExtents));\n}\n/**\n * The class `OmvDataAdapter` converts OMV protobuf geo data\n * to geometries for the given `IGeometryProcessor`.\n */\nclass OmvDataAdapter {\n    /**\n     * Constructs a new [[OmvProtobufDataAdapter]].\n     *\n     * @param processor - The [[IGeometryProcessor]] used to process the data.\n     * @param dataFilter - The [[OmvFeatureFilter]] used to filter features.\n     * @param logger - The [[ILogger]] used to log diagnostic messages.\n     */\n    constructor(processor, dataFilter, logger) {\n        this.id = \"omv-protobuf\";\n        this.m_geometryCommands = new OmvData_1.GeometryCommands();\n        this.roundUpCoordinatesIfNeeded = false;\n        this.m_processor = processor;\n        this.m_dataFilter = dataFilter;\n        this.m_logger = logger;\n    }\n    /**\n     * The [[OmvFeatureFilter]] used to filter features.\n     */\n    get dataFilter() {\n        return this.m_dataFilter;\n    }\n    /**\n     * The [[OmvFeatureFilter]] used to filter features.\n     */\n    set dataFilter(dataFilter) {\n        this.m_dataFilter = dataFilter;\n    }\n    /**\n     * Checks that the given data can be processed by this [[OmvProtobufDataAdapter]].\n     */\n    canProcess(data) {\n        return OmvUtils_1.isArrayBufferLike(data);\n    }\n    /**\n     * Processes the given data payload using this adapter's [[IGeometryProcessor]].\n     *\n     * @param data - The data payload to process.\n     * @param decodeInfo - The [[DecodedInfo]] of the tile to proceess.\n     */\n    process(data, decodeInfo) {\n        const { tileKey } = decodeInfo;\n        const payload = new Uint8Array(data);\n        const proto = vector_tile_1.com.mapbox.pb.Tile.decode(payload);\n        this.m_tileKey = tileKey;\n        OmvData_1.visitOmv(proto, this);\n    }\n    /**\n     * Visits the OMV layer.\n     *\n     * @param layer - The OMV layer to process.\n     */\n    visitLayer(layer) {\n        this.m_layer = layer;\n        const storageLevel = this.m_tileKey.level;\n        const layerName = layer.name;\n        if (this.m_dataFilter !== undefined &&\n            !this.m_dataFilter.wantsLayer(layerName, storageLevel)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Visits point features.\n     *\n     * @param feature - The OMV point features to process.\n     */\n    visitPointFeature(feature) {\n        var _a;\n        if (feature.geometry === undefined) {\n            return;\n        }\n        const storageLevel = this.m_tileKey.level;\n        const layerName = this.m_layer.name;\n        const layerExtents = (_a = this.m_layer.extent) !== null && _a !== void 0 ? _a : 4096;\n        if (this.m_dataFilter !== undefined &&\n            !this.m_dataFilter.wantsPointFeature(layerName, asGeometryType(feature), storageLevel)) {\n            return;\n        }\n        const geometry = [];\n        this.m_geometryCommands.accept(feature.geometry, {\n            type: \"Point\",\n            visitCommand: command => {\n                if (OmvData_1.isMoveToCommand(command)) {\n                    geometry.push(new three_1.Vector3(command.position.x, command.position.y, 0));\n                }\n            }\n        });\n        if (geometry.length === 0) {\n            return;\n        }\n        const env = createFeatureEnv(this.m_layer, feature, \"point\", storageLevel, this.m_processor.storageLevelOffset, this.m_logger);\n        this.m_processor.processPointFeature(layerName, layerExtents, geometry, env, storageLevel);\n    }\n    /**\n     * Visits the line features.\n     *\n     * @param feature - The line features to process.\n     */\n    visitLineFeature(feature) {\n        var _a;\n        if (feature.geometry === undefined) {\n            return;\n        }\n        const storageLevel = this.m_tileKey.level;\n        const layerName = this.m_layer.name;\n        const layerExtents = (_a = this.m_layer.extent) !== null && _a !== void 0 ? _a : 4096;\n        if (this.m_dataFilter !== undefined &&\n            !this.m_dataFilter.wantsLineFeature(layerName, asGeometryType(feature), storageLevel)) {\n            return;\n        }\n        const geometry = [];\n        let positions;\n        this.m_geometryCommands.accept(feature.geometry, {\n            type: \"Line\",\n            visitCommand: command => {\n                if (OmvData_1.isMoveToCommand(command)) {\n                    positions = [command.position];\n                    geometry.push({ positions });\n                }\n                else if (OmvData_1.isLineToCommand(command)) {\n                    positions.push(command.position);\n                }\n            }\n        });\n        if (geometry.length === 0) {\n            return;\n        }\n        if (this.mustRoundUpCoordinates) {\n            roundUpLineCoordinates(geometry, layerExtents);\n        }\n        const env = createFeatureEnv(this.m_layer, feature, \"line\", storageLevel, this.m_processor.storageLevelOffset, this.m_logger);\n        this.m_processor.processLineFeature(layerName, layerExtents, geometry, env, storageLevel);\n    }\n    /**\n     * Visits the polygon features.\n     *\n     * @param feature - The polygon features to process.\n     */\n    visitPolygonFeature(feature) {\n        var _a;\n        if (feature.geometry === undefined) {\n            return;\n        }\n        const storageLevel = this.m_tileKey.level;\n        const layerName = this.m_layer.name;\n        const layerExtents = (_a = this.m_layer.extent) !== null && _a !== void 0 ? _a : 4096;\n        if (this.m_dataFilter !== undefined &&\n            !this.m_dataFilter.wantsPolygonFeature(layerName, asGeometryType(feature), storageLevel)) {\n            return;\n        }\n        const geometry = [];\n        const currentPolygon = { rings: [] };\n        let currentRing;\n        this.m_geometryCommands.accept(feature.geometry, {\n            type: \"Polygon\",\n            visitCommand: command => {\n                if (OmvData_1.isMoveToCommand(command)) {\n                    currentRing = [command.position];\n                }\n                else if (OmvData_1.isLineToCommand(command)) {\n                    currentRing.push(command.position);\n                }\n                else if (OmvData_1.isClosePathCommand(command)) {\n                    if (currentRing !== undefined && currentRing.length > 0) {\n                        currentRing.push(currentRing[0].clone());\n                        currentPolygon.rings.push(currentRing);\n                    }\n                }\n            }\n        });\n        if (currentPolygon.rings.length > 0) {\n            geometry.push(currentPolygon);\n        }\n        if (geometry.length === 0) {\n            return;\n        }\n        if (this.mustRoundUpCoordinates) {\n            roundUpPolygonCoordinates(geometry, layerExtents);\n        }\n        checkWinding(geometry);\n        const env = createFeatureEnv(this.m_layer, feature, \"polygon\", storageLevel, this.m_processor.storageLevelOffset, this.m_logger);\n        this.m_processor.processPolygonFeature(layerName, layerExtents, geometry, env, storageLevel);\n    }\n    get mustRoundUpCoordinates() {\n        return (this.roundUpCoordinatesIfNeeded &&\n            this.m_tileKey.level < 5 &&\n            this.m_tileKey.column === this.m_tileKey.columnCount() - 1);\n    }\n}\nexports.OmvDataAdapter = OmvDataAdapter;\n//# sourceMappingURL=OmvDataAdapter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/OmvDataAdapter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/proto/vector_tile.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/proto/vector_tile.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n\nvar $protobuf = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.com = (function() {\n\n    /**\n     * Namespace com.\n     * @exports com\n     * @namespace\n     */\n    var com = {};\n\n    com.mapbox = (function() {\n\n        /**\n         * Namespace mapbox.\n         * @memberof com\n         * @namespace\n         */\n        var mapbox = {};\n\n        mapbox.pb = (function() {\n\n            /**\n             * Namespace pb.\n             * @memberof com.mapbox\n             * @namespace\n             */\n            var pb = {};\n\n            pb.Tile = (function() {\n\n                /**\n                 * Properties of a Tile.\n                 * @memberof com.mapbox.pb\n                 * @interface ITile\n                 * @property {Array.<com.mapbox.pb.Tile.ILayer>|null} [layers] Tile layers\n                 */\n\n                /**\n                 * Constructs a new Tile.\n                 * @memberof com.mapbox.pb\n                 * @classdesc Represents a Tile.\n                 * @implements ITile\n                 * @constructor\n                 * @param {com.mapbox.pb.ITile=} [properties] Properties to set\n                 */\n                function Tile(properties) {\n                    this.layers = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Tile layers.\n                 * @member {Array.<com.mapbox.pb.Tile.ILayer>} layers\n                 * @memberof com.mapbox.pb.Tile\n                 * @instance\n                 */\n                Tile.prototype.layers = $util.emptyArray;\n\n                /**\n                 * Decodes a Tile message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {com.mapbox.pb.Tile} Tile\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Tile.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 3:\n                            if (!(message.layers && message.layers.length))\n                                message.layers = [];\n                            message.layers.push($root.com.mapbox.pb.Tile.Layer.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Tile message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {com.mapbox.pb.Tile} Tile\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Tile.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Creates a Tile message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {com.mapbox.pb.Tile} Tile\n                 */\n                Tile.fromObject = function fromObject(object) {\n                    if (object instanceof $root.com.mapbox.pb.Tile)\n                        return object;\n                    var message = new $root.com.mapbox.pb.Tile();\n                    if (object.layers) {\n                        if (!Array.isArray(object.layers))\n                            throw TypeError(\".com.mapbox.pb.Tile.layers: array expected\");\n                        message.layers = [];\n                        for (var i = 0; i < object.layers.length; ++i) {\n                            if (typeof object.layers[i] !== \"object\")\n                                throw TypeError(\".com.mapbox.pb.Tile.layers: object expected\");\n                            message.layers[i] = $root.com.mapbox.pb.Tile.Layer.fromObject(object.layers[i]);\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Creates a plain object from a Tile message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {com.mapbox.pb.Tile} message Tile\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                Tile.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.arrays || options.defaults)\n                        object.layers = [];\n                    if (message.layers && message.layers.length) {\n                        object.layers = [];\n                        for (var j = 0; j < message.layers.length; ++j)\n                            object.layers[j] = $root.com.mapbox.pb.Tile.Layer.toObject(message.layers[j], options);\n                    }\n                    return object;\n                };\n\n                /**\n                 * Converts this Tile to JSON.\n                 * @function toJSON\n                 * @memberof com.mapbox.pb.Tile\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                Tile.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n\n                /**\n                 * GeomType enum.\n                 * @name com.mapbox.pb.Tile.GeomType\n                 * @enum {number}\n                 * @property {number} UNKNOWN=0 UNKNOWN value\n                 * @property {number} POINT=1 POINT value\n                 * @property {number} LINESTRING=2 LINESTRING value\n                 * @property {number} POLYGON=3 POLYGON value\n                 */\n                Tile.GeomType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"UNKNOWN\"] = 0;\n                    values[valuesById[1] = \"POINT\"] = 1;\n                    values[valuesById[2] = \"LINESTRING\"] = 2;\n                    values[valuesById[3] = \"POLYGON\"] = 3;\n                    return values;\n                })();\n\n                Tile.Value = (function() {\n\n                    /**\n                     * Properties of a Value.\n                     * @memberof com.mapbox.pb.Tile\n                     * @interface IValue\n                     * @property {string|null} [stringValue] Value stringValue\n                     * @property {number|null} [floatValue] Value floatValue\n                     * @property {number|null} [doubleValue] Value doubleValue\n                     * @property {number|Long|null} [intValue] Value intValue\n                     * @property {number|Long|null} [uintValue] Value uintValue\n                     * @property {number|Long|null} [sintValue] Value sintValue\n                     * @property {boolean|null} [boolValue] Value boolValue\n                     */\n\n                    /**\n                     * Constructs a new Value.\n                     * @memberof com.mapbox.pb.Tile\n                     * @classdesc Represents a Value.\n                     * @implements IValue\n                     * @constructor\n                     * @param {com.mapbox.pb.Tile.IValue=} [properties] Properties to set\n                     */\n                    function Value(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Value stringValue.\n                     * @member {string} stringValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.stringValue = \"\";\n\n                    /**\n                     * Value floatValue.\n                     * @member {number} floatValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.floatValue = 0;\n\n                    /**\n                     * Value doubleValue.\n                     * @member {number} doubleValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.doubleValue = 0;\n\n                    /**\n                     * Value intValue.\n                     * @member {number|Long} intValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.intValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                    /**\n                     * Value uintValue.\n                     * @member {number|Long} uintValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.uintValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                    /**\n                     * Value sintValue.\n                     * @member {number|Long} sintValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.sintValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                    /**\n                     * Value boolValue.\n                     * @member {boolean} boolValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.boolValue = false;\n\n                    /**\n                     * Decodes a Value message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {com.mapbox.pb.Tile.Value} Value\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Value.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile.Value();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.stringValue = reader.string();\n                                break;\n                            case 2:\n                                message.floatValue = reader.float();\n                                break;\n                            case 3:\n                                message.doubleValue = reader.double();\n                                break;\n                            case 4:\n                                message.intValue = reader.int64();\n                                break;\n                            case 5:\n                                message.uintValue = reader.uint64();\n                                break;\n                            case 6:\n                                message.sintValue = reader.sint64();\n                                break;\n                            case 7:\n                                message.boolValue = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Value message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {com.mapbox.pb.Tile.Value} Value\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Value.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Creates a Value message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {com.mapbox.pb.Tile.Value} Value\n                     */\n                    Value.fromObject = function fromObject(object) {\n                        if (object instanceof $root.com.mapbox.pb.Tile.Value)\n                            return object;\n                        var message = new $root.com.mapbox.pb.Tile.Value();\n                        if (object.stringValue != null)\n                            message.stringValue = String(object.stringValue);\n                        if (object.floatValue != null)\n                            message.floatValue = Number(object.floatValue);\n                        if (object.doubleValue != null)\n                            message.doubleValue = Number(object.doubleValue);\n                        if (object.intValue != null)\n                            if ($util.Long)\n                                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;\n                            else if (typeof object.intValue === \"string\")\n                                message.intValue = parseInt(object.intValue, 10);\n                            else if (typeof object.intValue === \"number\")\n                                message.intValue = object.intValue;\n                            else if (typeof object.intValue === \"object\")\n                                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();\n                        if (object.uintValue != null)\n                            if ($util.Long)\n                                (message.uintValue = $util.Long.fromValue(object.uintValue)).unsigned = true;\n                            else if (typeof object.uintValue === \"string\")\n                                message.uintValue = parseInt(object.uintValue, 10);\n                            else if (typeof object.uintValue === \"number\")\n                                message.uintValue = object.uintValue;\n                            else if (typeof object.uintValue === \"object\")\n                                message.uintValue = new $util.LongBits(object.uintValue.low >>> 0, object.uintValue.high >>> 0).toNumber(true);\n                        if (object.sintValue != null)\n                            if ($util.Long)\n                                (message.sintValue = $util.Long.fromValue(object.sintValue)).unsigned = false;\n                            else if (typeof object.sintValue === \"string\")\n                                message.sintValue = parseInt(object.sintValue, 10);\n                            else if (typeof object.sintValue === \"number\")\n                                message.sintValue = object.sintValue;\n                            else if (typeof object.sintValue === \"object\")\n                                message.sintValue = new $util.LongBits(object.sintValue.low >>> 0, object.sintValue.high >>> 0).toNumber();\n                        if (object.boolValue != null)\n                            message.boolValue = Boolean(object.boolValue);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Value message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {com.mapbox.pb.Tile.Value} message Value\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Value.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.stringValue = \"\";\n                            object.floatValue = 0;\n                            object.doubleValue = 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.intValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.intValue = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, true);\n                                object.uintValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.uintValue = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.sintValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.sintValue = options.longs === String ? \"0\" : 0;\n                            object.boolValue = false;\n                        }\n                        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\"))\n                            object.stringValue = message.stringValue;\n                        if (message.floatValue != null && message.hasOwnProperty(\"floatValue\"))\n                            object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;\n                        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\"))\n                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;\n                        if (message.intValue != null && message.hasOwnProperty(\"intValue\"))\n                            if (typeof message.intValue === \"number\")\n                                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;\n                            else\n                                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;\n                        if (message.uintValue != null && message.hasOwnProperty(\"uintValue\"))\n                            if (typeof message.uintValue === \"number\")\n                                object.uintValue = options.longs === String ? String(message.uintValue) : message.uintValue;\n                            else\n                                object.uintValue = options.longs === String ? $util.Long.prototype.toString.call(message.uintValue) : options.longs === Number ? new $util.LongBits(message.uintValue.low >>> 0, message.uintValue.high >>> 0).toNumber(true) : message.uintValue;\n                        if (message.sintValue != null && message.hasOwnProperty(\"sintValue\"))\n                            if (typeof message.sintValue === \"number\")\n                                object.sintValue = options.longs === String ? String(message.sintValue) : message.sintValue;\n                            else\n                                object.sintValue = options.longs === String ? $util.Long.prototype.toString.call(message.sintValue) : options.longs === Number ? new $util.LongBits(message.sintValue.low >>> 0, message.sintValue.high >>> 0).toNumber() : message.sintValue;\n                        if (message.boolValue != null && message.hasOwnProperty(\"boolValue\"))\n                            object.boolValue = message.boolValue;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Value to JSON.\n                     * @function toJSON\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Value.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    return Value;\n                })();\n\n                Tile.Feature = (function() {\n\n                    /**\n                     * Properties of a Feature.\n                     * @memberof com.mapbox.pb.Tile\n                     * @interface IFeature\n                     * @property {number|Long|null} [id] Feature id\n                     * @property {Array.<number>|null} [tags] Feature tags\n                     * @property {com.mapbox.pb.Tile.GeomType|null} [type] Feature type\n                     * @property {Array.<number>|null} [geometry] Feature geometry\n                     */\n\n                    /**\n                     * Constructs a new Feature.\n                     * @memberof com.mapbox.pb.Tile\n                     * @classdesc Represents a Feature.\n                     * @implements IFeature\n                     * @constructor\n                     * @param {com.mapbox.pb.Tile.IFeature=} [properties] Properties to set\n                     */\n                    function Feature(properties) {\n                        this.tags = [];\n                        this.geometry = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Feature id.\n                     * @member {number|Long} id\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                    /**\n                     * Feature tags.\n                     * @member {Array.<number>} tags\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.tags = $util.emptyArray;\n\n                    /**\n                     * Feature type.\n                     * @member {com.mapbox.pb.Tile.GeomType} type\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.type = 0;\n\n                    /**\n                     * Feature geometry.\n                     * @member {Array.<number>} geometry\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.geometry = $util.emptyArray;\n\n                    /**\n                     * Decodes a Feature message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {com.mapbox.pb.Tile.Feature} Feature\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Feature.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile.Feature();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.uint64();\n                                break;\n                            case 2:\n                                if (!(message.tags && message.tags.length))\n                                    message.tags = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.tags.push(reader.uint32());\n                                } else\n                                    message.tags.push(reader.uint32());\n                                break;\n                            case 3:\n                                message.type = reader.int32();\n                                break;\n                            case 4:\n                                if (!(message.geometry && message.geometry.length))\n                                    message.geometry = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.geometry.push(reader.uint32());\n                                } else\n                                    message.geometry.push(reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Feature message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {com.mapbox.pb.Tile.Feature} Feature\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Feature.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Creates a Feature message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {com.mapbox.pb.Tile.Feature} Feature\n                     */\n                    Feature.fromObject = function fromObject(object) {\n                        if (object instanceof $root.com.mapbox.pb.Tile.Feature)\n                            return object;\n                        var message = new $root.com.mapbox.pb.Tile.Feature();\n                        if (object.id != null)\n                            if ($util.Long)\n                                (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                            else if (typeof object.id === \"string\")\n                                message.id = parseInt(object.id, 10);\n                            else if (typeof object.id === \"number\")\n                                message.id = object.id;\n                            else if (typeof object.id === \"object\")\n                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                        if (object.tags) {\n                            if (!Array.isArray(object.tags))\n                                throw TypeError(\".com.mapbox.pb.Tile.Feature.tags: array expected\");\n                            message.tags = [];\n                            for (var i = 0; i < object.tags.length; ++i)\n                                message.tags[i] = object.tags[i] >>> 0;\n                        }\n                        switch (object.type) {\n                        case \"UNKNOWN\":\n                        case 0:\n                            message.type = 0;\n                            break;\n                        case \"POINT\":\n                        case 1:\n                            message.type = 1;\n                            break;\n                        case \"LINESTRING\":\n                        case 2:\n                            message.type = 2;\n                            break;\n                        case \"POLYGON\":\n                        case 3:\n                            message.type = 3;\n                            break;\n                        }\n                        if (object.geometry) {\n                            if (!Array.isArray(object.geometry))\n                                throw TypeError(\".com.mapbox.pb.Tile.Feature.geometry: array expected\");\n                            message.geometry = [];\n                            for (var i = 0; i < object.geometry.length; ++i)\n                                message.geometry[i] = object.geometry[i] >>> 0;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Feature message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {com.mapbox.pb.Tile.Feature} message Feature\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Feature.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.tags = [];\n                            object.geometry = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, true);\n                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.id = options.longs === String ? \"0\" : 0;\n                            object.type = options.enums === String ? \"UNKNOWN\" : 0;\n                        }\n                        if (message.id != null && message.hasOwnProperty(\"id\"))\n                            if (typeof message.id === \"number\")\n                                object.id = options.longs === String ? String(message.id) : message.id;\n                            else\n                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                        if (message.tags && message.tags.length) {\n                            object.tags = [];\n                            for (var j = 0; j < message.tags.length; ++j)\n                                object.tags[j] = message.tags[j];\n                        }\n                        if (message.type != null && message.hasOwnProperty(\"type\"))\n                            object.type = options.enums === String ? $root.com.mapbox.pb.Tile.GeomType[message.type] : message.type;\n                        if (message.geometry && message.geometry.length) {\n                            object.geometry = [];\n                            for (var j = 0; j < message.geometry.length; ++j)\n                                object.geometry[j] = message.geometry[j];\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Feature to JSON.\n                     * @function toJSON\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Feature.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    return Feature;\n                })();\n\n                Tile.Layer = (function() {\n\n                    /**\n                     * Properties of a Layer.\n                     * @memberof com.mapbox.pb.Tile\n                     * @interface ILayer\n                     * @property {number} version Layer version\n                     * @property {string} name Layer name\n                     * @property {Array.<com.mapbox.pb.Tile.IFeature>|null} [features] Layer features\n                     * @property {Array.<string>|null} [keys] Layer keys\n                     * @property {Array.<com.mapbox.pb.Tile.IValue>|null} [values] Layer values\n                     * @property {number|null} [extent] Layer extent\n                     */\n\n                    /**\n                     * Constructs a new Layer.\n                     * @memberof com.mapbox.pb.Tile\n                     * @classdesc Represents a Layer.\n                     * @implements ILayer\n                     * @constructor\n                     * @param {com.mapbox.pb.Tile.ILayer=} [properties] Properties to set\n                     */\n                    function Layer(properties) {\n                        this.features = [];\n                        this.keys = [];\n                        this.values = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Layer version.\n                     * @member {number} version\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.version = 1;\n\n                    /**\n                     * Layer name.\n                     * @member {string} name\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.name = \"\";\n\n                    /**\n                     * Layer features.\n                     * @member {Array.<com.mapbox.pb.Tile.IFeature>} features\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.features = $util.emptyArray;\n\n                    /**\n                     * Layer keys.\n                     * @member {Array.<string>} keys\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.keys = $util.emptyArray;\n\n                    /**\n                     * Layer values.\n                     * @member {Array.<com.mapbox.pb.Tile.IValue>} values\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.values = $util.emptyArray;\n\n                    /**\n                     * Layer extent.\n                     * @member {number} extent\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.extent = 4096;\n\n                    /**\n                     * Decodes a Layer message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {com.mapbox.pb.Tile.Layer} Layer\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Layer.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile.Layer();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 15:\n                                message.version = reader.uint32();\n                                break;\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                if (!(message.features && message.features.length))\n                                    message.features = [];\n                                message.features.push($root.com.mapbox.pb.Tile.Feature.decode(reader, reader.uint32()));\n                                break;\n                            case 3:\n                                if (!(message.keys && message.keys.length))\n                                    message.keys = [];\n                                message.keys.push(reader.string());\n                                break;\n                            case 4:\n                                if (!(message.values && message.values.length))\n                                    message.values = [];\n                                message.values.push($root.com.mapbox.pb.Tile.Value.decode(reader, reader.uint32()));\n                                break;\n                            case 5:\n                                message.extent = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        if (!message.hasOwnProperty(\"version\"))\n                            throw $util.ProtocolError(\"missing required 'version'\", { instance: message });\n                        if (!message.hasOwnProperty(\"name\"))\n                            throw $util.ProtocolError(\"missing required 'name'\", { instance: message });\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Layer message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {com.mapbox.pb.Tile.Layer} Layer\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Layer.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Creates a Layer message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {com.mapbox.pb.Tile.Layer} Layer\n                     */\n                    Layer.fromObject = function fromObject(object) {\n                        if (object instanceof $root.com.mapbox.pb.Tile.Layer)\n                            return object;\n                        var message = new $root.com.mapbox.pb.Tile.Layer();\n                        if (object.version != null)\n                            message.version = object.version >>> 0;\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        if (object.features) {\n                            if (!Array.isArray(object.features))\n                                throw TypeError(\".com.mapbox.pb.Tile.Layer.features: array expected\");\n                            message.features = [];\n                            for (var i = 0; i < object.features.length; ++i) {\n                                if (typeof object.features[i] !== \"object\")\n                                    throw TypeError(\".com.mapbox.pb.Tile.Layer.features: object expected\");\n                                message.features[i] = $root.com.mapbox.pb.Tile.Feature.fromObject(object.features[i]);\n                            }\n                        }\n                        if (object.keys) {\n                            if (!Array.isArray(object.keys))\n                                throw TypeError(\".com.mapbox.pb.Tile.Layer.keys: array expected\");\n                            message.keys = [];\n                            for (var i = 0; i < object.keys.length; ++i)\n                                message.keys[i] = String(object.keys[i]);\n                        }\n                        if (object.values) {\n                            if (!Array.isArray(object.values))\n                                throw TypeError(\".com.mapbox.pb.Tile.Layer.values: array expected\");\n                            message.values = [];\n                            for (var i = 0; i < object.values.length; ++i) {\n                                if (typeof object.values[i] !== \"object\")\n                                    throw TypeError(\".com.mapbox.pb.Tile.Layer.values: object expected\");\n                                message.values[i] = $root.com.mapbox.pb.Tile.Value.fromObject(object.values[i]);\n                            }\n                        }\n                        if (object.extent != null)\n                            message.extent = object.extent >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Layer message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {com.mapbox.pb.Tile.Layer} message Layer\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Layer.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.features = [];\n                            object.keys = [];\n                            object.values = [];\n                        }\n                        if (options.defaults) {\n                            object.name = \"\";\n                            object.extent = 4096;\n                            object.version = 1;\n                        }\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.features && message.features.length) {\n                            object.features = [];\n                            for (var j = 0; j < message.features.length; ++j)\n                                object.features[j] = $root.com.mapbox.pb.Tile.Feature.toObject(message.features[j], options);\n                        }\n                        if (message.keys && message.keys.length) {\n                            object.keys = [];\n                            for (var j = 0; j < message.keys.length; ++j)\n                                object.keys[j] = message.keys[j];\n                        }\n                        if (message.values && message.values.length) {\n                            object.values = [];\n                            for (var j = 0; j < message.values.length; ++j)\n                                object.values[j] = $root.com.mapbox.pb.Tile.Value.toObject(message.values[j], options);\n                        }\n                        if (message.extent != null && message.hasOwnProperty(\"extent\"))\n                            object.extent = message.extent;\n                        if (message.version != null && message.hasOwnProperty(\"version\"))\n                            object.version = message.version;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Layer to JSON.\n                     * @function toJSON\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Layer.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    return Layer;\n                })();\n\n                return Tile;\n            })();\n\n            return pb;\n        })();\n\n        return mapbox;\n    })();\n\n    return com;\n})();\n\nmodule.exports = $root;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/adapters/omv/proto/vector_tile.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/csscolorparser/csscolorparser.js":
/*!*******************************************************!*\
  !*** ./node_modules/csscolorparser/csscolorparser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  \"transparent\": [0,0,0,0], \"aliceblue\": [240,248,255,1],\n  \"antiquewhite\": [250,235,215,1], \"aqua\": [0,255,255,1],\n  \"aquamarine\": [127,255,212,1], \"azure\": [240,255,255,1],\n  \"beige\": [245,245,220,1], \"bisque\": [255,228,196,1],\n  \"black\": [0,0,0,1], \"blanchedalmond\": [255,235,205,1],\n  \"blue\": [0,0,255,1], \"blueviolet\": [138,43,226,1],\n  \"brown\": [165,42,42,1], \"burlywood\": [222,184,135,1],\n  \"cadetblue\": [95,158,160,1], \"chartreuse\": [127,255,0,1],\n  \"chocolate\": [210,105,30,1], \"coral\": [255,127,80,1],\n  \"cornflowerblue\": [100,149,237,1], \"cornsilk\": [255,248,220,1],\n  \"crimson\": [220,20,60,1], \"cyan\": [0,255,255,1],\n  \"darkblue\": [0,0,139,1], \"darkcyan\": [0,139,139,1],\n  \"darkgoldenrod\": [184,134,11,1], \"darkgray\": [169,169,169,1],\n  \"darkgreen\": [0,100,0,1], \"darkgrey\": [169,169,169,1],\n  \"darkkhaki\": [189,183,107,1], \"darkmagenta\": [139,0,139,1],\n  \"darkolivegreen\": [85,107,47,1], \"darkorange\": [255,140,0,1],\n  \"darkorchid\": [153,50,204,1], \"darkred\": [139,0,0,1],\n  \"darksalmon\": [233,150,122,1], \"darkseagreen\": [143,188,143,1],\n  \"darkslateblue\": [72,61,139,1], \"darkslategray\": [47,79,79,1],\n  \"darkslategrey\": [47,79,79,1], \"darkturquoise\": [0,206,209,1],\n  \"darkviolet\": [148,0,211,1], \"deeppink\": [255,20,147,1],\n  \"deepskyblue\": [0,191,255,1], \"dimgray\": [105,105,105,1],\n  \"dimgrey\": [105,105,105,1], \"dodgerblue\": [30,144,255,1],\n  \"firebrick\": [178,34,34,1], \"floralwhite\": [255,250,240,1],\n  \"forestgreen\": [34,139,34,1], \"fuchsia\": [255,0,255,1],\n  \"gainsboro\": [220,220,220,1], \"ghostwhite\": [248,248,255,1],\n  \"gold\": [255,215,0,1], \"goldenrod\": [218,165,32,1],\n  \"gray\": [128,128,128,1], \"green\": [0,128,0,1],\n  \"greenyellow\": [173,255,47,1], \"grey\": [128,128,128,1],\n  \"honeydew\": [240,255,240,1], \"hotpink\": [255,105,180,1],\n  \"indianred\": [205,92,92,1], \"indigo\": [75,0,130,1],\n  \"ivory\": [255,255,240,1], \"khaki\": [240,230,140,1],\n  \"lavender\": [230,230,250,1], \"lavenderblush\": [255,240,245,1],\n  \"lawngreen\": [124,252,0,1], \"lemonchiffon\": [255,250,205,1],\n  \"lightblue\": [173,216,230,1], \"lightcoral\": [240,128,128,1],\n  \"lightcyan\": [224,255,255,1], \"lightgoldenrodyellow\": [250,250,210,1],\n  \"lightgray\": [211,211,211,1], \"lightgreen\": [144,238,144,1],\n  \"lightgrey\": [211,211,211,1], \"lightpink\": [255,182,193,1],\n  \"lightsalmon\": [255,160,122,1], \"lightseagreen\": [32,178,170,1],\n  \"lightskyblue\": [135,206,250,1], \"lightslategray\": [119,136,153,1],\n  \"lightslategrey\": [119,136,153,1], \"lightsteelblue\": [176,196,222,1],\n  \"lightyellow\": [255,255,224,1], \"lime\": [0,255,0,1],\n  \"limegreen\": [50,205,50,1], \"linen\": [250,240,230,1],\n  \"magenta\": [255,0,255,1], \"maroon\": [128,0,0,1],\n  \"mediumaquamarine\": [102,205,170,1], \"mediumblue\": [0,0,205,1],\n  \"mediumorchid\": [186,85,211,1], \"mediumpurple\": [147,112,219,1],\n  \"mediumseagreen\": [60,179,113,1], \"mediumslateblue\": [123,104,238,1],\n  \"mediumspringgreen\": [0,250,154,1], \"mediumturquoise\": [72,209,204,1],\n  \"mediumvioletred\": [199,21,133,1], \"midnightblue\": [25,25,112,1],\n  \"mintcream\": [245,255,250,1], \"mistyrose\": [255,228,225,1],\n  \"moccasin\": [255,228,181,1], \"navajowhite\": [255,222,173,1],\n  \"navy\": [0,0,128,1], \"oldlace\": [253,245,230,1],\n  \"olive\": [128,128,0,1], \"olivedrab\": [107,142,35,1],\n  \"orange\": [255,165,0,1], \"orangered\": [255,69,0,1],\n  \"orchid\": [218,112,214,1], \"palegoldenrod\": [238,232,170,1],\n  \"palegreen\": [152,251,152,1], \"paleturquoise\": [175,238,238,1],\n  \"palevioletred\": [219,112,147,1], \"papayawhip\": [255,239,213,1],\n  \"peachpuff\": [255,218,185,1], \"peru\": [205,133,63,1],\n  \"pink\": [255,192,203,1], \"plum\": [221,160,221,1],\n  \"powderblue\": [176,224,230,1], \"purple\": [128,0,128,1],\n  \"rebeccapurple\": [102,51,153,1],\n  \"red\": [255,0,0,1], \"rosybrown\": [188,143,143,1],\n  \"royalblue\": [65,105,225,1], \"saddlebrown\": [139,69,19,1],\n  \"salmon\": [250,128,114,1], \"sandybrown\": [244,164,96,1],\n  \"seagreen\": [46,139,87,1], \"seashell\": [255,245,238,1],\n  \"sienna\": [160,82,45,1], \"silver\": [192,192,192,1],\n  \"skyblue\": [135,206,235,1], \"slateblue\": [106,90,205,1],\n  \"slategray\": [112,128,144,1], \"slategrey\": [112,128,144,1],\n  \"snow\": [255,250,250,1], \"springgreen\": [0,255,127,1],\n  \"steelblue\": [70,130,180,1], \"tan\": [210,180,140,1],\n  \"teal\": [0,128,128,1], \"thistle\": [216,191,216,1],\n  \"tomato\": [255,99,71,1], \"turquoise\": [64,224,208,1],\n  \"violet\": [238,130,238,1], \"wheat\": [245,222,179,1],\n  \"white\": [255,255,255,1], \"whitesmoke\": [245,245,245,1],\n  \"yellow\": [255,255,0,1], \"yellowgreen\": [154,205,50,1]}\n\nfunction clamp_css_byte(i) {  // Clamp to integer 0 .. 255.\n  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parse_css_int(str) {  // int or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_byte(parseFloat(str) / 100 * 255);\n  return clamp_css_byte(parseInt(str));\n}\n\nfunction parse_css_float(str) {  // float or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_float(parseFloat(str) / 100);\n  return clamp_css_float(parseFloat(str));\n}\n\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) h += 1;\n  else if (h > 1) h -= 1;\n\n  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n  if (h * 2 < 1) return m2;\n  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n  return m1;\n}\n\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.\n\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.\n      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n              (iv & 0xf0) | ((iv & 0xf0) >> 4),\n              (iv & 0xf) | ((iv & 0xf) << 4),\n              1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.\n      return [(iv & 0xff0000) >> 16,\n              (iv & 0xff00) >> 8,\n              iv & 0xff,\n              1];\n    }\n\n    return null;\n  }\n\n  var op = str.indexOf('('), ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op+1, ep-(op+1)).split(',');\n    var alpha = 1;  // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'rgb':\n        if (params.length !== 3) return null;\n        return [parse_css_int(params[0]),\n                parse_css_int(params[1]),\n                parse_css_int(params[2]),\n                alpha];\n      case 'hsla':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'hsl':\n        if (params.length !== 3) return null;\n        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),\n                alpha];\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\ntry { exports.parseCSSColor = parseCSSColor } catch(e) { }\n\n\n//# sourceURL=webpack:///./node_modules/csscolorparser/csscolorparser.js?");

/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/clip.js":
/*!*********************************************!*\
  !*** ./node_modules/geojson-vt/src/clip.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return clip; });\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ \"./node_modules/geojson-vt/src/feature.js\");\n\n\n\n/* clip features between two axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n */\n\nfunction clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll < k2) return features; // trivial accept\n    else if (maxAll < k1 || minAll >= k2) return null; // trivial reject\n\n    var clipped = [];\n\n    for (var i = 0; i < features.length; i++) {\n\n        var feature = features[i];\n        var geometry = feature.geometry;\n        var type = feature.type;\n\n        var min = axis === 0 ? feature.minX : feature.minY;\n        var max = axis === 0 ? feature.maxX : feature.maxY;\n\n        if (min >= k1 && max < k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (max < k1 || min >= k2) { // trivial reject\n            continue;\n        }\n\n        var newGeometry = [];\n\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n\n        } else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n\n        } else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n\n        } else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n\n        } else if (type === 'MultiPolygon') {\n            for (var j = 0; j < geometry.length; j++) {\n                var polygon = [];\n                clipLines(geometry[j], polygon, k1, k2, axis, true);\n                if (polygon.length) {\n                    newGeometry.push(polygon);\n                }\n            }\n        }\n\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (j = 0; j < newGeometry.length; j++) {\n                    clipped.push(Object(_feature__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(feature.id, type, newGeometry[j], feature.tags));\n                }\n                continue;\n            }\n\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    newGeometry = newGeometry[0];\n                } else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n\n            clipped.push(Object(_feature__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (var i = 0; i < geom.length; i += 3) {\n        var a = geom[i + axis];\n\n        if (a >= k1 && a <= k2) {\n            newGeom.push(geom[i]);\n            newGeom.push(geom[i + 1]);\n            newGeom.push(geom[i + 2]);\n        }\n    }\n}\n\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n\n    var slice = newSlice(geom);\n    var intersect = axis === 0 ? intersectX : intersectY;\n    var len = geom.start;\n    var segLen, t;\n\n    for (var i = 0; i < geom.length - 3; i += 3) {\n        var ax = geom[i];\n        var ay = geom[i + 1];\n        var az = geom[i + 2];\n        var bx = geom[i + 3];\n        var by = geom[i + 4];\n        var a = axis === 0 ? ax : ay;\n        var b = axis === 0 ? bx : by;\n        var exited = false;\n\n        if (trackMetrics) segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n\n        if (!isPolygon && exited) {\n            if (trackMetrics) slice.end = len + segLen * t;\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n\n        if (trackMetrics) len += segLen;\n    }\n\n    // add the last point\n    var last = geom.length - 3;\n    ax = geom[last];\n    ay = geom[last + 1];\n    az = geom[last + 2];\n    a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\n\nfunction newSlice(line) {\n    var slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (var i = 0; i < geom.length; i++) {\n        clipLine(geom[i], newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\n\nfunction addPoint(out, x, y, z) {\n    out.push(x);\n    out.push(y);\n    out.push(z);\n}\n\nfunction intersectX(out, ax, ay, bx, by, x) {\n    var t = (x - ax) / (bx - ax);\n    out.push(x);\n    out.push(ay + (by - ay) * t);\n    out.push(1);\n    return t;\n}\n\nfunction intersectY(out, ax, ay, bx, by, y) {\n    var t = (y - ay) / (by - ay);\n    out.push(ax + (bx - ax) * t);\n    out.push(y);\n    out.push(1);\n    return t;\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/clip.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/convert.js":
/*!************************************************!*\
  !*** ./node_modules/geojson-vt/src/convert.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return convert; });\n/* harmony import */ var _simplify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simplify */ \"./node_modules/geojson-vt/src/simplify.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature */ \"./node_modules/geojson-vt/src/feature.js\");\n\n\n\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nfunction convert(data, options) {\n    var features = [];\n    if (data.type === 'FeatureCollection') {\n        for (var i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], options, i);\n        }\n\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, options);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, options);\n    }\n\n    return features;\n}\n\nfunction convertFeature(features, geojson, options, index) {\n    if (!geojson.geometry) return;\n\n    var coords = geojson.geometry.coordinates;\n    var type = geojson.geometry.type;\n    var tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n    var geometry = [];\n    var id = geojson.id;\n    if (options.promoteId) {\n        id = geojson.properties[options.promoteId];\n    } else if (options.generateId) {\n        id = index || 0;\n    }\n    if (type === 'Point') {\n        convertPoint(coords, geometry);\n\n    } else if (type === 'MultiPoint') {\n        for (var i = 0; i < coords.length; i++) {\n            convertPoint(coords[i], geometry);\n        }\n\n    } else if (type === 'LineString') {\n        convertLine(coords, geometry, tolerance, false);\n\n    } else if (type === 'MultiLineString') {\n        if (options.lineMetrics) {\n            // explode into linestrings to be able to track metrics\n            for (i = 0; i < coords.length; i++) {\n                geometry = [];\n                convertLine(coords[i], geometry, tolerance, false);\n                features.push(Object(_feature__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(id, 'LineString', geometry, geojson.properties));\n            }\n            return;\n        } else {\n            convertLines(coords, geometry, tolerance, false);\n        }\n\n    } else if (type === 'Polygon') {\n        convertLines(coords, geometry, tolerance, true);\n\n    } else if (type === 'MultiPolygon') {\n        for (i = 0; i < coords.length; i++) {\n            var polygon = [];\n            convertLines(coords[i], polygon, tolerance, true);\n            geometry.push(polygon);\n        }\n    } else if (type === 'GeometryCollection') {\n        for (i = 0; i < geojson.geometry.geometries.length; i++) {\n            convertFeature(features, {\n                id: id,\n                geometry: geojson.geometry.geometries[i],\n                properties: geojson.properties\n            }, options, index);\n        }\n        return;\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n\n    features.push(Object(_feature__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(id, type, geometry, geojson.properties));\n}\n\nfunction convertPoint(coords, out) {\n    out.push(projectX(coords[0]));\n    out.push(projectY(coords[1]));\n    out.push(0);\n}\n\nfunction convertLine(ring, out, tolerance, isPolygon) {\n    var x0, y0;\n    var size = 0;\n\n    for (var j = 0; j < ring.length; j++) {\n        var x = projectX(ring[j][0]);\n        var y = projectY(ring[j][1]);\n\n        out.push(x);\n        out.push(y);\n        out.push(0);\n\n        if (j > 0) {\n            if (isPolygon) {\n                size += (x0 * y - x * y0) / 2; // area\n            } else {\n                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n            }\n        }\n        x0 = x;\n        y0 = y;\n    }\n\n    var last = out.length - 3;\n    out[2] = 1;\n    Object(_simplify__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(out, 0, last, tolerance);\n    out[last + 2] = 1;\n\n    out.size = Math.abs(size);\n    out.start = 0;\n    out.end = out.size;\n}\n\nfunction convertLines(rings, out, tolerance, isPolygon) {\n    for (var i = 0; i < rings.length; i++) {\n        var geom = [];\n        convertLine(rings[i], geom, tolerance, isPolygon);\n        out.push(geom);\n    }\n}\n\nfunction projectX(x) {\n    return x / 360 + 0.5;\n}\n\nfunction projectY(y) {\n    var sin = Math.sin(y * Math.PI / 180);\n    var y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/convert.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/feature.js":
/*!************************************************!*\
  !*** ./node_modules/geojson-vt/src/feature.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createFeature; });\n\nfunction createFeature(id, type, geom, tags) {\n    var feature = {\n        id: typeof id === 'undefined' ? null : id,\n        type: type,\n        geometry: geom,\n        tags: tags,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n    calcBBox(feature);\n    return feature;\n}\n\nfunction calcBBox(feature) {\n    var geom = feature.geometry;\n    var type = feature.type;\n\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n        calcLineBBox(feature, geom);\n\n    } else if (type === 'Polygon' || type === 'MultiLineString') {\n        for (var i = 0; i < geom.length; i++) {\n            calcLineBBox(feature, geom[i]);\n        }\n\n    } else if (type === 'MultiPolygon') {\n        for (i = 0; i < geom.length; i++) {\n            for (var j = 0; j < geom[i].length; j++) {\n                calcLineBBox(feature, geom[i][j]);\n            }\n        }\n    }\n}\n\nfunction calcLineBBox(feature, geom) {\n    for (var i = 0; i < geom.length; i += 3) {\n        feature.minX = Math.min(feature.minX, geom[i]);\n        feature.minY = Math.min(feature.minY, geom[i + 1]);\n        feature.maxX = Math.max(feature.maxX, geom[i]);\n        feature.maxY = Math.max(feature.maxY, geom[i + 1]);\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/feature.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/geojson-vt/src/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return geojsonvt; });\n/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert */ \"./node_modules/geojson-vt/src/convert.js\");\n/* harmony import */ var _clip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clip */ \"./node_modules/geojson-vt/src/clip.js\");\n/* harmony import */ var _wrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap */ \"./node_modules/geojson-vt/src/wrap.js\");\n/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform */ \"./node_modules/geojson-vt/src/transform.js\");\n/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tile */ \"./node_modules/geojson-vt/src/tile.js\");\n\n     // GeoJSON conversion and preprocessing\n           // stripe clipping algorithm\n           // date line processing\n // coordinate transformation\n     // final simplified tile generation\n\nfunction geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) console.time('preprocess data');\n\n    if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n    if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n\n    var features = Object(_convert__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(data, options);\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = Object(_wrap__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(features, options);\n\n    // start slicing from the top tile down\n    if (features.length) this.splitTile(features, 0, 0, 0);\n\n    if (debug) {\n        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    lineMetrics: false,     // whether to calculate line metrics\n    promoteId: null,        // name of a feature property to be promoted to feature.id\n    generateId: false,      // whether to generate feature ids. Cannot be used with promoteId\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this.tiles[id];\n\n        if (!tile) {\n            if (debug > 1) console.time('creation');\n\n            tile = this.tiles[id] = Object(_tile__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(features, z, x, y, options);\n            this.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this.stats[key] = (this.stats[key] || 0) + 1;\n                this.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) continue;\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (features.length === 0) continue;\n\n        if (debug > 1) console.time('clipping');\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = Object(_clip__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n        right = Object(_clip__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n        features = null;\n\n        if (left) {\n            tl = Object(_clip__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n            bl = Object(_clip__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n            left = null;\n        }\n\n        if (right) {\n            tr = Object(_clip__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n            br = Object(_clip__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n            right = null;\n        }\n\n        if (debug > 1) console.timeEnd('clipping');\n\n        stack.push(tl || [], z + 1, x * 2,     y * 2);\n        stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n        stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n        stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n    }\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    if (z < 0 || z > 24) return null;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) return Object(_transform__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.tiles[id], extent);\n\n    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) return null;\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n\n    if (debug > 1) console.time('drilling down');\n    this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) console.timeEnd('drilling down');\n\n    return this.tiles[id] ? Object(_transform__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction extend(dest, src) {\n    for (var i in src) dest[i] = src[i];\n    return dest;\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/index.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/simplify.js":
/*!*************************************************!*\
  !*** ./node_modules/geojson-vt/src/simplify.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return simplify; });\n\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nfunction simplify(coords, first, last, sqTolerance) {\n    var maxSqDist = sqTolerance;\n    var mid = (last - first) >> 1;\n    var minPosToMid = last - first;\n    var index;\n\n    var ax = coords[first];\n    var ay = coords[first + 1];\n    var bx = coords[last];\n    var by = coords[last + 1];\n\n    for (var i = first + 3; i < last; i += 3) {\n        var d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n\n        } else if (d === maxSqDist) {\n            // a workaround to ensure we choose a pivot close to the middle of the list,\n            // reducing recursion depth, for certain degenerate inputs\n            // https://github.com/mapbox/geojson-vt/issues/104\n            var posToMid = Math.abs(i - mid);\n            if (posToMid < minPosToMid) {\n                index = i;\n                minPosToMid = posToMid;\n            }\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 3) simplify(coords, first, index, sqTolerance);\n        coords[index + 2] = maxSqDist;\n        if (last - index > 3) simplify(coords, index, last, sqTolerance);\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(px, py, x, y, bx, by) {\n\n    var dx = bx - x;\n    var dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/simplify.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/tile.js":
/*!*********************************************!*\
  !*** ./node_modules/geojson-vt/src/tile.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createTile; });\n\nfunction createTile(features, z, tx, ty, options) {\n    var tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n    var tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: tx,\n        y: ty,\n        z: z,\n        transformed: false,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n    };\n    for (var i = 0; i < features.length; i++) {\n        tile.numFeatures++;\n        addFeature(tile, features[i], tolerance, options);\n\n        var minX = features[i].minX;\n        var minY = features[i].minY;\n        var maxX = features[i].maxX;\n        var maxY = features[i].maxY;\n\n        if (minX < tile.minX) tile.minX = minX;\n        if (minY < tile.minY) tile.minY = minY;\n        if (maxX > tile.maxX) tile.maxX = maxX;\n        if (maxY > tile.maxY) tile.maxY = maxY;\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, options) {\n\n    var geom = feature.geometry,\n        type = feature.type,\n        simplified = [];\n\n    if (type === 'Point' || type === 'MultiPoint') {\n        for (var i = 0; i < geom.length; i += 3) {\n            simplified.push(geom[i]);\n            simplified.push(geom[i + 1]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else if (type === 'LineString') {\n        addLine(simplified, geom, tile, tolerance, false, false);\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        for (i = 0; i < geom.length; i++) {\n            addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0);\n        }\n\n    } else if (type === 'MultiPolygon') {\n\n        for (var k = 0; k < geom.length; k++) {\n            var polygon = geom[k];\n            for (i = 0; i < polygon.length; i++) {\n                addLine(simplified, polygon[i], tile, tolerance, true, i === 0);\n            }\n        }\n    }\n\n    if (simplified.length) {\n        var tags = feature.tags || null;\n        if (type === 'LineString' && options.lineMetrics) {\n            tags = {};\n            for (var key in feature.tags) tags[key] = feature.tags[key];\n            tags['mapbox_clip_start'] = geom.start / geom.size;\n            tags['mapbox_clip_end'] = geom.end / geom.size;\n        }\n        var tileFeature = {\n            geometry: simplified,\n            type: type === 'Polygon' || type === 'MultiPolygon' ? 3 :\n                type === 'LineString' || type === 'MultiLineString' ? 2 : 1,\n            tags: tags\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.features.push(tileFeature);\n    }\n}\n\nfunction addLine(result, geom, tile, tolerance, isPolygon, isOuter) {\n    var sqTolerance = tolerance * tolerance;\n\n    if (tolerance > 0 && (geom.size < (isPolygon ? sqTolerance : tolerance))) {\n        tile.numPoints += geom.length / 3;\n        return;\n    }\n\n    var ring = [];\n\n    for (var i = 0; i < geom.length; i += 3) {\n        if (tolerance === 0 || geom[i + 2] > sqTolerance) {\n            tile.numSimplified++;\n            ring.push(geom[i]);\n            ring.push(geom[i + 1]);\n        }\n        tile.numPoints++;\n    }\n\n    if (isPolygon) rewind(ring, isOuter);\n\n    result.push(ring);\n}\n\nfunction rewind(ring, clockwise) {\n    var area = 0;\n    for (var i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (i = 0, len = ring.length; i < len / 2; i += 2) {\n            var x = ring[i];\n            var y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/tile.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/transform.js":
/*!**************************************************!*\
  !*** ./node_modules/geojson-vt/src/transform.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return transformTile; });\n\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nfunction transformTile(tile, extent) {\n    if (tile.transformed) return tile;\n\n    var z2 = 1 << tile.z,\n        tx = tile.x,\n        ty = tile.y,\n        i, j, k;\n\n    for (i = 0; i < tile.features.length; i++) {\n        var feature = tile.features[i],\n            geom = feature.geometry,\n            type = feature.type;\n\n        feature.geometry = [];\n\n        if (type === 1) {\n            for (j = 0; j < geom.length; j += 2) {\n                feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n            }\n        } else {\n            for (j = 0; j < geom.length; j++) {\n                var ring = [];\n                for (k = 0; k < geom[j].length; k += 2) {\n                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                }\n                feature.geometry.push(ring);\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(x, y, extent, z2, tx, ty) {\n    return [\n        Math.round(extent * (x * z2 - tx)),\n        Math.round(extent * (y * z2 - ty))];\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/transform.js?");

/***/ }),

/***/ "./node_modules/geojson-vt/src/wrap.js":
/*!*********************************************!*\
  !*** ./node_modules/geojson-vt/src/wrap.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return wrap; });\n/* harmony import */ var _clip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clip */ \"./node_modules/geojson-vt/src/clip.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature */ \"./node_modules/geojson-vt/src/feature.js\");\n\n\n\n\nfunction wrap(features, options) {\n    var buffer = options.buffer / options.extent;\n    var merged = features;\n    var left  = Object(_clip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(features, 1, -1 - buffer, buffer,     0, -1, 2, options); // left world copy\n    var right = Object(_clip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(features, 1,  1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n\n    if (left || right) {\n        merged = Object(_clip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n\n        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    var newFeatures = [];\n\n    for (var i = 0; i < features.length; i++) {\n        var feature = features[i],\n            type = feature.type;\n\n        var newGeometry;\n\n        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n            newGeometry = shiftCoords(feature.geometry, offset);\n\n        } else if (type === 'MultiLineString' || type === 'Polygon') {\n            newGeometry = [];\n            for (var j = 0; j < feature.geometry.length; j++) {\n                newGeometry.push(shiftCoords(feature.geometry[j], offset));\n            }\n        } else if (type === 'MultiPolygon') {\n            newGeometry = [];\n            for (j = 0; j < feature.geometry.length; j++) {\n                var newPolygon = [];\n                for (var k = 0; k < feature.geometry[j].length; k++) {\n                    newPolygon.push(shiftCoords(feature.geometry[j][k], offset));\n                }\n                newGeometry.push(newPolygon);\n            }\n        }\n\n        newFeatures.push(Object(_feature__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(feature.id, type, newGeometry, feature.tags));\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    var newPoints = [];\n    newPoints.size = points.size;\n\n    if (points.start !== undefined) {\n        newPoints.start = points.start;\n        newPoints.end = points.end;\n    }\n\n    for (var i = 0; i < points.length; i += 3) {\n        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n    }\n    return newPoints;\n}\n\n\n//# sourceURL=webpack:///./node_modules/geojson-vt/src/wrap.js?");

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/long/src/long.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\n\n// Utility\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Service;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\n\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\n\n// global object reference\nutil.global = typeof window !== \"undefined\" && window\n           || typeof global !== \"undefined\" && global\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n * @const\n */\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = THREE;\n\n//# sourceURL=webpack:///external_%22THREE%22?");

/***/ })

/******/ });