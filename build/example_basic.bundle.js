/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./examples/src/example_basic.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./examples/src/config.ts":
/*!********************************!*\
  !*** ./examples/src/config.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decoderPath = exports.styleSetName = exports.accessToken = exports.apikey = void 0;\n/** @hidden */\nexports.apikey = \"J0IJdYzKDYS3nHVDDEWETIqK3nAcxqW42vz7xeSq61M\";\n/** @hidden */\nexports.accessToken = \"AYlqpxvwl7C8tSVG22lX2lg\";\n/** @hidden */\nexports.styleSetName = \"tilezen\";\n/** @hidden */\nexports.decoderPath = \"./build/decoder.bundle.js\";\n\n\n//# sourceURL=webpack:///./examples/src/config.ts?");

/***/ }),

/***/ "./examples/src/example_basic.ts":
/*!***************************************!*\
  !*** ./examples/src/example_basic.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_omv_datasource_1 = __webpack_require__(/*! @here/harp-omv-datasource */ \"./node_modules/@here/harp-omv-datasource/index.js\");\nconst harp_leaflet_1 = __webpack_require__(/*! harp-leaflet */ \"./src/index.ts\");\nconst L = __importStar(__webpack_require__(/*! leaflet */ \"leaflet\"));\nconst config = __importStar(__webpack_require__(/*! ./config */ \"./examples/src/config.ts\"));\nconst map = L.map(\"map\").setView([38.912753, -77.032194], 15);\nconst popup = L.popup();\nfunction onMapClick(e) {\n    popup\n        .setLatLng(e.latlng)\n        .setContent(\"You clicked the map at \" + e.latlng.toString())\n        .openOn(map);\n}\nmap.on(\"click\", onMapClick);\nL.marker([38.912753, -77.032194])\n    .bindPopup(\"Hello <b>Harp GL</b>!<br>Whoa, it works!\")\n    .addTo(map)\n    .openPopup();\nconst harpGL = new harp_leaflet_1.HarpGL({\n    decoderUrl: \"./build/decoder.bundle.js\",\n    theme: \"resources/harp-map-theme/berlin_tilezen_base.json\",\n}).addTo(map);\nconst hereBaseDataSource = new harp_omv_datasource_1.OmvDataSource({\n    baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n    apiFormat: harp_omv_datasource_1.APIFormat.XYZOMV,\n    styleSetName: \"tilezen\",\n    authenticationCode: config.apikey,\n    authenticationMethod: {\n        method: harp_omv_datasource_1.AuthenticationMethod.QueryString,\n        name: \"apikey\",\n    },\n});\nconst osmBaseDataSource = new harp_omv_datasource_1.OmvDataSource({\n    baseUrl: \"https://xyz.api.here.com/tiles/osmbase/512/all\",\n    apiFormat: harp_omv_datasource_1.APIFormat.XYZMVT,\n    styleSetName: config.styleSetName,\n    maxZoomLevel: 17,\n    authenticationCode: config.accessToken,\n    concurrentDecoderScriptUrl: config.decoderPath,\n});\nharpGL.mapView.addDataSource(hereBaseDataSource);\nharpGL.mapView.addDataSource(osmBaseDataSource);\nhereBaseDataSource.enabled = true;\nosmBaseDataSource.enabled = false;\ninstallButtonGroupHandler({\n    \"theme-berlin-base\": \"resources/harp-map-theme/berlin_tilezen_base.json\",\n    \"theme-berlin-reduced-day\": \"resources/harp-map-theme/berlin_tilezen_day_reduced.json\",\n    \"theme-berlin-reduced-night\": \"resources/harp-map-theme/berlin_tilezen_night_reduced.json\",\n}, {\n    default: \"theme-berlin-base\",\n    onChange: (themeUri) => __awaiter(void 0, void 0, void 0, function* () {\n        harpGL.mapView.setTheme(themeUri);\n    }),\n});\ninstallButtonGroupHandler({\n    \"datasource-herebase\": hereBaseDataSource,\n    \"datasource-osmbase\": osmBaseDataSource,\n}, {\n    default: \"datasource-herebase\",\n    onChange: (newDataSource) => __awaiter(void 0, void 0, void 0, function* () {\n        osmBaseDataSource.enabled = newDataSource === osmBaseDataSource;\n        hereBaseDataSource.enabled = newDataSource === hereBaseDataSource;\n        harpGL.mapView.update();\n    }),\n});\ninstallButtonGroupHandler({\n    \"location-washington\": L.latLngBounds([38.906263, -77.06377], [38.858825, -76.96455]),\n    \"location-dubai\": L.latLngBounds([25.200165, 55.264556], [25.190379, 55.285199]),\n    \"location-france\": L.latLngBounds([51.412912, -5.998535], [43.052834, 8.4375]),\n    \"location-us\": L.latLngBounds([51.289406, -131.660156], [24.527135, -71.367188]),\n    \"location-europe\": L.latLngBounds([66.548263, -25.839844], [34.307144, 44.121094]),\n    \"location-earth\": L.latLngBounds([78, -180], [-55, 180]),\n}, {\n    noActive: true,\n    default: \"location-washington\",\n    onChange: (newBounds) => __awaiter(void 0, void 0, void 0, function* () {\n        map.fitBounds(newBounds);\n    }),\n});\nfunction installButtonGroupHandler(schema, options) {\n    let currentKey = options.default;\n    const buttons = {};\n    function setValue(newKey) {\n        const oldButton = buttons[currentKey];\n        const newButton = buttons[newKey];\n        if (options.noActive !== true) {\n            oldButton.classList.remove(\"active\");\n            newButton.classList.add(\"active\");\n        }\n        options.onChange(schema[newKey]);\n        currentKey = newKey;\n    }\n    // tslint:disable-next-line:forin\n    for (const key in schema) {\n        const button = document.getElementById(key);\n        buttons[key] = button;\n        button.onclick = (e) => {\n            e.stopPropagation();\n            setValue(key);\n        };\n        if (options.noActive !== true && key === currentKey) {\n            button.classList.add(\"active\");\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./examples/src/example_basic.ts?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index-decoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index-decoder.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/StyleSetEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/IMeshBuffers */ \"./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Outliner */ \"./node_modules/@here/harp-datasource-protocol/lib/Outliner.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ThreeBufferUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ \"./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js\"), exports);\n//# sourceMappingURL=index-decoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/index-decoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Components used for the decoding and styling of data that is used by the Datasources.\n *\n * @remarks\n * The DataSource Protocol package contains components used for the decoding and styling\n * of data that is used by the Datasources.\n * This code is shared between the ui-thread and the web-workers which are\n * used to parallelise the decoding of the data.\n * This module contains interfaces for choosing techniques form the techniques\n * catalog that are applied via the {@link Theme} files to draw geometries on the map canvas.\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TechniqueParams */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PostEffects */ \"./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PropertyValue */ \"./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ITileDecoder */ \"./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ITiler */ \"./node_modules/@here/harp-datasource-protocol/lib/ITiler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DecodedTile */ \"./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TileInfo */ \"./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ \"./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ThemeVisitor */ \"./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorUtils = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\nconst SHIFT_TRANSPARENCY = 24;\nconst SHIFT_RED = 16;\nconst SHIFT_GREEN = 8;\nconst SHIFT_BLUE = 0;\n//    Allow bitwise operations for colors decoding\nconst HEX_FULL_CHANNEL = 0xff;\nconst HEX_RGB_MASK = 0xffffff;\nconst HEX_TRGB_MASK = 0xffffffff;\nconst tmpColor = new THREE.Color();\n/**\n * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.\n *\n * The functions provided allows for conversion from and to our custom number based color format,\n * which contains transparency, red, green and blue color channels in a way that each channel\n * occupies 8 bits of resulting number (color format 0xTTRRGGBB).\n * In order to preserve compatibility with THREE.Color class and its hexadecimal color\n * representation, we do not store __alpha__ channel in encoded color's number, but replace it\n * with __transparency__ channel, which is simply opposite to alpha:\n * ```transparency = 0xFF - alpha```\n * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,\n * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],\n * [[THREE.Color.setHex]]).\n * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.\n */\nvar ColorUtils;\n(function (ColorUtils) {\n    /**\n     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).\n     *\n     * We do not use direct alpha channel mapping to hex in order to preserve compatibility\n     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency\n     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].\n     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and\n     * color defining transparency (alpha < 255) is always recognizable by the oldest\n     * bit set:\n     * ```typescript\n     * (color >> SHIFT_TRANSPARENCY) !== 0.\n     * ```\n     * @note All input components are floating points in <0, 1> range (inclusively).\n     * @note Although method encodes transparency channel in single number value, it is still\n     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to\n     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.\n     */\n    function getHexFromRgba(r, g, b, a) {\n        harp_utils_1.assert(a >= 0 && a <= 1);\n        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);\n        return ((t << SHIFT_TRANSPARENCY) ^\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));\n    }\n    ColorUtils.getHexFromRgba = getHexFromRgba;\n    /**\n     * Encodes RGB all color channels in single number with format 0xRRGGBB.\n     *\n     * All input channels should be in <0, 1> range (inclusively).\n     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.\n     *\n     * @note This method is fully compatible with THREE.js color encoding, so\n     * you may pass this value directly to THREE.Color c-tor.\n     */\n    function getHexFromRgb(r, g, b) {\n        harp_utils_1.assert(r >= 0 && r <= 1);\n        harp_utils_1.assert(g >= 0 && g <= 1);\n        harp_utils_1.assert(b >= 0 && b <= 1);\n        return (((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));\n    }\n    ColorUtils.getHexFromRgb = getHexFromRgb;\n    /**\n     * Encode and convert HSL value to number coded color format (0xRRGGBB).\n     *\n     * @see getHexFromRgb.\n     * @param h - Hue component value between 0 and 1.\n     * @param s - Saturation value between 0 and 1.\n     * @param l - Lightness channel between 0 and 1.\n     */\n    function getHexFromHsl(h, s, l) {\n        harp_utils_1.assert(h >= 0 && h <= 1);\n        harp_utils_1.assert(s >= 0 && s <= 1);\n        harp_utils_1.assert(l >= 0 && l <= 1);\n        return tmpColor.setHSL(h, s, l).getHex();\n    }\n    ColorUtils.getHexFromHsl = getHexFromHsl;\n    /**\n     * Retrieve RGBA channels separately from number encoded custom color format.\n     *\n     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color\n     * format.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating\n     * point from 0 to 1 inclusively.\n     */\n    function getRgbaFromHex(hex, target = new RGBA_1.RGBA()) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        target.r = ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.g = ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.b = ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.a =\n            (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /\n                HEX_FULL_CHANNEL;\n        return target;\n    }\n    ColorUtils.getRgbaFromHex = getRgbaFromHex;\n    /**\n     * Determines if number encoded color contains alpha (opacity) defined and different then 255.\n     *\n     * @param hex - The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns True if color has transparency defined.\n     */\n    function hasAlphaInHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex >> SHIFT_TRANSPARENCY !== 0;\n    }\n    ColorUtils.hasAlphaInHex = hasAlphaInHex;\n    /**\n     * Retrieves alpha color channel from hex encoded color value.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns The floating point alpha component in <0, 1> range.\n     */\n    function getAlphaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return (((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL);\n    }\n    ColorUtils.getAlphaFromHex = getAlphaFromHex;\n    /**\n     * Remove transparency info from the number coded color, makes it compatible with external libs.\n     *\n     * @see getAlphaFromHex.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns number coded color value representable as 0xRRGGBB in hex.\n     */\n    function removeAlphaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex & HEX_RGB_MASK;\n    }\n    ColorUtils.removeAlphaFromHex = removeAlphaFromHex;\n})(ColorUtils = exports.ColorUtils || (exports.ColorUtils = {}));\n//# sourceMappingURL=ColorUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFeatureText = exports.getFeatureName = exports.getFeatureId = exports.getProjectionName = exports.getProjection = exports.GeometryType = exports.getArrayConstructor = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst TechniqueAttr_1 = __webpack_require__(/*! ./TechniqueAttr */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js\");\nconst Techniques_1 = __webpack_require__(/*! ./Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\");\n/**\n * Returns an array with the data type specified as parameter.\n *\n * @param attr - specifies which type of data is being stored in the array\n */\nfunction getArrayConstructor(attr) {\n    switch (attr) {\n        case \"float\":\n            return Float32Array;\n        case \"uint8\":\n            return Uint8Array;\n        case \"uint16\":\n            return Uint16Array;\n        case \"uint32\":\n            return Uint32Array;\n        case \"int8\":\n            return Int8Array;\n        case \"int16\":\n            return Int16Array;\n        case \"int32\":\n            return Int32Array;\n    }\n}\nexports.getArrayConstructor = getArrayConstructor;\n/**\n * Geometry types supported by [[Geometry]] objects.\n */\nvar GeometryType;\n(function (GeometryType) {\n    GeometryType[GeometryType[\"Unspecified\"] = 0] = \"Unspecified\";\n    GeometryType[GeometryType[\"Point\"] = 1] = \"Point\";\n    GeometryType[GeometryType[\"Line\"] = 2] = \"Line\";\n    GeometryType[GeometryType[\"SolidLine\"] = 3] = \"SolidLine\";\n    GeometryType[GeometryType[\"Text\"] = 4] = \"Text\";\n    GeometryType[GeometryType[\"TextPath\"] = 5] = \"TextPath\";\n    GeometryType[GeometryType[\"ExtrudedLine\"] = 6] = \"ExtrudedLine\";\n    GeometryType[GeometryType[\"Polygon\"] = 7] = \"Polygon\";\n    GeometryType[GeometryType[\"ExtrudedPolygon\"] = 8] = \"ExtrudedPolygon\";\n    GeometryType[GeometryType[\"Object3D\"] = 9] = \"Object3D\";\n    GeometryType[GeometryType[\"Other\"] = 1000] = \"Other\";\n})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));\n/**\n * Returns the projection object specified in the parameter.\n *\n * @param projectionName - string describing projection to be used\n */\nfunction getProjection(projectionName) {\n    switch (projectionName) {\n        case \"mercator\":\n            return harp_geoutils_1.mercatorProjection;\n        case \"webMercator\":\n            return harp_geoutils_1.webMercatorProjection;\n        case \"sphere\":\n            return harp_geoutils_1.sphereProjection;\n        case \"normalizedEquirectangular\":\n            return harp_geoutils_1.normalizedEquirectangularProjection;\n        case \"equirectangular\":\n            return harp_geoutils_1.equirectangularProjection;\n        default:\n            throw new Error(`Unknown projection ${projectionName}`);\n    } // switch\n}\nexports.getProjection = getProjection;\n/**\n * String with the projection's name.\n *\n * @param projection - `Projection` object containing the name of the projection to retrieve\n */\nfunction getProjectionName(projection) {\n    if (projection === harp_geoutils_1.mercatorProjection) {\n        return \"mercator\";\n    }\n    else if (projection === harp_geoutils_1.webMercatorProjection) {\n        return \"webMercator\";\n    }\n    else if (projection === harp_geoutils_1.sphereProjection) {\n        return \"sphere\";\n    }\n    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {\n        return \"normalizedEquirectangular\";\n    }\n    else if (projection === harp_geoutils_1.equirectangularProjection) {\n        return \"equirectangular\";\n    }\n    throw new Error(\"Unknown projection\");\n}\nexports.getProjectionName = getProjectionName;\n/**\n * @returns Feature id from the provided attribute map.\n */\nfunction getFeatureId(attributeMap) {\n    if (attributeMap === undefined) {\n        return 0;\n    }\n    if (typeof attributeMap === \"number\") {\n        return attributeMap;\n    }\n    if (attributeMap.hasOwnProperty(\"$id\")) {\n        return attributeMap.$id;\n    }\n    return 0;\n}\nexports.getFeatureId = getFeatureId;\n/**\n * Determine the name of (OMV) feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param env - Environment containing the tags from the (OMV) feature.\n * @param useAbbreviation - `true` to use the abbreviation if available.\n * @param useIsoCode - `true` to use the tag \"iso_code\".\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nfunction getFeatureName(env, basePropName, useAbbreviation, useIsoCode, languages) {\n    var _a;\n    let name;\n    if (basePropName === undefined) {\n        basePropName = \"name\";\n    }\n    if (useAbbreviation) {\n        const abbreviation = env.lookup(`${basePropName}:short`);\n        if (typeof abbreviation === \"string\" && abbreviation.length > 0) {\n            return abbreviation;\n        }\n    }\n    if (useIsoCode) {\n        const isoCode = env.lookup(`iso_code`);\n        if (typeof isoCode === \"string\" && isoCode.length > 0) {\n            return isoCode;\n        }\n    }\n    if (languages !== undefined) {\n        for (const lang of languages) {\n            name = (_a = env.lookup(`${basePropName}:${lang}`)) !== null && _a !== void 0 ? _a : env.lookup(`${basePropName}_${lang}`);\n            if (typeof name === \"string\" && name.length > 0) {\n                return name;\n            }\n        }\n    }\n    name = env.lookup(basePropName);\n    if (typeof name === \"string\") {\n        return name;\n    }\n    return undefined;\n}\nexports.getFeatureName = getFeatureName;\n/**\n * Determine the text string of the map feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param feature - Feature, including properties from the (OMV) feature.\n * @param technique - technique defining how text should be created from feature\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nfunction getFeatureText(context, technique, languages) {\n    let useAbbreviation;\n    let useIsoCode;\n    const env = context instanceof Expr_1.Env ? context : context.env;\n    let propName = \"name\";\n    if (Techniques_1.isTextTechnique(technique) ||\n        Techniques_1.isPoiTechnique(technique) ||\n        Techniques_1.isLineMarkerTechnique(technique)) {\n        if (technique.text !== undefined) {\n            return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);\n        }\n        if (technique.label !== undefined) {\n            propName = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.label);\n            if (typeof propName !== \"string\") {\n                return undefined;\n            }\n        }\n        useAbbreviation = technique.useAbbreviation;\n        useIsoCode = technique.useIsoCode;\n    }\n    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);\n}\nexports.getFeatureText = getFeatureText;\n//# sourceMappingURL=DecodedTile.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Env.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Env.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEnv = exports.Env = void 0;\n/**\n * A class used to lookup properties by name.\n *\n * @remarks\n * Concrete implementation of `Env` like {@link MapEnv} are used\n * to resolve the property names used in {@link Expr | style expressions}.\n *\n * @example\n * ```typescript\n * const env = new MapEnv({\n *     kind: \"landuse\",\n * });\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n *\n * const value = expr.evaluate(env);\n *\n * console.log(`kind is '${value}`);\n * ```\n */\nclass Env {\n    /**\n     * Returns `true` if the given object is an instance of {@link Env}.\n     *\n     * @param object - The object to test.\n     */\n    static isEnv(object) {\n        return object instanceof Env;\n    }\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     */\n    lookup(name) {\n        return undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment. (Here: empty object).\n     */\n    unmap() {\n        return {};\n    }\n}\nexports.Env = Env;\n/**\n * `MapEnv` is a concrete implementation of {@link Env} that\n * creates a lookup environment from a set of properties.\n *\n * @example\n * ```typescript\n * const baseEnv = new MapEnv({\n *     $zoom: 14,\n * });\n *\n * // extends baseEnv with a the new binding (kind, \"landuse\").\n * const env = new MapEnv({ kind: \"landuse\" }, baseEnv);\n *\n * const zoom = env.lookup(\"$zoom\"); // zoom is 14\n * const kind = env.lookup(\"kind\"); // kind is is \"landuse\"\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n * const value = expr.evaluate(env); // value is \"landuse\"\n * ```\n */\nclass MapEnv extends Env {\n    constructor(entries, parent) {\n        super();\n        this.entries = entries;\n        this.parent = parent;\n    }\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     * @override\n     */\n    lookup(name) {\n        if (this.entries.hasOwnProperty(name)) {\n            const value = this.entries[name];\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return this.parent ? this.parent.lookup(name) : undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment, takes care of the parent\n     * object.\n     * @override\n     */\n    unmap() {\n        const obj = this.parent ? this.parent.unmap() : {};\n        for (const key in this.entries) {\n            if (this.entries.hasOwnProperty(key)) {\n                obj[key] = this.entries[key];\n            }\n        }\n        return obj;\n    }\n}\nexports.MapEnv = MapEnv;\n//# sourceMappingURL=Env.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Env.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Expr.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InterpolateExpr = exports.StepExpr = exports.CaseExpr = exports.MatchExpr = exports.CallExpr = exports.HasAttributeExpr = exports.ObjectLiteralExpr = exports.StringLiteralExpr = exports.NumberLiteralExpr = exports.BooleanLiteralExpr = exports.NullLiteralExpr = exports.LiteralExpr = exports.VarExpr = exports.Expr = exports.ExprScope = exports.isJsonExpr = exports.ExprDependencies = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js\");\nconst ExprInstantiator_1 = __webpack_require__(/*! ./ExprInstantiator */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js\");\nconst ExprParser_1 = __webpack_require__(/*! ./ExprParser */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst Pixels_1 = __webpack_require__(/*! ./Pixels */ \"./node_modules/@here/harp-datasource-protocol/lib/Pixels.js\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\n__exportStar(__webpack_require__(/*! ./Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\"), exports);\nconst exprEvaluator = new ExprEvaluator_1.ExprEvaluator();\nconst exprInstantiator = new ExprInstantiator_1.ExprInstantiator();\n/**\n * The dependencies of an {@link Expr}.\n */\nclass ExprDependencies {\n    constructor() {\n        /**\n         * The properties needed to evaluate the {@link Expr}.\n         */\n        this.properties = new Set();\n    }\n}\nexports.ExprDependencies = ExprDependencies;\nclass ComputeExprDependencies {\n    /**\n     * Gets the dependencies of an {@link Expr}.\n     *\n     * @param expr - The {@link Expr} to process.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param dependencies - The output [[Set]] of dependency names.\n     */\n    static of(expr) {\n        const dependencies = new ExprDependencies();\n        expr.accept(this.instance, dependencies);\n        return dependencies;\n    }\n    visitNullLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitNumberLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitStringLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitObjectLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitVarExpr(expr, context) {\n        context.properties.add(expr.name);\n    }\n    visitHasAttributeExpr(expr, context) {\n        context.properties.add(expr.name);\n    }\n    visitCallExpr(expr, context) {\n        expr.args.forEach(childExpr => childExpr.accept(this, context));\n        switch (expr.op) {\n            case \"dynamic-properties\":\n                context.volatile = true;\n                break;\n            case \"feature-state\":\n                context.featureState = true;\n                context.properties.add(\"$state\");\n                context.properties.add(\"$id\");\n                break;\n            case \"id\":\n                context.properties.add(\"$id\");\n                break;\n            case \"zoom\":\n            case \"world-ppi-scale\":\n            case \"world-discrete-ppi-scale\":\n                context.properties.add(\"$zoom\");\n                break;\n            case \"geometry-type\":\n                context.properties.add(\"$geometryType\");\n                break;\n            default:\n                break;\n        }\n    }\n    visitMatchExpr(expr, context) {\n        expr.value.accept(this, context);\n        expr.branches.forEach(([_, branch]) => branch.accept(this, context));\n        expr.fallback.accept(this, context);\n    }\n    visitCaseExpr(expr, context) {\n        expr.branches.forEach(([condition, branch]) => {\n            condition.accept(this, context);\n            branch.accept(this, context);\n        });\n        expr.fallback.accept(this, context);\n    }\n    visitStepExpr(expr, context) {\n        expr.input.accept(this, context);\n        expr.defaultValue.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n    visitInterpolateExpr(expr, context) {\n        expr.input.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n}\nComputeExprDependencies.instance = new ComputeExprDependencies();\nfunction isJsonExpr(v) {\n    return Array.isArray(v) && v.length > 0 && typeof v[0] === \"string\";\n}\nexports.isJsonExpr = isJsonExpr;\n/**\n * The evaluation scope of an {@link Expr}.\n */\nvar ExprScope;\n(function (ExprScope) {\n    /**\n     * The scope of an {@link Expr} used as value of an attribute.\n     */\n    ExprScope[ExprScope[\"Value\"] = 0] = \"Value\";\n    /**\n     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.\n     */\n    ExprScope[ExprScope[\"Condition\"] = 1] = \"Condition\";\n    /**\n     * The scope of an {@link Expr} used as dynamic property attribute value.\n     */\n    ExprScope[ExprScope[\"Dynamic\"] = 2] = \"Dynamic\";\n})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));\n/**\n * Abstract class representing the\n * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}\n * used in {@link Theme}.\n */\nclass Expr {\n    /**\n     * Tests of given value is an {@link Expr}.\n     *\n     * @param value - The object to test.\n     */\n    static isExpr(value) {\n        return value instanceof Expr;\n    }\n    /**\n     * Creates an expression from the given `code`.\n     *\n     * @param code - The code to parse.\n     * @returns The parsed {@link Expr}.\n     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.\n     */\n    static parse(code) {\n        const parser = new ExprParser_1.ExprParser(code);\n        const expr = parser.parse();\n        return expr;\n    }\n    /**\n     * Creates a style expression from JSON.\n     *\n     * @remarks\n     * The optional set of {@link Theme.definitions | definitions} is used\n     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.\n     *\n     * @param json - JSON object representing the expression to parse.\n     * @param definitions - Optional set of definitions used to expand references.\n     * @param definitionExprCache - Optional cache of `Expr` instances\n     *\n     * @example\n     * ```typescript\n     * const expr = Expr.fromJSON([\"all\",\n     *     [\"==\", [\"geometry-type\"], \"LineString\"],\n     *     [\"has\", \"text\"]\n     * ]);\n     * ```\n     */\n    static fromJSON(json, definitions, definitionExprCache) {\n        const referenceResolverState = definitions !== undefined\n            ? {\n                definitions,\n                lockedNames: new Set(),\n                cache: definitionExprCache !== null && definitionExprCache !== void 0 ? definitionExprCache : new Map()\n            }\n            : undefined;\n        return parseNode(json, referenceResolverState);\n    }\n    /**\n     * Evaluate an expression returning a {@link Value} object.\n     *\n     * @param env - The {@link Env} used to lookup symbols.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param cache - A cache of previously computed results.\n     */\n    evaluate(env, scope = ExprScope.Value, cache) {\n        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));\n    }\n    /**\n     * Instantiates this {@link Expr}.\n     *\n     * @remarks\n     * references to the `get` and `has` operator using the given instantiation context.\n     *\n     * @param context - The [[InstantationContext]] used to resolve names.\n     */\n    instantiate(context) {\n        return this.accept(exprInstantiator, context);\n    }\n    /**\n     * Gets the dependencies of this {@link Expr}.\n     */\n    dependencies() {\n        if (!this.m_dependencies) {\n            this.m_dependencies = ComputeExprDependencies.of(this);\n        }\n        return this.m_dependencies;\n    }\n    /**\n     * Create a unique object that is structurally equivalent to this {@link Expr}.\n     *\n     * @param pool - The [[ExprPool]] used to create a unique\n     * equivalent object of this {@link Expr}.\n     */\n    intern(pool) {\n        return pool.add(this);\n    }\n    toJSON() {\n        return new ExprSerializer().serialize(this);\n    }\n    /**\n     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.\n     */\n    isDynamic() {\n        if (this.m_isDynamic === undefined) {\n            this.m_isDynamic = this.exprIsDynamic();\n        }\n        return this.m_isDynamic;\n    }\n}\nexports.Expr = Expr;\n/**\n * A node representing a `get` expression.\n */\nclass VarExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitVarExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.VarExpr = VarExpr;\n/**\n * A node representing a `literal` expression.\n */\nclass LiteralExpr extends Expr {\n    /**\n     * Create a [[LiteralExpr]] from the given value.\n     *\n     * @param value - A constant value.\n     */\n    static fromValue(value) {\n        switch (typeof value) {\n            case \"boolean\":\n                return new BooleanLiteralExpr(value);\n            case \"number\":\n                return new NumberLiteralExpr(value);\n            case \"string\":\n                return new StringLiteralExpr(value);\n            case \"object\":\n                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);\n            default:\n                throw new Error(`failed to create a literal from '${value}'`);\n        } // switch\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.LiteralExpr = LiteralExpr;\n/**\n * Null literal expression.\n */\nclass NullLiteralExpr extends LiteralExpr {\n    constructor() {\n        super();\n        /** @override */\n        this.value = null;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitNullLiteralExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.NullLiteralExpr = NullLiteralExpr;\nNullLiteralExpr.instance = new NullLiteralExpr();\n/**\n * Boolean literal expression.\n */\nclass BooleanLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitBooleanLiteralExpr(this, context);\n    }\n}\nexports.BooleanLiteralExpr = BooleanLiteralExpr;\n/**\n * Number literal expression.\n */\nclass NumberLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitNumberLiteralExpr(this, context);\n    }\n}\nexports.NumberLiteralExpr = NumberLiteralExpr;\n/**\n * String literal expression.\n */\nclass StringLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /**\n     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.\n     */\n    get promotedValue() {\n        var _a, _b, _c;\n        if (this.m_promotedValue === undefined) {\n            this.m_promotedValue = (_b = (_a = RGBA_1.RGBA.parse(this.value)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(this.value)) !== null && _b !== void 0 ? _b : null;\n        }\n        return (_c = this.m_promotedValue) !== null && _c !== void 0 ? _c : undefined;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitStringLiteralExpr(this, context);\n    }\n}\nexports.StringLiteralExpr = StringLiteralExpr;\n/**\n * Object literal expression.\n */\nclass ObjectLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get isArrayLiteral() {\n        return Array.isArray(this.value);\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitObjectLiteralExpr(this, context);\n    }\n}\nexports.ObjectLiteralExpr = ObjectLiteralExpr;\n/**\n * A node reperesenting a `has` expression.\n */\nclass HasAttributeExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitHasAttributeExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.HasAttributeExpr = HasAttributeExpr;\n/**\n * A node representing a `call` expression.\n */\nclass CallExpr extends Expr {\n    constructor(op, args) {\n        super();\n        this.op = op;\n        this.args = args;\n    }\n    /**\n     * Returns the child nodes of this {@link Expr}.\n     *\n     * @deprecated Use {@link CallExpr.args} instead.\n     */\n    get children() {\n        return this.args;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitCallExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        var _a;\n        const descriptor = (_a = this.descriptor) !== null && _a !== void 0 ? _a : ExprEvaluator_1.ExprEvaluator.getOperator(this.op);\n        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {\n            return true;\n        }\n        return this.args.some(e => e.isDynamic());\n    }\n}\nexports.CallExpr = CallExpr;\n/**\n * A node representing a `match` expression.\n */\nclass MatchExpr extends Expr {\n    constructor(value, branches, fallback) {\n        super();\n        this.value = value;\n        this.branches = branches;\n        this.fallback = fallback;\n    }\n    /**\n     * Tests if the given JSON node is a valid label for the `\"match\"` operator.\n     *\n     * @param node - A JSON value.\n     */\n    static isValidMatchLabel(node) {\n        switch (typeof node) {\n            case \"number\":\n            case \"string\":\n                return true;\n            case \"object\":\n                if (!Array.isArray(node) || node.length === 0) {\n                    return false;\n                }\n                const elementTy = typeof node[0];\n                if (elementTy === \"number\" || elementTy === \"string\") {\n                    return node.every(t => typeof t === elementTy);\n                }\n                return false;\n            default:\n                return false;\n        } // switch\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitMatchExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.value.isDynamic() ||\n            this.branches.some(([_, branch]) => branch.isDynamic()) ||\n            this.fallback.isDynamic());\n    }\n}\nexports.MatchExpr = MatchExpr;\n/**\n * A node representing a `case` expression.\n */\nclass CaseExpr extends Expr {\n    constructor(branches, fallback) {\n        super();\n        this.branches = branches;\n        this.fallback = fallback;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitCaseExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||\n            this.fallback.isDynamic());\n    }\n}\nexports.CaseExpr = CaseExpr;\n/**\n * A node representing a `step` expression.\n */\nclass StepExpr extends Expr {\n    constructor(input, defaultValue, stops) {\n        super();\n        this.input = input;\n        this.defaultValue = defaultValue;\n        this.stops = stops;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitStepExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.input.isDynamic() ||\n            this.defaultValue.isDynamic() ||\n            this.stops.some(([_, value]) => value.isDynamic()));\n    }\n}\nexports.StepExpr = StepExpr;\n/**\n * A node representing an `interpolate` expression.\n */\nclass InterpolateExpr extends Expr {\n    constructor(mode, input, stops) {\n        super();\n        this.mode = mode;\n        this.input = input;\n        this.stops = stops;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitInterpolateExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());\n    }\n}\nexports.InterpolateExpr = InterpolateExpr;\n/**\n * Serializes the Expr to JSON.\n *\n * @internal\n */\nclass ExprSerializer {\n    serialize(expr) {\n        return expr.accept(this, undefined);\n    }\n    visitNullLiteralExpr(expr, context) {\n        return null;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitStringLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        if (expr.value instanceof THREE.Vector2) {\n            return [\"make-vector\", expr.value.x, expr.value.y];\n        }\n        else if (expr.value instanceof THREE.Vector3) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z];\n        }\n        else if (expr.value instanceof THREE.Vector4) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z, expr.value.w];\n        }\n        return [\"literal\", expr.value];\n    }\n    visitVarExpr(expr, context) {\n        return [\"get\", expr.name];\n    }\n    visitHasAttributeExpr(expr, context) {\n        return [\"has\", expr.name];\n    }\n    visitCallExpr(expr, context) {\n        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];\n    }\n    visitMatchExpr(expr, context) {\n        const branches = [];\n        for (const [label, body] of expr.branches) {\n            branches.push(label, this.serialize(body));\n        }\n        return [\"match\", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];\n    }\n    visitCaseExpr(expr, context) {\n        const branches = [];\n        for (const [condition, body] of expr.branches) {\n            branches.push(this.serialize(condition), this.serialize(body));\n        }\n        return [\"case\", ...branches, this.serialize(expr.fallback)];\n    }\n    visitStepExpr(expr, context) {\n        const result = [\"step\"];\n        result.push(this.serialize(expr.input));\n        result.push(this.serialize(expr.defaultValue));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n    visitInterpolateExpr(expr, context) {\n        const result = [\"interpolate\", expr.mode];\n        result.push(this.serialize(expr.input));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n}\nfunction parseNode(node, referenceResolverState) {\n    if (Array.isArray(node)) {\n        return parseCall(node, referenceResolverState);\n    }\n    else if (node === null) {\n        return NullLiteralExpr.instance;\n    }\n    else if (typeof node === \"boolean\") {\n        return new BooleanLiteralExpr(node);\n    }\n    else if (typeof node === \"number\") {\n        return new NumberLiteralExpr(node);\n    }\n    else if (typeof node === \"string\") {\n        return new StringLiteralExpr(node);\n    }\n    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);\n}\nfunction parseCall(node, referenceResolverState) {\n    const op = node[0];\n    if (typeof op !== \"string\") {\n        throw new Error(\"expected a builtin function name\");\n    }\n    switch (op) {\n        case \"!has\":\n        case \"!in\":\n            return new CallExpr(\"!\", [parseCall([op.slice(1), ...node.slice(1)])]);\n        case \"ref\":\n            return resolveReference(node, referenceResolverState);\n        case \"get\":\n            return parseGetExpr(node, referenceResolverState);\n        case \"has\":\n            return parseHasExpr(node, referenceResolverState);\n        case \"literal\":\n            return parseLiteralExpr(node);\n        case \"match\":\n            return parseMatchExpr(node, referenceResolverState);\n        case \"case\":\n            return parseCaseExpr(node, referenceResolverState);\n        case \"interpolate\":\n            return parseInterpolateExpr(node, referenceResolverState);\n        case \"step\":\n            return parseStepExpr(node, referenceResolverState);\n        default:\n            return makeCallExpr(op, node, referenceResolverState);\n    } // switch\n}\nfunction parseGetExpr(node, referenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"get\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new VarExpr(name);\n}\nfunction parseHasExpr(node, referenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"has\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new HasAttributeExpr(name);\n}\nfunction parseLiteralExpr(node) {\n    const obj = node[1];\n    if (obj === null || typeof obj !== \"object\") {\n        throw new Error(\"expected an object or array literal\");\n    }\n    return new ObjectLiteralExpr(obj);\n}\nfunction parseMatchExpr(node, referenceResolverState) {\n    if (node.length < 4) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (!(node.length % 2)) {\n        throw new Error(\"fallback is missing in 'match' expression\");\n    }\n    const value = parseNode(node[1], referenceResolverState);\n    const conditions = [];\n    for (let i = 2; i < node.length - 1; i += 2) {\n        const label = node[i];\n        if (!MatchExpr.isValidMatchLabel(label)) {\n            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);\n        }\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        conditions.push([label, expr]);\n    }\n    const fallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new MatchExpr(value, conditions, fallback);\n}\nfunction parseCaseExpr(node, referenceResolverState) {\n    if (node.length < 3) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (node.length % 2) {\n        throw new Error(\"fallback is missing in 'case' expression\");\n    }\n    const branches = [];\n    for (let i = 1; i < node.length - 1; i += 2) {\n        const condition = parseNode(node[i], referenceResolverState);\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        branches.push([condition, expr]);\n    }\n    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new CaseExpr(branches, caseFallback);\n}\nfunction isInterpolationMode(object) {\n    if (!Array.isArray(object)) {\n        return false;\n    }\n    switch (object[0]) {\n        case \"discrete\":\n        case \"linear\":\n        case \"cubic\":\n        case \"exponential\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction parseInterpolateExpr(node, referenceResolverState) {\n    const mode = node[1];\n    if (!isInterpolationMode(mode)) {\n        throw new Error(\"expected an interpolation type\");\n    }\n    if (mode[0] === \"exponential\" && typeof mode[1] !== \"number\") {\n        throw new Error(\"expected the base of the exponential interpolation\");\n    }\n    const input = node[2] !== undefined ? parseNode(node[2], referenceResolverState) : undefined;\n    if (!Expr.isExpr(input)) {\n        throw new Error(`expected the input of the interpolation`);\n    }\n    if (node.length === 3 || !(node.length % 2)) {\n        throw new Error(\"invalid number of samples\");\n    }\n    const stops = [];\n    for (let i = 3; i < node.length - 1; i += 2) {\n        const key = node[i];\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new InterpolateExpr(mode, input, stops);\n}\nfunction parseStepExpr(node, referenceResolverState) {\n    if (node.length < 2) {\n        throw new Error(\"expected the input of the 'step' operator\");\n    }\n    if (node.length < 3 || !(node.length % 2)) {\n        throw new Error(\"not enough arguments\");\n    }\n    const input = parseNode(node[1], referenceResolverState);\n    const defaultValue = parseNode(node[2], referenceResolverState);\n    const stops = [];\n    for (let i = 3; i < node.length; i += 2) {\n        const key = node[i];\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new StepExpr(input, defaultValue, stops);\n}\nfunction makeCallExpr(op, node, referenceResolverState) {\n    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));\n}\nfunction resolveReference(node, referenceResolverState) {\n    if (typeof node[1] !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    if (referenceResolverState === undefined) {\n        throw new Error(`ref used with no definitions`);\n    }\n    const name = node[1];\n    if (referenceResolverState.lockedNames.has(name)) {\n        throw new Error(`circular referene to '${name}'`);\n    }\n    if (!(name in referenceResolverState.definitions)) {\n        throw new Error(`definition '${name}' not found`);\n    }\n    const cachedEntry = referenceResolverState.cache.get(name);\n    if (cachedEntry !== undefined) {\n        return cachedEntry;\n    }\n    let definitionEntry = referenceResolverState.definitions[name];\n    let result;\n    if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(definitionEntry.value)) {\n        // found a reference to an interpolation using\n        // the deprecated object-like syntax.\n        return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));\n    }\n    else if (isJsonExpr(definitionEntry.value)) {\n        definitionEntry = definitionEntry.value;\n    }\n    else {\n        return Expr.fromJSON(definitionEntry.value);\n    }\n    if (isJsonExpr(definitionEntry)) {\n        referenceResolverState.lockedNames.add(name);\n        try {\n            result = parseNode(definitionEntry, referenceResolverState);\n        }\n        finally {\n            referenceResolverState.lockedNames.delete(name);\n        }\n    }\n    else {\n        throw new Error(`unsupported definition ${name}`);\n    }\n    referenceResolverState.cache.set(name, result);\n    return result;\n}\n//# sourceMappingURL=Expr.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Expr.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprEvaluator = exports.ExprEvaluatorContext = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst ArrayOperators_1 = __webpack_require__(/*! ./operators/ArrayOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js\");\nconst CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js\");\nconst ColorOperators_1 = __webpack_require__(/*! ./operators/ColorOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js\");\nconst ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js\");\nconst FeatureOperators_1 = __webpack_require__(/*! ./operators/FeatureOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js\");\nconst FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js\");\nconst MapOperators_1 = __webpack_require__(/*! ./operators/MapOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js\");\nconst MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js\");\nconst MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js\");\nconst ObjectOperators_1 = __webpack_require__(/*! ./operators/ObjectOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js\");\nconst StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js\");\nconst TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js\");\nconst VectorOperators_1 = __webpack_require__(/*! ./operators/VectorOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js\");\nconst Pixels_1 = __webpack_require__(/*! ./Pixels */ \"./node_modules/@here/harp-datasource-protocol/lib/Pixels.js\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\nconst operatorDescriptors = new Map();\n/**\n * Promote string literals and values to color and pixel constants.\n *\n * @hidden\n * @internal\n */\nfunction promoteValue(context, expr) {\n    var _a, _b, _c;\n    if (expr instanceof Expr_1.StringLiteralExpr) {\n        return (_a = expr.promotedValue) !== null && _a !== void 0 ? _a : expr.value;\n    }\n    const value = context.evaluate(expr);\n    if (typeof value === \"string\") {\n        return (_c = (_b = RGBA_1.RGBA.parse(value)) !== null && _b !== void 0 ? _b : Pixels_1.Pixels.parse(value)) !== null && _c !== void 0 ? _c : value;\n    }\n    return value;\n}\nfunction cubicInterpolate(context, interp, t) {\n    if (t < interp.stops[0][0]) {\n        return promoteValue(context, interp.stops[0][1]);\n    }\n    else if (t >= interp.stops[interp.stops.length - 1][0]) {\n        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);\n    }\n    // indices\n    const i1 = interp.stops.findIndex(stop => stop[0] > t);\n    const i0 = Math.max(0, i1 - 1);\n    const iP = i0 === 0 ? i1 : i0 - 1;\n    const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;\n    // keys\n    const tP = interp.stops[iP][0];\n    const t0 = interp.stops[i0][0];\n    const t1 = interp.stops[i1][0];\n    const tN = interp.stops[iN][0];\n    const dt = (t1 - t0) * 0.5;\n    const wP = dt / (t0 - tP);\n    const wN = dt / (tN - t1);\n    const p = (t - t0) / (t1 - t0);\n    const pp = p * p;\n    const ppp = pp * p;\n    // coefficients\n    const cP = -wP * ppp + 2 * wP * pp - wP * p;\n    const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const cN = wN * ppp - wN * pp;\n    // values\n    const vP = promoteValue(context, interp.stops[iP][1]);\n    const v0 = promoteValue(context, interp.stops[i0][1]);\n    const v1 = promoteValue(context, interp.stops[i1][1]);\n    const vN = promoteValue(context, interp.stops[iN][1]);\n    if (typeof vP === \"number\" &&\n        typeof v0 === \"number\" &&\n        typeof v1 === \"number\" &&\n        typeof vN === \"number\") {\n        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;\n    }\n    else if (vP instanceof RGBA_1.RGBA &&\n        v0 instanceof RGBA_1.RGBA &&\n        v1 instanceof RGBA_1.RGBA &&\n        vN instanceof RGBA_1.RGBA) {\n        return new RGBA_1.RGBA(THREE.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1), THREE.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1), THREE.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1), THREE.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1));\n    }\n    else if (vP instanceof Pixels_1.Pixels &&\n        v0 instanceof Pixels_1.Pixels &&\n        v1 instanceof Pixels_1.Pixels &&\n        vN instanceof Pixels_1.Pixels) {\n        return new Pixels_1.Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);\n    }\n    else if (vP instanceof THREE.Color &&\n        v0 instanceof THREE.Color &&\n        v1 instanceof THREE.Color &&\n        vN instanceof THREE.Color) {\n        return new THREE.Color(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b);\n    }\n    else if (vP instanceof THREE.Vector2 &&\n        v0 instanceof THREE.Vector2 &&\n        v1 instanceof THREE.Vector2 &&\n        vN instanceof THREE.Vector2) {\n        return new THREE.Vector2(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y);\n    }\n    else if (vP instanceof THREE.Vector3 &&\n        v0 instanceof THREE.Vector3 &&\n        v1 instanceof THREE.Vector3 &&\n        vN instanceof THREE.Vector3) {\n        return new THREE.Vector3(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z);\n    }\n    else if (vP instanceof THREE.Vector4 &&\n        v0 instanceof THREE.Vector4 &&\n        v1 instanceof THREE.Vector4 &&\n        vN instanceof THREE.Vector4) {\n        return new THREE.Vector4(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z, cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w);\n    }\n    else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {\n        const N = vP.length;\n        const r = [];\n        for (let i = 0; i < N; ++i) {\n            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];\n        }\n        return r;\n    }\n    throw new Error(`failed to interpolate values`);\n}\n/*\n * @hidden\n */\nclass ExprEvaluatorContext {\n    constructor(evaluator, env, scope, cache) {\n        this.evaluator = evaluator;\n        this.env = env;\n        this.scope = scope;\n        this.cache = cache;\n    }\n    /**\n     * Evaluate the given expression.\n     *\n     * @param expr - The {@link Expr} to evaluate.\n     */\n    evaluate(expr) {\n        var _a, _b;\n        if (expr === undefined) {\n            throw new Error(\"Failed to evaluate expression\");\n        }\n        const cachedResult = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(expr);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        const result = expr.accept(this.evaluator, this);\n        (_b = this.cache) === null || _b === void 0 ? void 0 : _b.set(expr, result);\n        return result;\n    }\n    /**\n     * Wraps the given value in an {@link Expr} if needed.\n     *\n     * @param value -\n     */\n    wrapValue(value) {\n        return Expr_1.Expr.isExpr(value) ? value : Expr_1.LiteralExpr.fromValue(value);\n    }\n}\nexports.ExprEvaluatorContext = ExprEvaluatorContext;\n/**\n * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.\n *\n * @hidden\n */\nclass ExprEvaluator {\n    static defineOperator(op, builtin) {\n        operatorDescriptors.set(op, builtin);\n    }\n    static defineOperators(builtins) {\n        Object.getOwnPropertyNames(builtins).forEach(p => {\n            this.defineOperator(p, builtins[p]);\n        });\n    }\n    /**\n     * Returns the [[OperatorDescriptor]] for the given operator name.\n     * @hidden\n     */\n    static getOperator(op) {\n        return operatorDescriptors.get(op);\n    }\n    visitVarExpr(expr, context) {\n        const value = context.env.lookup(expr.name);\n        return value !== undefined ? value : null;\n    }\n    visitNullLiteralExpr(expr, context) {\n        return null;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitStringLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitHasAttributeExpr(expr, context) {\n        return context.env.lookup(expr.name) !== undefined;\n    }\n    visitMatchExpr(match, context) {\n        const r = context.evaluate(match.value);\n        for (const [label, body] of match.branches) {\n            if (Array.isArray(label) && label.includes(r)) {\n                return context.evaluate(body);\n            }\n            else if (label === r) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n    visitCaseExpr(match, context) {\n        if (context.scope === Expr_1.ExprScope.Value) {\n            const firstDynamicCondition = match.branches.findIndex(([condition, _]) => condition.isDynamic());\n            if (firstDynamicCondition !== -1) {\n                let branches;\n                for (let i = 0; i < match.branches.length; ++i) {\n                    const [condition, body] = match.branches[i];\n                    const evaluatedCondition = context.evaluate(condition);\n                    const evaluatedBody = context.evaluate(body);\n                    if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {\n                        return evaluatedBody;\n                    }\n                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {\n                        // skip this branch, it constantly evaluates to false.\n                        continue;\n                    }\n                    if (branches === undefined) {\n                        branches = [];\n                    }\n                    branches === null || branches === void 0 ? void 0 : branches.push([\n                        context.wrapValue(evaluatedCondition),\n                        context.wrapValue(evaluatedBody)\n                    ]);\n                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {\n                        // skip unreachble expressions\n                        return new Expr_1.CaseExpr(branches, Expr_1.LiteralExpr.fromValue(null));\n                    }\n                }\n                const fallback = context.evaluate(match.fallback);\n                return branches === undefined\n                    ? fallback\n                    : new Expr_1.CaseExpr(branches, context.wrapValue(fallback));\n            }\n        }\n        for (const [condition, body] of match.branches) {\n            if (context.evaluate(condition)) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n    visitCallExpr(expr, context) {\n        var _a;\n        const descriptor = (_a = expr.descriptor) !== null && _a !== void 0 ? _a : operatorDescriptors.get(expr.op);\n        if (descriptor) {\n            expr.descriptor = descriptor;\n            let result;\n            if (context.scope === Expr_1.ExprScope.Value && expr.isDynamic()) {\n                if (expr.descriptor.partialEvaluate) {\n                    return expr.descriptor.partialEvaluate(context, expr);\n                }\n                const args = expr.args.map(arg => {\n                    return context.wrapValue(context.evaluate(arg));\n                });\n                if (args.every((arg, i) => arg === expr.args[i])) {\n                    return expr;\n                }\n                result = new Expr_1.CallExpr(expr.op, args);\n            }\n            else {\n                result = descriptor.call(context, expr);\n            }\n            return result;\n        }\n        throw new Error(`undefined operator '${expr.op}'`);\n    }\n    visitStepExpr(expr, context) {\n        if (context.scope === Expr_1.ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            const defaultValue = context.evaluate(expr.defaultValue);\n            return new Expr_1.StepExpr(context.wrapValue(input), context.wrapValue(defaultValue), expr.stops.map(([key, value]) => {\n                const v = context.evaluate(value);\n                return [key, context.wrapValue(v)];\n            }));\n        }\n        else {\n            const input = context.evaluate(expr.input);\n            if (typeof input !== \"number\") {\n                throw new Error(`input '${input}' must be a number`);\n            }\n            if (input < expr.stops[0][0]) {\n                return context.evaluate(expr.defaultValue);\n            }\n            let index = expr.stops.findIndex(s => s[0] > input);\n            if (index === -1) {\n                index = expr.stops.length;\n            }\n            return context.evaluate(expr.stops[index - 1][1]);\n        }\n    }\n    visitInterpolateExpr(expr, context) {\n        if (context.scope === Expr_1.ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            return new Expr_1.InterpolateExpr(expr.mode, context.wrapValue(input), expr.stops.map(([key, value]) => {\n                const v = context.evaluate(value);\n                return [key, context.wrapValue(v)];\n            }));\n        }\n        else {\n            const param = context.evaluate(expr.input);\n            if (typeof param !== \"number\") {\n                throw new Error(`input must be a number`);\n            }\n            if (expr.mode[0] === \"cubic\") {\n                return cubicInterpolate(context, expr, param);\n            }\n            const keyIndex = expr.stops.findIndex(stop => stop[0] > param);\n            if (keyIndex === -1) {\n                // all the keys are smaller than the parameter\n                return context.evaluate(expr.stops[expr.stops.length - 1][1]);\n            }\n            else if (keyIndex === 0) {\n                return context.evaluate(expr.stops[0][1]);\n            }\n            const [key, value] = expr.stops[keyIndex];\n            const [prevKey, prevValue] = expr.stops[keyIndex - 1];\n            const v0 = promoteValue(context, prevValue);\n            let t = 0;\n            switch (expr.mode[0]) {\n                case \"discrete\":\n                    return v0;\n                case \"linear\":\n                    t = (param - prevKey) / (key - prevKey);\n                    break;\n                case \"exponential\": {\n                    const base = expr.mode[1];\n                    t =\n                        base === 1\n                            ? (param - prevKey) / (key - prevKey)\n                            : (Math.pow(base, param - prevKey) - 1) /\n                                (Math.pow(base, key - prevKey) - 1);\n                    break;\n                }\n                default:\n                    throw new Error(`interpolation mode ${JSON.stringify(expr.mode)} is not supported`);\n            }\n            const v1 = promoteValue(context, value);\n            if (typeof v0 === \"number\" && typeof v1 === \"number\") {\n                return THREE.MathUtils.lerp(v0, v1, t);\n            }\n            else if (v0 instanceof RGBA_1.RGBA && v1 instanceof RGBA_1.RGBA) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof Pixels_1.Pixels && v1 instanceof Pixels_1.Pixels) {\n                return new Pixels_1.Pixels(THREE.MathUtils.lerp(v0.value, v1.value, t));\n            }\n            else if (v0 instanceof THREE.Color && v1 instanceof THREE.Color) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof THREE.Vector2 && v1 instanceof THREE.Vector2) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof THREE.Vector3 && v1 instanceof THREE.Vector3) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (v0 instanceof THREE.Vector4 && v1 instanceof THREE.Vector4) {\n                return v0.clone().lerp(v1, t);\n            }\n            else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {\n                return v0.map((x, i) => THREE.MathUtils.lerp(x, v1[i], t));\n            }\n            throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);\n        }\n    }\n}\nexports.ExprEvaluator = ExprEvaluator;\nExprEvaluator.defineOperators(CastOperators_1.CastOperators);\nExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);\nExprEvaluator.defineOperators(MathOperators_1.MathOperators);\nExprEvaluator.defineOperators(StringOperators_1.StringOperators);\nExprEvaluator.defineOperators(ColorOperators_1.ColorOperators);\nExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);\nExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);\nExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);\nExprEvaluator.defineOperators(ArrayOperators_1.ArrayOperators);\nExprEvaluator.defineOperators(ObjectOperators_1.ObjectOperators);\nExprEvaluator.defineOperators(FeatureOperators_1.FeatureOperators);\nExprEvaluator.defineOperators(MapOperators_1.MapOperators);\nExprEvaluator.defineOperators(VectorOperators_1.VectorOperators);\n//# sourceMappingURL=ExprEvaluator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprInstantiator = void 0;\nconst Env_1 = __webpack_require__(/*! ./Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst emptyEnv = new Env_1.Env();\n/**\n * @hidden\n */\nclass ExprInstantiator {\n    visitNullLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitBooleanLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitStringLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitVarExpr(expr, context) {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name);\n        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);\n    }\n    visitHasAttributeExpr(expr, context) {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name) !== undefined;\n        return Expr_1.LiteralExpr.fromValue(value);\n    }\n    visitCallExpr(expr, context) {\n        const args = expr.args.map(arg => arg.accept(this, context));\n        if (args.some((a, i) => a !== expr.args[i])) {\n            return new Expr_1.CallExpr(expr.op, args);\n        }\n        return expr;\n    }\n    visitMatchExpr(match, context) {\n        const value = match.value.accept(this, context);\n        if (value instanceof Expr_1.LiteralExpr) {\n            const r = value.value;\n            for (const [label, body] of match.branches) {\n                if (Array.isArray(label) && label.includes(r)) {\n                    return body.accept(this, context);\n                }\n                else if (label === r) {\n                    return body.accept(this, context);\n                }\n            }\n            return match.fallback.accept(this, context);\n        }\n        let changed = match.value !== value;\n        const branches = match.branches.map(([label, branch]) => {\n            const newBranch = branch.accept(this, context);\n            if (newBranch !== branch) {\n                changed = true;\n            }\n            return [label, newBranch];\n        });\n        const fallback = match.fallback.accept(this, context);\n        if (fallback !== match.fallback) {\n            changed = true;\n        }\n        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;\n    }\n    visitCaseExpr(expr, context) {\n        const branches = [];\n        let changed = false;\n        for (const [condition, branch] of expr.branches) {\n            const newCondition = condition.accept(this, context);\n            const deps = newCondition.dependencies();\n            if (!condition.isDynamic() && deps.properties.size === 0) {\n                if (Boolean(newCondition.evaluate(emptyEnv, Expr_1.ExprScope.Condition))) {\n                    return branch.accept(this, context);\n                }\n            }\n            else {\n                if (newCondition !== condition) {\n                    changed = true;\n                }\n                branches.push([newCondition, branch]);\n            }\n        }\n        if (branches.length === 0) {\n            // all the conditions of this CaseExpr evaluated\n            // to false, so the resulting of instantiating this CaseExpr\n            // is the same as instantiating its fallback expression.\n            return expr.fallback.accept(this, context);\n        }\n        if (branches.length !== expr.branches.length) {\n            // the number of branches changed, this means that\n            // some of the branches had constant expressions that\n            // evaluate to false. In this case the resulting\n            // `CaseExpr` has less branches.\n            changed = true;\n        }\n        // Instantiate the body of all the branches of this CaseExpr\n        // that have dynamic conditions.\n        branches.forEach(branch => {\n            const instantiatedBranch = branch[1].accept(this, context);\n            if (instantiatedBranch !== branch[1]) {\n                changed = true;\n            }\n            branch[1] = instantiatedBranch;\n        });\n        const fallback = expr.fallback.accept(this, context);\n        if (fallback !== expr.fallback) {\n            changed = true;\n        }\n        if (!changed) {\n            // nothing changed, return the old expression.\n            return expr;\n        }\n        return new Expr_1.CaseExpr(branches, fallback);\n    }\n    visitStepExpr(expr, context) {\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new Expr_1.StepExpr(input, defaultValue, stops);\n    }\n    visitInterpolateExpr(expr, context) {\n        const input = expr.input.accept(this, context);\n        const stops = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new Expr_1.InterpolateExpr(expr.mode, input, stops);\n    }\n}\nexports.ExprInstantiator = ExprInstantiator;\n//# sourceMappingURL=ExprInstantiator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprParser = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * Character value\n */\nvar Character;\n(function (Character) {\n    Character[Character[\"Tab\"] = 9] = \"Tab\";\n    Character[Character[\"Lf\"] = 10] = \"Lf\";\n    Character[Character[\"Cr\"] = 13] = \"Cr\";\n    Character[Character[\"Space\"] = 32] = \"Space\";\n    Character[Character[\"LParen\"] = 40] = \"LParen\";\n    Character[Character[\"RParen\"] = 41] = \"RParen\";\n    Character[Character[\"Comma\"] = 44] = \"Comma\";\n    Character[Character[\"Dot\"] = 46] = \"Dot\";\n    Character[Character[\"LBracket\"] = 91] = \"LBracket\";\n    Character[Character[\"Backslash\"] = 92] = \"Backslash\";\n    Character[Character[\"RBracket\"] = 93] = \"RBracket\";\n    Character[Character[\"_0\"] = 48] = \"_0\";\n    Character[Character[\"_9\"] = 57] = \"_9\";\n    Character[Character[\"_\"] = 95] = \"_\";\n    Character[Character[\"A\"] = 64] = \"A\";\n    Character[Character[\"Z\"] = 90] = \"Z\";\n    Character[Character[\"a\"] = 97] = \"a\";\n    Character[Character[\"z\"] = 122] = \"z\";\n    Character[Character[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    Character[Character[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    Character[Character[\"Exclaim\"] = 33] = \"Exclaim\";\n    Character[Character[\"Equal\"] = 61] = \"Equal\";\n    Character[Character[\"Caret\"] = 94] = \"Caret\";\n    Character[Character[\"Tilde\"] = 126] = \"Tilde\";\n    Character[Character[\"Dollar\"] = 36] = \"Dollar\";\n    Character[Character[\"Less\"] = 60] = \"Less\";\n    Character[Character[\"Greater\"] = 62] = \"Greater\";\n    Character[Character[\"Bar\"] = 124] = \"Bar\";\n    Character[Character[\"Amp\"] = 38] = \"Amp\";\n})(Character || (Character = {}));\n/**\n * Check if a codepoint is a whitespace character.\n */\nfunction isSpace(codepoint) {\n    switch (codepoint) {\n        case Character.Tab:\n        case Character.Lf:\n        case Character.Cr:\n        case Character.Space:\n            return true;\n        default:\n            return false;\n    } // switch\n}\n/**\n * Check if codepoint is a digit character.\n */\nfunction isNumber(codepoint) {\n    return codepoint >= Character._0 && codepoint <= Character._9;\n}\n/**\n * Check if codepoint is a letter character.\n */\nfunction isLetter(codepoint) {\n    return ((codepoint >= Character.a && codepoint <= Character.z) ||\n        (codepoint >= Character.A && codepoint <= Character.Z));\n}\n/**\n * Check if codepoint is either a digit or a letter character.\n */\nfunction isLetterOrNumber(codepoint) {\n    return isLetter(codepoint) || isNumber(codepoint);\n}\n/**\n * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.\n */\nfunction isIdentChar(codepoint) {\n    return (isLetterOrNumber(codepoint) ||\n        codepoint === Character._ ||\n        codepoint === Character.Dollar ||\n        codepoint === Character.Dot ||\n        codepoint === Character.LBracket ||\n        codepoint === Character.RBracket);\n}\n/**\n * Tokens used in theme grammar.\n */\nvar Token;\n(function (Token) {\n    Token[Token[\"Eof\"] = 0] = \"Eof\";\n    Token[Token[\"Error\"] = 1] = \"Error\";\n    Token[Token[\"Identifier\"] = 2] = \"Identifier\";\n    Token[Token[\"Number\"] = 3] = \"Number\";\n    Token[Token[\"String\"] = 4] = \"String\";\n    Token[Token[\"Comma\"] = 5] = \"Comma\";\n    Token[Token[\"LParen\"] = 6] = \"LParen\";\n    Token[Token[\"RParen\"] = 7] = \"RParen\";\n    Token[Token[\"LBracket\"] = 8] = \"LBracket\";\n    Token[Token[\"RBracket\"] = 9] = \"RBracket\";\n    Token[Token[\"Exclaim\"] = 10] = \"Exclaim\";\n    Token[Token[\"TildeEqual\"] = 11] = \"TildeEqual\";\n    Token[Token[\"CaretEqual\"] = 12] = \"CaretEqual\";\n    Token[Token[\"DollarEqual\"] = 13] = \"DollarEqual\";\n    Token[Token[\"EqualEqual\"] = 14] = \"EqualEqual\";\n    Token[Token[\"ExclaimEqual\"] = 15] = \"ExclaimEqual\";\n    Token[Token[\"Less\"] = 16] = \"Less\";\n    Token[Token[\"Greater\"] = 17] = \"Greater\";\n    Token[Token[\"LessEqual\"] = 18] = \"LessEqual\";\n    Token[Token[\"GreaterEqual\"] = 19] = \"GreaterEqual\";\n    Token[Token[\"BarBar\"] = 20] = \"BarBar\";\n    Token[Token[\"AmpAmp\"] = 21] = \"AmpAmp\";\n})(Token || (Token = {}));\n/**\n * Maps a token to its string name.\n */\nfunction tokenSpell(token) {\n    switch (token) {\n        case Token.Eof:\n            return \"eof\";\n        case Token.Error:\n            return \"error\";\n        case Token.Identifier:\n            return \"identifier\";\n        case Token.Number:\n            return \"number\";\n        case Token.String:\n            return \"string\";\n        case Token.Comma:\n            return \",\";\n        case Token.LParen:\n            return \"(\";\n        case Token.RParen:\n            return \")\";\n        case Token.LBracket:\n            return \"[\";\n        case Token.RBracket:\n            return \"]\";\n        case Token.Exclaim:\n            return \"!\";\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        case Token.BarBar:\n            return \"||\";\n        case Token.AmpAmp:\n            return \"&&\";\n        default:\n            throw new Error(`invalid token ${token}`);\n    }\n}\n/**\n * Lexer class implementation.\n */\nclass Lexer {\n    constructor(code) {\n        this.code = code;\n        this.m_token = Token.Error;\n        this.m_index = 0;\n        this.m_char = Character.Lf;\n    }\n    /**\n     * Single lexer token.\n     */\n    token() {\n        return this.m_token;\n    }\n    /**\n     * Parsed text.\n     */\n    text() {\n        var _a;\n        return (_a = this.m_text) !== null && _a !== void 0 ? _a : \"\";\n    }\n    /**\n     * Go to the next token.\n     */\n    next() {\n        this.m_token = this.yylex();\n        if (this.m_token === Token.Error) {\n            throw new Error(`unexpected character ${this.m_char}`);\n        }\n        return this.m_token;\n    }\n    yyinp() {\n        var _a;\n        this.m_char = (_a = this.code.codePointAt(this.m_index++)) !== null && _a !== void 0 ? _a : 0;\n    }\n    yylex() {\n        this.m_text = undefined;\n        while (isSpace(this.m_char)) {\n            this.yyinp();\n        }\n        if (this.m_char === 0) {\n            return Token.Eof;\n        }\n        const ch = this.m_char;\n        this.yyinp();\n        switch (ch) {\n            case Character.LParen:\n                return Token.LParen;\n            case Character.RParen:\n                return Token.RParen;\n            case Character.LBracket:\n                return Token.LBracket;\n            case Character.RBracket:\n                return Token.RBracket;\n            case Character.Comma:\n                return Token.Comma;\n            case Character.SingleQuote:\n            case Character.DoubleQuote: {\n                const start = this.m_index - 1;\n                while (this.m_char && this.m_char !== ch) {\n                    // ### TODO handle escape sequences\n                    this.yyinp();\n                }\n                if (this.m_char !== ch) {\n                    throw new Error(\"Unfinished string literal\");\n                }\n                this.yyinp();\n                this.m_text = this.code.substring(start, this.m_index - 2);\n                return Token.String;\n            }\n            case Character.Exclaim:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.ExclaimEqual;\n                }\n                return Token.Exclaim;\n            case Character.Caret:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.CaretEqual;\n                }\n                return Token.Error;\n            case Character.Tilde:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.TildeEqual;\n                }\n                return Token.Error;\n            case Character.Equal:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.EqualEqual;\n                }\n                return Token.Error;\n            case Character.Less:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.LessEqual;\n                }\n                return Token.Less;\n            case Character.Greater:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.GreaterEqual;\n                }\n                return Token.Greater;\n            case Character.Bar:\n                if (this.m_char === Character.Bar) {\n                    this.yyinp();\n                    return Token.BarBar;\n                }\n                return Token.Error;\n            case Character.Amp:\n                if (this.m_char === Character.Amp) {\n                    this.yyinp();\n                    return Token.AmpAmp;\n                }\n                return Token.Error;\n            default: {\n                const start = this.m_index - 2;\n                if (isLetter(ch) ||\n                    ch === Character._ ||\n                    (ch === Character.Dollar && isIdentChar(this.m_char))) {\n                    while (isIdentChar(this.m_char)) {\n                        this.yyinp();\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Identifier;\n                }\n                else if (isNumber(ch)) {\n                    while (isNumber(this.m_char)) {\n                        this.yyinp();\n                    }\n                    if (this.m_char === Character.Dot) {\n                        this.yyinp();\n                        while (isNumber(this.m_char)) {\n                            this.yyinp();\n                        }\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Number;\n                }\n                else if (ch === Character.Dollar) {\n                    if (this.m_char === Character.Equal) {\n                        this.yyinp();\n                        return Token.DollarEqual;\n                    }\n                    return Token.Error;\n                }\n            }\n        }\n        return Token.Error;\n    }\n}\nfunction getEqualityOp(token) {\n    switch (token) {\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        default:\n            return undefined;\n    } // switch\n}\nfunction getRelationalOp(token) {\n    switch (token) {\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        default:\n            return undefined;\n    } // switch\n}\nclass ExprParser {\n    constructor(code) {\n        this.lex = new Lexer(code);\n        this.lex.next();\n    }\n    parse() {\n        return this.parseLogicalOr();\n    }\n    yyexpect(token) {\n        if (this.lex.token() !== token) {\n            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +\n                `found '${tokenSpell(this.lex.token())}'`);\n        }\n        this.lex.next();\n    }\n    parsePrimary() {\n        switch (this.lex.token()) {\n            case Token.Identifier: {\n                const text = this.lex.text();\n                switch (text) {\n                    case \"has\":\n                        this.lex.next(); // skip has keyword\n                        this.yyexpect(Token.LParen);\n                        const hasAttribute = this.lex.text();\n                        this.yyexpect(Token.Identifier);\n                        this.yyexpect(Token.RParen);\n                        return new Expr_1.HasAttributeExpr(hasAttribute);\n                    case \"length\":\n                        this.lex.next(); // skip length keyword\n                        this.yyexpect(Token.LParen);\n                        const value = this.parseLogicalOr();\n                        this.yyexpect(Token.RParen);\n                        return new Expr_1.CallExpr(\"length\", [value]);\n                    default:\n                        const expr = new Expr_1.VarExpr(text);\n                        this.lex.next();\n                        return expr;\n                }\n            }\n            case Token.LParen: {\n                this.lex.next();\n                const expr = this.parseLogicalOr();\n                this.yyexpect(Token.RParen);\n                return expr;\n            }\n            default:\n                return this.parseLiteral();\n        } // switch\n    }\n    parseLiteral() {\n        switch (this.lex.token()) {\n            case Token.Number: {\n                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));\n                this.lex.next();\n                return expr;\n            }\n            case Token.String: {\n                const expr = new Expr_1.StringLiteralExpr(this.lex.text());\n                this.lex.next();\n                return expr;\n            }\n            default:\n                throw new Error(\"Syntax error\");\n        } // switch\n    }\n    parseUnary() {\n        if (this.lex.token() === Token.Exclaim) {\n            this.lex.next();\n            return new Expr_1.CallExpr(\"!\", [this.parseUnary()]);\n        }\n        return this.parsePrimary();\n    }\n    parseRelational() {\n        let expr = this.parseUnary();\n        while (true) {\n            if (this.lex.token() === Token.Identifier && this.lex.text() === \"in\") {\n                this.lex.next();\n                this.yyexpect(Token.LBracket);\n                const elements = [this.parseLiteral()];\n                while (this.lex.token() === Token.Comma) {\n                    this.lex.next();\n                    elements.push(this.parseLiteral());\n                }\n                this.yyexpect(Token.RBracket);\n                expr = new Expr_1.CallExpr(\"in\", [\n                    expr,\n                    Expr_1.LiteralExpr.fromValue(elements.map(({ value }) => value))\n                ]);\n            }\n            else {\n                const op = getRelationalOp(this.lex.token());\n                if (op === undefined) {\n                    break;\n                }\n                this.lex.next();\n                const right = this.parseUnary();\n                expr = new Expr_1.CallExpr(op, [expr, right]);\n            }\n        }\n        return expr;\n    }\n    parseEquality() {\n        let expr = this.parseRelational();\n        while (true) {\n            let op = getEqualityOp(this.lex.token());\n            if (op === undefined) {\n                break;\n            }\n            if (op === \"~=\") {\n                op = \"in\";\n            }\n            this.lex.next();\n            const right = this.parseRelational();\n            expr = new Expr_1.CallExpr(op, [expr, right]);\n        }\n        return expr;\n    }\n    parseLogicalAnd() {\n        const expr = this.parseEquality();\n        if (this.lex.token() !== Token.AmpAmp) {\n            return expr;\n        }\n        const expressions = [expr];\n        do {\n            this.lex.next();\n            expressions.push(this.parseEquality());\n        } while (this.lex.token() === Token.AmpAmp);\n        return new Expr_1.CallExpr(\"all\", expressions);\n    }\n    parseLogicalOr() {\n        const expr = this.parseLogicalAnd();\n        if (this.lex.token() !== Token.BarBar) {\n            return expr;\n        }\n        const expressions = [expr];\n        do {\n            this.lex.next();\n            expressions.push(this.parseLogicalAnd());\n        } while (this.lex.token() === Token.BarBar);\n        return new Expr_1.CallExpr(\"any\", expressions);\n    }\n}\nexports.ExprParser = ExprParser;\n//# sourceMappingURL=ExprParser.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExprPool = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.\n *\n * @hidden\n */\nclass ExprPool {\n    constructor() {\n        this.m_booleanLiterals = new Map();\n        this.m_numberLiterals = new Map();\n        this.m_stringLiterals = new Map();\n        this.m_objectLiterals = new Map();\n        this.m_arrayLiterals = [];\n        this.m_varExprs = new Map();\n        this.m_hasAttributeExprs = new Map();\n        this.m_matchExprs = [];\n        this.m_caseExprs = [];\n        this.m_interpolateExprs = [];\n        this.m_stepExprs = [];\n        this.m_callExprs = new Map();\n    }\n    /**\n     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}\n     * object that is structurally equivalent to `expr`.\n     *\n     * @param expr - The {@link Expr} to add to this [[ExprPool]].\n     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.\n     */\n    add(expr) {\n        return expr.accept(this, undefined);\n    }\n    visitNullLiteralExpr(expr, context) {\n        return Expr_1.NullLiteralExpr.instance;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        const e = this.m_booleanLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_booleanLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        const e = this.m_numberLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_numberLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitStringLiteralExpr(expr, context) {\n        const e = this.m_stringLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_stringLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        const e = this.m_objectLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        if (Array.isArray(expr.value)) {\n            const array = expr.value;\n            const r = this.m_arrayLiterals.find(literal => {\n                const elements = literal.value;\n                if (elements.length !== array.length) {\n                    return false;\n                }\n                return array.every((x, i) => x === elements[i]);\n            });\n            if (r !== undefined) {\n                return r;\n            }\n            this.m_arrayLiterals.push(expr);\n        }\n        this.m_objectLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitVarExpr(expr, context) {\n        const e = this.m_varExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_varExprs.set(expr.name, expr);\n        return expr;\n    }\n    visitHasAttributeExpr(expr, context) {\n        const e = this.m_hasAttributeExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_hasAttributeExprs.set(expr.name, expr);\n        return expr;\n    }\n    visitMatchExpr(expr, context) {\n        const value = expr.value.accept(this, context);\n        const branches = expr.branches.map(([label, body]) => [\n            label,\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        for (const candidate of this.m_matchExprs) {\n            if (candidate.value !== value) {\n                continue;\n            }\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n        const r = new Expr_1.MatchExpr(value, branches, fallback);\n        this.m_matchExprs.push(r);\n        return r;\n    }\n    visitCaseExpr(expr, context) {\n        const branches = expr.branches.map(([condition, body]) => [\n            condition.accept(this, context),\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        for (const candidate of this.m_caseExprs) {\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n        const r = new Expr_1.CaseExpr(branches, fallback);\n        this.m_caseExprs.push(r);\n        return r;\n    }\n    visitCallExpr(expr, context) {\n        // rewrite the actual arguments\n        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));\n        // ensure we have a valid set of interned expressions for the calls\n        if (!this.m_callExprs.has(expr.op)) {\n            this.m_callExprs.set(expr.op, []);\n        }\n        // get the calls for the given operator.\n        const calls = this.m_callExprs.get(expr.op);\n        for (const call of calls) {\n            // check the number of arguments\n            if (call.args.length !== expressions.length) {\n                continue;\n            }\n            // find the index of the first mismatch.\n            let index = 0;\n            for (; index < call.args.length; ++index) {\n                if (call.args[index] !== expressions[index]) {\n                    break;\n                }\n            }\n            if (index === call.args.length) {\n                // no mismatch found, return the 'interned' call.\n                return call;\n            }\n        }\n        const e = new Expr_1.CallExpr(expr.op, expressions);\n        e.descriptor = expr.descriptor;\n        calls.push(e);\n        return e;\n    }\n    visitStepExpr(expr, context) {\n        if (this.m_stepExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const step of this.m_stepExprs) {\n            if (step.input === input &&\n                step.defaultValue === defaultValue &&\n                stops.length === step.stops.length &&\n                stops.every(([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1])) {\n                return step;\n            }\n        }\n        const e = new Expr_1.StepExpr(input, defaultValue, stops);\n        this.m_stepExprs.push(e);\n        return e;\n    }\n    visitInterpolateExpr(expr, context) {\n        if (this.m_interpolateExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const stops = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const interp of this.m_interpolateExprs) {\n            if (interp.input === input &&\n                interp.mode[0] === expr.mode[0] &&\n                interp.mode[1] === expr.mode[1] &&\n                stops.length === interp.stops.length &&\n                stops.every(([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1])) {\n                return interp;\n            }\n        }\n        const e = new Expr_1.InterpolateExpr(expr.mode, input, stops);\n        this.m_interpolateExprs.push(e);\n        return e;\n    }\n}\nexports.ExprPool = ExprPool;\n//# sourceMappingURL=ExprPool.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=GeoJsonDataType.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IMeshBuffers.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ITileDecoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ITiler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ITiler.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ITiler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ITiler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.interpolatedPropertyDefinitionToJsonExpr = exports.isInterpolatedPropertyDefinition = exports.InterpolationMode = void 0;\n/**\n * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.\n * @internal\n */\nvar InterpolationMode;\n(function (InterpolationMode) {\n    InterpolationMode[InterpolationMode[\"Discrete\"] = 0] = \"Discrete\";\n    InterpolationMode[InterpolationMode[\"Linear\"] = 1] = \"Linear\";\n    InterpolationMode[InterpolationMode[\"Cubic\"] = 2] = \"Cubic\";\n    InterpolationMode[InterpolationMode[\"Exponential\"] = 3] = \"Exponential\";\n})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));\n/**\n * Checks if a property is interpolated.\n * @param p - property to be checked\n * @internal\n */\nfunction isInterpolatedPropertyDefinition(p) {\n    if (p &&\n        p.interpolationMode === undefined &&\n        Array.isArray(p.values) &&\n        p.values.length > 0 &&\n        p.values[0] !== undefined &&\n        Array.isArray(p.zoomLevels) &&\n        p.zoomLevels.length > 0 &&\n        p.zoomLevels[0] !== undefined &&\n        p.values.length === p.zoomLevels.length) {\n        return true;\n    }\n    return false;\n}\nexports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;\n/**\n * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].\n *\n * @param property - A valid [[InterpolatedPropertyDefinition]]\n */\nfunction interpolatedPropertyDefinitionToJsonExpr(property) {\n    if (property.interpolation === undefined || property.interpolation === \"Discrete\") {\n        const step = [\"step\", [\"zoom\"], property.values[0]];\n        for (let i = 1; i < property.zoomLevels.length; ++i) {\n            step.push(property.zoomLevels[i], property.values[i]);\n        }\n        return step;\n    }\n    const interpolation = [\"interpolate\"];\n    switch (property.interpolation) {\n        case \"Linear\":\n            interpolation.push([\"linear\"]);\n            break;\n        case \"Cubic\":\n            interpolation.push([\"cubic\"]);\n            break;\n        case \"Exponential\":\n            interpolation.push([\n                \"exponential\",\n                property.exponent !== undefined ? property.exponent : 2\n            ]);\n            break;\n        default:\n            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);\n    } //switch\n    interpolation.push([\"zoom\"]);\n    for (let i = 0; i < property.zoomLevels.length; ++i) {\n        interpolation.push(property.zoomLevels[i], property.values[i]);\n    }\n    return interpolation;\n}\nexports.interpolatedPropertyDefinitionToJsonExpr = interpolatedPropertyDefinitionToJsonExpr;\n//# sourceMappingURL=InterpolatedPropertyDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Outliner.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Outliner.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addPolygonEdges = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst currEdgeStart = new THREE.Vector2();\nconst currEdgeGoal = new THREE.Vector2();\nconst prevEdgeStart = new THREE.Vector2();\nconst prevEdgeGoal = new THREE.Vector2();\n/**\n * Fills an index buffer with the indices for the edges of a polygon contour.\n *\n * @param indexBuffer - Edge index buffer to be filled.\n * @param vertexOffset - Starting offset of the vertices composing the contour.\n * @param vertexStride - Number of elements per contour vertex.\n * @param polygonContour - Vertices that compose the contour.\n * @param polygonContourEdges - Collection of booleans indicating if contour edges should be added.\n */\nfunction addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {\n    for (let i = 0; i < polygonContourEdges.length; ++i) {\n        if (polygonContourEdges[i]) {\n            if (isExtruded === true) {\n                const vFootprint0 = vertexOffset + i * 2;\n                const vRoof0 = vFootprint0 + 1;\n                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;\n                const vRoof1 = vFootprint1 + 1;\n                if (addFootprintEdges === true) {\n                    indexBuffer.push(vFootprint0, vFootprint1);\n                }\n                indexBuffer.push(vRoof0, vRoof1);\n                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;\n                if (polygonContourEdges[prevEdgeIdx]) {\n                    if (wallEdgeSlope !== undefined) {\n                        const v0x = polygonContour[i * vertexStride];\n                        const v0y = polygonContour[i * vertexStride + 1];\n                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];\n                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];\n                        currEdgeStart.set(v0x, v0y);\n                        currEdgeGoal.set(v1x, v1y);\n                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);\n                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);\n                        if (prevEdgeGoal\n                            .sub(prevEdgeStart)\n                            .normalize()\n                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {\n                            indexBuffer.push(vFootprint0, vRoof0);\n                        }\n                    }\n                    else {\n                        indexBuffer.push(vFootprint0, vRoof0);\n                    }\n                }\n            }\n            else {\n                const vFoot0 = vertexOffset + i;\n                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);\n                indexBuffer.push(vFoot0, vRoof0);\n            }\n        }\n    }\n}\nexports.addPolygonEdges = addPolygonEdges;\n//# sourceMappingURL=Outliner.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Outliner.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Pixels.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Pixels.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pixels = void 0;\nconst RX = /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/;\n/**\n * A class representing Pixels.\n *\n * @hidden\n * @internal\n */\nclass Pixels {\n    /**\n     * Constructs a [[Pixels]] literal\n     *\n     * @param value - The number of pixels.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Parses a pixel string literal.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text) {\n        const match = RX.exec(text);\n        if (match === null) {\n            return undefined;\n        }\n        return new Pixels(Number(match[1]));\n    }\n    toJSON() {\n        return `${this.value}px`;\n    }\n}\nexports.Pixels = Pixels;\n//# sourceMappingURL=Pixels.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Pixels.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=PostEffects.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPropertyValue = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst Pixels_1 = __webpack_require__(/*! ./Pixels */ \"./node_modules/@here/harp-datasource-protocol/lib/Pixels.js\");\nconst RGBA_1 = __webpack_require__(/*! ./RGBA */ \"./node_modules/@here/harp-datasource-protocol/lib/RGBA.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PropertyValue\");\n/**\n * Get the value of the specified property in given `env`.\n *\n * @param property - Property of a technique.\n * @param env - The {@link Env} used to evaluate the property\n * @param cache - An optional expression cache.\n */\nfunction getPropertyValue(property, env, cache) {\n    var _a, _b, _c;\n    if (Expr_1.Expr.isExpr(property)) {\n        try {\n            let r = property.evaluate(env, Expr_1.ExprScope.Dynamic, cache);\n            if (typeof r === \"string\") {\n                r = (_b = (_a = RGBA_1.RGBA.parse(r)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(r)) !== null && _b !== void 0 ? _b : r;\n            }\n            if (r instanceof RGBA_1.RGBA) {\n                return r.getHex();\n            }\n            else if (r instanceof Pixels_1.Pixels) {\n                return r.value * ((_c = Number(env.lookup(\"$pixelToMeters\"))) !== null && _c !== void 0 ? _c : 1);\n            }\n            return r;\n        }\n        catch (error) {\n            logger.error(\"failed to evaluate expression\", JSON.stringify(property), \"error\", String(error));\n            return null;\n        }\n    }\n    if (property === null || typeof property === \"undefined\") {\n        return null;\n    }\n    else if (typeof property !== \"string\") {\n        // Property in numeric or array, etc. format\n        return property;\n    }\n    else {\n        // Non-interpolated string encoded numeral parsing\n        const pixelToMeters = env.lookup(\"$pixelToMeters\") || 1;\n        const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);\n        return value !== undefined ? value : property;\n    }\n}\nexports.getPropertyValue = getPropertyValue;\n//# sourceMappingURL=PropertyValue.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/RGBA.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RGBA = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\n/**\n * A class representing RGBA colors.\n *\n * @hidden\n * @internal\n */\nclass RGBA {\n    /**\n     * Constructs a [[RGBA]] color using the given components in the [0..1] range.\n     */\n    constructor(r = 1, g = 1, b = 1, a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    /**\n     * Parses a string describing a color.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text) {\n        const color = StringEncodedNumeral_1.parseStringEncodedColor(text);\n        if (color === undefined) {\n            return undefined;\n        }\n        return ColorUtils_1.ColorUtils.getRgbaFromHex(color);\n    }\n    /**\n     * Clones this [[RGBA]] color.\n     */\n    clone() {\n        return new RGBA(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Returns this color encoded as one single number.\n     */\n    getHex() {\n        return ColorUtils_1.ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Linearly interpolate the components of this color.\n     */\n    lerp(target, t) {\n        this.r = three_1.MathUtils.lerp(this.r, target.r, t);\n        this.g = three_1.MathUtils.lerp(this.g, target.g, t);\n        this.b = three_1.MathUtils.lerp(this.b, target.b, t);\n        this.a = three_1.MathUtils.lerp(this.a, target.a, t);\n        return this;\n    }\n    /**\n     * Returns this color encoded as JSON literal.\n     */\n    toJSON() {\n        return `rgba(${(this.r * 255) << 0}, ${(this.g * 255) << 0}, ${(this.b * 255) << 0}, ${this.a})`;\n    }\n}\nexports.RGBA = RGBA;\n//# sourceMappingURL=RGBA.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/RGBA.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseStringEncodedColor = exports.parseStringEncodedNumeral = exports.StringEncodedNumeralFormatMaxSize = exports.StringEncodedNumeralFormats = exports.StringEncodedColorFormats = exports.StringEncodedMetricFormats = exports.StringEncodedNumeralType = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n//@ts-ignore\nconst csscolorparser_1 = __webpack_require__(/*! csscolorparser */ \"./node_modules/csscolorparser/csscolorparser.js\");\nconst ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\n/**\n * Enumeration of supported string encoded numerals.\n * @internal\n */\nvar StringEncodedNumeralType;\n(function (StringEncodedNumeralType) {\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Meters\"] = 0] = \"Meters\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Pixels\"] = 1] = \"Pixels\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Hex\"] = 2] = \"Hex\";\n})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));\nconst StringEncodedMeters = {\n    type: StringEncodedNumeralType.Meters,\n    size: 1,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))m$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedMeters.regExp.exec(encodedValue);\n        return match ? (target[0] = Number(match[1])) !== undefined : false;\n    }\n};\nconst StringEncodedPixels = {\n    type: StringEncodedNumeralType.Pixels,\n    size: 1,\n    mask: 1.0,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedPixels.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        target[0] = Number(match[1]);\n        return true;\n    }\n};\nconst StringEncodedHex = {\n    type: StringEncodedNumeralType.Hex,\n    size: 4,\n    regExp: /^\\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedHex.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        const hex = match[1];\n        const size = hex.length;\n        // Only few sizes are possible for given reg-exp.\n        harp_utils_1.assert(size === 4 || size === 8, `Matched incorrect hex color format`);\n        // Note that we simply ignore alpha channel value.\n        // TODO: To be resolved with HARP-7517\n        if (size === 4) {\n            // #RGB or #RGBA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;\n        }\n        else if (size === 8) {\n            // #RRGGBB or #RRGGBBAA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;\n        }\n        return true;\n    }\n};\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.\n * @internal\n */\nexports.StringEncodedMetricFormats = [\n    StringEncodedMeters,\n    StringEncodedPixels\n];\nconst StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.\n * @internal\n */\nexports.StringEncodedColorFormats = [StringEncodedHex];\nconst StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);\n/**\n * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with\n * [[StringEncodedNumeralType]] enum).\n * @internal\n */\nexports.StringEncodedNumeralFormats = [\n    ...exports.StringEncodedMetricFormats,\n    ...exports.StringEncodedColorFormats\n];\n/**\n * @internal\n */\nexports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);\nconst tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);\n/**\n * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].\n *\n * @param numeral - The string representing numeric value.\n * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).\n * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression\n * provided in [[numeral]].\n */\nfunction parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {\n    return parseStringLiteral(numeral, exports.StringEncodedNumeralFormats, pixelToMeters);\n}\nexports.parseStringEncodedNumeral = parseStringEncodedNumeral;\n/**\n * Parse string encoded color value using all known [[StringEncodedColorFormats]].\n *\n * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).\n * @returns The color parsed or __undefined__ if non of the known representations matches\n * the expression provided in [[color]].\n */\nfunction parseStringEncodedColor(color) {\n    return parseStringLiteral(color, exports.StringEncodedColorFormats);\n}\nexports.parseStringEncodedColor = parseStringEncodedColor;\nfunction parseStringLiteral(text, formats, pixelToMeters = 1.0) {\n    const matchedFormat = formats.find(format => {\n        return format.decoder(text, tmpBuffer) ? true : false;\n    });\n    if (matchedFormat === undefined) {\n        const components = csscolorparser_1.parseCSSColor(text);\n        return Array.isArray(components) && !components.some(c => isNaN(c))\n            ? ColorUtils_1.ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3])\n            : undefined;\n    }\n    switch (matchedFormat === null || matchedFormat === void 0 ? void 0 : matchedFormat.type) {\n        case StringEncodedNumeralType.Pixels:\n            return tmpBuffer[0] * pixelToMeters;\n        case StringEncodedNumeralType.Hex:\n            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);\n        default:\n            return tmpBuffer[0];\n    }\n}\n//# sourceMappingURL=StringEncodedNumeral.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeDecodedTechnique = exports.StyleSetEvaluator = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst ExprPool_1 = __webpack_require__(/*! ./ExprPool */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst TechniqueDescriptors_1 = __webpack_require__(/*! ./TechniqueDescriptors */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js\");\nconst Techniques_1 = __webpack_require__(/*! ./Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"StyleSetEvaluator\");\nconst DEFAULT_TECHNIQUE_ATTR_SCOPE = TechniqueDescriptors_1.AttrScope.TechniqueGeometry;\n/**\n * Get the attribute scope of the given style property.\n *\n * @remarks\n * Certain Style properties change their dynamic scope behavior\n * based on other properties. For example, the `color` property\n * of `extruded-polygon` change behavior based on the usage\n * of `vertexColors`.\n *\n * @param style A valid Style.\n * @param attrName The name of the attribute of the {@link style}.\n */\nfunction getStyleAttributeScope(style, attrName) {\n    var _a, _b;\n    if (style.technique === \"extruded-polygon\") {\n        if (attrName === \"color\" && style.vertexColors !== false) {\n            return DEFAULT_TECHNIQUE_ATTR_SCOPE;\n        }\n    }\n    return ((_b = (_a = TechniqueDescriptors_1.getTechniqueAttributeDescriptor(style.technique, attrName)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : DEFAULT_TECHNIQUE_ATTR_SCOPE);\n}\n/**\n * `StyleConditionClassifier` searches for usages of `$layer` in `when` conditions\n * associated with styling rules.\n *\n * @hidden\n */\nclass StyleConditionClassifier {\n    classify(style) {\n        if (style._whenExpr) {\n            const savedStyle = this.switchStyle(style);\n            style._whenExpr = style._whenExpr.accept(this, undefined);\n            this._style = savedStyle;\n        }\n    }\n    visitNullLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitBooleanLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitStringLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitVarExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitHasAttributeExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitMatchExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitCaseExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitCallExpr(call, enclosingExpr) {\n        if (call.op === \"all\") {\n            // processing of an `[\"all\", e1, e2, ... eN]` expression. In this case\n            // search for expressions matching comparison of `$layer` and string literals\n            // in the sub expressions.\n            const children = call.args\n                .map(childExpr => childExpr.accept(this, call))\n                .filter(childExpr => childExpr !== undefined);\n            return new Expr_1.CallExpr(call.op, children);\n        }\n        else if (enclosingExpr) {\n            // `call` is a direct child expression of an `\"all\"` operator.\n            const matched = this.matchVarStringComparison(call);\n            if (matched) {\n                if (this._style.layer === undefined && matched.name === \"$layer\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$layer\"], \"some layer name\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $layer in\n                    // [[StyleInternalParams]].\n                    this._style.layer = matched.value;\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n                else if (this._style._geometryType === undefined &&\n                    matched.name === \"$geometryType\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$geometryType\"], \"geometry\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $geometryType in\n                    // [[StyleInternalParams]].\n                    this._style._geometryType = matched.value;\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n            }\n        }\n        return call;\n    }\n    visitStepExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitInterpolateExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    /**\n     * Tests if the given `call` matches the structure [\"==\", [\"get\", name], value].\n     * If a match is found returns an object containing the `name` and the `value`;\n     *\n     * @param call - The expression to match.\n     */\n    matchVarStringComparison(call) {\n        if (call.op === \"==\") {\n            const left = call.args[0];\n            const right = call.args[1];\n            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {\n                return { name: left.name, value: right.value };\n            }\n            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {\n                return { name: right.name, value: left.value };\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Sets the given `style` as current.\n     *\n     * @returns The previous `style`.\n     */\n    switchStyle(style) {\n        const saved = this._style;\n        this._style = style;\n        return saved;\n    }\n}\nclass OptimizedSubSetKey {\n    constructor(layer, geometryType) {\n        this.key = \"\";\n        this.set(layer, geometryType);\n    }\n    set(layer, geometryType, env) {\n        let keyUpdateNeeded = false;\n        if (layer === undefined) {\n            const envLayer = env !== undefined ? env.lookup(\"$layer\") : undefined;\n            layer = typeof envLayer === \"string\" ? envLayer : undefined;\n        }\n        if (this.layer !== layer) {\n            this.layer = layer;\n            keyUpdateNeeded = true;\n        }\n        if (geometryType === undefined) {\n            const envGeometryType = env !== undefined ? env.lookup(\"$geometryType\") : undefined;\n            geometryType = typeof envGeometryType === \"string\" ? envGeometryType : undefined;\n        }\n        if (this.geometryType !== geometryType) {\n            this.geometryType = geometryType;\n            keyUpdateNeeded = true;\n        }\n        if (keyUpdateNeeded) {\n            this.updateKey();\n        }\n        return this;\n    }\n    updateKey() {\n        if (this.layer !== undefined) {\n            if (this.geometryType !== undefined) {\n                this.key = `${this.layer}:${this.geometryType}`;\n            }\n            else {\n                this.key = `${this.layer}:`;\n            }\n        }\n        else {\n            if (this.geometryType !== undefined) {\n                this.key = `:${this.geometryType}`;\n            }\n            else {\n                this.key = \"all\";\n            }\n        }\n        this.cachedStyleSet = undefined;\n    }\n}\n/**\n * Combine data from datasource and apply the rules from a specified theme to show it on the map.\n */\nclass StyleSetEvaluator {\n    constructor(m_options) {\n        this.m_options = m_options;\n        this.m_techniques = [];\n        this.m_exprPool = new ExprPool_1.ExprPool();\n        this.m_cachedResults = new Map();\n        this.m_styleConditionClassifier = new StyleConditionClassifier();\n        this.m_subStyleSetCache = new Map();\n        this.m_definitionExprCache = new Map();\n        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();\n        this.m_emptyEnv = new Expr_1.Env();\n        this.m_featureDependencies = [];\n        this.m_definitions = this.m_options.definitions;\n        this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);\n        computeDefaultRenderOrder(this.styleSet);\n        this.compileStyleSet();\n    }\n    /**\n     * Find all techniques that fit the current objects' environment.\n     * *The techniques in the resulting array may not be modified* since they are being reused for\n     * identical objects.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     * representation.\n     * @param layer - The optional layer name used to filter techniques.\n     * @param geometryType - The optional geometryType used to filter techniques.\n     */\n    getMatchingTechniques(env, layer, geometryType) {\n        if (this.m_previousResult &&\n            this.m_previousEnv &&\n            this.m_featureDependencies.every(p => { var _a; return ((_a = this.m_previousEnv) === null || _a === void 0 ? void 0 : _a.lookup(p)) === env.lookup(p); })) {\n            return this.m_previousResult;\n        }\n        const result = [];\n        this.m_cachedResults.clear();\n        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;\n        optimizedSubSetKey.set(layer, geometryType, env);\n        // get the requested $layer and $geometryType, if any.\n        this.m_layer = optimizedSubSetKey.layer;\n        this.m_geometryType = optimizedSubSetKey.geometryType;\n        this.m_zoomLevel = env.lookup(\"$zoom\");\n        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);\n        for (const currStyle of searchedStyleSet) {\n            if (this.processStyle(env, currStyle, result)) {\n                break;\n            }\n        }\n        this.m_previousResult = result;\n        this.m_previousEnv = env;\n        return result;\n    }\n    /**\n     * Check if `styleSet` contains any rule related to `layer`.\n     *\n     * @param layer - name of layer\n     */\n    wantsLayer(layer) {\n        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);\n    }\n    /**\n     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.\n     *\n     * @param layer - name of layer\n     * @param geometryType - type of layer - `point`, `line` or `polygon`\n     */\n    wantsFeature(layer, geometryType) {\n        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))\n            .length > 0);\n    }\n    /**\n     * Get the expression evaluation cache, for further feature processing.\n     *\n     * This object is valid until next `getMatchingTechniques` call.\n     */\n    get expressionEvaluatorCache() {\n        return this.m_cachedResults;\n    }\n    /**\n     * Reset array of techniques.\n     *\n     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.\n     */\n    resetTechniques() {\n        for (const techinque of this.m_techniques) {\n            techinque._index = undefined;\n        }\n        this.m_techniques.length = 0;\n        this.m_previousResult = undefined;\n        this.m_previousEnv = undefined;\n    }\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get techniques() {\n        return this.m_techniques;\n    }\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get decodedTechniques() {\n        return this.m_techniques.map(makeDecodedTechnique);\n    }\n    getOptimizedStyleSet(subSetKey) {\n        if (subSetKey.cachedStyleSet !== undefined) {\n            return subSetKey.cachedStyleSet;\n        }\n        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);\n        if (optimizedStyleSet !== undefined) {\n            subSetKey.cachedStyleSet = optimizedStyleSet;\n            return optimizedStyleSet;\n        }\n        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);\n        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);\n        subSetKey.cachedStyleSet = optimizedStyleSet;\n        return optimizedStyleSet;\n    }\n    createPreFilteredStyleSet(subSetKey) {\n        const { layer, geometryType } = subSetKey;\n        return this.styleSet.filter(style => {\n            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {\n                return false;\n            }\n            if (geometryType !== undefined &&\n                style._geometryType !== undefined &&\n                style._geometryType !== geometryType) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * Compile the `when` conditions found when traversting the styling rules.\n     */\n    compileStyleSet() {\n        this.m_featureDependencies = [\"$layer\", \"$geometryType\", \"$zoom\"];\n        this.styleSet.forEach(style => this.compileStyle(style));\n        // Create optimized styleSets for each `layer` & `geometryType` tuple.\n        this.styleSet.forEach(style => {\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));\n        });\n    }\n    /**\n     * Compile the `when` conditions reachable from the given `style`.\n     *\n     * @param style - The current style.\n     */\n    compileStyle(style) {\n        this.checkStyleDynamicAttributes(style);\n        if (style.when !== undefined) {\n            try {\n                style._whenExpr = Array.isArray(style.when)\n                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)\n                    : Expr_1.Expr.parse(style.when);\n                // search for usages of '$layer' and any other\n                // special symbol that can be used to speed up the evaluation\n                // of the `when` conditions associated to this `style`.\n                this.m_styleConditionClassifier.classify(style);\n                if (style._whenExpr !== undefined) {\n                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);\n                }\n                const deps = style._whenExpr.dependencies();\n                deps === null || deps === void 0 ? void 0 : deps.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n                if (Expr_1.isJsonExpr(style.minZoomLevel)) {\n                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel).intern(this.m_exprPool);\n                }\n                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {\n                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel).intern(this.m_exprPool);\n                }\n            }\n            catch (err) {\n                logger.log(\"failed to evaluate expression\", JSON.stringify(style.when), \"error\", String(err));\n            }\n        }\n    }\n    /**\n     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the\n     * current objects' environment. The attributes of the styles are assembled to create a unique\n     * technique for every object.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     *            representation.\n     * @param style - Current style (could also be top of stack).\n     * @param result - The array of resulting techniques. There may be more than one technique per\n     *               object, resulting in multiple graphical objects for representation.\n     * @returns `true` if style has been found and processing is finished. `false` if not found, or\n     *          more than one technique should be applied.\n     */\n    processStyle(env, style, result) {\n        if (!this.checkZoomLevel(env, style)) {\n            return false;\n        }\n        if (this.m_layer !== undefined &&\n            style.layer !== undefined &&\n            style.layer !== this.m_layer) {\n            return false;\n        }\n        if (this.m_geometryType !== undefined &&\n            style._geometryType !== undefined &&\n            style._geometryType !== this.m_geometryType) {\n            return false;\n        }\n        if (style._whenExpr) {\n            try {\n                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {\n                    // Stop processing this styling rule. The `when` condition\n                    // associated with the current `style` evaluates to false so\n                    // no techinque defined by this style should be applied.\n                    return false;\n                }\n            }\n            catch (error) {\n                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);\n                return false;\n            }\n        }\n        if (style.technique === undefined) {\n            return false;\n        }\n        // we found a technique!\n        if (style.technique !== \"none\") {\n            result.push(this.getTechniqueForStyleMatch(env, style));\n        }\n        // stop processing if \"final\" is set\n        return style.final === true;\n    }\n    checkZoomLevel(env, style) {\n        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {\n            return true;\n        }\n        const zoomLevel = this.m_zoomLevel;\n        if (zoomLevel === undefined) {\n            return true;\n        }\n        if (style.minZoomLevel !== undefined) {\n            let minZoomLevel = style.minZoomLevel;\n            if (style._minZoomLevelExpr) {\n                // the constraint is defined as expression, evaluate it and\n                // use its value\n                try {\n                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);\n                }\n                catch (error) {\n                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);\n                }\n            }\n            if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n                return false;\n            }\n        }\n        if (style.maxZoomLevel !== undefined) {\n            let maxZoomLevel = style.maxZoomLevel;\n            if (style._maxZoomLevelExpr) {\n                try {\n                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);\n                }\n                catch (error) {\n                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);\n                }\n            }\n            if (typeof maxZoomLevel === \"number\" && zoomLevel >= maxZoomLevel) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getTechniqueForStyleMatch(env, style) {\n        let technique;\n        if (style._dynamicTechniques !== undefined) {\n            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);\n            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);\n            technique = style._dynamicTechniques.get(key);\n            if (technique === undefined) {\n                technique = this.createTechnique(style, key, dynamicAttributes);\n                style._dynamicTechniques.set(key, technique);\n            }\n        }\n        else {\n            technique = style._staticTechnique;\n            if (technique === undefined) {\n                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);\n            }\n        }\n        if (technique._index === undefined) {\n            technique._index = this.m_techniques.length;\n            this.m_techniques.push(technique);\n        }\n        return technique;\n    }\n    getDynamicTechniqueKey(style, dynamicAttributes) {\n        const dynamicAttrKey = dynamicAttributes\n            .map(([_attrName, attrValue]) => {\n            if (attrValue === undefined) {\n                return \"U\";\n            }\n            else {\n                return JSON.stringify(attrValue);\n            }\n        })\n            .join(\":\");\n        return `${style._styleSetIndex}:${dynamicAttrKey}`;\n    }\n    checkStyleDynamicAttributes(style) {\n        var _a;\n        if (style._dynamicTechniqueAttributes !== undefined || style.technique === \"none\") {\n            return;\n        }\n        style._dynamicTechniqueAttributes = [];\n        style._dynamicFeatureAttributes = [];\n        style._dynamicForwardedAttributes = [];\n        style._staticAttributes = [];\n        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;\n        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;\n        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;\n        const targetStaticAttributes = style._staticAttributes;\n        const processAttribute = (attrName, attrValue) => {\n            if (attrValue === undefined) {\n                return;\n            }\n            if (Expr_1.isJsonExpr(attrValue)) {\n                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);\n            }\n            else if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(attrValue)) {\n                // found a property using an object-like interpolation definition.\n                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);\n            }\n            if (Expr_1.Expr.isExpr(attrValue)) {\n                const deps = attrValue.dependencies();\n                if (deps.featureState) {\n                    if (attrName !== \"enabled\") {\n                        logger.log(\"feature-state is not supported in this context\");\n                    }\n                    else {\n                        style._usesFeatureState = true;\n                    }\n                }\n                if (deps.properties.size === 0 && !attrValue.isDynamic()) {\n                    // no data-dependencies detected.\n                    attrValue = attrValue.evaluate(this.m_emptyEnv);\n                }\n            }\n            if (Expr_1.Expr.isExpr(attrValue)) {\n                const attrScope = getStyleAttributeScope(style, attrName);\n                const deps = attrValue.dependencies();\n                deps.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n                switch (attrScope) {\n                    case TechniqueDescriptors_1.AttrScope.FeatureGeometry:\n                        dynamicFeatureAttributes.push([attrName, attrValue]);\n                        break;\n                    case TechniqueDescriptors_1.AttrScope.TechniqueGeometry:\n                        dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        break;\n                    case TechniqueDescriptors_1.AttrScope.TechniqueRendering:\n                        if (deps.properties.size === 0) {\n                            dynamicForwardedAttributes.push([attrName, attrValue]);\n                        }\n                        else {\n                            dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        }\n                        break;\n                }\n            }\n            else if (attrValue !== undefined && attrValue !== null) {\n                targetStaticAttributes.push([attrName, attrValue]);\n            }\n        };\n        const replacement = new Map([\n            [\"category\", \"_category\"],\n            [\"secondaryCategory\", \"_secondaryCategory\"]\n        ]);\n        for (const p in style) {\n            if (!style.hasOwnProperty(p)) {\n                continue;\n            }\n            if (p.startsWith(\"_\")) {\n                continue;\n            }\n            if ([\"when\", \"technique\", \"layer\", \"attr\", \"description\"].includes(p)) {\n                continue;\n            }\n            const pp = (_a = replacement.get(p)) !== null && _a !== void 0 ? _a : p;\n            processAttribute(pp, style[p]);\n        }\n        if (style.attr !== undefined) {\n            for (const attrName in style.attr) {\n                if (!style.attr.hasOwnProperty(attrName)) {\n                    continue;\n                }\n                processAttribute(attrName, style.attr[attrName]);\n            }\n        }\n        if (dynamicTechniqueAttributes.length > 0) {\n            style._dynamicTechniques = new Map();\n        }\n    }\n    evaluateTechniqueProperties(style, env) {\n        if (style._dynamicTechniqueAttributes === undefined) {\n            return [];\n        }\n        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {\n            try {\n                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);\n                return [attrName, evaluatedValue];\n            }\n            catch (error) {\n                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);\n                return [attrName, null];\n            }\n        });\n    }\n    createTechnique(style, key, dynamicAttrs) {\n        var _a, _b;\n        const technique = {};\n        technique.name = style.technique;\n        if (style._staticAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._staticAttributes) {\n                if (attrValue !== null) {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        for (const [attrName, attrValue] of dynamicAttrs) {\n            if (attrValue !== null) {\n                technique[attrName] = attrValue;\n            }\n        }\n        if (style._dynamicFeatureAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n        if (style._dynamicForwardedAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n        technique._index = this.m_techniques.length;\n        technique._styleSetIndex = style._styleSetIndex;\n        if (style.styleSet !== undefined) {\n            technique._styleSet = style.styleSet;\n        }\n        if (style._usesFeatureState !== undefined) {\n            technique._usesFeatureState = style._usesFeatureState;\n        }\n        Techniques_1.setTechniqueRenderOrderOrPriority(technique, (_a = this.m_options.priorities) !== null && _a !== void 0 ? _a : [], (_b = this.m_options.labelPriorities) !== null && _b !== void 0 ? _b : []);\n        this.m_techniques.push(technique);\n        return technique;\n    }\n}\nexports.StyleSetEvaluator = StyleSetEvaluator;\nfunction computeDefaultRenderOrder(styleSet) {\n    let techniqueRenderOrder = 0;\n    let styleSetIndex = 0;\n    for (const style of styleSet) {\n        style._styleSetIndex = styleSetIndex++;\n        if (style.technique !== undefined && style.renderOrder === undefined) {\n            style.renderOrder = techniqueRenderOrder++;\n        }\n    }\n}\nfunction resolveReferences(styleSet, definitions) {\n    return styleSet.map(style => resolveStyleReferences(style, definitions));\n}\nfunction resolveStyleReferences(style, definitions) {\n    return Object.assign({}, style);\n}\n/**\n * Create transferable representation of dynamic technique.\n *\n * Converts  non-transferable {@link Expr}instances back to JSON form.\n */\nfunction makeDecodedTechnique(technique) {\n    const result = {};\n    for (const attrName in technique) {\n        if (!technique.hasOwnProperty(attrName)) {\n            continue;\n        }\n        let attrValue = technique[attrName];\n        if (typeof attrValue === \"object\" &&\n            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {\n            attrValue = Expr_1.LiteralExpr.fromValue(attrValue);\n        }\n        if (Expr_1.Expr.isExpr(attrValue)) {\n            attrValue = attrValue.toJSON();\n        }\n        result[attrName] = attrValue;\n    }\n    return result;\n}\nexports.makeDecodedTechnique = makeDecodedTechnique;\n//# sourceMappingURL=StyleSetEvaluator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.evaluateTechniqueAttr = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst PropertyValue_1 = __webpack_require__(/*! ./PropertyValue */ \"./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js\");\nfunction evaluateTechniqueAttr(context, attrValue, defaultValue) {\n    if (attrValue === undefined) {\n        return defaultValue;\n    }\n    const result = Expr_1.Env.isEnv(context)\n        ? PropertyValue_1.getPropertyValue(attrValue, context)\n        : PropertyValue_1.getPropertyValue(attrValue, context.env, context.cachedExprResults);\n    return result !== null && result !== void 0 ? result : defaultValue;\n}\nexports.evaluateTechniqueAttr = evaluateTechniqueAttr;\n//# sourceMappingURL=TechniqueAttr.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTechniqueAutomaticAttrs = exports.getTechniqueAttributeDescriptor = exports.getTechniqueDescriptor = exports.AttrScope = void 0;\nvar AttrScope;\n(function (AttrScope) {\n    /**\n     * Attributes that affect generation of feature geometry and thus must be resolved at decoding\n     * time.\n     *\n     * @remarks\n     * They may have huge variancy as they are implemented as vertex attributes or embedded in\n     * generated meshes.\n     *\n     * These attributes are available only in decoding scope.\n     */\n    AttrScope[AttrScope[\"FeatureGeometry\"] = 0] = \"FeatureGeometry\";\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * These attributes affect generated geometry and  thus must be resolved at decoding time.\n     *\n     * @remarks\n     * They shouldn't have big variancy and evaluate to at least dozens of values as each\n     * combination of these attributes consitute new technique and material.\n     *\n     * These attributes are available in decoding and rendering scope.\n     */\n    AttrScope[AttrScope[\"TechniqueGeometry\"] = 1] = \"TechniqueGeometry\";\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     *\n     * @remarks\n     * Attributes that can be changed in resulting object/material from frame to frame. They are\n     * usually implemented as uniforms.\n     *\n     * These attributes may be available only at rendering scope.\n     */\n    AttrScope[AttrScope[\"TechniqueRendering\"] = 2] = \"TechniqueRendering\";\n})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));\n/**\n * @internal\n */\nfunction mergeTechniqueDescriptor(...descriptors) {\n    const result = {\n        attrDescriptors: {}\n    };\n    for (const descriptor of descriptors) {\n        if (descriptor.attrTransparencyColor !== undefined) {\n            result.attrTransparencyColor = descriptor.attrTransparencyColor;\n        }\n        if (descriptor.attrDescriptors !== undefined) {\n            result.attrDescriptors = Object.assign(Object.assign({}, result.attrDescriptors), descriptor.attrDescriptors);\n        }\n    }\n    return result;\n}\nconst baseTechniqueParamsDescriptor = {\n    // TODO: Choose which techniques should support color with transparency.\n    // For now we chosen all, but it maybe not suitable for text or line marker techniques.\n    attrTransparencyColor: \"color\",\n    attrDescriptors: {\n        enabled: AttrScope.FeatureGeometry,\n        fadeFar: AttrScope.TechniqueRendering,\n        fadeNear: AttrScope.TechniqueRendering,\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        side: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n};\nconst pointTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        size: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n});\nconst squaresTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);\nconst circlesTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);\nconst lineMarkerTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        text: AttrScope.FeatureGeometry,\n        label: AttrScope.FeatureGeometry,\n        useAbbreviation: AttrScope.FeatureGeometry,\n        useIsoCode: AttrScope.FeatureGeometry,\n        poiName: AttrScope.FeatureGeometry,\n        imageTexture: AttrScope.FeatureGeometry,\n        iconColor: AttrScope.TechniqueRendering,\n        iconBrightness: AttrScope.TechniqueRendering,\n        backgroundColor: AttrScope.TechniqueRendering,\n        backgroundSize: AttrScope.TechniqueRendering,\n        backgroundOpacity: AttrScope.TechniqueRendering,\n        color: AttrScope.TechniqueRendering,\n        opacity: AttrScope.TechniqueRendering,\n        size: AttrScope.TechniqueRendering\n    }\n});\nconst polygonalTechniqueDescriptor = {\n    attrDescriptors: {\n        polygonOffset: { scope: AttrScope.TechniqueRendering, automatic: true },\n        polygonOffsetFactor: { scope: AttrScope.TechniqueRendering, automatic: true },\n        polygonOffsetUnits: { scope: AttrScope.TechniqueRendering, automatic: true },\n        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineColor: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering\n    }\n};\nconst solidLineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {\n    attrDescriptors: {\n        lineWidth: AttrScope.TechniqueRendering,\n        secondaryWidth: AttrScope.TechniqueRendering,\n        secondaryColor: AttrScope.TechniqueRendering,\n        dashSize: AttrScope.TechniqueRendering,\n        gapSize: AttrScope.TechniqueRendering,\n        outlineColor: { scope: AttrScope.TechniqueRendering, automatic: true },\n        caps: { scope: AttrScope.TechniqueRendering, automatic: true },\n        drawRangeStart: { scope: AttrScope.TechniqueRendering, automatic: true },\n        drawRangeEnd: { scope: AttrScope.TechniqueRendering, automatic: true },\n        dashes: { scope: AttrScope.TechniqueRendering, automatic: true },\n        dashColor: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n});\nconst lineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        // TODO, check, which are really dynamic !\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineWidth: AttrScope.FeatureGeometry\n    }\n});\nconst fillTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {\n    attrDescriptors: {\n        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineWidth: AttrScope.TechniqueRendering\n    }\n});\nconst standardTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        color: AttrScope.FeatureGeometry,\n        vertexColors: { scope: AttrScope.TechniqueRendering, automatic: true },\n        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },\n        roughness: { scope: AttrScope.TechniqueRendering, automatic: true },\n        metalness: { scope: AttrScope.TechniqueRendering, automatic: true },\n        alphaTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        emissive: { scope: AttrScope.TechniqueRendering, automatic: true },\n        emissiveIntensity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        refractionRatio: { scope: AttrScope.TechniqueRendering, automatic: true },\n        normalMapType: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n});\nconst extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {\n    attrDescriptors: {\n        height: AttrScope.FeatureGeometry,\n        floorHeight: AttrScope.FeatureGeometry,\n        color: AttrScope.FeatureGeometry,\n        defaultColor: AttrScope.FeatureGeometry,\n        defaultHeight: AttrScope.FeatureGeometry,\n        constantHeight: AttrScope.FeatureGeometry,\n        boundaryWalls: AttrScope.FeatureGeometry,\n        footprint: AttrScope.FeatureGeometry,\n        maxSlope: AttrScope.FeatureGeometry,\n        animateExtrusion: AttrScope.TechniqueRendering,\n        lineWidth: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineColor: AttrScope.TechniqueRendering\n    }\n});\nconst textTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        text: AttrScope.FeatureGeometry,\n        label: AttrScope.FeatureGeometry,\n        useAbbreviation: AttrScope.FeatureGeometry,\n        useIsoCode: AttrScope.FeatureGeometry,\n        backgroundColor: AttrScope.TechniqueRendering,\n        backgroundSize: AttrScope.TechniqueRendering,\n        backgroundOpacity: AttrScope.TechniqueRendering,\n        color: AttrScope.TechniqueRendering,\n        opacity: AttrScope.TechniqueRendering,\n        priority: AttrScope.TechniqueRendering,\n        size: AttrScope.TechniqueRendering\n    }\n});\nconst shaderTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {\n    attrDescriptors: {\n        params: AttrScope.TechniqueRendering\n    }\n});\nconst techniqueDescriptors = {\n    \"extruded-polygon\": extrudedPolygonTechniqueDescriptor,\n    \"line-marker\": lineMarkerTechniquePropTypes,\n    \"labeled-icon\": lineMarkerTechniquePropTypes,\n    \"solid-line\": solidLineTechniqueDescriptor,\n    \"dashed-line\": solidLineTechniqueDescriptor,\n    terrain: standardTechniqueDescriptor,\n    standard: standardTechniqueDescriptor,\n    squares: squaresTechniquePropTypes,\n    circles: circlesTechniquePropTypes,\n    line: lineTechniqueDescriptor,\n    segments: lineTechniqueDescriptor,\n    fill: fillTechniqueDescriptor,\n    text: textTechniqueDescriptor,\n    shader: shaderTechniqueDescriptor\n};\nfunction getTechniqueDescriptor(technique) {\n    if (typeof technique !== \"string\") {\n        technique = technique.name;\n    }\n    return techniqueDescriptors[technique];\n}\nexports.getTechniqueDescriptor = getTechniqueDescriptor;\nfunction getTechniqueAttributeDescriptor(technique, attrName) {\n    const techniqueDescriptor = getTechniqueDescriptor(technique);\n    const attrDescriptors = techniqueDescriptor === null || techniqueDescriptor === void 0 ? void 0 : techniqueDescriptor.attrDescriptors;\n    const descriptor = attrDescriptors === null || attrDescriptors === void 0 ? void 0 : attrDescriptors[attrName];\n    if (typeof descriptor === undefined) {\n        return undefined;\n    }\n    else if (typeof descriptor === \"object\") {\n        return descriptor;\n    }\n    return { scope: descriptor };\n}\nexports.getTechniqueAttributeDescriptor = getTechniqueAttributeDescriptor;\nconst automaticAttributeCache = new Map();\nfunction getTechniqueAutomaticAttrs(technique) {\n    var _a;\n    if (typeof technique !== \"string\") {\n        technique = technique.name;\n    }\n    if (automaticAttributeCache.has(technique)) {\n        return automaticAttributeCache.get(technique);\n    }\n    const descriptors = [];\n    const attrDescriptors = (_a = getTechniqueDescriptor(technique)) === null || _a === void 0 ? void 0 : _a.attrDescriptors;\n    if (attrDescriptors === undefined) {\n        return descriptors;\n    }\n    for (const attrName in attrDescriptors) {\n        if (!attrDescriptors.hasOwnProperty(attrName)) {\n            continue;\n        }\n        const descr = attrDescriptors[attrName];\n        if (descr === undefined || typeof descr === \"number\") {\n            continue;\n        }\n        if (descr.automatic === true) {\n            descriptors.push(attrName);\n        }\n    }\n    automaticAttributeCache.set(technique, descriptors);\n    return descriptors;\n}\nexports.getTechniqueAutomaticAttrs = getTechniqueAutomaticAttrs;\n//# sourceMappingURL=TechniqueDescriptors.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTextureBuffer = exports.PlacementToken = exports.PoiStackMode = exports.TextureCoordinateType = exports.GeometryKindSet = exports.GeometryKind = exports.StandardGeometryKind = void 0;\n/**\n * Standard kinds of geometry.\n */\nvar StandardGeometryKind;\n(function (StandardGeometryKind) {\n    /**\n     * Used in the enabledKinds/disabledKinds filter to match any kind.\n     */\n    StandardGeometryKind[\"All\"] = \"_all_\";\n    /**\n     * Background geometry.\n     */\n    StandardGeometryKind[\"Background\"] = \"background\";\n    /**\n     * Terrain geometry.\n     */\n    StandardGeometryKind[\"Terrain\"] = \"terrain\";\n    /**\n     * Default value for the FillTechnique.\n     */\n    StandardGeometryKind[\"Area\"] = \"area\";\n    /**\n     * Default value for all line techniques.\n     */\n    StandardGeometryKind[\"Line\"] = \"line\";\n    /**\n     * Default value for the FillTechnique.\n     */\n    StandardGeometryKind[\"Water\"] = \"water\";\n    /**\n     * Political borders.\n     */\n    StandardGeometryKind[\"Border\"] = \"border\";\n    /**\n     * Basis for all roads.\n     */\n    StandardGeometryKind[\"Road\"] = \"road\";\n    /**\n     * Default value for the ExtrudedPolygonTechnique.\n     */\n    StandardGeometryKind[\"Building\"] = \"building\";\n    /**\n     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.\n     */\n    StandardGeometryKind[\"Label\"] = \"label\";\n    /**\n     * Anything that may show up last.\n     */\n    StandardGeometryKind[\"Detail\"] = \"detail\";\n})(StandardGeometryKind = exports.StandardGeometryKind || (exports.StandardGeometryKind = {}));\n// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexports.GeometryKind = StandardGeometryKind;\n/**\n * A set of {@link GeometryKind}s.\n */\nclass GeometryKindSet extends Set {\n    /**\n     * Return `true` if the Set is a superset of the set 'subset'.\n     */\n    isSuperset(subset) {\n        for (const elem of subset) {\n            if (!this.has(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Return `true` if the Set intersects Set 'set'.\n     */\n    hasIntersection(set) {\n        for (const elem of set) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'\n     * if set is not a Set.\n     */\n    hasOrIntersects(set) {\n        if (set instanceof Set) {\n            return this.hasIntersection(set);\n        }\n        return this.has(set);\n    }\n    /**\n     * Return `true` if this set and the array of elements share at least a single element.\n     */\n    hasOrIntersectsArray(subset) {\n        for (const elem of subset) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.GeometryKindSet = GeometryKindSet;\nvar TextureCoordinateType;\n(function (TextureCoordinateType) {\n    /**\n     * Texture coordinates are in tile space.\n     *\n     * @remarks\n     * SW of the tile will have (0,0) and NE will have (1,1).\n     */\n    TextureCoordinateType[\"TileSpace\"] = \"tile-space\";\n    /**\n     * Texture coordinates are in equirectangular space.\n     *\n     * @remarks\n     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).\n     */\n    TextureCoordinateType[\"EquirectangularSpace\"] = \"equirectangular-space\";\n    /**\n     * Texture coordinates in feature space.\n     *\n     * @remarks\n     * To compute texture coordinates in feature space,\n     * the feature must have a property named `bbox` with value\n     * the tuple `[west, south, east, north]`.\n     */\n    TextureCoordinateType[\"FeatureSpace\"] = \"feature-space\";\n})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));\n/**\n * Define the stacking option. Enum values for theme file are in \"kebab-case\".\n */\nvar PoiStackMode;\n(function (PoiStackMode) {\n    /**\n     * Show in a stack.\n     */\n    PoiStackMode[\"Show\"] = \"show-in-stack\";\n    /**\n     * Do not show in a stack.\n     */\n    PoiStackMode[\"Hide\"] = \"hide-in-stack\";\n    /**\n     * Show category parent in the stack.\n     */\n    PoiStackMode[\"ShowParent\"] = \"show-parent\";\n})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));\n/**\n * Defines options (tokens) supported for text placements defined via [[placements]] attribute.\n *\n * @remarks\n * Possible values are defined as vertical placement letter and horizontal letter, where\n * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:\n * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),\n * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).\n * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:\n * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),\n * `SW` (south-west), `W` (west).\n */\nvar PlacementToken;\n(function (PlacementToken) {\n    PlacementToken[\"TopLeft\"] = \"TL\";\n    PlacementToken[\"Top\"] = \"T\";\n    PlacementToken[\"TopRight\"] = \"TR\";\n    PlacementToken[\"Right\"] = \"R\";\n    PlacementToken[\"BottomRight\"] = \"BR\";\n    PlacementToken[\"Bottom\"] = \"B\";\n    PlacementToken[\"BottomLeft\"] = \"BL\";\n    PlacementToken[\"Left\"] = \"L\";\n    PlacementToken[\"Center\"] = \"C\";\n    PlacementToken[\"NorthWest\"] = \"NW\";\n    PlacementToken[\"North\"] = \"N\";\n    PlacementToken[\"NorthEast\"] = \"NE\";\n    PlacementToken[\"East\"] = \"E\";\n    PlacementToken[\"SouthEast\"] = \"SE\";\n    PlacementToken[\"South\"] = \"S\";\n    PlacementToken[\"SouthWest\"] = \"SW\";\n    PlacementToken[\"West\"] = \"W\";\n})(PlacementToken = exports.PlacementToken || (exports.PlacementToken = {}));\n/**\n * Type guard to check if an object is an instance of `TextureBuffer`.\n */\nfunction isTextureBuffer(object) {\n    return object && object.buffer && typeof object.type === \"string\";\n}\nexports.isTextureBuffer = isTextureBuffer;\n//# sourceMappingURL=TechniqueParams.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Techniques.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setTechniqueRenderOrderOrPriority = exports.composeTechniqueTextureName = exports.addBuffersToTransferList = exports.textureCoordinateType = exports.needsVertexNormals = exports.isLabelRejectionLineTechnique = exports.isShaderTechnique = exports.isTextTechnique = exports.isTerrainTechnique = exports.isStandardTechnique = exports.isExtrudedPolygonTechnique = exports.isFillTechnique = exports.isStandardExtrudedLineTechnique = exports.isBasicExtrudedLineTechnique = exports.isExtrudedLineTechnique = exports.isSegmentsTechnique = exports.isSpecialDashesLineTechnique = exports.isSolidLineTechnique = exports.isLineTechnique = exports.isLineMarkerTechnique = exports.isPoiTechnique = exports.isSquaresTechnique = exports.isCirclesTechnique = exports.TRANSPARENCY_PROPERTY_KEYS = exports.TEXTURE_PROPERTY_KEYS = void 0;\nconst TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js\");\n/**\n * Names of the supported texture properties.\n * @internal\n */\nexports.TEXTURE_PROPERTY_KEYS = [\n    \"map\",\n    \"normalMap\",\n    \"displacementMap\",\n    \"roughnessMap\",\n    \"emissiveMap\",\n    \"alphaMap\",\n    \"metalnessMap\",\n    \"bumpMap\"\n];\n/**\n * Names of the properties controlling transparency.\n * @internal\n */\nexports.TRANSPARENCY_PROPERTY_KEYS = [\"opacity\", \"transparent\"];\n/**\n * Type guard to check if an object is an instance of `CirclesTechnique`.\n */\nfunction isCirclesTechnique(technique) {\n    return technique.name === \"circles\";\n}\nexports.isCirclesTechnique = isCirclesTechnique;\n/**\n * Type guard to check if an object is an instance of `SquaresTechnique`.\n */\nfunction isSquaresTechnique(technique) {\n    return technique.name === \"squares\";\n}\nexports.isSquaresTechnique = isSquaresTechnique;\n/**\n * Type guard to check if an object is an instance of `PoiTechnique`.\n */\nfunction isPoiTechnique(technique) {\n    return technique.name === \"labeled-icon\";\n}\nexports.isPoiTechnique = isPoiTechnique;\n/**\n * Type guard to check if an object is an instance of `LineMarkerTechnique`.\n */\nfunction isLineMarkerTechnique(technique) {\n    return technique.name === \"line-marker\";\n}\nexports.isLineMarkerTechnique = isLineMarkerTechnique;\n/**\n * Type guard to check if an object is an instance of `LineTechnique`.\n */\nfunction isLineTechnique(technique) {\n    return technique.name === \"line\";\n}\nexports.isLineTechnique = isLineTechnique;\n/**\n * Type guard to check if an object is an instance of `SolidLineTechnique`.\n */\nfunction isSolidLineTechnique(technique) {\n    return technique.name === \"solid-line\" || technique.name === \"dashed-line\";\n}\nexports.isSolidLineTechnique = isSolidLineTechnique;\n/**\n * Type guard to check if an object is an instance of `SolidLineTechnique` and is a kind that\n * has special dashes.\n * @note Lines with special dashes need line caps to render properly.\n */\nfunction isSpecialDashesLineTechnique(technique) {\n    return ((technique.name === \"solid-line\" || technique.name === \"dashed-line\") &&\n        technique.dashes !== undefined &&\n        technique.dashes !== \"Square\");\n}\nexports.isSpecialDashesLineTechnique = isSpecialDashesLineTechnique;\n/**\n * Type guard to check if an object is an instance of `SegmentsTechnique`.\n */\nfunction isSegmentsTechnique(technique) {\n    return technique.name === \"segments\";\n}\nexports.isSegmentsTechnique = isSegmentsTechnique;\n/**\n * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`\n * or `StandardExtrudedLineTechnique`.\n */\nfunction isExtrudedLineTechnique(technique) {\n    return technique.name === \"extruded-line\";\n}\nexports.isExtrudedLineTechnique = isExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`.\n */\nfunction isBasicExtrudedLineTechnique(technique) {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"basic\";\n}\nexports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of `StandardExtrudedLineTechnique`.\n */\nfunction isStandardExtrudedLineTechnique(technique) {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"standard\";\n}\nexports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of `FillTechnique`.\n */\nfunction isFillTechnique(technique) {\n    return technique.name === \"fill\";\n}\nexports.isFillTechnique = isFillTechnique;\n/**\n * Type guard to check if an object is an instance of `ExtrudedPolygonTechnique`.\n */\nfunction isExtrudedPolygonTechnique(technique) {\n    return technique.name === \"extruded-polygon\";\n}\nexports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;\n/**\n * Type guard to check if an object is an instance of `StandardTechnique`.\n */\nfunction isStandardTechnique(technique) {\n    return technique.name === \"standard\";\n}\nexports.isStandardTechnique = isStandardTechnique;\n/**\n * Type guard to check if an object is an instance of `TerrainTechnique`.\n */\nfunction isTerrainTechnique(technique) {\n    return technique.name === \"terrain\";\n}\nexports.isTerrainTechnique = isTerrainTechnique;\n/**\n * Type guard to check if an object is an instance of `TextTechnique`.\n */\nfunction isTextTechnique(technique) {\n    return technique.name === \"text\";\n}\nexports.isTextTechnique = isTextTechnique;\n/**\n * Type guard to check if an object is an instance of `ShaderTechnique`.\n */\nfunction isShaderTechnique(technique) {\n    return technique.name === \"shader\";\n}\nexports.isShaderTechnique = isShaderTechnique;\nfunction isLabelRejectionLineTechnique(technique) {\n    return technique.name === \"label-rejection-line\";\n}\nexports.isLabelRejectionLineTechnique = isLabelRejectionLineTechnique;\n/**\n * Check if vertex normals should be generated for this technique (if no normals are in the data).\n * @param technique - Technique to check.\n */\nfunction needsVertexNormals(technique) {\n    return (isExtrudedPolygonTechnique(technique) ||\n        isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isStandardExtrudedLineTechnique(technique));\n}\nexports.needsVertexNormals = needsVertexNormals;\n/**\n * Get the texture coordinate type if the technique supports it.\n */\nfunction textureCoordinateType(technique) {\n    if (isStandardTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isExtrudedPolygonTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isTerrainTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isShaderTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.textureCoordinateType = textureCoordinateType;\n/**\n * Add all the buffers of the technique to the transfer list.\n */\nfunction addBuffersToTransferList(technique, transferList) {\n    if (isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)) {\n        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {\n            const textureProperty = technique[texturePropertyKey];\n            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {\n                if (textureProperty.buffer instanceof ArrayBuffer) {\n                    transferList.push(textureProperty.buffer);\n                }\n            }\n        }\n    }\n}\nexports.addBuffersToTransferList = addBuffersToTransferList;\n/**\n * Compose full texture name for given image name with technique specified.\n * Some techniques allows to add prefix/postfix to icons names specified, this\n * function uses technique information to create fully qualified texture name.\n * @param imageName - base name of the marker icon.\n * @param technique - the technique describing POI or line marker.\n * @returns fully qualified texture name for loading from atlas (without extension).\n */\nfunction composeTechniqueTextureName(imageName, technique) {\n    let textureName = imageName;\n    if (typeof technique.imageTexturePrefix === \"string\") {\n        textureName = technique.imageTexturePrefix + textureName;\n    }\n    if (typeof technique.imageTexturePostfix === \"string\") {\n        textureName = textureName + technique.imageTexturePostfix;\n    }\n    return textureName;\n}\nexports.composeTechniqueTextureName = composeTechniqueTextureName;\n/**\n * Sets a technique's render order (or priority for screen-space techniques) depending on its\n * category and the priorities specified in a given theme.\n * @param technique- The technique whose render order or priority will be set.\n * @param theme - The theme from which the category priorities will be taken.\n */\nfunction setTechniqueRenderOrderOrPriority(technique, priorities, labelPriorities) {\n    if (isTextTechnique(technique) ||\n        isPoiTechnique(technique) ||\n        isLineMarkerTechnique(technique)) {\n        // for screen-space techniques the `category` is used to assign\n        // priorities.\n        if (labelPriorities && typeof technique._category === \"string\") {\n            // override the `priority` when the technique uses `category`.\n            const priority = labelPriorities.indexOf(technique._category);\n            if (priority !== -1) {\n                technique.priority = labelPriorities.length - priority;\n            }\n        }\n    }\n    else if (priorities && technique._styleSet !== undefined) {\n        // Compute the render order based on the style category and styleSet.\n        const computeRenderOrder = (category) => {\n            const priority = priorities === null || priorities === void 0 ? void 0 : priorities.findIndex(entry => entry.group === technique._styleSet && entry.category === category);\n            return priority !== undefined && priority !== -1 ? (priority + 1) * 10 : undefined;\n        };\n        if (typeof technique._category === \"string\") {\n            // override the renderOrder when the technique is using categories.\n            const renderOrder = computeRenderOrder(technique._category);\n            if (renderOrder !== undefined) {\n                technique.renderOrder = renderOrder;\n            }\n        }\n        if (typeof technique._secondaryCategory === \"string\") {\n            // override the secondaryRenderOrder when the technique is using categories.\n            const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);\n            if (secondaryRenderOrder !== undefined) {\n                technique.secondaryRenderOrder = secondaryRenderOrder;\n            }\n        }\n    }\n}\nexports.setTechniqueRenderOrderOrPriority = setTechniqueRenderOrderOrPriority;\n//# sourceMappingURL=Techniques.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Techniques.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Theme.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isJsonExprReference = void 0;\n/**\n * Checks if the given value is a reference to a definition.\n *\n * @param value - The value of a technique property.\n */\nfunction isJsonExprReference(value) {\n    return (Array.isArray(value) &&\n        value.length === 2 &&\n        value[0] === \"ref\" &&\n        typeof value[1] === \"string\");\n}\nexports.isJsonExprReference = isJsonExprReference;\n//# sourceMappingURL=Theme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Theme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThemeVisitor = void 0;\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * The ThemeVisitor visits every style in the theme in a depth-first fashion.\n */\nclass ThemeVisitor {\n    constructor(theme) {\n        this.theme = theme;\n    }\n    /**\n     * Applies a function to every style in the theme.\n     *\n     * @param visitFunc - Function to be called with `style` as an argument. Function should return\n     *                  `true` to cancel visitation.\n     * @returns `true` if function has finished prematurely.\n     */\n    visitStyles(visitFunc) {\n        const visit = (style) => {\n            if (Expr_1.isJsonExpr(style)) {\n                return false;\n            }\n            if (visitFunc(style)) {\n                return true;\n            }\n            return false;\n        };\n        if (this.theme.styles !== undefined) {\n            for (const styleSetName in this.theme.styles) {\n                if (this.theme.styles[styleSetName] !== undefined) {\n                    for (const style of this.theme.styles[styleSetName]) {\n                        if (visit(style)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\nexports.ThemeVisitor = ThemeVisitor;\n//# sourceMappingURL=ThemeVisitor.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeBufferUtils = void 0;\nconst DecodedTile_1 = __webpack_require__(/*! ./DecodedTile */ \"./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js\");\n/**\n * Collection of helper methods to convert\n * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}\n * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.\n * See also [[CustomDatasourceExample]].\n */\nvar ThreeBufferUtils;\n(function (ThreeBufferUtils) {\n    function getBufferElementType(buffer) {\n        if (buffer instanceof Int8Array) {\n            return \"int8\";\n        }\n        else if (buffer instanceof Uint8Array) {\n            return \"uint8\";\n        }\n        else if (buffer instanceof Int16Array) {\n            return \"int16\";\n        }\n        else if (buffer instanceof Uint16Array) {\n            return \"uint16\";\n        }\n        else if (buffer instanceof Int32Array) {\n            return \"int32\";\n        }\n        else if (buffer instanceof Uint32Array) {\n            return \"uint32\";\n        }\n        else if (buffer instanceof Float32Array) {\n            return \"float\";\n        }\n        throw new Error(`Unsupported buffer type ${name}`);\n    }\n    ThreeBufferUtils.getBufferElementType = getBufferElementType;\n    function fromThreeBufferAttribute(bufferAttribute) {\n        const buffer = bufferAttribute.array;\n        return {\n            name: bufferAttribute.name,\n            buffer: buffer.buffer,\n            type: getBufferElementType(buffer),\n            itemCount: bufferAttribute.itemSize,\n            normalized: bufferAttribute.normalized\n        };\n    }\n    ThreeBufferUtils.fromThreeBufferAttribute = fromThreeBufferAttribute;\n    function fromThreeInterleavedBufferAttribute(bufferAttribute) {\n        throw new Error(\"Not implemented yet\");\n    }\n    ThreeBufferUtils.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;\n    function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {\n        const vertexAttributes = [];\n        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);\n        for (const name of attributeNames) {\n            const attribute = bufferGeometry.attributes[name];\n            // FIXME: Also support InterleavedBufferAttribute\n            const vertexAttribute = fromThreeBufferAttribute(attribute);\n            vertexAttribute.name = name;\n            vertexAttributes.push(vertexAttribute);\n        }\n        const index = bufferGeometry.index !== null\n            ? fromThreeBufferAttribute(bufferGeometry.index)\n            : undefined;\n        let count = 0;\n        if (index !== undefined) {\n            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;\n        }\n        else {\n            // If there is no index buffer, try to deduce the count from the position attribute.\n            const posAttr = bufferGeometry.attributes.position;\n            if (posAttr === undefined) {\n                throw new Error(\"Missing position attibute to deduce item count\");\n            }\n            count = posAttr.count;\n        }\n        return {\n            type: DecodedTile_1.GeometryType.Unspecified,\n            vertexAttributes,\n            index,\n            groups: [{ start: 0, count, technique: techniqueIndex }]\n        };\n    }\n    ThreeBufferUtils.fromThreeBufferGeometry = fromThreeBufferGeometry;\n})(ThreeBufferUtils = exports.ThreeBufferUtils || (exports.ThreeBufferUtils = {}));\n//# sourceMappingURL=ThreeBufferUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=TileInfo.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerDecoderProtocol = exports.RequestController = void 0;\n/**\n * Allows to cancel and prioritize requests inside the requestQueue.\n *\n * @remarks\n * Useful to optimize the order of decoding tiles during animations and camera movements.\n *\n * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.\n */\nclass RequestController {\n    /**\n     * Creates an instance of `RequestController`.\n     *\n     * @param {number} priority\n     * @param {AbortController} abortController Optional [[AbortController]] used internally, since\n     *      [[AbortController]]s should not be subclassed.\n     */\n    constructor(priority = 0, abortController = new AbortController()) {\n        this.priority = priority;\n        this.abortController = abortController;\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.RequestController = RequestController;\n/**\n * Communication protocol with [[ITileDecoder]].\n */\nvar WorkerDecoderProtocol;\n(function (WorkerDecoderProtocol) {\n    /**\n     * Define possible names of messages exchanged with decoder services within `WebWorker`.\n     */\n    let DecoderMessageName;\n    (function (DecoderMessageName) {\n        DecoderMessageName[\"Configuration\"] = \"configuration\";\n    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));\n    /**\n     * Type guard to check if an object is an instance of `ConfigurationMessage`.\n     */\n    function isConfigurationMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === DecoderMessageName.Configuration);\n    }\n    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;\n    /**\n     * Define possible names of requests called on decoder services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"DecodeTileRequest\"] = \"decode-tile-request\";\n        Requests[\"TileInfoRequest\"] = \"tile-info-request\";\n    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));\n    /**\n     * Type guard to check if an object is a decoded tile object sent to a worker.\n     */\n    function isDecodeTileRequest(message) {\n        return (message &&\n            typeof message.type === \"string\" &&\n            message.type === Requests.DecodeTileRequest);\n    }\n    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;\n    /**\n     * Type guard to check if an object is an info tile object sent to a worker.\n     */\n    function isTileInfoRequest(message) {\n        return (message && typeof message.type === \"string\" && message.type === Requests.TileInfoRequest);\n    }\n    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;\n})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));\n//# sourceMappingURL=WorkerDecoderProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerServiceProtocol = void 0;\n/**\n * Common communication protocol for [[WorkerService]].\n */\nvar WorkerServiceProtocol;\n(function (WorkerServiceProtocol) {\n    /**\n     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service\n     * instances in workers.\n     */\n    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = \"worker-service-manager\";\n    /**\n     * Define possible names of messages exchanged with services within `WebWorker`.\n     */\n    let ServiceMessageName;\n    (function (ServiceMessageName) {\n        ServiceMessageName[\"Initialized\"] = \"initialized\";\n        ServiceMessageName[\"Request\"] = \"request\";\n        ServiceMessageName[\"Response\"] = \"response\";\n    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));\n    /**\n     * Type guard to check if an object is a signal message from worker.\n     */\n    function isInitializedMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Initialized);\n    }\n    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;\n    /**\n     * Define possible names of requests called on services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"CreateService\"] = \"create-service\";\n        Requests[\"DestroyService\"] = \"destroy-service\";\n    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));\n    /**\n     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.\n     */\n    function isUnknownServiceError(error) {\n        return error.message.includes(\"unknown targetServiceType requested: \");\n    }\n    WorkerServiceProtocol.isUnknownServiceError = isUnknownServiceError;\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    function isRequestMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Request);\n    }\n    WorkerServiceProtocol.isRequestMessage = isRequestMessage;\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    function isResponseMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Response);\n    }\n    WorkerServiceProtocol.isResponseMessage = isResponseMessage;\n})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));\n//# sourceMappingURL=WorkerServiceProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerTilerProtocol = void 0;\n/**\n * Communication protocol with {@link ITiler}.\n */\nvar WorkerTilerProtocol;\n(function (WorkerTilerProtocol) {\n    /**\n     * Define possible names of requests called on tiler services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"RegisterIndex\"] = \"register-index\";\n        Requests[\"UpdateIndex\"] = \"update-index\";\n        Requests[\"TileRequest\"] = \"tile-request\";\n    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));\n    /**\n     * Type guard to check if an object is an index registration request sent to a worker.\n     */\n    function isRegisterIndexRequest(message) {\n        return (message && typeof message.type === \"string\" && message.type === Requests.RegisterIndex);\n    }\n    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;\n    /**\n     * Type guard to check if an object is an update request for the index registration.\n     */\n    function isUpdateIndexRequest(message) {\n        return message && typeof message.type === \"string\" && message.type === Requests.UpdateIndex;\n    }\n    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;\n    /**\n     * Type guard to check if an object is a tile request sent to a worker.\n     */\n    function isTileRequest(message) {\n        return message && typeof message.type === \"string\" && message.type === Requests.TileRequest;\n    }\n    WorkerTilerProtocol.isTileRequest = isTileRequest;\n})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));\n//# sourceMappingURL=WorkerTilerProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayOperators = void 0;\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst VALID_ELEMENT_TYPES = [\"boolean\", \"number\", \"string\"];\nfunction checkElementTypes(arg, array) {\n    if (!(arg instanceof Expr_1.StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {\n        throw new Error(`expected \"boolean\", \"number\" or \"string\" instead of '${JSON.stringify(arg)}'`);\n    }\n    const ty = arg.value;\n    array.forEach((element, index) => {\n        if (typeof element !== ty) {\n            throw new Error(`expected array element at index ${index} to have type '${ty}'`);\n        }\n    });\n}\nfunction checkArrayLength(arg, array) {\n    if (!(arg instanceof Expr_1.NumberLiteralExpr)) {\n        throw new Error(`missing expected number of elements`);\n    }\n    const length = arg.value;\n    if (array.length !== length) {\n        throw new Error(`the array must have ${length} element(s)`);\n    }\n}\nfunction checkArray(context, arg) {\n    const value = context.evaluate(arg);\n    if (!Array.isArray(value)) {\n        throw new Error(`'${value}' is not an array`);\n    }\n    return value;\n}\nconst operators = {\n    array: {\n        call: (context, call) => {\n            switch (call.args.length) {\n                case 0:\n                    throw new Error(\"not enough arguments\");\n                case 1:\n                    return checkArray(context, call.args[0]);\n                case 2: {\n                    const array = checkArray(context, call.args[1]);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                case 3: {\n                    const array = checkArray(context, call.args[2]);\n                    checkArrayLength(call.args[1], array);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n        }\n    },\n    \"make-array\": {\n        call: (context, call) => {\n            if (call.args.length === 0) {\n                throw new Error(\"not enough arguments\");\n            }\n            return [...call.args.map(arg => context.evaluate(arg))];\n        }\n    },\n    at: {\n        call: (context, call) => {\n            const args = call.args;\n            const index = context.evaluate(args[0]);\n            if (typeof index !== \"number\") {\n                throw new Error(`expected the index of the element to retrieve`);\n            }\n            const value = context.evaluate(args[1]);\n            if (!Array.isArray(value)) {\n                throw new Error(`expected an array`);\n            }\n            return index >= 0 && index < value.length ? value[index] : null;\n        }\n    },\n    slice: {\n        call: (context, call) => {\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            }\n            const input = context.evaluate(call.args[0]);\n            if (!(typeof input === \"string\" || Array.isArray(input))) {\n                throw new Error(\"input must be a string or an array\");\n            }\n            const start = context.evaluate(call.args[1]);\n            if (typeof start !== \"number\") {\n                throw new Error(\"expected an index\");\n            }\n            let end;\n            if (call.args.length > 2) {\n                end = context.evaluate(call.args[2]);\n                if (typeof end !== \"number\") {\n                    throw new Error(\"expected an index\");\n                }\n            }\n            return input.slice(start, end);\n        }\n    }\n};\nexports.ArrayOperators = operators;\n//# sourceMappingURL=ArrayOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CastOperators = void 0;\nconst operators = {\n    \"to-boolean\": {\n        call: (context, call) => {\n            return Boolean(context.evaluate(call.args[0]));\n        }\n    },\n    \"to-string\": {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0]));\n        }\n    },\n    \"to-number\": {\n        call: (context, call) => {\n            for (const arg of call.args) {\n                const value = Number(context.evaluate(arg));\n                if (!isNaN(value)) {\n                    return value;\n                }\n            }\n            throw new Error(\"cannot convert the value to a number\");\n        }\n    }\n};\nexports.CastOperators = operators;\n//# sourceMappingURL=CastOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorOperators = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! ../ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ../StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\nconst operators = {\n    alpha: {\n        call: (context, call) => {\n            let color = context.evaluate(call.args[0]);\n            if (typeof color === \"string\") {\n                color = StringEncodedNumeral_1.parseStringEncodedColor(color);\n            }\n            const alpha = typeof color === \"number\" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;\n            return alpha;\n        }\n    },\n    rgba: {\n        call: (context, call) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            const a = context.evaluate(call.args[3]);\n            if (typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                typeof a === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0 &&\n                a >= 0 &&\n                a <= 1) {\n                return rgbaToHex(r, g, b, a);\n            }\n            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);\n        }\n    },\n    rgb: {\n        call: (context, call) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            if (typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0) {\n                return rgbToHex(r, g, b);\n            }\n            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);\n        }\n    },\n    // Hsl operator contains angle modulated to <0, 360> range, percent of\n    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)\n    hsl: {\n        call: (context, call) => {\n            const h = context.evaluate(call.args[0]);\n            const s = context.evaluate(call.args[1]);\n            const l = context.evaluate(call.args[2]);\n            if (typeof h === \"number\" &&\n                typeof s === \"number\" &&\n                typeof l === \"number\" &&\n                h >= 0 &&\n                s >= 0 &&\n                l >= 0) {\n                return hslToHex(h, s, l);\n            }\n            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);\n        }\n    }\n};\nfunction rgbaToHex(r, g, b, a) {\n    // We decode rgba color channels using custom hex format with transparency.\n    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255, THREE.MathUtils.clamp(a, 0, 1));\n}\nfunction rgbToHex(r, g, b) {\n    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255);\n}\nfunction hslToHex(h, s, l) {\n    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.MathUtils.euclideanModulo(h, 360) / 360, THREE.MathUtils.clamp(s, 0, 100) / 100, THREE.MathUtils.clamp(l, 0, 100) / 100);\n}\nexports.ColorOperators = operators;\n//# sourceMappingURL=ColorOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComparisonOperators = void 0;\nfunction compare(context, call, strict = false) {\n    const left = context.evaluate(call.args[0]);\n    const right = context.evaluate(call.args[1]);\n    if (!((typeof left === \"number\" && typeof right === \"number\") ||\n        (typeof left === \"string\" && typeof right === \"string\"))) {\n        if (strict) {\n            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);\n        }\n    }\n    switch (call.op) {\n        case \"<\":\n            return left < right;\n        case \">\":\n            return left > right;\n        case \"<=\":\n            return left <= right;\n        case \">=\":\n            return left >= right;\n        default:\n            throw new Error(`invalid comparison operator '${call.op}'`);\n    }\n}\nconst operators = {\n    \"!\": {\n        call: (context, call) => {\n            return !context.evaluate(call.args[0]);\n        }\n    },\n    \"==\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left === right;\n        }\n    },\n    \"!=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left !== right;\n        }\n    },\n    \"<\": { call: (context, call) => compare(context, call) },\n    \">\": { call: (context, call) => compare(context, call) },\n    \"<=\": { call: (context, call) => compare(context, call) },\n    \">=\": { call: (context, call) => compare(context, call) }\n};\nexports.ComparisonOperators = operators;\n//# sourceMappingURL=ComparisonOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FeatureOperators = void 0;\nconst Env_1 = __webpack_require__(/*! ../Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst operators = {\n    \"geometry-type\": {\n        call: (context, call) => {\n            const geometryType = context.env.lookup(\"$geometryType\");\n            switch (geometryType) {\n                case \"point\":\n                    return \"Point\";\n                case \"line\":\n                    return \"LineString\";\n                case \"polygon\":\n                    return \"Polygon\";\n                default:\n                    return null;\n            }\n        }\n    },\n    \"feature-state\": {\n        isDynamicOperator: () => true,\n        call: (context, call) => {\n            var _a, _b;\n            if (context.scope !== Expr_1.ExprScope.Dynamic) {\n                throw new Error(\"feature-state cannot be used in this context\");\n            }\n            const property = context.evaluate(call.args[0]);\n            if (typeof property !== \"string\") {\n                throw new Error(`expected the name of the property of the feature state`);\n            }\n            const state = context.env.lookup(\"$state\");\n            if (Env_1.Env.isEnv(state)) {\n                return (_a = state.lookup(property)) !== null && _a !== void 0 ? _a : null;\n            }\n            else if (state instanceof Map) {\n                return (_b = state.get(property)) !== null && _b !== void 0 ? _b : null;\n            }\n            return null;\n        }\n    },\n    id: {\n        call: (context, call) => {\n            var _a;\n            return (_a = context.env.lookup(\"$id\")) !== null && _a !== void 0 ? _a : null;\n        }\n    }\n};\nexports.FeatureOperators = operators;\n//# sourceMappingURL=FeatureOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlowOperators = void 0;\nfunction conditionalCast(context, type, args) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            for (const childExpr of args) {\n                const value = context.evaluate(childExpr);\n                if (typeof value === type) {\n                    return value;\n                }\n            }\n            throw new Error(`expected a '${type}'`);\n        default:\n            throw new Error(`invalid type '${type}'`);\n    } // switch\n}\nconst operators = {\n    all: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (!context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n    any: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n    none: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n    boolean: {\n        call: (context, call) => {\n            return conditionalCast(context, \"boolean\", call.args);\n        }\n    },\n    number: {\n        call: (context, call) => {\n            return conditionalCast(context, \"number\", call.args);\n        }\n    },\n    string: {\n        call: (context, call) => {\n            return conditionalCast(context, \"string\", call.args);\n        }\n    }\n};\nexports.FlowOperators = operators;\n//# sourceMappingURL=FlowOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapOperators = void 0;\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst operators = {\n    \"ppi-scale\": {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            return value * scaleFactor;\n        }\n    },\n    \"world-ppi-scale\": {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            const pixels = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            const zoom = context.env.lookup(\"$zoom\");\n            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);\n            const v = pixels * zoomWidth * scaleFactor;\n            return v;\n        }\n    },\n    \"world-discrete-ppi-scale\": {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            const pixels = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            const zoom = context.env.lookup(\"$zoom\");\n            const zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));\n            const v = pixels * zoomWidthDiscrete * scaleFactor;\n            return v;\n        }\n    },\n    ppi: {\n        call: (context) => {\n            const ppi = context.env.lookup(\"$ppi\");\n            if (typeof ppi === \"number\") {\n                return ppi;\n            }\n            return 72;\n        }\n    },\n    zoom: {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            var _a;\n            if (context.scope === Expr_1.ExprScope.Value) {\n                return call;\n            }\n            return (_a = context.env.lookup(\"$zoom\")) !== null && _a !== void 0 ? _a : null;\n        }\n    }\n};\nexports.MapOperators = operators;\n//# sourceMappingURL=MapOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathOperators = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst operators = {\n    \"^\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);\n            }\n            return Math.pow(a, b);\n        }\n    },\n    \"-\": {\n        call: (context, call) => {\n            if (call.args.length === 1) {\n                const value = context.evaluate(call.args[0]);\n                if (typeof value !== \"number\") {\n                    throw new Error(`nvalid operand '${typeof value} for operator '-'`);\n                }\n                return -value;\n            }\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);\n            }\n            return a - b;\n        }\n    },\n    \"/\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);\n            }\n            return a / b;\n        }\n    },\n    \"%\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);\n            }\n            return a % b;\n        }\n    },\n    \"+\": {\n        call: (context, call) => {\n            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);\n        }\n    },\n    \"*\": {\n        call: (context, call) => {\n            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);\n        }\n    },\n    abs: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'abs'`);\n            }\n            return Math.abs(value);\n        }\n    },\n    acos: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'acos'`);\n            }\n            return Math.acos(value);\n        }\n    },\n    asin: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'asin'`);\n            }\n            return Math.asin(value);\n        }\n    },\n    atan: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'atan'`);\n            }\n            return Math.atan(value);\n        }\n    },\n    ceil: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ceil'`);\n            }\n            return Math.ceil(value);\n        }\n    },\n    cos: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'cos'`);\n            }\n            return Math.cos(value);\n        }\n    },\n    e: {\n        call: () => {\n            return Math.E;\n        }\n    },\n    floor: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'floor'`);\n            }\n            return Math.floor(value);\n        }\n    },\n    ln: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln'`);\n            }\n            return Math.log(value);\n        }\n    },\n    ln2: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln2'`);\n            }\n            return Math.log2(value);\n        }\n    },\n    log10: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'log10'`);\n            }\n            return Math.log10(value);\n        }\n    },\n    max: {\n        call: (context, call) => {\n            return Math.max(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n    min: {\n        call: (context, call) => {\n            return Math.min(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n    /**\n     * Clamp numeric value to given range, inclusive.\n     *\n     * Synopsis:\n     * ```\n     * [\"clamp\", v: number, min: number, max: number]`\n     * ```\n     */\n    clamp: {\n        call: (context, call) => {\n            const v = context.evaluate(call.args[0]);\n            const min = context.evaluate(call.args[1]);\n            const max = context.evaluate(call.args[2]);\n            if (typeof v !== \"number\" || typeof min !== \"number\" || typeof max !== \"number\") {\n                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);\n            }\n            return THREE.MathUtils.clamp(v, min, max);\n        }\n    },\n    pi: {\n        call: () => {\n            return Math.PI;\n        }\n    },\n    round: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'round'`);\n            }\n            return Math.round(value);\n        }\n    },\n    sin: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sin'`);\n            }\n            return Math.sin(value);\n        }\n    },\n    sqrt: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);\n            }\n            return Math.sqrt(value);\n        }\n    },\n    tan: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'tan'`);\n            }\n            return Math.tan(value);\n        }\n    }\n};\nexports.MathOperators = operators;\n//# sourceMappingURL=MathOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MiscOperators = void 0;\nconst operators = {\n    length: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (Array.isArray(value) || typeof value === \"string\") {\n                return value.length;\n            }\n            throw new Error(`invalid operand '${value}' for operator 'length'`);\n        }\n    },\n    coalesce: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                const value = context.evaluate(childExpr);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        }\n    }\n};\nexports.MiscOperators = operators;\n//# sourceMappingURL=MiscOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObjectOperators = void 0;\nconst Env_1 = __webpack_require__(/*! ../Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nvar LookupMode;\n(function (LookupMode) {\n    LookupMode[LookupMode[\"get\"] = 0] = \"get\";\n    LookupMode[LookupMode[\"has\"] = 1] = \"has\";\n})(LookupMode || (LookupMode = {}));\nfunction lookupMember(context, args, lookupMode) {\n    var _a;\n    const memberName = context.evaluate(args[0]);\n    if (typeof memberName !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    const object = context.evaluate(args[1]);\n    if (object && typeof object === \"object\") {\n        if (Env_1.Env.isEnv(object)) {\n            const value = (_a = object.lookup(memberName)) !== null && _a !== void 0 ? _a : null;\n            return lookupMode === LookupMode.get ? value : value !== null;\n        }\n        if (hasOwnProperty.call(object, memberName)) {\n            return lookupMode === LookupMode.get ? object[memberName] : true;\n        }\n    }\n    return lookupMode === LookupMode.get ? null : false;\n}\nconst operators = {\n    in: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            const object = context.evaluate(call.args[1]);\n            if (typeof value === \"string\" && typeof object === \"string\") {\n                return object.includes(value);\n            }\n            else if (Array.isArray(object)) {\n                return object.includes(value);\n            }\n            return false;\n        }\n    },\n    get: {\n        call: (context, call) => lookupMember(context, call.args, LookupMode.get)\n    },\n    has: {\n        call: (context, call) => lookupMember(context, call.args, LookupMode.has)\n    },\n    \"dynamic-properties\": {\n        isDynamicOperator: () => true,\n        call: (context, call) => {\n            if (context.scope === Expr_1.ExprScope.Dynamic) {\n                return context.env;\n            }\n            return call;\n        }\n    }\n};\nexports.ObjectOperators = operators;\n//# sourceMappingURL=ObjectOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringOperators = void 0;\nconst operators = {\n    concat: {\n        call: (context, call) => {\n            return \"\".concat(...call.args.map(a => String(context.evaluate(a))));\n        }\n    },\n    downcase: {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0])).toLocaleLowerCase();\n        }\n    },\n    upcase: {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0])).toLocaleUpperCase();\n        }\n    },\n    \"~=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.includes(right);\n            }\n            return false;\n        }\n    },\n    \"^=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.startsWith(right);\n            }\n            return false;\n        }\n    },\n    \"$=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.endsWith(right);\n            }\n            return false;\n        }\n    }\n};\nexports.StringOperators = operators;\n//# sourceMappingURL=StringOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeOperators = void 0;\nconst operators = {\n    typeof: {\n        call: (context, call) => {\n            return typeof context.evaluate(call.args[0]);\n        }\n    }\n};\nexports.TypeOperators = operators;\n//# sourceMappingURL=TypeOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorOperators = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nfunction isVector(context, call, type) {\n    let ctor;\n    switch (type) {\n        case \"vector2\":\n            ctor = THREE.Vector2;\n            break;\n        case \"vector3\":\n            ctor = THREE.Vector3;\n            break;\n        case \"vector4\":\n            ctor = THREE.Vector4;\n            break;\n    }\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof ctor) {\n            return value;\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\nfunction toVector(context, call, type) {\n    let VectorCtor;\n    let components;\n    switch (type) {\n        case \"vector2\":\n            VectorCtor = THREE.Vector2;\n            components = 2;\n            break;\n        case \"vector3\":\n            VectorCtor = THREE.Vector3;\n            components = 3;\n            break;\n        case \"vector4\":\n            VectorCtor = THREE.Vector4;\n            components = 4;\n            break;\n    }\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof VectorCtor) {\n            return value;\n        }\n        else if (Array.isArray(value) &&\n            value.length === components &&\n            value.every(v => typeof v === \"number\")) {\n            return new VectorCtor().fromArray(value);\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\nconst operators = {\n    \"make-vector\": {\n        call: (context, call) => {\n            if (call._value !== undefined) {\n                return call._value;\n            }\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            }\n            else if (call.args.length > 4) {\n                throw new Error(\"too many arguments\");\n            }\n            const components = call.args.map(arg => context.evaluate(arg));\n            components.forEach((element, index) => {\n                if (typeof element !== \"number\") {\n                    throw new Error(`expected vector component at index ${index} to have type \"number\"`);\n                }\n            });\n            let result;\n            switch (components.length) {\n                case 2:\n                    result = new THREE.Vector2().fromArray(components);\n                    break;\n                case 3:\n                    result = new THREE.Vector3().fromArray(components);\n                    break;\n                case 4:\n                    result = new THREE.Vector4().fromArray(components);\n                    break;\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n            if (call.args.every(arg => arg instanceof Expr_1.NumberLiteralExpr)) {\n                call._value = result;\n            }\n            return result;\n        }\n    },\n    vector2: {\n        call: (context, call) => isVector(context, call, \"vector2\")\n    },\n    vector3: {\n        call: (context, call) => isVector(context, call, \"vector3\")\n    },\n    vector4: {\n        call: (context, call) => isVector(context, call, \"vector4\")\n    },\n    \"to-vector2\": {\n        call: (context, call) => toVector(context, call, \"vector2\")\n    },\n    \"to-vector3\": {\n        call: (context, call) => toVector(context, call, \"vector3\")\n    },\n    \"to-vector4\": {\n        call: (context, call) => toVector(context, call, \"vector4\")\n    }\n};\nexports.VectorOperators = operators;\n//# sourceMappingURL=VectorOperators.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-fetch/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-fetch/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=index.web.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-fetch/index.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EdgeLengthGeometrySubdivisionModifier = exports.SubdivisionMode = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js\");\nconst VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3()];\nvar SubdivisionMode;\n(function (SubdivisionMode) {\n    /**\n     * Subdivide all edges\n     */\n    SubdivisionMode[SubdivisionMode[\"All\"] = 0] = \"All\";\n    /**\n     * Only subdivide horizontal and vertical edges\n     */\n    SubdivisionMode[SubdivisionMode[\"NoDiagonals\"] = 1] = \"NoDiagonals\";\n})(SubdivisionMode = exports.SubdivisionMode || (exports.SubdivisionMode = {}));\n/**\n * The [[EdgeLengthGeometrySubdivisionModifier]] subdivides triangle mesh depending on\n * length of edges.\n */\nclass EdgeLengthGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {\n    /**\n     * Constructs a new [[EdgeLengthGeometrySubdivisionModifier]].\n     *\n     * @param subdivision - The subdivision factor\n     * @param geoBox - The geo bounding box of a tile\n     * @param subdivisionMode - Configures what edges to divide\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(subdivision, geoBox, subdivisionMode = SubdivisionMode.All, projection) {\n        super();\n        this.subdivision = subdivision;\n        this.geoBox = geoBox;\n        this.subdivisionMode = subdivisionMode;\n        this.projection = projection;\n        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Planar, \"EdgeLengthGeometrySubdivisionModifier only supports planar projections\");\n        const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);\n        const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);\n        this.m_projectedBox = {\n            min: {\n                x: Math.min(northEast.x, southWest.x),\n                y: Math.min(northEast.y, southWest.y),\n                z: Math.min(northEast.z, southWest.z)\n            },\n            max: {\n                x: Math.max(northEast.x, southWest.x),\n                y: Math.max(northEast.y, southWest.y),\n                z: Math.max(northEast.z, southWest.z)\n            }\n        };\n        this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;\n        this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;\n        // Increase max length slightly to account for precision errors\n        if (this.subdivisionMode === SubdivisionMode.All) {\n            this.m_maxLengthX *= 1.1;\n            this.m_maxLengthY *= 1.1;\n        }\n        this.m_maxLength = Math.sqrt(this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY);\n    }\n    /**\n     * Return upper bound for length of diagonal edges\n     */\n    get maxLength() {\n        return this.m_maxLength;\n    }\n    /**\n     * Return upper bound for edge length in x direction\n     */\n    get maxLengthX() {\n        return this.m_maxLengthX;\n    }\n    /**\n     * Return upper bound for edge length in y direction\n     */\n    get maxLengthY() {\n        return this.m_maxLengthY;\n    }\n    /** @override */\n    shouldSplitTriangle(a, b, c) {\n        const shouldSplitAB = this.shouldSplitEdge(a, b);\n        const shouldSplitBC = this.shouldSplitEdge(b, c);\n        const shouldSplitCA = this.shouldSplitEdge(c, a);\n        const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;\n        if (!shouldSplit) {\n            return;\n        }\n        const ab = a.distanceTo(b);\n        const bc = b.distanceTo(c);\n        const ca = c.distanceTo(a);\n        const maxDistance = Math.max(shouldSplitAB ? ab : 0, shouldSplitBC ? bc : 0, shouldSplitCA ? ca : 0);\n        if (ab === maxDistance) {\n            return 0;\n        }\n        else if (bc === maxDistance) {\n            return 1;\n        }\n        else if (ca === maxDistance) {\n            return 2;\n        }\n        throw new Error(\"Could not split triangle.\");\n    }\n    shouldSplitEdge(a, b) {\n        switch (this.subdivisionMode) {\n            case SubdivisionMode.All:\n                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY) ||\n                    a.distanceTo(b) > this.m_maxLength);\n            case SubdivisionMode.NoDiagonals:\n                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY));\n        }\n    }\n}\nexports.EdgeLengthGeometrySubdivisionModifier = EdgeLengthGeometrySubdivisionModifier;\n//# sourceMappingURL=EdgeLengthGeometrySubdivisionModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SphericalGeometrySubdivisionModifier = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js\");\nconst VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];\n/**\n * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned\n * on the surface of a sphere centered at `(0, 0, 0)`.\n */\nclass SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {\n    /**\n     * Constructs a new [[SphericalGeometrySubdivisionModifier]].\n     *\n     * @param angle - The maximum angle in radians between two vertices and the origin.\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(angle, projection = harp_geoutils_1.sphereProjection) {\n        super();\n        this.angle = angle;\n        this.projection = projection;\n    }\n    /** @override */\n    shouldSplitTriangle(a, b, c) {\n        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);\n        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);\n        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);\n        const alpha = aa.angleTo(bb);\n        const beta = bb.angleTo(cc);\n        const gamma = cc.angleTo(aa);\n        // find the maximum angle\n        const m = Math.max(alpha, Math.max(beta, gamma));\n        // split the triangle if needed.\n        if (m < this.angle) {\n            return undefined;\n        }\n        if (m === alpha) {\n            return 0;\n        }\n        else if (m === beta) {\n            return 1;\n        }\n        else if (m === gamma) {\n            return 2;\n        }\n        throw new Error(\"failed to split triangle\");\n    }\n}\nexports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;\n//# sourceMappingURL=SphericalGeometrySubdivisionModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubdivisionModifier = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst tmpVectorA = new three_1.Vector3();\nconst tmpVectorB = new three_1.Vector3();\nconst tmpVectorC = new three_1.Vector3();\n/**\n * The [[SubdivisionModifier]] subdivides triangle mesh geometries.\n */\nclass SubdivisionModifier {\n    /**\n     * Constructs a new [[SubdivisionModifier]].\n     */\n    constructor() {\n        // nothing to do\n    }\n    /**\n     * Subdivides the faces of the given [[THREE.BufferGeometry]].\n     *\n     * This method modifies (in-place) the vertices and the faces of the geometry.\n     * Please note that only the vertex position and their UV coordinates are subdivided.\n     * Normals, vertex colors and other attributes are left unmodified.\n     *\n     * @param geometry - The [[THREE.BufferGeometry]] to subdivide.\n     */\n    modify(geometry) {\n        const positionAttr = geometry.getAttribute(\"position\");\n        const position = Array.from(positionAttr.array);\n        const uvAttr = geometry.getAttribute(\"uv\");\n        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;\n        const edgeAttr = geometry.getAttribute(\"edge\");\n        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;\n        const wallAttr = geometry.getAttribute(\"wall\");\n        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;\n        const indexAttr = geometry.getIndex();\n        const indices = Array.from(indexAttr.array);\n        // A cache containing the indices of the vertices added\n        // when subdiving the faces of the geometry.\n        const cache = new Map();\n        /**\n         * Returns the index of the vertex positioned in the middle of the given vertices.\n         */\n        function middleVertex(i, j) {\n            // Build a unique `key` for the pair of indices `(i, j)`.\n            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;\n            const h = cache.get(key);\n            if (h !== undefined) {\n                // Nothing to do, a vertex in the middle of (i, j) was already created.\n                return h;\n            }\n            // The position of the new vertex.\n            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);\n            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n            // The index of the new vertex.\n            const index = position.length / 3;\n            position.push(...tmpVectorC.toArray());\n            // Cache the position of the new vertex.\n            cache.set(key, index);\n            // The uvs of the new vertex.\n            if (uv !== undefined) {\n                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);\n                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);\n                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n                uv.push(tmpVectorC.x, tmpVectorC.y);\n            }\n            // The edge and wall attributes of the new vertex.\n            // If a new vertex has been introduced between i and j, connect the elements\n            // accordingly.\n            if (edge !== undefined) {\n                if (edge[i] === j) {\n                    edge.push(j);\n                    edge[i] = index;\n                }\n                else if (edge[j] === i) {\n                    edge.push(i);\n                    edge[j] = index;\n                }\n                else {\n                    edge.push(-1);\n                }\n            }\n            if (wall !== undefined) {\n                if (wall[i] === j) {\n                    wall.push(j);\n                    wall[i] = index;\n                }\n                else if (wall[j] === i) {\n                    wall.push(i);\n                    wall[j] = index;\n                }\n                else {\n                    wall.push(-1);\n                }\n            }\n            return index;\n        }\n        const newIndices = [];\n        while (indices.length >= 3) {\n            const v0 = indices.shift();\n            const v1 = indices.shift();\n            const v2 = indices.shift();\n            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);\n            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);\n            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);\n            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);\n            switch (edgeToSplit) {\n                case 0: {\n                    const v3 = middleVertex(v0, v1);\n                    indices.push(v0, v3, v2, v3, v1, v2);\n                    break;\n                }\n                case 1: {\n                    const v3 = middleVertex(v1, v2);\n                    indices.push(v0, v1, v3, v0, v3, v2);\n                    break;\n                }\n                case 2: {\n                    const v3 = middleVertex(v2, v0);\n                    indices.push(v0, v1, v3, v3, v1, v2);\n                    break;\n                }\n                case undefined: {\n                    newIndices.push(v0, v1, v2);\n                    break;\n                }\n                default:\n                    throw new Error(\"failed to subdivide the given geometry\");\n            }\n        }\n        positionAttr.array =\n            positionAttr.array instanceof Float32Array\n                ? new Float32Array(position)\n                : new Float64Array(position);\n        positionAttr.count = position.length / positionAttr.itemSize;\n        positionAttr.needsUpdate = true;\n        geometry.setIndex(newIndices);\n        if (uv !== undefined) {\n            uvAttr.array = new Float32Array(uv);\n            uvAttr.count = uv.length / uvAttr.itemSize;\n            uvAttr.needsUpdate = true;\n        }\n        if (edge !== undefined) {\n            edgeAttr.array = new Float32Array(edge);\n            edgeAttr.count = edge.length / edgeAttr.itemSize;\n            edgeAttr.needsUpdate = true;\n        }\n        return geometry;\n    }\n}\nexports.SubdivisionModifier = SubdivisionModifier;\n//# sourceMappingURL=SubdivisionModifier.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Utility classes for working with geospatial data.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBoxExtentLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPolygonLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPolygon */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/coordinates/LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/IdentityProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/TransverseMercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/projection/SphereProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ \"./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTree */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/SubTiles */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/SubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/tiling/PolarTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/Vector2Like */ \"./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/Vector3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/TransformLike */ \"./node_modules/@here/harp-geoutils/lib/math/TransformLike.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3 */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoBox = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\n/**\n * `GeoBox` is used to represent a bounding box in geo coordinates.\n */\nclass GeoBox {\n    /**\n     * Constructs a new `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    constructor(southWest, northEast) {\n        this.southWest = southWest;\n        this.northEast = northEast;\n        if (this.west > this.east) {\n            this.northEast.longitude += 360;\n        }\n    }\n    /**\n     * Returns a `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    static fromCoordinates(southWest, northEast) {\n        return new GeoBox(southWest, northEast);\n    }\n    /**\n     * Returns a `GeoBox` with the given center and dimensions.\n     *\n     * @param center - The center position of geo box.\n     * @param extent - Box latitude and logitude span\n     */\n    static fromCenterAndExtents(center, extent) {\n        return new GeoBox(new GeoCoordinates_1.GeoCoordinates(center.latitude - extent.latitudeSpan / 2, center.longitude - extent.longitudeSpan / 2), new GeoCoordinates_1.GeoCoordinates(center.latitude + extent.latitudeSpan / 2, center.longitude + extent.longitudeSpan / 2));\n    }\n    /**\n     * Returns the minimum altitude or `undefined`.\n     */\n    get minAltitude() {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.min(this.southWest.altitude, this.northEast.altitude);\n    }\n    /**\n     * Returns the maximum altitude or `undefined`.\n     */\n    get maxAltitude() {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.max(this.southWest.altitude, this.northEast.altitude);\n    }\n    /**\n     * Returns the south latitude in degrees of this `GeoBox`.\n     */\n    get south() {\n        return this.southWest.latitude;\n    }\n    /**\n     * Returns the north altitude in degrees of this `GeoBox`.\n     */\n    get north() {\n        return this.northEast.latitude;\n    }\n    /**\n     * Returns the west longitude in degrees of this `GeoBox`.\n     */\n    get west() {\n        return this.southWest.longitude;\n    }\n    /**\n     * Returns the east longitude in degrees of this `GeoBox`.\n     */\n    get east() {\n        return this.northEast.longitude;\n    }\n    /**\n     * Returns the center of this `GeoBox`.\n     */\n    get center() {\n        const latitude = (this.south + this.north) * 0.5;\n        const { west, east } = this;\n        const { minAltitude, altitudeSpan } = this;\n        let altitude;\n        if (minAltitude !== undefined && altitudeSpan !== undefined) {\n            altitude = minAltitude + altitudeSpan * 0.5;\n        }\n        if (west <= east) {\n            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);\n        }\n        let longitude = (360 + east + west) * 0.5;\n        if (longitude > 360) {\n            longitude -= 360;\n        }\n        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);\n    }\n    /**\n     * Returns the latitude span in radians.\n     */\n    get latitudeSpanInRadians() {\n        return THREE.MathUtils.degToRad(this.latitudeSpan);\n    }\n    /**\n     * Returns the longitude span in radians.\n     */\n    get longitudeSpanInRadians() {\n        return THREE.MathUtils.degToRad(this.longitudeSpan);\n    }\n    /**\n     * Returns the latitude span in degrees.\n     */\n    get latitudeSpan() {\n        return this.north - this.south;\n    }\n    get altitudeSpan() {\n        if (this.maxAltitude === undefined || this.minAltitude === undefined) {\n            return undefined;\n        }\n        return this.maxAltitude - this.minAltitude;\n    }\n    /**\n     * Returns the longitude span in degrees.\n     */\n    get longitudeSpan() {\n        let width = this.northEast.longitude - this.southWest.longitude;\n        if (width < 0) {\n            width += 360;\n        }\n        return width;\n    }\n    /**\n     * Returns the latitude span in degrees.\n     * @deprecated Use [[latitudeSpan]] instead.\n     */\n    get latitudeSpanInDegrees() {\n        return this.latitudeSpan;\n    }\n    /**\n     * Returns the longitude span in degrees.\n     * @deprecated Use [[longitudeSpan]] instead.\n     */\n    get longitudeSpanInDegrees() {\n        return this.longitudeSpan;\n    }\n    /**\n     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.\n     *\n     * @param point - The geo coordinates.\n     */\n    contains(point) {\n        if (point.altitude === undefined ||\n            this.minAltitude === undefined ||\n            this.maxAltitude === undefined) {\n            return this.containsHelper(point);\n        }\n        const isFlat = this.minAltitude === this.maxAltitude;\n        const isSameAltitude = this.minAltitude === point.altitude;\n        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;\n        // If box is flat, we should check the altitude and containment,\n        // otherwise we should check also altitude difference where we consider\n        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!\n        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {\n            return this.containsHelper(point);\n        }\n        return false;\n    }\n    /**\n     * Clones this `GeoBox` instance.\n     */\n    clone() {\n        return new GeoBox(this.southWest.clone(), this.northEast.clone());\n    }\n    /**\n     * Update the bounding box by considering a given point.\n     *\n     * @param point - The point that may expand the bounding box.\n     */\n    growToContain(point) {\n        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);\n        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);\n        this.southWest.altitude =\n            this.southWest.altitude !== undefined && point.altitude !== undefined\n                ? Math.min(this.southWest.altitude, point.altitude)\n                : this.southWest.altitude !== undefined\n                    ? this.southWest.altitude\n                    : point.altitude !== undefined\n                        ? point.altitude\n                        : undefined;\n        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);\n        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);\n        this.northEast.altitude =\n            this.northEast.altitude !== undefined && point.altitude !== undefined\n                ? Math.max(this.northEast.altitude, point.altitude)\n                : this.northEast.altitude !== undefined\n                    ? this.northEast.altitude\n                    : point.altitude !== undefined\n                        ? point.altitude\n                        : undefined;\n    }\n    containsHelper(point) {\n        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {\n            return false;\n        }\n        const { west, east } = this;\n        let longitude = point.longitude;\n        if (east > GeoCoordinates_1.MAX_LONGITUDE) {\n            while (longitude < west) {\n                longitude = longitude + 360;\n            }\n        }\n        if (longitude > east) {\n            while (longitude > west + 360) {\n                longitude = longitude - 360;\n            }\n        }\n        return longitude >= west && longitude < east;\n    }\n}\nexports.GeoBox = GeoBox;\n//# sourceMappingURL=GeoBox.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoBoxExtentLike = void 0;\n/**\n * Type guard to assert that `object` conforms to {@link GeoBoxExtentLike} interface.\n */\nfunction isGeoBoxExtentLike(obj) {\n    return (obj &&\n        typeof obj === \"object\" &&\n        typeof obj.latitudeSpan === \"number\" &&\n        typeof obj.longitudeSpan === \"number\");\n}\nexports.isGeoBoxExtentLike = isGeoBoxExtentLike;\n//# sourceMappingURL=GeoBoxExtentLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoCoordLike = exports.geoCoordLikeToGeoPointLike = exports.geoCoordLikeToGeoCoordinatesLike = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\");\nconst LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\");\nfunction geoCoordLikeToGeoCoordinatesLike(coord) {\n    return GeoCoordinatesLike_1.isGeoCoordinatesLike(coord)\n        ? coord\n        : LatLngLike_1.isLatLngLike(coord)\n            ? { latitude: coord.lat, longitude: coord.lng }\n            : { latitude: coord[1], longitude: coord[0] };\n}\nexports.geoCoordLikeToGeoCoordinatesLike = geoCoordLikeToGeoCoordinatesLike;\nfunction geoCoordLikeToGeoPointLike(coord) {\n    return GeoPointLike_1.isGeoPointLike(coord)\n        ? coord\n        : LatLngLike_1.isLatLngLike(coord)\n            ? [coord.lng, coord.lat]\n            : [coord.longitude, coord.latitude];\n}\nexports.geoCoordLikeToGeoPointLike = geoCoordLikeToGeoPointLike;\nfunction isGeoCoordLike(object) {\n    return GeoCoordinatesLike_1.isGeoCoordinatesLike(object) || LatLngLike_1.isLatLngLike(object) || !GeoPointLike_1.isGeoPointLike(object);\n}\nexports.isGeoCoordLike = isGeoCoordLike;\n//# sourceMappingURL=GeoCoordLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoCoordinates = exports.MIN_LONGITUDE = exports.MAX_LONGITUDE = exports.MIN_LATITUDE = exports.MAX_LATITUDE = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\");\nconst LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\");\nexports.MAX_LATITUDE = 90;\nexports.MIN_LATITUDE = -90;\nexports.MAX_LONGITUDE = 180;\nexports.MIN_LONGITUDE = -180;\nconst tmpV0 = new THREE.Vector3();\nconst tmpV1 = new THREE.Vector3();\n/**\n * Compute the modulo.\n *\n * @internal\n */\nfunction mod(dividend, divisor) {\n    const modulo = dividend % divisor;\n    const modulo_sign = modulo < 0;\n    const divisor_sign = divisor < 0;\n    return modulo_sign === divisor_sign ? modulo : modulo + divisor;\n}\n/**\n * `GeoCoordinates` is used to represent geo positions.\n */\nclass GeoCoordinates {\n    /**\n     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    constructor(latitude, longitude, altitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.altitude = altitude;\n    }\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    static fromDegrees(latitude, longitude, altitude) {\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in radians.\n     * @param longitude - Longitude in radians.\n     * @param altitude - Altitude in meters.\n     */\n    static fromRadians(latitude, longitude, altitude) {\n        return new GeoCoordinates(THREE.MathUtils.radToDeg(latitude), THREE.MathUtils.radToDeg(longitude), altitude);\n    }\n    /**\n     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.\n     * ```typescript\n     * const center = { lat: 53.3, lng: 13.4 };\n     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);\n     * ```\n     * @param latLng - A {@link LatLngLike} object literal.\n     */\n    static fromLatLng(latLng) {\n        return new GeoCoordinates(latLng.lat, latLng.lng);\n    }\n    /**\n     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.\n     *\n     * Example:\n     * ```typescript\n     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);\n     *\n     * let geoCoords: number[] = ...;\n     *\n     * if (isGeoPointLike(geoCoords)) {\n     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);\n     * }\n     * ```\n     * @param geoPoint - An [[Array]] of at least two elements following the order\n     * longitude, latitude, altitude.\n     */\n    static fromGeoPoint(geoPoint) {\n        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);\n    }\n    /**\n     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.\n     *\n     * Example:\n     * ```typescript\n     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);\n     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });\n     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));\n     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });\n     * ```\n     *\n     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}\n     * or {@link LatLngLike} object literal.\n     */\n    static fromObject(geoPoint) {\n        if (GeoPointLike_1.isGeoPointLike(geoPoint)) {\n            return GeoCoordinates.fromGeoPoint(geoPoint);\n        }\n        else if (GeoCoordinatesLike_1.isGeoCoordinatesLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);\n        }\n        else if (LatLngLike_1.isLatLngLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);\n        }\n        throw new Error(\"Invalid input coordinate format.\");\n    }\n    /**\n     * Returns a `GeoCoordinates` resulting from the linear interpolation of other two.\n     * @param geoCoords0 - One of the `GeoCoordinates` used for interpolation.\n     * @param geoCoords1 - The other `GeoCoordinates` used for interpolation.\n     * @param factor - Interpolation factor. If `0` result will be equal to `geoCoords0`, if `1`\n     * it'll be equal to `geoCoords1`.\n     * @param wrap - If `true`, interpolation will be done across the antimeridian, otherwise it's\n     * done across the Greenwich meridian. Supported only if longitude span is less than 360 deg.\n     * @default false\n     * @param normalize - If `true`, interpolation result will be normalized. @default false\n     */\n    static lerp(geoCoords0, geoCoords1, factor, wrap = false, normalize = false) {\n        var _a, _b;\n        if (wrap) {\n            if (geoCoords0.lng < geoCoords1.lng) {\n                const geoCoordsEnd = geoCoords0.clone();\n                geoCoordsEnd.longitude += 360;\n                return this.lerp(geoCoords1, geoCoordsEnd, 1 - factor);\n            }\n            else {\n                const geoCoordsEnd = geoCoords1.clone();\n                geoCoordsEnd.longitude += 360;\n                return this.lerp(geoCoords0, geoCoordsEnd, factor);\n            }\n        }\n        const v0 = tmpV0.set(geoCoords0.lat, geoCoords0.lng, (_a = geoCoords0.altitude) !== null && _a !== void 0 ? _a : 0);\n        const v1 = tmpV1.set(geoCoords1.lat, geoCoords1.lng, (_b = geoCoords1.altitude) !== null && _b !== void 0 ? _b : 0);\n        v0.lerp(v1, factor);\n        const result = new GeoCoordinates(v0.x, v0.y, v0.z);\n        return normalize ? result.normalized() : result;\n    }\n    /**\n     * Returns the latitude in radians.\n     */\n    get latitudeInRadians() {\n        return THREE.MathUtils.degToRad(this.latitude);\n    }\n    /**\n     * Returns the longitude in radians.\n     */\n    get longitudeInRadians() {\n        return THREE.MathUtils.degToRad(this.longitude);\n    }\n    /**\n     * Returns the latitude in degrees.\n     * @deprecated Use the [[latitude]] property instead.\n     */\n    get latitudeInDegrees() {\n        return this.latitude;\n    } // compat api\n    /**\n     * Returns the longitude in degrees.\n     * @deprecated Use the [[longitude]] property instead.\n     */\n    get longitudeInDegrees() {\n        return this.longitude;\n    } // compat api\n    /**\n     * The latitude in the degrees.\n     */\n    get lat() {\n        return this.latitude;\n    }\n    /**\n     * The longitude in the degrees.\n     */\n    get lng() {\n        return this.longitude;\n    }\n    /**\n     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.\n     */\n    isValid() {\n        return !isNaN(this.latitude) && !isNaN(this.longitude);\n    }\n    /**\n     * Returns the normalized `GeoCoordinates`.\n     */\n    normalized() {\n        let { latitude, longitude } = this;\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return this;\n        }\n        if (longitude < -180 || longitude > 180) {\n            longitude = mod(longitude + 180, 360) - 180;\n        }\n        latitude = THREE.MathUtils.clamp(latitude, -90, 90);\n        return new GeoCoordinates(latitude, longitude, this.altitude);\n    }\n    /**\n     * Returns `true` if this `GeoCoordinates` is equal to the other.\n     *\n     * @param other - GeoCoordinatesLike to compare to.\n     */\n    equals(other) {\n        return (this.latitude === other.latitude &&\n            this.longitude === other.longitude &&\n            this.altitude === other.altitude);\n    }\n    /**\n     * Copy values from the other.\n     *\n     * @param other - GeoCoordinatesLike to copy all values from.\n     */\n    copy(other) {\n        this.latitude = other.latitude;\n        this.longitude = other.longitude;\n        this.altitude = other.altitude;\n        return this;\n    }\n    /**\n     * Clones this `GeoCoordinates`.\n     */\n    clone() {\n        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);\n    }\n    /**\n     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.\n     */\n    toLatLng() {\n        return { lat: this.latitude, lng: this.longitude };\n    }\n    /**\n     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].\n     */\n    toGeoPoint() {\n        return this.altitude !== undefined\n            ? [this.longitude, this.latitude, this.altitude]\n            : [this.longitude, this.latitude];\n    }\n    /**\n     * Returns the minimum longitude span from this `GeoCoordinates` to another.\n     *\n     * @param other - The other GeoCoordinatesLike defining the longitude span.\n     */\n    minLongitudeSpanTo(other) {\n        const minLongitude = Math.min(this.longitude, other.longitude);\n        const maxLongitude = Math.max(this.longitude, other.longitude);\n        return Math.min(maxLongitude - minLongitude, 360 + minLongitude - maxLongitude);\n    }\n}\nexports.GeoCoordinates = GeoCoordinates;\n//# sourceMappingURL=GeoCoordinates.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoCoordinatesLike = void 0;\n/**\n * Type guard to assert that `object` conforms to {@link GeoCoordinatesLike} data interface.\n */\nfunction isGeoCoordinatesLike(object) {\n    return (object &&\n        typeof object.latitude === \"number\" &&\n        typeof object.longitude === \"number\" &&\n        (typeof object.altitude === \"number\" || typeof object.altitude === \"undefined\"));\n}\nexports.isGeoCoordinatesLike = isGeoCoordinatesLike;\n//# sourceMappingURL=GeoCoordinatesLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoPointLike = void 0;\n/**\n * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.\n */\nfunction isGeoPointLike(geoPoint) {\n    if (Array.isArray(geoPoint)) {\n        const [longitude, latitude, altitude] = geoPoint;\n        return (typeof longitude === \"number\" &&\n            typeof latitude === \"number\" &&\n            (altitude === undefined || typeof altitude === \"number\"));\n    }\n    return false;\n}\nexports.isGeoPointLike = isGeoPointLike;\n//# sourceMappingURL=GeoPointLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoPolygon = exports.isAntimeridianCrossing = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ./GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst GeoCoordLike_1 = __webpack_require__(/*! ./GeoCoordLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js\");\nfunction computeLonSpanAcrossGreewich(lonA, lonB) {\n    return Math.max(lonA, lonB) - Math.min(lonA, lonB);\n}\nfunction isLeftToRightAntimeridianCrossing(lonStart, lonEnd) {\n    return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;\n}\nfunction isRightToLeftAntimeridianCrossing(lonStart, lonEnd) {\n    return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);\n}\nfunction isAntimeridianCrossing(lonStart, lonEnd) {\n    return (Math.sign(lonStart) === -Math.sign(lonEnd) &&\n        computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180);\n}\nexports.isAntimeridianCrossing = isAntimeridianCrossing;\n/**\n * A GeoPolygon in 2D Space (altitudes will be ignored).\n * Coordinates are expected in counter-clockwise order, for convex polygons a sorting is\n * available.\n * Clockwise ordered or selfintersecting Polygons might lead to no or unexpected results.\n *\n * @beta @internal\n */\nclass GeoPolygon {\n    /**\n     * Creates a GeoPolygon instance\n     *\n     * @param coordinates An array of GeoCoordinates acting as the Vertices of the Polygon.\n     * @param needsSort  If `true` it will sort the coordinates in ccw order, this will only\n     *  result correctly for convex polygons @default false\n     * @param needsWrapping  If `true` it will wrap around coordinates crossing the antemeridian.\n     * Only supported for polygons with sides that don't span more than 180 degrees longitude.\n     * @default false\n     */\n    constructor(coordinates, needsSort = false, needsWrapping = false) {\n        this.m_coordinates = coordinates.map(coord => {\n            return GeoCoordLike_1.geoCoordLikeToGeoCoordinatesLike(coord);\n        });\n        if (needsSort) {\n            this.sortCCW();\n        }\n        if (needsWrapping) {\n            this.wrapCoordinatesAround();\n        }\n    }\n    get coordinates() {\n        return this.m_coordinates;\n    }\n    /**\n     * Gets a BoundingBox for the Polygon\n     *\n     * Might have unexpected results for twisted or concave Polygons\n     */\n    getGeoBoundingBox() {\n        const centroid = this.getCentroid();\n        if (centroid === undefined) {\n            //return a BBox without extend if the centroid could not be generated\n            return GeoBox_1.GeoBox.fromCoordinates(this.coordinates[0], this.coordinates[0]);\n        }\n        const { east, west } = this.getEastAndWest(centroid);\n        const { north, south } = this.getNorthAndSouth();\n        return GeoBox_1.GeoBox.fromCoordinates(new GeoCoordinates_1.GeoCoordinates(south, west), new GeoCoordinates_1.GeoCoordinates(north, east));\n    }\n    /**\n     * Gets the Centroid for the Polygon\n     *\n     * Might be undefined or with unexpected results for twisted or concave Polygons.\n     */\n    getCentroid() {\n        const area = this.getArea();\n        if (area === 0) {\n            return undefined;\n        }\n        let latitude = 0;\n        let longitude = 0;\n        let f;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            f =\n                coordinate.latitude * previousCoordinate.longitude -\n                    previousCoordinate.latitude * coordinate.longitude;\n            latitude += (coordinate.latitude + previousCoordinate.latitude) * f;\n            longitude += (coordinate.longitude + previousCoordinate.longitude) * f;\n            previousIndex = index;\n        });\n        f = area * 6;\n        return new GeoCoordinates_1.GeoCoordinates(latitude / f, area < 0 /* antimeridian crossing */ ? -180 + longitude / f : longitude / f);\n    }\n    sortCCW() {\n        const polyCenter = this.getPolyAverageCenter();\n        if (!polyCenter) {\n            return;\n        }\n        //sorts by angle from x-axis\n        this.m_coordinates.sort((a, b) => {\n            const veca = new three_1.Vector2(a.latitude - polyCenter.latitude, a.longitude - polyCenter.longitude).normalize();\n            const vecb = new three_1.Vector2(b.latitude - polyCenter.latitude, b.longitude - polyCenter.longitude).normalize();\n            return vecb.angle() - veca.angle();\n        });\n    }\n    wrapCoordinatesAround() {\n        const firstAntimerCrossIndex = this.m_coordinates.findIndex((val, index) => {\n            const prevLonIndex = index === 0 ? this.m_coordinates.length - 1 : index - 1;\n            const prevLon = this.m_coordinates[prevLonIndex].longitude;\n            const lon = val.longitude;\n            return isLeftToRightAntimeridianCrossing(prevLon, lon);\n        });\n        if (firstAntimerCrossIndex < 0) {\n            return;\n        }\n        let wrapAround = true;\n        for (let i = 0; i < this.m_coordinates.length; i++) {\n            const index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;\n            const currentLon = this.m_coordinates[index].longitude;\n            const nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;\n            if (wrapAround) {\n                this.m_coordinates[index].longitude += 360;\n            }\n            if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {\n                wrapAround = false;\n            }\n            else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {\n                wrapAround = true;\n            }\n        }\n    }\n    getPolyAverageCenter() {\n        const polySum = this.m_coordinates.reduce((prev, curr) => {\n            return new GeoCoordinates_1.GeoCoordinates(prev.latitude + curr.latitude, prev.longitude + curr.longitude);\n        });\n        //create an average center point\n        return new GeoCoordinates_1.GeoCoordinates(polySum.latitude / this.m_coordinates.length, polySum.longitude / this.m_coordinates.length);\n    }\n    getArea() {\n        let area = 0;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            area += coordinate.latitude * previousCoordinate.longitude;\n            area -= coordinate.longitude * previousCoordinate.latitude;\n            previousIndex = index;\n        });\n        return (area /= 2);\n    }\n    getEastAndWest(center) {\n        let west = center.longitude;\n        let east = center.longitude;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            previousIndex = index;\n            const veca = new three_1.Vector2(coordinate.latitude - center.latitude, coordinate.longitude - center.longitude).normalize();\n            const vecb = new three_1.Vector2(previousCoordinate.latitude - center.latitude, previousCoordinate.longitude - center.longitude).normalize();\n            let ccw = Math.sign(vecb.angle() - veca.angle()) === 1;\n            // overwrite in case of angle over axis\n            if (vecb.y >= 0 && veca.y < 0) {\n                ccw = true;\n            }\n            const long = coordinate.longitude;\n            if (long < center.longitude) {\n                if (ccw) {\n                    west = Math.min(west, long);\n                }\n                else {\n                    east = Math.min(east, long);\n                }\n            }\n            else {\n                if (ccw) {\n                    east = Math.max(east, long);\n                }\n                else {\n                    west = Math.max(west, long);\n                }\n            }\n        });\n        return { east, west };\n    }\n    getNorthAndSouth() {\n        let north = GeoCoordinates_1.MIN_LATITUDE;\n        let south = GeoCoordinates_1.MAX_LATITUDE;\n        this.m_coordinates.forEach((coordinate, index) => {\n            north = Math.max(north, coordinate.latitude);\n            south = Math.min(south, coordinate.latitude);\n        });\n        return { north, south };\n    }\n}\nexports.GeoPolygon = GeoPolygon;\n//# sourceMappingURL=GeoPolygon.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygon.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGeoPolygonLike = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GeoCoordLike_1 = __webpack_require__(/*! ./GeoCoordLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordLike.js\");\n/**\n * Type guard to assert that `object` conforms to {@link GeoPolygonLike} data interface.\n *\n * @beta, @internal\n */\nfunction isGeoPolygonLike(object) {\n    if (!object || (!Array.isArray(object.coordinates) && object.coordinates.length > 2)) {\n        return false;\n    }\n    let isValid = true;\n    //TODO: this might take a while, not sure this should be that extensive\n    object.coordinates.forEach((coord) => {\n        if (!GeoCoordLike_1.isGeoCoordLike(object)) {\n            isValid = false;\n        }\n    });\n    return isValid;\n}\nexports.isGeoPolygonLike = isGeoPolygonLike;\n//# sourceMappingURL=GeoPolygonLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPolygonLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLatLngLike = void 0;\n/**\n * Type guard to assert that `object` conforms to {@link LatLngLike} interface.\n */\nfunction isLatLngLike(object) {\n    return object && typeof object.lat === \"number\" && typeof object.lng === \"number\";\n}\nexports.isLatLngLike = isLatLngLike;\n//# sourceMappingURL=LatLngLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Box3Like.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBox3Like = void 0;\n/**\n * Returns true if the given object implements the {@link Box3Like} interface.\n *\n * @param object - A valid object.\n */\nfunction isBox3Like(object) {\n    const box3 = object;\n    return box3.min !== undefined && box3.max !== undefined;\n}\nexports.isBox3Like = isBox3Like;\n//# sourceMappingURL=Box3Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Box3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/MathUtils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathUtils = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nvar MathUtils;\n(function (MathUtils) {\n    /**\n     * Creates a new empty bounding box.\n     *\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/Box3 | THREE.Box3} instead.\n     */\n    function newEmptyBox3() {\n        return {\n            min: { x: Infinity, y: Infinity, z: Infinity },\n            max: { x: -Infinity, y: -Infinity, z: -Infinity }\n        };\n    }\n    MathUtils.newEmptyBox3 = newEmptyBox3;\n    /**\n     * Set the components of the given [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param v - The [Vector3Like]\n     */\n    function newVector3(x, y, z, v) {\n        if (v === undefined) {\n            return { x, y, z };\n        }\n        v.x = x;\n        v.y = y;\n        v.z = z;\n        return v;\n    }\n    MathUtils.newVector3 = newVector3;\n    /**\n     * Copies the vector across.\n     *\n     * @param from - The vector to copy from.\n     * @param to - The resulting [Vector3Like] instance, with the contents copied from from\n     */\n    function copyVector3(from, to) {\n        to.x = from.x;\n        to.y = from.y;\n        to.z = from.z;\n        return to;\n    }\n    MathUtils.copyVector3 = copyVector3;\n    /**\n     * Converts an angle measured in degrees to an equivalent value in radians.\n     *\n     * @param degrees - Value in degrees.\n     * @returns Value in radians.\n     * @deprecated use THREE.MathUtils.degToRad instead\n     */\n    MathUtils.degToRad = THREE.MathUtils.degToRad;\n    /**\n     * Converts an angle measured in radians to an equivalent value in degrees.\n     *\n     * @param degrees - Value in radians.\n     * @returns Value in degrees.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.radToDeg\n     *                | THREE.MathUtils.radToDeg}.\n     */\n    MathUtils.radToDeg = THREE.MathUtils.radToDeg;\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     * @returns Clamped value.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.clamp\n     *                | THREE.MathUtils.clamp}.\n     */\n    MathUtils.clamp = THREE.MathUtils.clamp;\n    /**\n     * Normalize angle in degrees to range `[0, 360)`.\n     *\n     * @param a - Angle in degrees.\n     * @returns Angle in degrees in range `[0, 360)`.\n     */\n    function normalizeAngleDeg(a) {\n        a = a % 360;\n        if (a < 0) {\n            a = a + 360;\n        }\n        return a;\n    }\n    MathUtils.normalizeAngleDeg = normalizeAngleDeg;\n    /**\n     * Normalize latitude angle in degrees to range `[-180, 180]`.\n     *\n     * @param a - Latitude angle in degrees.\n     * @returns Latitude angle in degrees in range `[-180, 180]`.\n     */\n    function normalizeLongitudeDeg(a) {\n        a = normalizeAngleDeg(a);\n        if (a > 180) {\n            a = a - 360;\n        }\n        return a;\n    }\n    MathUtils.normalizeLongitudeDeg = normalizeLongitudeDeg;\n    /**\n     * Return the minimal delta between angles `a` and `b` given in degrees.\n     *\n     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed\n     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.\n     *\n     * Useful when interpolating between `b` and `a` in angle space.\n     *\n     * @param a - Start angle in degrees.\n     * @param b - End angle in degrees.\n     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.\n     */\n    function angleDistanceDeg(a, b) {\n        a = normalizeAngleDeg(a);\n        b = normalizeAngleDeg(b);\n        const d = a - b;\n        if (d > 180) {\n            return d - 360;\n        }\n        else if (d <= -180) {\n            return d + 360;\n        }\n        else {\n            return d;\n        }\n    }\n    MathUtils.angleDistanceDeg = angleDistanceDeg;\n    /**\n     * Interpolate linearly between two angles given in degrees.\n     *\n     * @param p0 - Angle from in degrees\n     * @param p1 - Angle to in degrees\n     * @param t - Interpolation factor (alpha), in range `0-1`.\n     */\n    function interpolateAnglesDeg(p0, p1, t) {\n        // hand crafted version,\n        // see stack for maybe better versions:\n        //    https://stackoverflow.com/questions/2708476/rotation-interpolation\n        const d = angleDistanceDeg(p1, p0);\n        const r = (p0 + d * t) % 360;\n        return r;\n    }\n    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;\n})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));\n//# sourceMappingURL=MathUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/MathUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OrientedBox3 = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nfunction intersectsSlab(rayDir, p, axis, extent, t) {\n    const epsilon = 1e-20;\n    const e = axis.dot(p);\n    const f = axis.dot(rayDir);\n    if (Math.abs(f) < epsilon) {\n        // ray parallel to near/far slab lines.\n        return Math.abs(e) <= extent;\n    }\n    // ray intersects near/far slab lines.\n    const finv = 1 / f;\n    const t1 = (e + extent) * finv;\n    const t2 = (e - extent) * finv;\n    if (t1 > t2) {\n        // t1 is far intersect, t2 is near.\n        if (t2 > t.min) {\n            t.min = t2;\n        }\n        if (t1 < t.max) {\n            t.max = t1;\n        }\n    }\n    else {\n        // t1 is near intersect, t2 is far.\n        if (t1 > t.min) {\n            t.min = t1;\n        }\n        if (t2 < t.max) {\n            t.max = t2;\n        }\n    }\n    return t.min <= t.max && t.max >= 0;\n}\nconst tmpVec = new three_1.Vector3();\nconst tmpT = { min: -Infinity, max: Infinity };\nclass OrientedBox3 {\n    /**\n     * Creates a new `OrientedBox3`.\n     *\n     * @hideconstructor\n     */\n    constructor(position, rotationMatrix, extents) {\n        /**\n         * The position of the center of this `OrientedBox3`.\n         */\n        this.position = new three_1.Vector3();\n        /**\n         * The x-axis of this `OrientedBox3`.\n         */\n        this.xAxis = new three_1.Vector3(1, 0, 0);\n        /**\n         * The y-axis of this `OrientedBox3`.\n         */\n        this.yAxis = new three_1.Vector3(0, 1, 0);\n        /**\n         * The z-axis of this `OrientedBox3`.\n         */\n        this.zAxis = new three_1.Vector3(0, 0, 1);\n        /**\n         * The extents of this `OrientedBox3`.\n         */\n        this.extents = new three_1.Vector3();\n        if (position !== undefined) {\n            this.position.copy(position);\n        }\n        if (rotationMatrix !== undefined) {\n            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);\n        }\n        if (extents !== undefined) {\n            this.extents.copy(extents);\n        }\n    }\n    /**\n     * Create a copy of this [[OrientedBoundingBox]].\n     */\n    clone() {\n        const newBox = new OrientedBox3();\n        newBox.copy(this);\n        return newBox;\n    }\n    /**\n     * Copies the values of `other` to this {@link OrientedBox3}.\n     * @param other - The other {@link OrientedBox3} to copy.\n     */\n    copy(other) {\n        this.position.copy(other.position);\n        this.xAxis.copy(other.xAxis);\n        this.yAxis.copy(other.yAxis);\n        this.zAxis.copy(other.zAxis);\n        this.extents.copy(other.extents);\n    }\n    /**\n     * Gets the center position of this {@link OrientedBox3}.\n     *\n     * @param center - The returned center position.\n     */\n    getCenter(center = new three_1.Vector3()) {\n        return center.copy(this.position);\n    }\n    /**\n     * Gets the size of this {@link OrientedBox3}.\n     *\n     * @param size - The returned size.\n     */\n    getSize(size = new three_1.Vector3()) {\n        return size.copy(this.extents).multiplyScalar(2);\n    }\n    /**\n     * Gets the orientation matrix of this `OrientedBox3`.\n     * @param matrix - The output orientation matrix.\n     */\n    getRotationMatrix(matrix = new three_1.Matrix4()) {\n        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);\n    }\n    /**\n     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.\n     *\n     * @param frustumOrPlanes - Frustum or array of planes.\n     */\n    intersects(frustumOrPlanes) {\n        const planes = Array.isArray(frustumOrPlanes)\n            ? frustumOrPlanes\n            : frustumOrPlanes.planes;\n        for (const plane of planes) {\n            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +\n                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +\n                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);\n            const d = plane.distanceToPoint(this.position);\n            if (d + r < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks intersection with the given ray.\n     *\n     * @param ray - The ray to test.\n     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.\n     */\n    intersectsRay(ray) {\n        // Slabs intersection algorithm.\n        tmpT.min = -Infinity;\n        tmpT.max = Infinity;\n        tmpVec.copy(this.position).sub(ray.origin);\n        if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {\n            return undefined;\n        }\n        return tmpT.min > 0 ? tmpT.min : tmpT.max;\n    }\n    /**\n     * Returns true if this {@link OrientedBox3} contains the given point.\n     *\n     * @param point - A valid point.\n     */\n    contains(point) {\n        const dx = point.x - this.position.x;\n        const dy = point.y - this.position.y;\n        const dz = point.z - this.position.z;\n        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);\n        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);\n        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);\n        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPoint(point) {\n        return Math.sqrt(this.distanceToPointSquared(point));\n    }\n    /**\n     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPointSquared(point) {\n        const d = new three_1.Vector3();\n        d.subVectors(point, this.position);\n        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];\n        let result = 0;\n        for (let i = 0; i < 3; ++i) {\n            const length = lengths[i];\n            const extent = this.extents.getComponent(i);\n            if (length < -extent) {\n                const dd = extent + length;\n                result += dd * dd;\n            }\n            else if (length > extent) {\n                const dd = length - extent;\n                result += dd * dd;\n            }\n        }\n        return result;\n    }\n}\nexports.OrientedBox3 = OrientedBox3;\n//# sourceMappingURL=OrientedBox3.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isOrientedBox3Like = void 0;\n/**\n * Returns true if the given object implements the interface {@link OrientedBox3Like}.\n *\n * @param object - The object.\n */\nfunction isOrientedBox3Like(object) {\n    const obb = object;\n    return (obb.position !== undefined &&\n        obb.xAxis !== undefined &&\n        obb.yAxis !== undefined &&\n        obb.zAxis !== undefined &&\n        obb.extents !== undefined);\n}\nexports.isOrientedBox3Like = isOrientedBox3Like;\n//# sourceMappingURL=OrientedBox3Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/TransformLike.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/TransformLike.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTransformLike = void 0;\n/**\n * Returns true if the given object implements the interface {@link TransformLike}.\n *\n * @param object - The object.\n */\nfunction isTransformLike(object) {\n    const transform = object;\n    return (transform.position !== undefined &&\n        transform.xAxis !== undefined &&\n        transform.yAxis !== undefined &&\n        transform.zAxis !== undefined);\n}\nexports.isTransformLike = isTransformLike;\n//# sourceMappingURL=TransformLike.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/TransformLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVector2Like = void 0;\nfunction isVector2Like(v) {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\";\n}\nexports.isVector2Like = isVector2Like;\n//# sourceMappingURL=Vector2Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Vector2Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isVector3Like = void 0;\nfunction isVector3Like(v) {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\nexports.isVector3Like = isVector3Like;\n//# sourceMappingURL=Vector3Like.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EarthConstants = void 0;\nclass EarthConstants {\n}\nexports.EarthConstants = EarthConstants;\n/** The equatorial circumference in meters. */\nEarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;\n/** The equatorial radius in meters. */\nEarthConstants.EQUATORIAL_RADIUS = 6378137.0;\n/** The lowest point on earth (Dead Sea) in meters. */\nEarthConstants.MIN_ELEVATION = -433.0;\n/** The highest point on earth (Mt. Everest) in meters. */\nEarthConstants.MAX_ELEVATION = 8848.0;\n/** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */\nEarthConstants.MAX_BUILDING_HEIGHT = 828;\n//# sourceMappingURL=EarthConstants.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.equirectangularProjection = exports.normalizedEquirectangularProjection = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass EquirectangularProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = 0.0;\n        result.min.y = 0.0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale / 2;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        var _a;\n        if (result === undefined) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x =\n            (THREE.MathUtils.degToRad(geoPoint.longitude) + Math.PI) *\n                EquirectangularProjection.geoToWorldScale *\n                this.unitScale;\n        result.y =\n            (THREE.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) *\n                EquirectangularProjection.geoToWorldScale *\n                this.unitScale;\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -\n            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));\n        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;\n        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;\n            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;\n            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;\n            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            }\n            else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = sizeX * 0.5 * this.unitScale;\n            result.extents.y = sizeY * 0.5 * this.unitScale;\n            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan !== null && altitudeSpan !== void 0 ? altitudeSpan : 0) * 0.5);\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\nEquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);\nEquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to unit coordinates and vice\n * versa.\n */\nexports.normalizedEquirectangularProjection = new EquirectangularProjection(1);\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to world coordinates and vice\n * versa.\n */\nexports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n//# sourceMappingURL=EquirectangularProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.identityProjection = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass IdentityProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = -Math.PI;\n        result.min.y = -Math.PI * 0.5;\n        result.min.z = minAltitude;\n        result.max.x = Math.PI;\n        result.max.y = Math.PI * 0.5;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        var _a;\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = THREE.MathUtils.degToRad(geoPoint.longitude);\n        result.y = THREE.MathUtils.degToRad(geoPoint.latitude);\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));\n        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = min.x;\n            result.min.y = min.y;\n            result.min.z = min.z;\n            result.max.x = max.x;\n            result.max.y = max.y;\n            result.max.z = max.z;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (min.x + max.x) * 0.5;\n            result.position.y = (min.y + max.y) * 0.5;\n            result.position.z = (min.z + max.z) * 0.5;\n            result.extents.x = (max.x - min.x) * 0.5;\n            result.extents.y = (max.y - min.y) * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n/**\n * Identity {@link Projection} used to convert geo coordinates to unit coordinates and vice versa.\n */\nexports.identityProjection = new IdentityProjection(1);\n//# sourceMappingURL=IdentityProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webMercatorProjection = exports.mercatorProjection = exports.MercatorConstants = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass MercatorProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    static clamp(val, min, max) {\n        return Math.min(Math.max(min, val), max);\n    }\n    static latitudeClamp(latitude) {\n        return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);\n    }\n    static latitudeProject(latitude) {\n        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;\n    }\n    static latitudeClampProject(latitude) {\n        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));\n    }\n    static unprojectLatitude(y) {\n        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;\n    }\n    /** @override */\n    getScaleFactor(worldPoint) {\n        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPointLike, result) {\n        var _a;\n        let geoPoint;\n        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {\n            geoPoint = geoPointLike;\n        }\n        else {\n            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);\n        }\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        result.y =\n            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *\n                this.unitScale;\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        var _a;\n        const worldCenter = this.projectPoint(geoBox.center);\n        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +\n            0.5) *\n            this.unitScale;\n        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +\n            0.5) *\n            this.unitScale;\n        const worldYCenter = (worldNorth + worldSouth) * 0.5;\n        worldCenter.y = worldYCenter;\n        const latitudeSpan = worldNorth - worldSouth;\n        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = worldCenter.x - longitudeSpan * 0.5;\n            result.min.y = worldCenter.y - latitudeSpan * 0.5;\n            result.max.x = worldCenter.x + longitudeSpan * 0.5;\n            result.max.y = worldCenter.y + latitudeSpan * 0.5;\n            const altitudeSpan = geoBox.altitudeSpan;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            }\n            else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = longitudeSpan * 0.5;\n            result.extents.y = latitudeSpan * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, ((_a = geoBox.altitudeSpan) !== null && _a !== void 0 ? _a : 0) * 0.5);\n        }\n        else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n    /** @override */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        // this implementation of [[reprojectPoint]] supports both\n        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only\n        // difference betweeen these two variants of WEB Mercator\n        // is in the orientation of the Y axis, so we just flip Y coordinates\n        // when reprojecting between them.\n        if (sourceProjection !== this &&\n            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {\n            if (result === undefined) {\n                result = {};\n            }\n            result.x = worldPos.x;\n            result.y = this.unitScale - worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return super.reprojectPoint(sourceProjection, worldPos, result);\n    }\n}\nclass WebMercatorProjection extends MercatorProjection {\n    /** @override */\n    projectPoint(geoPointLike, result) {\n        var _a;\n        let geoPoint;\n        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {\n            geoPoint = geoPointLike;\n        }\n        else {\n            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);\n        }\n        /*\n         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n         * might be a concrete class which is not available at runtime.\n         * Consider the following example:\n         *\n         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n         *\n         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n         */\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));\n        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const x = worldPoint.x / this.unitScale - 0.5;\n        const y = 0.5 - worldPoint.y / this.unitScale;\n        const longitude = 360 * x;\n        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;\n        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const r = super.projectBox(geoBox, result);\n        if (Box3Like_1.isBox3Like(r)) {\n            // Invert the y axis for web mercator, this means that max => min & min => max\n            const maxY = r.max.y;\n            r.max.y = this.unitScale - r.min.y;\n            r.min.y = this.unitScale - maxY;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);\n            r.position.y = this.unitScale - r.position.y;\n        }\n        return r;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));\n        return geoBox;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n    /** @override */\n    localTangentSpace(point, result) {\n        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        }\n        else {\n            MathUtils_1.MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);\n        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);\n        return result;\n    }\n}\nclass MercatorConstants {\n}\nexports.MercatorConstants = MercatorConstants;\n// Math.atan(Math.sinh(Math.PI))\nMercatorConstants.MAXIMUM_LATITUDE = 1.4844222297453323;\n/**\n * Mercator {@link Projection} used to convert geo coordinates to world coordinates and vice versa.\n */\nexports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n/**\n * Web Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n//# sourceMappingURL=MercatorProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/Projection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Projection = exports.ProjectionType = void 0;\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\n/**\n * The type of projection.\n */\nvar ProjectionType;\n(function (ProjectionType) {\n    /**\n     * A type of [Projection] with zero curvature.\n     */\n    ProjectionType[ProjectionType[\"Planar\"] = 0] = \"Planar\";\n    /**\n     * A spherical [Projection].\n     */\n    ProjectionType[ProjectionType[\"Spherical\"] = 1] = \"Spherical\";\n})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));\n/**\n * `Projection` is used to convert positions from geo coordinates to world coordinates and vice\n * versa.\n */\nclass Projection {\n    /**\n     * Constructs the Projection\n     *\n     * @param unitScale - How to transform the projected coordinates to world units.\n     */\n    constructor(unitScale) {\n        this.unitScale = unitScale;\n        //Prevent empty constructor error.\n    }\n    /**\n     * Gets the {@link TransformLike} of the local tangent space at the given point.\n     *\n     * @param point - The geo / world coordinates.\n     * @param result - The {@link TransformLike}.\n     */\n    localTangentSpace(point, result) {\n        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        }\n        else {\n            MathUtils_1.MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n        return result;\n    }\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     * Implementations should be aware of worldPos and result may be one object\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid position in the world space defined by the source projection.\n     * @param result - The resulting position reprojected using this {@link Projection}.\n     * @hidden\n     */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        if (sourceProjection === this) {\n            if (result === undefined) {\n                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n            }\n            result.x = worldPos.x;\n            result.y = worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);\n    }\n}\nexports.Projection = Projection;\n//# sourceMappingURL=Projection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/Projection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sphereProjection = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\n/**\n * Transforms the given vector using the provided basis.\n */\nfunction apply(xAxis, yAxis, zAxis, v) {\n    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;\n    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;\n    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n/**\n * Returns the quadrants for the given longitude. The quadrant is defined as:\n *  - quadrant(+Math.PI * -1.0) = 0\n *  - quadrant(+Math.PI * -0.5) = 1\n *  - quadrant(+Math.PI *  0.0) = 2\n *  - quadrant(+Math.PI *  0.5) = 3\n *  - quadrant(+Math.PI *  1.0) = 4\n *\n * @param longitude - The longitude in radians.\n */\nfunction getLongitudeQuadrant(longitude) {\n    const oneOverPI = 1 / Math.PI;\n    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));\n    return THREE.MathUtils.clamp(quadrantIndex, 0, 4);\n}\nfunction lengthOfVector3(worldPoint) {\n    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);\n    return d;\n}\n/**\n * Creates a Box3 enclosing the geobox.\n *\n * @param geoBox - Ghe given geobox\n * @param worldBox - The resulting axis aligned bounding box.\n */\nfunction makeBox3(geoBox, worldBox, unitScale) {\n    var _a;\n    const halfEquatorialRadius = (unitScale + ((_a = geoBox.maxAltitude) !== null && _a !== void 0 ? _a : 0)) * 0.5;\n    const minLongitude = THREE.MathUtils.degToRad(geoBox.west);\n    const maxLongitude = THREE.MathUtils.degToRad(geoBox.east);\n    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);\n    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);\n    let xMin = Math.cos(minLongitude);\n    let xMax = xMin;\n    let yMin = Math.sin(minLongitude);\n    let yMax = yMin;\n    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {\n        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);\n        xMin = Math.min(x, xMin);\n        xMax = Math.max(x, xMax);\n        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);\n        yMin = Math.min(y, yMin);\n        yMax = Math.max(y, yMax);\n    }\n    const cosMaxLongitude = Math.cos(maxLongitude);\n    xMin = Math.min(cosMaxLongitude, xMin);\n    xMax = Math.max(cosMaxLongitude, xMax);\n    const sinMaxLongitude = Math.sin(maxLongitude);\n    yMin = Math.min(sinMaxLongitude, yMin);\n    yMax = Math.max(sinMaxLongitude, yMax);\n    const xCenter = (xMax + xMin) * halfEquatorialRadius;\n    const xExtent = (xMax - xMin) * halfEquatorialRadius;\n    const yCenter = (yMax + yMin) * halfEquatorialRadius;\n    const yExtent = (yMax - yMin) * halfEquatorialRadius;\n    // Calculate Z boundaries.\n    const minLatitude = THREE.MathUtils.degToRad(geoBox.south);\n    const maxLatutide = THREE.MathUtils.degToRad(geoBox.north);\n    const zMax = Math.sin(maxLatutide);\n    const zMin = Math.sin(minLatitude);\n    const zCenter = (zMax + zMin) * halfEquatorialRadius;\n    const zExtent = (zMax - zMin) * halfEquatorialRadius;\n    worldBox.min.x = xCenter - xExtent;\n    worldBox.min.y = yCenter - yExtent;\n    worldBox.min.z = zCenter - zExtent;\n    worldBox.max.x = xCenter + xExtent;\n    worldBox.max.y = yCenter + yExtent;\n    worldBox.max.z = zCenter + zExtent;\n    return worldBox;\n}\n/**\n * Computes the spherical projection of the given geo coordinates.\n *\n * @param geoPoint - The geo coordinates.\n * @param worldpoint - The resulting world coordinates.\n */\nfunction project(geoPoint, worldpoint, unitScale) {\n    var _a;\n    const radius = unitScale + ((_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0);\n    const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n    const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n    const cosLatitude = Math.cos(latitude);\n    worldpoint.x = radius * cosLatitude * Math.cos(longitude);\n    worldpoint.y = radius * cosLatitude * Math.sin(longitude);\n    worldpoint.z = radius * Math.sin(latitude);\n    return worldpoint;\n}\nclass SphereProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Spherical;\n    }\n    /** @override */\n    worldExtent(_minElevation, maxElevation, result = new THREE.Box3()) {\n        const radius = this.unitScale + maxElevation;\n        result.min.x = -radius;\n        result.min.y = -radius;\n        result.min.z = -radius;\n        result.max.x = radius;\n        result.max.y = radius;\n        result.max.z = radius;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {\n        return project(geoPoint, result, this.unitScale);\n    }\n    /** @override */\n    unprojectPoint(point) {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y;\n        const parallelRadius = Math.sqrt(parallelRadiusSq);\n        const v = point.z / parallelRadius;\n        if (isNaN(v)) {\n            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);\n        }\n        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);\n        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);\n    }\n    /** @override */\n    unprojectAltitude(point) {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;\n        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;\n    }\n    /** @override */\n    projectBox(geoBox, result = new THREE.Box3()) {\n        var _a, _b;\n        if (Box3Like_1.isBox3Like(result)) {\n            return makeBox3(geoBox, result, this.unitScale);\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            if (geoBox.longitudeSpan >= 90) {\n                const bounds = makeBox3(geoBox, new THREE.Box3(), this.unitScale);\n                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;\n                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;\n                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;\n                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;\n                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;\n                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;\n                return result;\n            }\n            const { south, west, north, east, center: mid } = geoBox;\n            const midX = mid.longitude;\n            const midY = mid.latitude;\n            const cosSouth = Math.cos(THREE.MathUtils.degToRad(south));\n            const sinSouth = Math.sin(THREE.MathUtils.degToRad(south));\n            const cosWest = Math.cos(THREE.MathUtils.degToRad(west));\n            const sinWest = Math.sin(THREE.MathUtils.degToRad(west));\n            const cosNorth = Math.cos(THREE.MathUtils.degToRad(north));\n            const sinNorth = Math.sin(THREE.MathUtils.degToRad(north));\n            const cosEast = Math.cos(THREE.MathUtils.degToRad(east));\n            const sinEast = Math.sin(THREE.MathUtils.degToRad(east));\n            const cosMidX = Math.cos(THREE.MathUtils.degToRad(midX));\n            const sinMidX = Math.sin(THREE.MathUtils.degToRad(midX));\n            const cosMidY = Math.cos(THREE.MathUtils.degToRad(midY));\n            const sinMidY = Math.sin(THREE.MathUtils.degToRad(midY));\n            // Build the orientation of the OBB using the normal vector and its partial derivates.\n            // the sperical coordinates of the mid point of the geobox.\n            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);\n            // the partial derivates of the normal vector.\n            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);\n            let width;\n            let minY;\n            let maxY;\n            if (south >= 0) {\n                // abs(dot(southWest - southEast, xAxis))\n                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));\n                // dot(south, yAxis)\n                minY = cosMidY * sinSouth - sinMidY * cosSouth;\n                // dot(northEast, zAxis)\n                maxY =\n                    cosMidY * sinNorth -\n                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n            else {\n                if (north <= 0) {\n                    // abs(dot(northWest - northEast, xAxis))\n                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));\n                    // dot(north, yAxis)\n                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;\n                }\n                else {\n                    // abs(dot(west - east, xAxis))\n                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));\n                    // dot(northEast, yAxis)\n                    maxY =\n                        cosMidY * sinNorth -\n                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);\n                }\n                // dot(southEast, yAxis)\n                minY =\n                    cosMidY * sinSouth -\n                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n            const rMax = (this.unitScale + ((_a = geoBox.maxAltitude) !== null && _a !== void 0 ? _a : 0)) * 0.5;\n            const rMin = (this.unitScale + ((_b = geoBox.minAltitude) !== null && _b !== void 0 ? _b : 0)) * 0.5;\n            // min(dot(southEast, zAxis), dot(northEast, zAxis))\n            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);\n            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);\n            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);\n            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);\n            apply(result.xAxis, result.yAxis, result.zAxis, result.position);\n            result.position.x = result.position.x - result.zAxis.x * result.extents.z;\n            result.position.y = result.position.y - result.zAxis.y * result.extents.z;\n            result.position.z = result.position.z - result.zAxis.z * result.extents.z;\n            return result;\n        }\n        throw new Error(\"Invalid bounding box\");\n    }\n    /** @override */\n    unprojectBox(_worldBox) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return lengthOfVector3(worldPoint) - this.unitScale;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);\n        worldPoint.x *= scale;\n        worldPoint.y *= scale;\n        worldPoint.z *= scale;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 0 };\n        }\n        const scale = 1 / (lengthOfVector3(worldPoint) || 1);\n        normal.x = worldPoint.x * scale;\n        normal.y = worldPoint.y * scale;\n        normal.z = worldPoint.z * scale;\n        return normal;\n    }\n    /** @override */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {\n            const { x, y, z } = worldPos;\n            const r = this.unitScale;\n            const mx = x / r - Math.PI;\n            const my = y / r - Math.PI;\n            const w = Math.exp(my);\n            const d = w * w;\n            const gx = (2 * w) / (d + 1);\n            const gy = (d - 1) / (d + 1);\n            const scale = r + z;\n            if (result === undefined) {\n                result = {};\n            }\n            result.x = Math.cos(mx) * gx * scale;\n            result.y = Math.sin(mx) * gx * scale;\n            result.z = gy * scale;\n            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {\n                result.z = -result.z;\n            }\n            return result;\n        }\n        return super.reprojectPoint(sourceProjection, worldPos, result);\n    }\n    /** @override */\n    localTangentSpace(point, result) {\n        let geoPoint;\n        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n            geoPoint = point;\n        }\n        else {\n            MathUtils_1.MathUtils.copyVector3(point, result.position);\n            geoPoint = this.unprojectPoint(point);\n        }\n        const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n        const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n        const cosLongitude = Math.cos(longitude);\n        const sinLongitude = Math.sin(longitude);\n        const cosLatitude = Math.cos(latitude);\n        const sinLatitude = Math.sin(latitude);\n        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);\n        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);\n        return result;\n    }\n}\nexports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);\n//# sourceMappingURL=SphereProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transverseMercatorProjection = exports.TransverseMercatorUtils = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\n/**\n *\n * https://en.wikipedia.org/wiki/Transverse_Mercator_projection\n * http://mathworld.wolfram.com/MercatorProjection.html\n *\n */\nclass TransverseMercatorProjection extends Projection_1.Projection {\n    constructor(unitScale) {\n        super(unitScale);\n        this.unitScale = unitScale;\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n        this.m_phi0 = 0;\n        this.m_lambda0 = 0;\n    }\n    /**\n     * Like in regular Mercator projection, there are two points on sphere\n     * with radius about 5 degrees, that is out of projected space.\n     *\n     *\n     * in regular Mercator these points are:\n     *     (90, any), (-90, any)\n     *\n     * and in transverse Mercator:\n     *     (0, 90), (0, -90)\n     *\n     * So, in transverse we need to compute distnce to poles, and clamp if\n     * radius is exceeded\n     */\n    static clampGeoPoint(geoPoint, _unitScale) {\n        const lat = geoPoint.latitude;\n        const lon = geoPoint.longitude;\n        const r = TransverseMercatorUtils.POLE_RADIUS;\n        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;\n        const nearestQuarter = Math.round(lon / 90);\n        const deltaLon = nearestQuarter * 90 - lon;\n        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {\n            return geoPoint;\n        }\n        const deltaLat = lat - 0;\n        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;\n        if (distanceToPoleSq < rsq) {\n            const distanceToPole = Math.sqrt(distanceToPoleSq);\n            const scale = (r - distanceToPole) / distanceToPole;\n            // const quarter = ((nearestQuarter % 4) + 4) % 4;\n            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;\n            const dir = 1;\n            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;\n            return new GeoCoordinates_1.GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);\n        }\n        return geoPoint;\n    }\n    /** @override */\n    getScaleFactor(worldPoint) {\n        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        var _a;\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 };\n        }\n        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);\n        const normalLon = clamped.longitude / 360 + 0.5;\n        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);\n        const phi = THREE.MathUtils.degToRad(clamped.latitude);\n        const lambda = THREE.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;\n        const B = Math.cos(phi) * Math.sin(lambda);\n        // result.x = 1/2 * Math.log((1 + B) / (1 - B));\n        result.x = Math.atanh(B);\n        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;\n        const outScale = 0.5 / Math.PI;\n        result.x =\n            this.unitScale * (THREE.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);\n        result.y = this.unitScale * THREE.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);\n        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const tau = Math.PI * 2;\n        const nx = worldPoint.x / this.unitScale;\n        const ny = worldPoint.y / this.unitScale;\n        const offset = nx === 1 ? 0 : Math.floor(nx);\n        const x = tau * (nx - 0.5 - offset);\n        const y = tau * (ny - 0.5);\n        const z = worldPoint.z || 0;\n        const D = y + this.m_phi0;\n        const phi = Math.asin(Math.sin(D) / Math.cosh(x));\n        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(phi, lambda, z);\n        return geoPoint;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const { north, south, east, west } = geoBox;\n        const pointsToCheck = [\n            geoBox.center,\n            geoBox.northEast,\n            geoBox.southWest,\n            new GeoCoordinates_1.GeoCoordinates(south, east),\n            new GeoCoordinates_1.GeoCoordinates(north, west)\n        ];\n        const E = TransverseMercatorUtils.POLE_EDGE_DEG;\n        const containsWestCut = west < -90 && east > -90;\n        const containsEastCut = west < 90 && east > 90;\n        const containsCenterX = west < 0 && east > 0;\n        const containsCenterY = west < E && east > -E && north > 0 && south < 0;\n        if (containsWestCut) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, -90));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, -90));\n        }\n        if (containsEastCut) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 90));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 90));\n        }\n        if (containsCenterX) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 0));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 0));\n        }\n        if (containsCenterY) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, west));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, east));\n        }\n        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);\n        const projected = pointsToCheck.map(p => this.projectPoint(p));\n        const vx = projected.map(p => p.x);\n        const vy = projected.map(p => p.y);\n        const vz = projected.map(p => p.z);\n        const minX = Math.min(...vx);\n        const minY = Math.min(...vy);\n        const minZ = Math.min(...vz);\n        const maxX = Math.max(...vx);\n        const maxY = Math.max(...vy);\n        const maxZ = Math.max(...vz);\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = minX;\n            result.min.y = minY;\n            result.min.z = minZ;\n            result.max.x = maxX;\n            result.max.y = maxY;\n            result.max.z = maxZ;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (minX + maxX) / 2;\n            result.position.y = (minY + maxY) / 2;\n            result.position.z = (minZ + maxZ) / 2;\n            result.extents.x = (maxX - minX) / 2;\n            result.extents.y = (maxY - minY) / 2;\n            result.extents.z = (maxZ - minZ) / 2;\n        }\n        else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n    /**\n     * There are 8 sub-regions on entire projection space\n     * where both longitude and latitude preserve direction.\n     * If bounding box hits more than one region, it should be splitted\n     * into sub-boxes by regions, (un)projected and then united again.\n     *\n     *\n     * directions in form [latitude / longitude]:\n     *    1 |\n     *       dr / dl | dl / ul \n     * 0.75 ----------|----------\n     *       ur / dr | ul / ur \n     * 0.5  ----------|----------\n     *       ul / ur | ur / dr \n     * 0.25 ----------|----------\n     *       dl / ul | dr / dl \n     *      |\n     *     0         0.5        1\n     *     @override\n     */\n    unprojectBox(worldBox) {\n        const s = this.unitScale;\n        const min = worldBox.min;\n        const max = worldBox.max;\n        const pointsToCheck = [\n            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },\n            min,\n            max,\n            { x: min.x, y: max.y, z: 0 },\n            { x: max.x, y: min.y, z: 0 }\n        ];\n        const center = 0.5 * s;\n        const lowerQ = 0.25 * s;\n        const upperQ = 0.75 * s;\n        const containsCenterX = min.x < center && max.x > center;\n        const containsCenterY = min.y < center && max.y > center;\n        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;\n        const containsUpperQY = min.y < upperQ && max.y > upperQ;\n        if (containsCenterY) {\n            pointsToCheck.push({ x: min.x, y: center, z: 0 });\n            pointsToCheck.push({ x: max.x, y: center, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: center, z: 0 });\n            }\n        }\n        if (containsLowerQY) {\n            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });\n            }\n        }\n        if (containsUpperQY) {\n            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: upperQ, z: 0 });\n            }\n        }\n        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));\n        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);\n        const latitudes = geoPoints.map(g => g.latitude);\n        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);\n        const altitudes = geoPoints.map(g => { var _a; return (_a = g.altitude) !== null && _a !== void 0 ? _a : 0; });\n        const minGeo = new GeoCoordinates_1.GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));\n        const maxGeo = new GeoCoordinates_1.GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));\n        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n}\nclass TransverseMercatorUtils {\n    /**\n     * There are two regions on projected space that have same geo coordinates,\n     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }\n     * they both have geo coordinates of   (0, [-90..+90])\n     * and should be aligned somehow to fall into first or second region\n     * to make proper bounding boxes, tile bounds, etc.\n     */\n    static alignLatitude(points, referencePoint) {\n        const EPSILON = 1e-9;\n        for (const point of points) {\n            if (point.latitude === 0) {\n                point.latitude = referencePoint.latitude * EPSILON;\n            }\n        }\n    }\n    /**\n     * There are two regions on projected plane,\n     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }\n     * that represent longitude edge where -180 and +180 met.\n     * Points falling in this regions should be aligned to get proper boxes etc.\n     */\n    static alignLongitude(points, referencePoint) {\n        const bad = referencePoint.longitude < 0 ? 180 : -180;\n        const good = referencePoint.longitude < 0 ? -180 : 180;\n        for (const point of points) {\n            if (point.longitude === bad) {\n                point.longitude = good;\n            }\n        }\n    }\n}\nexports.TransverseMercatorUtils = TransverseMercatorUtils;\nTransverseMercatorUtils.POLE_EDGE = 1.4844222297453323;\nTransverseMercatorUtils.POLE_EDGE_DEG = THREE.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);\nTransverseMercatorUtils.POLE_RADIUS = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;\nTransverseMercatorUtils.POLE_RADIUS_SQ = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);\n/**\n * Transverse Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexports.transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n//# sourceMappingURL=TransverseMercatorProjection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlatTileBoundingBoxGenerator = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given\n * TilingScheme.\n */\nclass FlatTileBoundingBoxGenerator {\n    /**\n     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given\n     * TilingScheme.\n     *\n     * @param tilingScheme - The {@link TilingScheme} used to compute bounding boxes.\n     * @param minElevation - The minimum elevation in meters.\n     * @param maxElevation - The maximum elevation in meters.\n     */\n    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {\n        this.tilingScheme = tilingScheme;\n        this.minElevation = minElevation;\n        this.maxElevation = maxElevation;\n        this.m_tilingScheme = tilingScheme;\n        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);\n        const { min, max } = this.m_worldBox;\n        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };\n    }\n    /**\n     * Returns the {@link Projection} of the {@link TilingScheme}.\n     */\n    get projection() {\n        return this.m_tilingScheme.projection;\n    }\n    /**\n     * Returns the {@link SubdivisionScheme} of the {@link TilingScheme}.\n     */\n    get subdivisionScheme() {\n        return this.m_tilingScheme.subdivisionScheme;\n    }\n    /**\n     * Returns the bounding box in world coordinates of the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const worldBounds = new THREE.Box3();\n     * generator.getWorldBox(geoBox, worldBounds);\n     * console.log(worldBounds.getCenter());\n     * ```\n     *\n     * @param tileKey - The TileKey.\n     * @param result - The optional object used to store the resulting bounding box in world\n     * coordinates.\n     */\n    getWorldBox(tileKey, result) {\n        const level = tileKey.level;\n        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);\n        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);\n        const sizeX = this.m_worldDimensions.x / levelDimensionX;\n        const sizeY = this.m_worldDimensions.y / levelDimensionY;\n        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;\n        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;\n        if (!result) {\n            result = new THREE.Box3();\n        }\n        result.min.x = originX;\n        result.min.y = originY;\n        result.min.z = this.m_worldBox.min.z;\n        result.max.x = originX + sizeX;\n        result.max.y = originY + sizeY;\n        result.max.z = this.m_worldBox.max.z;\n        return result;\n    }\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const geoBox = generator.getGeoBox(worldBounds);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tileKey - The {@link TileKey}.\n     */\n    getGeoBox(tileKey) {\n        const worldBox = this.getWorldBox(tileKey);\n        return this.projection.unprojectBox(worldBox);\n    }\n}\nexports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;\n//# sourceMappingURL=FlatTileBoundingBoxGenerator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.halfQuadTreeSubdivisionScheme = void 0;\nclass HalfQuadTreeSubdivisionScheme {\n    getSubdivisionX() {\n        return 2;\n    }\n    getSubdivisionY(level) {\n        return level === 0 ? 1 : 2;\n    }\n    getLevelDimensionX(level) {\n        return 1 << level;\n    }\n    getLevelDimensionY(level) {\n        return level !== 0 ? 1 << (level - 1) : 1;\n    }\n}\n/**\n * A {@link SubdivisionScheme} used to represent half quadtrees.\n * This particular subdivision scheme is\n * used by the HERE tiling scheme.\n */\nexports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();\n//# sourceMappingURL=HalfQuadTreeSubdivisionScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hereTilingScheme = void 0;\nconst EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js\");\nconst HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * {@link TilingScheme} used by most of the data published by HERE.\n *\n * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular\n * projection.\n */\nexports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);\n//# sourceMappingURL=HereTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mercatorTilingScheme = void 0;\nconst MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * The {@link TilingScheme} used by the HERE web tiles.\n *\n * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.\n */\nexports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);\n//# sourceMappingURL=MercatorTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.polarTilingScheme = void 0;\nconst TransverseMercatorProjection_1 = __webpack_require__(/*! ../projection/TransverseMercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and\n * transverse Mercator projection.\n */\nexports.polarTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, TransverseMercatorProjection_1.transverseMercatorProjection);\n//# sourceMappingURL=PolarTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuadTree = void 0;\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\n/**\n * A class used to represent a quadtree.\n */\nclass QuadTree {\n    /**\n     * Constructs a new `QuadTree` for the given {@link TilingScheme}.\n     *\n     * Example:\n     * ```typescript\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * const geoBox = quadTree.getGeoBox(tileKey);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tilingScheme - The TilingScheme used by this `QuadTree`.\n     */\n    constructor(tilingScheme) {\n        this.tilingScheme = tilingScheme;\n    }\n    /**\n     * Visits this `QuadTree` and invoke the given accept method\n     * with the current {@link TileKey} and\n     * its bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = new GeoCoordinates(latitude, longitude);\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * quadTree.visit((tileKey, geoBox) => {\n     *     if (geoBox.contains(geoPos)) {\n     *         console.log(\"tile\", tileKey, \"contains\", geoPos);\n     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.\n     *     }\n     *     return false; // stop visiting the quadtree,\n     *                   // the tile's geoBox doesn't contain the given coordinates.\n     * });\n     * ```\n     *\n     * @param accept - A function that takes a {@link TileKey}\n     * and its bounding box in geo coordinates\n     * and returns `true` if the visit of the `QuadTree`\n     * should continue; otherwise `false`.\n     */\n    visit(accept) {\n        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);\n    }\n    /**\n     * Visits the subtree starting from the given tile.\n     *\n     * @param tileKey - The root of the subtree that should be visited.\n     * @param accept - A function that takes a {@link TileKey}\n     *                 and its bounding box in geo coordinates\n     *                 and returns `true` if the visit of the\n     *                 `QuadTree` should continue; otherwise `false`.\n     */\n    visitTileKey(tileKey, accept) {\n        const geoBox = this.tilingScheme.getGeoBox(tileKey);\n        if (!accept(tileKey, geoBox)) {\n            return;\n        }\n        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {\n            this.visitTileKey(subTileKey, accept);\n        }\n    }\n}\nexports.QuadTree = QuadTree;\n//# sourceMappingURL=QuadTree.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.quadTreeSubdivisionScheme = void 0;\nclass QuadTreeSubdivisionScheme {\n    getSubdivisionX() {\n        return 2;\n    }\n    getSubdivisionY() {\n        return 2;\n    }\n    getLevelDimensionX(level) {\n        return 1 << level;\n    }\n    getLevelDimensionY(level) {\n        return 1 << level;\n    }\n}\n/**\n * {@link SubdivisionScheme} representing a quadtree.\n */\nexports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();\n//# sourceMappingURL=QuadTreeSubdivisionScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubTiles = void 0;\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\nclass SubTiles {\n    constructor(tileKey, sizeX, sizeY) {\n        this.tileKey = tileKey;\n        this.sizeX = sizeX;\n        this.sizeY = sizeY;\n    }\n    [Symbol.iterator]() {\n        return this.sizeX === 2 && this.sizeY === 2\n            ? SubTiles.ZCurveIterator(this.tileKey)\n            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);\n    }\n}\nexports.SubTiles = SubTiles;\n(function (SubTiles) {\n    function* RowColumnIterator(parentKey, sizeX, sizeY) {\n        for (let y = 0; y < sizeY; y++) {\n            for (let x = 0; x < sizeX; x++) {\n                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);\n            }\n        }\n    }\n    SubTiles.RowColumnIterator = RowColumnIterator;\n    function* ZCurveIterator(parentKey) {\n        for (let i = 0; i < 4; i++) {\n            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);\n        }\n    }\n    SubTiles.ZCurveIterator = ZCurveIterator;\n})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));\n//# sourceMappingURL=SubTiles.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SubdivisionScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileKey = void 0;\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.\n];\n/**\n * The `TileKey` instances are used to address a tile in a quadtree.\n *\n * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one\n * single tile. On every level, each tile is divided into four children (therefore the name\n * quadtree).\n *\n * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number\n * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only\n * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles\n * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.\n *\n * A tile key is usually created using [[fromRowColumnLevel]]() method.\n *\n * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not\n * modify the original object.\n *\n * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for\n * easy vertical navigation of the tree. The number of available rows and columns in the tile's\n * level is given with [[rowCount]]() and [[columnCount]]().\n *\n * Tile keys can be created from and converted into various alternative formats:\n *\n *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based\n *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based\n *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation\n *\n * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be\n * represented in the number representation returned by [[mortonCode]]().\n */\nclass TileKey {\n    /**\n     * Constructs a new immutable instance of a `TileKey`.\n     *\n     * For the better readability, {@link TileKey.fromRowColumnLevel} should be preferred.\n     *\n     * Note - row and column must not be greater than the maximum rows/columns for the given level.\n     *\n     * @param row - Represents the row in the quadtree.\n     * @param column - Represents the column in the quadtree.\n     * @param level - Represents the level in the quadtree.\n     */\n    constructor(row, column, level) {\n        this.row = row;\n        this.column = column;\n        this.level = level;\n    }\n    /**\n     * Creates a tile key.\n     *\n     * @param row - The requested row. Must be less than 2 to the power of level.\n     * @param column - The requested column. Must be less than 2 to the power of level.\n     * @param level - The requested level.\n     */\n    static fromRowColumnLevel(row, column, level) {\n        return new TileKey(row, column, level);\n    }\n    /**\n     * Creates a tile key from a quad string.\n     *\n     * The quad string can be created with [[toQuadKey]].\n     *\n     * @param quadkey - The quadkey to convert.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromQuadKey(quadkey) {\n        const level = quadkey.length;\n        let row = 0;\n        let column = 0;\n        for (let i = 0; i < quadkey.length; ++i) {\n            const mask = 1 << i;\n            const d = parseInt(quadkey.charAt(level - i - 1), 10);\n            if (d & 0x1) {\n                column |= mask;\n            }\n            if (d & 0x2) {\n                row |= mask;\n            }\n        }\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Creates a tile key from a numeric Morton code representation.\n     *\n     * You can convert a tile key into a numeric Morton code with [[mortonCode]].\n     *\n     * @param quadKey64 - The Morton code to be converted.\n     * @returns A new instance of {@link TileKey}.\n     */\n    static fromMortonCode(quadKey64) {\n        let level = 0;\n        let row = 0;\n        let column = 0;\n        let quadKey = quadKey64;\n        while (quadKey > 1) {\n            const mask = 1 << level;\n            if (quadKey & 0x1) {\n                column |= mask;\n            }\n            if (quadKey & 0x2) {\n                row |= mask;\n            }\n            level++;\n            quadKey = (quadKey - (quadKey & 0x3)) / 4;\n        }\n        const result = TileKey.fromRowColumnLevel(row, column, level);\n        result.m_mortonCode = quadKey64;\n        return result;\n    }\n    /**\n     * Creates a tile key from a heretile code string.\n     *\n     * The string can be created with [[toHereTile]].\n     *\n     * @param quadkey64 - The string representation of the HERE tile key.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromHereTile(quadkey64) {\n        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));\n        result.m_hereTile = quadkey64;\n        return result;\n    }\n    /**\n     * Returns the number of available columns at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of columns.\n     * @returns The available columns at the given level.\n     */\n    static columnsAtLevel(level) {\n        return Math.pow(2, level);\n    }\n    /**\n     * Returns the number of available rows at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of rows.\n     * @returns The available rows at the given level.\n     */\n    static rowsAtLevel(level) {\n        return Math.pow(2, level);\n    }\n    /**\n     * Returns the closest matching `TileKey` in a cartesian coordinate system.\n     *\n     * @param level - The level for the tile key.\n     * @param coordX - The X coordinate.\n     * @param coordY - The Y coordinate.\n     * @param totalWidth - The maximum X coordinate.\n     * @param totalHeight - The maximum Y coordinate.\n     * @returns A new tile key at the given level that includes the given coordinates.\n     */\n    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {\n        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);\n    }\n    /**\n     * Computes the Morton code of the parent tile key of the given Morton code.\n     *\n     * Note: The parent key of the root key is the root key itself.\n     *\n     * @param mortonCode - A Morton code, for example, obtained from [[mortonCode]].\n     * @returns The Morton code of the parent tile.\n     */\n    static parentMortonCode(mortonCode) {\n        return Math.floor(mortonCode / 4);\n    }\n    /**\n     * Returns a tile key representing the parent of the tile addressed by this tile key.\n     *\n     * Throws an exception is this tile is already the root.\n     */\n    parent() {\n        if (this.level === 0) {\n            throw new Error(\"Cannot get the parent of the root tile key\");\n        }\n        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);\n    }\n    /**\n     * Returns a new tile key at a level that differs from this tile's level by delta.\n     *\n     * Equivalent to `changedLevelTo(level() + delta)`.\n     *\n     * Note - root key is returned if `delta` is smaller than the level of this tile key.\n     *\n     * @param delta - The numeric difference between the current level and the requested level.\n     */\n    changedLevelBy(delta) {\n        const level = Math.max(0, this.level + delta);\n        let row = this.row;\n        let column = this.column;\n        if (delta >= 0) {\n            row <<= delta;\n            column <<= delta;\n        }\n        else {\n            row >>>= -delta;\n            column >>>= -delta;\n        }\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Returns a new tile key at the requested level.\n     *\n     * If the requested level is smaller than the tile's level, then the key of an ancestor of this\n     * tile is returned. If the requested level is larger than the tile's level, then the key of\n     * first child or grandchild of this tile is returned, for example, the child with the lowest\n     * row and column number. If the requested level equals this tile's level, then the tile key\n     * itself is returned. If the requested level is negative, the root tile key is returned.\n     *\n     * @param level - The requested level.\n     */\n    changedLevelTo(level) {\n        return this.changedLevelBy(level - this.level);\n    }\n    /**\n     * Converts the tile key to a numeric code representation.\n     *\n     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].\n     *\n     * Note - only levels <= 26 are supported.\n     */\n    mortonCode() {\n        if (this.m_mortonCode === undefined) {\n            let column = this.column;\n            let row = this.row;\n            let result = powerOfTwo[this.level << 1];\n            for (let i = 0; i < this.level; ++i) {\n                if (column & 0x1) {\n                    result += powerOfTwo[2 * i];\n                }\n                if (row & 0x1) {\n                    result += powerOfTwo[2 * i + 1];\n                }\n                column >>>= 1;\n                row >>>= 1;\n            }\n            this.m_mortonCode = result;\n        }\n        return this.m_mortonCode;\n    }\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * The string is a quadkey Morton code representation as a string.\n     *\n     * You can convert back from a quadkey string with [[fromHereTile]].\n     */\n    toHereTile() {\n        if (this.m_hereTile === undefined) {\n            this.m_hereTile = this.mortonCode().toString();\n        }\n        return this.m_hereTile;\n    }\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the\n     * base of 4, but without the leading 1, with the following properties:\n     *  1. the number of digits equals the level.\n     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3\n     *     to a quadkey string gives the tiles's children.\n     *\n     * You can convert back from a quadkey string with [[fromQuadKey]].\n     */\n    toQuadKey() {\n        let result = \"\";\n        for (let i = this.level; i > 0; --i) {\n            const mask = 1 << (i - 1);\n            const col = (this.column & mask) !== 0;\n            const row = (this.row & mask) !== 0;\n            if (col && row) {\n                result += \"3\";\n            }\n            else if (row) {\n                result += \"2\";\n            }\n            else if (col) {\n                result += \"1\";\n            }\n            else {\n                result += \"0\";\n            }\n        }\n        return result;\n    }\n    /**\n     * Equality operator.\n     *\n     * @param qnr - The tile key to compare to.\n     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.\n     */\n    equals(qnr) {\n        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;\n    }\n    /**\n     * Returns the absolute quadkey that is constructed from its sub quadkey.\n     *\n     * @param sub - The sub key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubKey(sub) {\n        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? \"-\" : sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);\n    }\n    /**\n     * Returns the absolute quadkey that is constructed from its sub HERE tile key.\n     *\n     * @param sub - The sub HERE key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubHereTile(sub) {\n        const subQuad = TileKey.fromHereTile(sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);\n    }\n    /**\n     * Returns a sub quadkey that is relative to its parent.\n     *\n     * This function can be used to generate sub keys that are relative to a parent that is delta\n     * levels up in the quadtree.\n     *\n     * This function can be used to create shortened keys for quads on lower levels if the parent is\n     * known.\n     *\n     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If\n     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.\n     *\n     * Deltas larger than 16 are not supported.\n     *\n     * @param delta - The number of levels relative to its parent quadkey. Must be greater or equal\n     * to 0 and smaller than 16.\n     * @returns The quadkey relative to its parent that is `delta` levels up the tree.\n     */\n    getSubHereTile(delta) {\n        const key = this.mortonCode();\n        const msb = 1 << (delta * 2);\n        const mask = msb - 1;\n        const result = (key & mask) | msb;\n        return result.toString();\n    }\n    /**\n     * Returns the number of available rows in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    rowCount() {\n        return TileKey.rowsAtLevel(this.level);\n    }\n    /**\n     * Returns the number of available columns in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    columnCount() {\n        return TileKey.columnsAtLevel(this.level);\n    }\n}\nexports.TileKey = TileKey;\n//# sourceMappingURL=TileKey.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileKeyUtils = void 0;\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\nclass TileKeyUtils {\n    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {\n        const projection = tilingScheme.projection;\n        const worldPoint = projection.projectPoint(geoPoint);\n        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);\n    }\n    static worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {\n        const projection = tilingScheme.projection;\n        const subdivisionScheme = tilingScheme.subdivisionScheme;\n        const cx = subdivisionScheme.getLevelDimensionX(level);\n        const cy = subdivisionScheme.getLevelDimensionY(level);\n        const { min, max } = projection.worldExtent(0, 0);\n        const worldSizeX = max.x - min.x;\n        const worldSizeY = max.y - min.y;\n        if (worldPoint.x < min.x || worldPoint.x > max.x) {\n            return null;\n        }\n        if (worldPoint.y < min.y || worldPoint.y > max.y) {\n            return null;\n        }\n        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));\n        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));\n        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);\n    }\n    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {\n        const wrap = (value, lower, upper) => {\n            if (value < lower) {\n                return upper - ((lower - value) % (upper - lower));\n            }\n            return lower + ((value - lower) % (upper - lower));\n        };\n        const clamp = (x, minVal, maxVal) => {\n            return Math.min(Math.max(x, minVal), maxVal);\n        };\n        // Clamp at the poles and wrap around the international date line.\n        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);\n        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);\n        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);\n        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);\n        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);\n        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);\n        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);\n        if (!minTileKey || !maxTileKey) {\n            throw new Error(\"Invalid coordinates\");\n        }\n        const minColumn = minTileKey.column;\n        let maxColumn = maxTileKey.column;\n        // wrap around case\n        if (southWestLongitude > northEastLongitude) {\n            if (maxColumn !== minColumn) {\n                maxColumn += columnCount;\n            }\n            else {\n                // do not duplicate\n                maxColumn += columnCount - 1;\n            }\n        }\n        const minRow = Math.min(minTileKey.row, maxTileKey.row);\n        const maxRow = Math.max(minTileKey.row, maxTileKey.row);\n        const keys = new Array();\n        for (let row = minRow; row <= maxRow; ++row) {\n            for (let column = minColumn; column <= maxColumn; ++column) {\n                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));\n            }\n        }\n        return keys;\n    }\n}\nexports.TileKeyUtils = TileKeyUtils;\n//# sourceMappingURL=TileKeyUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileTreeTraverse = void 0;\nconst SubTiles_1 = __webpack_require__(/*! ./SubTiles */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js\");\nclass TileTreeTraverse {\n    constructor(subdivisionScheme) {\n        this.m_subdivisionScheme = subdivisionScheme;\n    }\n    subTiles(tileKey) {\n        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);\n        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);\n        return new SubTiles_1.SubTiles(tileKey, divX, divY);\n    }\n}\nexports.TileTreeTraverse = TileTreeTraverse;\n//# sourceMappingURL=TileTreeTraverse.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TilingScheme = void 0;\nconst FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ \"./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js\");\nconst TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js\");\nconst TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js\");\n/**\n * The `TilingScheme` represents how the data is tiled.\n */\nclass TilingScheme {\n    /**\n     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.\n     *\n     * @param subdivisionScheme - The subdivision scheme used by this `TilingScheme`.\n     * @param projection - The projection used by this `TilingScheme`.\n     */\n    constructor(subdivisionScheme, projection) {\n        this.subdivisionScheme = subdivisionScheme;\n        this.projection = projection;\n        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);\n        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);\n    }\n    /**\n     * Returns the sub tile keys of the given tile.\n     *\n     * @param tileKey - The {@link TileKey}.\n     * @returns The list of the sub tile keys.\n     */\n    getSubTileKeys(tileKey) {\n        return this.tileTreeTraverse.subTiles(tileKey);\n    }\n    /**\n     * Gets the {@link TileKey} from the given geo position and level.\n     *\n     * @param geoPoint - The position in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKey(geoPoint, level) {\n        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);\n    }\n    /**\n     * Gets the list of {@link TileKey}s contained in the given {@link GeoBox}.\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKeys(geoBox, level) {\n        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);\n    }\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * @param tileKey - The `TileKey`.\n     */\n    getGeoBox(tileKey) {\n        return this.boundingBoxGenerator.getGeoBox(tileKey);\n    }\n    /**\n     * Returns the bounding box in world coordinates.\n     *\n     * @param tileKey - The `TileKey`.\n     * @param result - The optional object that will contain the resulting bounding box.\n     */\n    getWorldBox(tileKey, result) {\n        return this.boundingBoxGenerator.getWorldBox(tileKey, result);\n    }\n}\nexports.TilingScheme = TilingScheme;\n//# sourceMappingURL=TilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webMercatorTilingScheme = void 0;\nconst MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and web Mercator projection.\n */\nexports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);\n//# sourceMappingURL=WebMercatorTilingScheme.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/index.js":
/*!************************************************!*\
  !*** ./node_modules/@here/harp-lines/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/Lines */ \"./node_modules/@here/harp-lines/lib/Lines.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TriangulateLines */ \"./node_modules/@here/harp-lines/lib/TriangulateLines.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/HighPrecisionLines */ \"./node_modules/@here/harp-lines/lib/HighPrecisionLines.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/HighPrecisionUtils */ \"./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionLines.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HighPrecisionLine = exports.HighPrecisionWireFrameLine = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ \"./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js\");\n/**\n * Class used to render high-precision wireframe lines.\n */\nclass HighPrecisionWireFrameLine extends THREE.Line {\n    /**\n     * Creates a `HighPrecisionWireFrameLine` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     * @param positions - Array of 2D/3D positions.\n     */\n    constructor(geometry, material, positions) {\n        super(geometry, material);\n        this.matrixWorldInverse = new THREE.Matrix4();\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n    get bufferGeometry() {\n        return this.geometry;\n    }\n    get shaderMaterial() {\n        return this.material;\n    }\n    setPositions(positions) {\n        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);\n    }\n    setupForRendering() {\n        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n    updateMatrixWorld(force) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n        super.updateMatrixWorld(force);\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.copy(this.matrixWorld).invert();\n        }\n    }\n}\nexports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;\n/**\n * Class used to render high-precision lines.\n */\nclass HighPrecisionLine extends THREE.Mesh {\n    /**\n     * Creates a `HighPrecisionLine` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     * @param positions - Array of 2D/3D positions.\n     */\n    constructor(geometry, material, positions) {\n        super(geometry, material);\n        this.matrixWorldInverse = new THREE.Matrix4();\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n    get bufferGeometry() {\n        return this.geometry;\n    }\n    get shaderMaterial() {\n        return this.material;\n    }\n    setPositions(positions) {\n        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);\n    }\n    setupForRendering() {\n        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n    updateMatrixWorld(force) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n        super.updateMatrixWorld(force);\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.copy(this.matrixWorld).invert();\n        }\n    }\n}\nexports.HighPrecisionLine = HighPrecisionLine;\n//# sourceMappingURL=HighPrecisionLines.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/HighPrecisionLines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HighPrecisionPoints = void 0;\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ \"./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js\");\n/**\n * Class used to render high-precision points.\n */\nclass HighPrecisionPoints extends THREE.Points {\n    /**\n     * Creates a `HighPrecisionPoints` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions - Array of 2D/3D positions.\n     * @param color - Color of the rendered point.\n     * @param opacity - Opacity of the rendered point.\n     */\n    constructor(geometry, material, positions, color, opacity) {\n        if (material === undefined) {\n            material = new harp_materials_1.HighPrecisionPointMaterial({\n                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : 1\n            });\n        }\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n        this.matrixWorldInverse = new THREE.Matrix4();\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n    get bufferGeometry() {\n        return this.geometry;\n    }\n    /**\n     * Clears the [[BufferGeometry]] used to render this point.\n     */\n    clearGeometry() {\n        return (this.geometry = new THREE.BufferGeometry());\n    }\n    get shaderMaterial() {\n        return this.material;\n    }\n    setPositions(positions) {\n        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);\n    }\n    setupForRendering() {\n        if (this.material.isHighPrecisionPointsMaterial &&\n            this.dimensionality !== undefined) {\n            this.material.setDimensionality(this.dimensionality);\n        }\n        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n    updateMatrixWorld(force) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n        super.updateMatrixWorld(force);\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.copy(this.matrixWorld).invert();\n        }\n    }\n}\nexports.HighPrecisionPoints = HighPrecisionPoints;\n//# sourceMappingURL=HighPrecisionPoints.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HighPrecisionUtils = void 0;\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst HPL = __webpack_require__(/*! ./HighPrecisionLines */ \"./node_modules/@here/harp-lines/lib/HighPrecisionLines.js\");\nconst HPP = __webpack_require__(/*! ./HighPrecisionPoints */ \"./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js\");\nconst TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ \"./node_modules/@here/harp-lines/lib/TriangulateLines.js\");\nvar HighPrecisionUtils;\n(function (HighPrecisionUtils) {\n    /**\n     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.\n     * precision.\n     *\n     * @param v -\n     */\n    function doubleToFloatVec(v) {\n        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));\n    }\n    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;\n    /**\n     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the\n     * difference of the double elements and their float counterparts.\n     *\n     * @param v - Vector3 to convert to float IN-PLACE!\n     */\n    function makeFloatVec(v) {\n        const majorX = Math.fround(v.x);\n        const majorY = Math.fround(v.y);\n        const majorZ = Math.fround(v.z);\n        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);\n        v.x = Math.fround(majorX);\n        v.y = Math.fround(majorY);\n        v.z = Math.fround(majorZ);\n        return minorVec;\n    }\n    HighPrecisionUtils.makeFloatVec = makeFloatVec;\n    /**\n     * Calculate high-precision camera position used in vertex shader of high-precision materials.\n     *\n     * @param camera - Camera used to get the high-precision position.\n     * @param objectInverseWorldMatrix - Inverse World Matrix of the rendered\n     *                                   [[HighPrecisionObject]].\n     */\n    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {\n        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);\n        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);\n        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);\n        // split the double float vector into hi and lo parts\n        const eyePosFloat = doubleToFloatVec(eyePos);\n        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));\n        return {\n            viewProjection: mvp,\n            eyePosHi: eyePosFloat,\n            eyePosLo\n        };\n    }\n    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;\n    /**\n     * Updates the high-precision uniform data of a material used to render a\n     * [[HighPrecisionObject]].\n     *\n     * @param object - [[HighPrecisionObject]] used for rendering.\n     * @param camera - Camera used to get the high-precision position.\n     * @param shaderMaterial - Material which uniforms will be updated.\n     */\n    function updateHpUniforms(object, camera, shaderMaterial) {\n        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);\n        const mvp = highPrecisionCameraInfo.viewProjection;\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_mvp &&\n                shaderMaterial.uniforms.u_eyepos &&\n                shaderMaterial.uniforms.u_eyepos_lowpart) {\n                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);\n                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());\n                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());\n            }\n            else {\n                throw Error(\"High pecision material has missing uniforms\");\n            }\n        }\n        else {\n            throw Error(\"High pecision line has no high precision material\");\n        }\n    }\n    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;\n    /**\n     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].\n     *\n     * @param positions - Array of positions.\n     */\n    function createAttributes(positions) {\n        if (positions.length > 0) {\n            const v = positions[0];\n            if (v === undefined || v === null) {\n                throw Error(\"Empty element in positions\");\n            }\n            const positionVec = new Array();\n            const positionVecLow = new Array();\n            const addHPValue = (...values) => {\n                for (const value of values) {\n                    const major = Math.fround(value);\n                    positionVecLow.push(value - major);\n                    positionVec.push(major);\n                }\n            };\n            const addHPVector = (vec) => {\n                addHPValue(vec.x, vec.y, vec.z);\n            };\n            const vAny = v;\n            if (vAny.z !== undefined) {\n                positions.forEach(vec => {\n                    addHPVector(vec);\n                });\n            }\n            else {\n                if (positionVec.length % 3 !== 0) {\n                    throw Error(\"Positions must be 3D, not 2D\");\n                }\n                positions.forEach((n) => {\n                    addHPValue(n);\n                });\n            }\n            return {\n                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),\n                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)\n            };\n        }\n        else {\n            return {\n                positionHigh: new three_1.Float32BufferAttribute([], 3),\n                positionLow: new three_1.Float32BufferAttribute([], 3)\n            };\n        }\n    }\n    HighPrecisionUtils.createAttributes = createAttributes;\n    /**\n     * Assembles an interleaved buffer containing the position attribute data for a\n     * [[HighPrecisionObject]].\n     *\n     * @param positions - Array of positions.\n     * @param stride - Stride of the elements in the `positions` array.\n     * @param positionOffset - Offset into the `positions` array.\n     */\n    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {\n        const newPositions = new Array();\n        const end = positions.length;\n        for (let i = 0; i < end; i += stride) {\n            for (let j = 0; j < positionOffset; j++) {\n                newPositions.push(positions[i + j]);\n            }\n            const x = positions[i + positionOffset];\n            const y = positions[i + positionOffset + 1];\n            const z = positions[i + positionOffset + 2];\n            const majorX = Math.fround(x);\n            const minorX = x - majorX;\n            const majorY = Math.fround(y);\n            const minorY = y - majorY;\n            const majorZ = Math.fround(z);\n            const minorZ = z - majorZ;\n            // insert values in interleaved buffer\n            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);\n            for (let j = positionOffset + 3; j < stride; j++) {\n                newPositions.push(positions[i + j]);\n            }\n        }\n        return newPositions;\n    }\n    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;\n    /**\n     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].\n     *\n     * @param object - [[HighPrecisionObject]] which position attribute will be set.\n     * @param positions - Array of positions.\n     */\n    function setPositions(object, positions) {\n        const attributes = createAttributes(positions);\n        object.bufferGeometry.setAttribute(\"position\", attributes.positionHigh);\n        object.bufferGeometry.setAttribute(\"positionLow\", attributes.positionLow);\n        return attributes.positionHigh.itemSize;\n    }\n    HighPrecisionUtils.setPositions = setPositions;\n    /**\n     * Convert positions from `Array<Vector3>` to `Array<number>`.\n     *\n     * @param positions - Array of positions.\n     */\n    function convertPositions(positions) {\n        if (positions.length <= 0) {\n            return { positions: [] };\n        }\n        const v = positions[0];\n        if (v === undefined || v === null) {\n            throw Error(\"Empty element in positions\");\n        }\n        const vAny = v;\n        if (vAny.y === undefined && vAny.z === undefined) {\n            return { positions: positions };\n        }\n        const returnPositions = new Array();\n        positions.forEach(vec => {\n            returnPositions.push(vec.x, vec.y, vec.z);\n        });\n        return { positions: returnPositions };\n    }\n    HighPrecisionUtils.convertPositions = convertPositions;\n    /**\n     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.\n     *\n     * @param linePositions - Array of 2D/3D positions.\n     * @param params - Parameters used to configure the created [[HighPrecisionObject]].\n     */\n    function createLine(linePositions, params) {\n        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;\n        const addCircles = params.addCircles !== undefined ? params.addCircles : false;\n        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;\n        const positions = [];\n        const indices = [];\n        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);\n        const hpLineGeometry = new three_1.BufferGeometry();\n        const hpPositions = addInterleavedAttributes3(positions, 3);\n        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);\n        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);\n        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);\n        hpLineGeometry.setAttribute(\"position\", positionAttribute);\n        hpLineGeometry.setAttribute(\"positionLow\", positionLowAttribute);\n        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));\n        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);\n        const lineObject = wireFrame\n            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)\n            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);\n        lineObject.setupForRendering();\n        return lineObject;\n    }\n    HighPrecisionUtils.createLine = createLine;\n    /**\n     * Creates a group of [[HighPrecisionPoints]].\n     *\n     * @param pointPositions - Array of 2D/3D positions.\n     * @param materialParameters - Parameters used to configure the material used to render the\n     * created [[HighPrecisionPoints]].\n     */\n    function createPoints(pointPositions, materialParameters) {\n        const indices = [];\n        for (let i = 0; i < pointPositions.length; i++) {\n            indices.push(indices.length / 3);\n        }\n        const hpPointsGeometry = new three_1.BufferGeometry();\n        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)\n            ? materialParameters\n            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);\n        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);\n        setPositions(pointsObject, pointPositions);\n        pointsObject.setupForRendering();\n        return pointsObject;\n    }\n    HighPrecisionUtils.createPoints = createPoints;\n})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));\n//# sourceMappingURL=HighPrecisionUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/Lines.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/Lines.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LineGroup = exports.createSimpleLineGeometry = exports.createLineGeometry = exports.LineGeometry = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n// Preallocate temp variables used during line generation.\nconst tmpV = new THREE.Vector3();\nconst tmpNormal = new THREE.Vector3();\nconst tmpTangent0 = new THREE.Vector3();\nconst tmpTangent1 = new THREE.Vector3();\nconst tmpBitangent = new THREE.Vector3();\nconst SEGMENT_OFFSET = 0.1;\n/**\n * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].\n */\n/** Base line vertex attributes. */\nconst LINE_VERTEX_ATTRIBUTES = {\n    attributes: [\n        // The \"extrusionCoord\" is a vec4 which represents:\n        // xy: Extrusion coordinates\n        // sign(xy): Extrusion direction\n        // z: Line length\n        { name: \"extrusionCoord\", itemSize: 3, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 3 },\n        { name: \"tangent\", itemSize: 3, offset: 6 },\n        { name: \"bitangent\", itemSize: 4, offset: 9 }\n    ],\n    stride: 13\n};\n/** Optional normal and uv coordinates. */\nconst NORMAL_UV_VERTEX_ATTRIBUTES = {\n    attributes: [\n        { name: \"uv\", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },\n        { name: \"normal\", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }\n    ],\n    stride: 5\n};\n/** Base line vertex attributes plus normals and uv coordinates. */\nconst LINE_VERTEX_ATTRIBUTES_NUV = {\n    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],\n    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n/**\n * Declares all the vertex attributes used for rendering a line using the\n * [[HighPrecisionLineMaterial]].\n */\nconst HP_LINE_VERTEX_ATTRIBUTES = {\n    attributes: [\n        { name: \"extrusionCoord\", itemSize: 2, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 2 },\n        { name: \"positionLow\", itemSize: 3, offset: 5 },\n        { name: \"tangent\", itemSize: 3, offset: 8 },\n        { name: \"bitangent\", itemSize: 4, offset: 11 }\n    ],\n    stride: 15\n};\n/** High precision line vertex attributes plus normals and uv coordinates. */\nconst HP_LINE_VERTEX_ATTRIBUTES_NUV = {\n    attributes: [\n        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,\n        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes\n    ],\n    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n/**\n * Class that holds the vertex and index attributes for a [[Lines]] object.\n */\nclass LineGeometry {\n    constructor() {\n        this.vertices = [];\n        this.vertexColors = [];\n        this.indices = [];\n    }\n}\nexports.LineGeometry = LineGeometry;\nfunction getVertexDescriptor(hasNormalsAndUvs, highPrecision) {\n    if (highPrecision) {\n        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;\n    }\n    else {\n        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;\n    }\n}\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param center - Center of the polyline.\n * @param polyline - Array of `numbers` describing a polyline.\n * @param offsets - Array of `numbers` representing line segment offsets.\n * @param uvs - Array of `numbers` representing texture coordinates.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n * @param highPrecision - If `true` will create high-precision vertex information.\n */\nfunction createLineGeometry(center, polyline, projection, offsets, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;\n    const pointCount = polyline.length / 3;\n    const segments = new Array(pointCount);\n    const tangents = new Array(polyline.length - 3);\n    const baseVertex = geometry.vertices.length / stride;\n    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;\n    const hasTexCoords = uvs !== undefined && uvs.length > 0;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n    harp_utils_1.assert(!hasSegmentOffsets || offsets.length === pointCount);\n    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);\n    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);\n    // Compute segments and tangents.\n    let sum = SEGMENT_OFFSET;\n    segments[0] = sum;\n    for (let i = 0; i < pointCount - 1; ++i) {\n        let sqrLength = 0;\n        for (let j = 0; j < 3; ++j) {\n            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];\n            tangents[i * 3 + j] = d;\n            sqrLength += d * d;\n        }\n        const len = Math.sqrt(sqrLength);\n        sum = sum + len;\n        segments[i + 1] = sum;\n    }\n    const lineCoverage = hasSegmentOffsets\n        ? Math.abs(offsets[offsets.length - 1] - offsets[0])\n        : 1.0;\n    const lineLength = segments[segments.length - 1] / lineCoverage;\n    // Override the segments if offsets are explicitly provided.\n    if (hasSegmentOffsets) {\n        for (let i = 0; i < pointCount; ++i) {\n            segments[i] = offsets[i] * lineLength + SEGMENT_OFFSET;\n        }\n    }\n    // Check if we're working with a closed line.\n    let isClosed = true;\n    for (let j = 0; j < 3; ++j) {\n        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];\n    }\n    const tmpVertices = [];\n    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {\n        tmpVertices.length = 0;\n        // Store the segment and extrusionCoord attributes.\n        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);\n        tmpVertices.push(segment, extrusionCoord * 1, lineLength);\n        // Store the position attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            if (!highPrecision) {\n                geometry.vertices.push(polyline[i * 3 + j]);\n                tmpVertices.push(polyline[i * 3 + j]);\n            }\n            else {\n                const highComp = Math.fround(polyline[i * 3 + j]);\n                const lowComp = polyline[i * 3 + j] - highComp;\n                geometry.vertices.push(highComp, lowComp);\n                tmpVertices.push(highComp, lowComp);\n            }\n            tmpNormal.setComponent(j, polyline[i * 3 + j]);\n        }\n        // Store the bitangent attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            tmpTangent0.setComponent(j, tangents[T1 + j]);\n            tmpTangent1.setComponent(j, tangents[T2 + j]);\n        }\n        tmpTangent0.normalize();\n        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpNormal.add(center); // tmpNormal contains world position\n        projection.surfaceNormal(tmpNormal, tmpNormal);\n        const angle = computeBitangent(tmpNormal, tmpTangent0, tmpTangent1.normalize(), tmpBitangent);\n        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        if (hasTexCoords) {\n            // uvs\n            geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);\n            tmpVertices.push(uvs[i * 2], uvs[i * 2 + 1]);\n            // normals\n            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n        }\n        geometry.vertices.push(...tmpVertices);\n        // Add vertex colors (if supplied).\n        if (vertexColors) {\n            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);\n            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);\n        }\n    };\n    for (let i = 0; i < pointCount; ++i) {\n        // Retrieve the per-point tangents.\n        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;\n        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);\n        // Process v0 and v1.\n        if (i > 0) {\n            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);\n        }\n        // Process v2 and v3.\n        if (i + 1 < pointCount) {\n            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);\n        }\n    }\n    // Store the triangle indices in the final index buffer.\n    for (let i = 0; i < pointCount - 1; ++i) {\n        const base = baseVertex + i * 4;\n        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);\n    }\n    return geometry;\n}\nexports.createLineGeometry = createLineGeometry;\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param polyline - Array of `numbers` describing a polyline.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n */\nfunction createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n    const pointCount = polyline.length / 3;\n    let index = geometry.vertices.length / 3;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n    for (let i = 0; i < pointCount; ++i, index++) {\n        if (i > 0) {\n            geometry.indices.push(index);\n        }\n        if (i < pointCount - 1) {\n            geometry.indices.push(index);\n        }\n        for (let j = 0; j < 3; ++j) {\n            geometry.vertices.push(polyline[i * 3 + j]);\n            if (vertexColors) {\n                geometry.vertexColors.push(colors[i * 3 + j]);\n            }\n        }\n    }\n    return geometry;\n}\nexports.createSimpleLineGeometry = createSimpleLineGeometry;\n/**\n * Class used to render groups (or batches) of width-variable lines (in the same tile).\n */\nclass LineGroup {\n    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {\n        this.hasNormalsAndUvs = hasNormalsAndUvs;\n        this.highPrecision = highPrecision;\n        this.isSimple = isSimple;\n        this.m_geometry = new LineGeometry();\n    }\n    /**\n     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.\n     *\n     * @param vertices - Array of vertex attributes.\n     * @param colors - Array of vertex colors.\n     * @param indices - Array of vertex indices.\n     * @param geometry - [[BufferGeometry]] object which will store all the `Lines` attribute data.\n     * @param hasNormalsAnUvs - Whether vertices have normal and uv coordinates as attributes.\n     * @param highPrecision - If `true` will create high-precision vertex information.\n     * @param isSimple - `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.\n     */\n    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {\n        if (isSimple) {\n            geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(vertices), 3));\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\"color\", new THREE.BufferAttribute(new Float32Array(colors), 3));\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        }\n        else {\n            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);\n            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);\n            vertexDescriptor.attributes.forEach(descr => {\n                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);\n                geometry.setAttribute(descr.name, attribute);\n            });\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\"color\", new THREE.BufferAttribute(new Float32Array(colors), 3));\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        }\n    }\n    /**\n     * Clears the list of line strips.\n     */\n    clear() {\n        this.m_geometry.vertices = [];\n        this.m_geometry.vertexColors = [];\n        this.m_geometry.indices = [];\n    }\n    /**\n     * Add the given points to this line group.\n     *\n     * @param center - World center of the provided points.\n     * @param points - Sequence of (x,y,z) coordinates.\n     * @param offsets - Sequence of line segment offsets.\n     * @param uvs - Sequence of (u,v) texture coordinates.\n     * @param colors - Sequence of (r,g,b) color components.\n     */\n    add(center, points, projection, offsets, uvs, colors) {\n        if (!this.isSimple) {\n            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);\n            createLineGeometry(center, points, projection, offsets, uvs, colors, this.m_geometry, this.highPrecision);\n        }\n        else {\n            createSimpleLineGeometry(points, colors, this.m_geometry);\n        }\n        return this;\n    }\n    /**\n     * Returns the list of vertices.\n     */\n    get vertices() {\n        return this.m_geometry.vertices;\n    }\n    /**\n     * Returns the list of vertex colors.\n     */\n    get vertexColors() {\n        return this.m_geometry.vertexColors;\n    }\n    /**\n     * Returns the list of indices.\n     */\n    get indices() {\n        return this.m_geometry.indices;\n    }\n    /**\n     * Returns the list of [[VertexAttributeDescriptor]]s.\n     */\n    get vertexAttributes() {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;\n    }\n    /**\n     * Returns the vertex attribute stride.\n     */\n    get stride() {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;\n    }\n    /**\n     * Creates a three.js geometry.\n     */\n    createGeometry(geometry) {\n        if (geometry === undefined) {\n            geometry = new THREE.BufferGeometry();\n        }\n        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);\n    }\n}\nexports.LineGroup = LineGroup;\nfunction computeBitangent(n, t0, t1, bt) {\n    let angle = 0;\n    if (!t0.equals(t1)) {\n        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));\n        if (Number.isNaN(angle)) {\n            angle = 0;\n        }\n    }\n    bt.copy(t0).add(t1).normalize().cross(n).normalize();\n    return angle;\n}\n//# sourceMappingURL=Lines.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/Lines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/TriangulateLines.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/TriangulateLines.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructLineWidth = exports.reconstructLine = exports.triangulateLine = exports.numCirclePoints = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UNIT_Z = new THREE.Vector3(0, 0, 1);\nconst POINTS = [0, 1, 2, 1, 3, 2];\nconst BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];\nconst SECTORS_IN_CIRCLE = 8;\nconst STEP = Math.PI / SECTORS_IN_CIRCLE;\n/**\n * Adds a half-circle geometry to original line\n *\n * @param x - The line end X (used as circle center X)\n * @param y - The line end Y (used as circle center Y)\n * @param lineAngle - The cap incline angle\n * @param radius - The cap (circle) radius\n * @param vertices - The input vertex buffer (cap vertices are added there)\n * @param indices - The input index buffer (cap indices are is added there)\n */\nfunction addCircle(x, y, lineAngle, radius, vertices, indices) {\n    const baseVertex = vertices.length / 3;\n    // Add cap center to vertices directly (it doesn't need rotation)\n    vertices.push(x, y, 0);\n    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {\n        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg\n        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);\n        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);\n    }\n}\n/**\n * Returns the number of points in circle used for caps.\n *\n * @param lineWidth - Width of line.\n */\nfunction numCirclePoints(lineWidth) {\n    return SECTORS_IN_CIRCLE + 1;\n}\nexports.numCirclePoints = numCirclePoints;\n/**\n * Create a triangle mesh from the given polyline.\n *\n * @param points - Sequence of (x,y,z) coordinates.\n * @param width - The width of the extruded line.\n * @param vertices - The output vertex buffer.\n * @param indices - The output index buffer.\n * @param startWithCircle - `true` if the line should start will a circle.\n * @param endWithCircle - `true` if the line should end with a circle.\n */\nfunction triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {\n    if (points.length < 3) {\n        return;\n    }\n    // This vector is used for computing cap angle\n    const angleVec = new THREE.Vector2();\n    if (startWithCircle) {\n        // Define lineAngle as (direction - origin) vector angle to X axis\n        const lineAngle = points.length !== 3\n            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()\n            : 0;\n        addCircle(points[0], points[1], lineAngle, width, vertices, indices);\n    }\n    const baseVertex = vertices.length / 3;\n    // bt = Bitangent (i.e. extrusion vector)\n    const prevBt = new THREE.Vector3();\n    const p = new THREE.Vector3(); // current point\n    const n = new THREE.Vector3(); // next point\n    const bt = new THREE.Vector3();\n    const averageBt = new THREE.Vector3();\n    const p0 = new THREE.Vector3();\n    const p1 = new THREE.Vector3();\n    const p2 = new THREE.Vector3();\n    const p3 = new THREE.Vector3();\n    const N = points.length / 3;\n    let vertexOffset = 0;\n    for (let i = 0; i < N; ++i) {\n        let useBevel = false;\n        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);\n        if (i + 1 < N) {\n            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);\n            bt.copy(n).sub(p).normalize().cross(UNIT_Z);\n            averageBt.copy(bt);\n            if (i > 0) {\n                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));\n                useBevel = prevBt.angleTo(bt) > Math.PI / 2;\n                if (useBevel) {\n                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);\n                    p0.copy(bt).add(prevBt).normalize().multiplyScalar(-inclineWidth).add(p);\n                    p1.copy(prevBt).multiplyScalar(width).add(p);\n                    // p2 is used for \"miter\" connections\n                    p2.copy(bt).add(prevBt).normalize().multiplyScalar(inclineWidth).add(p);\n                    p3.copy(bt).multiplyScalar(width).add(p);\n                }\n            }\n            if (useBevel) {\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);\n            }\n            else {\n                p0.copy(averageBt).multiplyScalar(-width).add(p);\n                p1.copy(averageBt).multiplyScalar(width).add(p);\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n            }\n            prevBt.copy(bt);\n        }\n        else {\n            p0.copy(prevBt).multiplyScalar(-width).add(p);\n            p1.copy(prevBt).multiplyScalar(width).add(p);\n            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n        }\n        if (i !== N - 1) {\n            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));\n            vertexOffset += useBevel ? 4 : 2;\n        }\n    }\n    if (endWithCircle) {\n        const lineAngle = points.length !== 2\n            ? angleVec\n                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])\n                .angle()\n            : Math.PI;\n        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);\n    }\n}\nexports.triangulateLine = triangulateLine;\n/**\n * Reconstruct the original points of a line from the vertices of the triangulated line.\n *\n * @param inBuffer - Buffer with vertices.\n * @param startOffset - Start index, will differ from `0` if the line has caps.\n * @returns Buffer containing the original points of the triangulated line.\n */\nfunction reconstructLine(inBuffer, startOffset) {\n    const outBuffer = new Float32Array(inBuffer.length / 2);\n    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {\n        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;\n        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;\n        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;\n    }\n    return outBuffer;\n}\nexports.reconstructLine = reconstructLine;\n/**\n * Extract the line width from a triangulated line.\n *\n * @param inBuffer - Array of vertex elements of a triangulated line.\n * @param startIndex - Start index, will differ from `0` if the line has caps.\n */\nfunction reconstructLineWidth(inBuffer, startIndex) {\n    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];\n    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];\n    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];\n    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;\n}\nexports.reconstructLineWidth = reconstructLineWidth;\n//# sourceMappingURL=TriangulateLines.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/TriangulateLines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lrucache/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * LRU cache.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/LRUCache */ \"./node_modules/@here/harp-lrucache/lib/LRUCache.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lrucache/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lrucache/lib/LRUCache.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/lib/LRUCache.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = exports.Entry = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/** @hidden */\nclass Entry {\n    constructor(key, value, size, newer, older) {\n        this.key = key;\n        this.value = value;\n        this.size = size;\n        this.newer = newer;\n        this.older = older;\n    }\n}\nexports.Entry = Entry;\n/**\n * Fixed size cache that evicts its entries in least-recently-used order when it overflows.\n * Modeled after standard JavaScript `Map` otherwise.\n */\nclass LRUCache {\n    /**\n     * Creates a new instance of `LRUCache`.\n     *\n     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached\n     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if\n     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum\n     * number of elements stored.\n     *\n     * @param cacheCapacity - Number used to configure the maximum cache size, may express\n     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].\n     * @param sizeFunction - A function determining the size per element.\n     */\n    constructor(cacheCapacity, sizeFunction = () => 1) {\n        this.m_size = 0;\n        /**\n         * The internal map object that keeps the key-value pairs and their order.\n         */\n        this.m_map = new Map();\n        /**\n         * The newest entry, i.e. the most recently used item.\n         */\n        this.m_newest = null;\n        /**\n         * The oldest entry, i.e. the least recently used item.\n         */\n        this.m_oldest = null;\n        this.m_capacity = cacheCapacity;\n        this.m_sizeFunction = sizeFunction;\n    }\n    /**\n     * Iterates over all items from the most recently used item to the least recently used one.\n     *\n     * **Note**: Results are undefined if the entire cache is modified during iteration. You may\n     * although modify the current element in [[callbackfn]] function.\n     *\n     * @param callbackfn - The callback to call for each item.\n     * @param thisArg - Optional this argument for the callback.\n     */\n    forEach(callbackfn, thisArg) {\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const older = entry.older;\n            callbackfn.call(thisArg, entry.value, entry.key, this);\n            entry = older;\n        }\n    }\n    /**\n     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.\n     *\n     * @returns The size of the cache.\n     */\n    get size() {\n        return this.m_size;\n    }\n    /**\n     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache\n     * can contain or the total amount of memory that may be consumed by cache if element size\n     * function was specified in cache c-tor.\n     *\n     * @returns The capacity of the cache.\n     */\n    get capacity() {\n        return this.m_capacity;\n    }\n    /**\n     * @deprecated - DO NOT USE. Will be removed in future versions.\n     *\n     * Returns the internal map object that keeps the key-value pairs and their order.\n     *\n     * @returns The internal map object.\n     */\n    get map() {\n        // ### TODO - remove me. Cache must not expose its internal object,\n        // modifications to it are fatal for the internal state machine.\n        return this.m_map;\n    }\n    /**\n     * Returns the newest entry in the cache.\n     *\n     * @returns Newest entry in the cache.\n     */\n    get newest() {\n        return this.m_newest;\n    }\n    /**\n     * Returns the oldest entry in the cache.\n     *\n     * Note: Does not promote the oldest item as most recently used item.\n     *\n     * @returns Oldest entry in the cache.\n     */\n    get oldest() {\n        return this.m_oldest;\n    }\n    /**\n     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,\n     * all items will be evicted until the cache shrinks to `newCapacity`.\n     *\n     * @param newCapacity - The new capacity of this cache.\n     */\n    setCapacity(newCapacity) {\n        this.m_capacity = newCapacity;\n        this.evict();\n    }\n    /**\n     * Resets the cache capacity and function used to measure the element size.\n     *\n     * @param newCapacity - The new capacity masured in units returned from [[sizeMeasure]] funtion.\n     * @param sizeMeasure - Function that defines the size of element, if you want to measure\n     * number of elements only always return 1 from this function (default), you may also\n     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.\n     */\n    setCapacityAndMeasure(newCapacity, sizeMeasure = () => 1) {\n        this.m_capacity = newCapacity;\n        this.m_sizeFunction = sizeMeasure;\n        this.shrinkToCapacity();\n    }\n    /**\n     * Updates the size of all elements in this cache. If their aggregated size is larger than the\n     * capacity, items will be evicted until the cache shrinks to fit the capacity.\n     */\n    shrinkToCapacity() {\n        let size = 0;\n        const sizeFunction = this.m_sizeFunction;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entrySize = sizeFunction(entry.value);\n            entry.size = entrySize;\n            size += entrySize;\n            entry = entry.older;\n        }\n        this.m_size = size;\n        this.evict();\n    }\n    /**\n     * Inserts or updates a key/value pair in the cache.\n     *\n     * If the key already existed in the cache, it will be updated and promoted to the most recently\n     * used item.\n     *\n     * If the key didn't exist in the cache, it will be inserted as most recently used item. An\n     * eviction of the least recently used item takes place if the cache exceeded its capacity.\n     *\n     * @param key - The key for the key-value pair to insert or update.\n     * @param value - The value for the key-value pair to insert or update.\n     */\n    set(key, value) {\n        const valueSize = this.m_sizeFunction(value);\n        let entry = this.m_map.get(key);\n        if (entry !== undefined) {\n            this.m_size = this.m_size - entry.size + valueSize;\n            entry.value = value;\n            entry.size = valueSize;\n            this.promoteEntry(entry);\n            this.evict();\n        }\n        else {\n            if (valueSize > this.m_capacity) {\n                return; // single item too big to cache\n            }\n            entry = new Entry(key, value, valueSize, null, null);\n            if (this.m_map.size === 0) {\n                this.m_newest = this.m_oldest = entry;\n            }\n            else {\n                harp_utils_1.assert(this.m_newest !== null);\n                const newest = this.m_newest;\n                entry.older = this.m_newest;\n                newest.newer = entry;\n                this.m_newest = entry;\n            }\n            this.m_map.set(key, entry);\n            this.m_size += valueSize;\n            this.evict();\n        }\n    }\n    /**\n     * Looks up key in the cache and returns the associated value.\n     *\n     * @param key - The key to look up.\n     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.\n     */\n    get(key) {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n        this.promoteEntry(entry);\n        return entry.value;\n    }\n    /**\n     * Test if a key/value pair is in the cache.\n     *\n     * @param key - The key to look up.\n     * @returns `true` if the key-value pair is in the cache, `false` otherwise.\n     */\n    has(key) {\n        return this.m_map.has(key);\n    }\n    /**\n     * Clears the cache and removes all stored key-value pairs.\n     *\n     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the\n     * eviction callback.\n     */\n    clear() {\n        this.m_newest = this.m_oldest = null;\n        this.m_size = 0;\n        this.m_map.clear();\n    }\n    /**\n     * Evicts all items from the cache, calling the eviction callback on each item.\n     *\n     * Use [[clear]] to remove all items without calling the eviction callback.\n     */\n    evictAll() {\n        const cb = this.evictionCallback;\n        if (cb !== undefined) {\n            this.forEach((value, key) => cb(key, value));\n        }\n        this.clear();\n    }\n    /**\n     * Evict selected elements from the cache using [[selector]] function.\n     *\n     * @param selector - The function for selecting elements for eviction.\n     * @param thisArg - Optional _this_ object reference.\n     */\n    evictSelected(selector, thisArg) {\n        const cb = this.evictionCallback;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entryOlder = entry.older;\n            if (selector.call(thisArg, entry.value, entry.key)) {\n                if (cb !== undefined) {\n                    cb(entry.key, entry.value);\n                }\n                this.deleteEntry(entry);\n                this.m_map.delete(entry.key);\n            }\n            entry = entryOlder;\n        }\n    }\n    /**\n     * Explicitly removes a key-value pair from the cache.\n     *\n     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.\n     *\n     * @param key - The key of the key-value pair to delete.\n     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.\n     */\n    delete(key) {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return false;\n        }\n        this.deleteEntry(entry);\n        return this.m_map.delete(key);\n    }\n    evict() {\n        while (this.m_oldest !== null && this.m_size > this.m_capacity) {\n            const evicted = this.evictOldest();\n            if (evicted === undefined) {\n                return;\n            }\n        }\n    }\n    evictOldest() {\n        harp_utils_1.assert(this.m_oldest !== null);\n        const oldest = this.m_oldest;\n        harp_utils_1.assert(oldest.older === null);\n        let itemToRemove = oldest;\n        if (this.canEvict !== undefined) {\n            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {\n                if (itemToRemove.newer === null) {\n                    return undefined;\n                }\n                itemToRemove = itemToRemove.newer;\n            }\n        }\n        if (itemToRemove === oldest) {\n            this.m_oldest = itemToRemove.newer;\n            if (itemToRemove.newer !== null) {\n                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = null;\n            }\n        }\n        else {\n            if (itemToRemove.newer !== null) {\n                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = itemToRemove.older;\n                if (itemToRemove.older !== null) {\n                    itemToRemove.older.newer = itemToRemove.newer;\n                }\n            }\n            else {\n                return undefined;\n            }\n        }\n        const isOk = this.m_map.delete(itemToRemove.key);\n        harp_utils_1.assert(isOk === true);\n        if (isOk && this.evictionCallback !== undefined) {\n            this.evictionCallback(itemToRemove.key, itemToRemove.value);\n        }\n        this.m_size -= itemToRemove.size;\n        return itemToRemove;\n    }\n    deleteEntry(entry) {\n        if (entry === this.m_newest) {\n            this.m_newest = entry.older;\n        }\n        else if (entry.newer) {\n            entry.newer.older = entry.older;\n        }\n        else {\n            harp_utils_1.assert(false);\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        else if (entry.older) {\n            entry.older.newer = entry.newer;\n        }\n        else {\n            harp_utils_1.assert(false);\n        }\n        this.m_size -= entry.size;\n    }\n    promoteEntry(entry) {\n        if (entry === this.m_newest) {\n            return;\n        } // already newest, nothing to do\n        // re-link newer and older items\n        if (entry.newer) {\n            harp_utils_1.assert(entry.newer.older === entry);\n            entry.newer.older = entry.older;\n        }\n        if (entry.older) {\n            harp_utils_1.assert(entry.older.newer === entry);\n            entry.older.newer = entry.newer;\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        // re-link ourselves\n        entry.newer = null;\n        entry.older = this.m_newest;\n        // finally, set ourselves as the newest entry\n        harp_utils_1.assert(this.m_newest !== null);\n        const newest = this.m_newest;\n        harp_utils_1.assert(newest.newer === null);\n        newest.newer = entry;\n        this.m_newest = entry;\n    }\n}\nexports.LRUCache = LRUCache;\n//# sourceMappingURL=LRUCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lrucache/lib/LRUCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Decoder worker for {@ref MapView}.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/DataProvider */ \"./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TileDataSource */ \"./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TileLoader */ \"./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataProvider = void 0;\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\n/**\n * Interface for all `DataProvider` subclasses.\n *\n * @remarks\n * The `DataProvider` is an abstraction of the tile\n * loader which is only responsible for loading the data of a specific tile,\n * without any relation to displaying or even decoding the data.\n */\nclass DataProvider extends three_1.EventDispatcher {\n    constructor() {\n        super(...arguments);\n        this.m_clients = new Set();\n    }\n    /**\n     * Registers a client to the data provider.\n     *\n     * @param client - The client to register.\n     * @returns Promise to wait for successful (or failed) connection to the data source.\n     */\n    register(client) {\n        if (this.m_clients.size === 0) {\n            this.m_connectPromise = this.connect();\n        }\n        this.m_clients.add(client);\n        return this.m_connectPromise;\n    }\n    /**\n     * Unregisters a client from the data provider.\n     *\n     * @param client - The client to unregister.\n     */\n    unregister(client) {\n        if (this.m_clients.delete(client) && this.m_clients.size === 0) {\n            this.dispose();\n        }\n    }\n}\nexports.DataProvider = DataProvider;\n//# sourceMappingURL=DataProvider.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileDataSource = exports.TileFactory = void 0;\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst ThemeLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/ThemeLoader */ \"./node_modules/@here/harp-mapview/lib/ThemeLoader.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TileLoader_1 = __webpack_require__(/*! ./TileLoader */ \"./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js\");\n/**\n * Templated factory class to create instances of [[Tile]].\n */\nclass TileFactory {\n    /**\n     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is\n     * created.\n     *\n     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].\n     */\n    constructor(m_modelConstructor) {\n        this.m_modelConstructor = m_modelConstructor;\n    }\n    /**\n     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments\n     * to the constructor of [[Tile]].\n     *\n     * @param dataSource - [[Datasource]] this class belongs to.\n     * @param tileKey - Quadtree address of the [[Tile]].\n     */\n    create(dataSource, tileKey) {\n        const tile = new this.m_modelConstructor(dataSource, tileKey);\n        tile.tileLoader = new TileLoader_1.TileLoader(dataSource, tileKey, dataSource.dataProvider(), dataSource.decoder);\n        return tile;\n    }\n}\nexports.TileFactory = TileFactory;\n/**\n * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the\n * tile content asynchronously. The decoder can be passed in as an option, or a default\n * asynchronous one is generated.\n */\nclass TileDataSource extends harp_mapview_1.DataSource {\n    /**\n     * Set up the `TileDataSource`.\n     *\n     * @param m_tileFactory - Factory to create the [[Tile]] instances.\n     * @param m_options - Options specifying the parameters of the [[DataSource]].\n     */\n    constructor(m_tileFactory, m_options) {\n        var _a, _b;\n        super(m_options);\n        this.m_tileFactory = m_tileFactory;\n        this.m_options = m_options;\n        this.logger = harp_utils_1.LoggerManager.instance.create(\"TileDataSource\");\n        this.m_isReady = false;\n        if (m_options.decoder) {\n            this.m_decoder = m_options.decoder;\n        }\n        else if (m_options.concurrentDecoderServiceName) {\n            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);\n        }\n        else {\n            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +\n                `concurrentDecoderServiceName`);\n        }\n        this.useGeometryLoader = true;\n        this.cacheable = true;\n        this.m_unregisterClearTileCache = (_b = (_a = this.dataProvider()).onDidInvalidate) === null || _b === void 0 ? void 0 : _b.call(_a, () => this.mapView.markTilesDirty(this));\n    }\n    /** @override */\n    dispose() {\n        var _a;\n        (_a = this.m_unregisterClearTileCache) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.decoder.dispose();\n        this.dataProvider().unregister(this);\n    }\n    /** @override */\n    ready() {\n        return this.m_isReady && this.m_options.dataProvider.ready();\n    }\n    /**\n     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with\n     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].\n     */\n    get decoder() {\n        return this.m_decoder;\n    }\n    /** @override */\n    async connect() {\n        await Promise.all([this.m_options.dataProvider.register(this), this.m_decoder.connect()]);\n        this.m_isReady = true;\n        let customOptions = {};\n        if (this.m_options.storageLevelOffset !== undefined) {\n            customOptions = {\n                storageLevelOffset: this.m_options.storageLevelOffset\n            };\n        }\n        this.m_decoder.configure({ languages: this.languages }, customOptions);\n    }\n    /**\n     * @override\n     */\n    setLanguages(languages) {\n        this.languages = languages;\n        this.m_decoder.configure({\n            languages: this.languages\n        });\n        this.mapView.clearTileCache(this.name);\n    }\n    /**\n     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.\n     *\n     * Applies new {@here/harp-datasource-protocol StyleSet} and definitions from theme only\n     * if matching styleset (see `styleSetName` property) is found in `theme`.\n     * @override\n     */\n    async setTheme(theme, languages) {\n        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.\n        theme = await ThemeLoader_1.ThemeLoader.load(theme);\n        let styleSet;\n        if (this.styleSetName !== undefined && theme.styles !== undefined) {\n            styleSet = theme.styles[this.styleSetName];\n        }\n        if (languages !== undefined) {\n            this.languages = languages;\n        }\n        if (styleSet !== undefined) {\n            this.m_decoder.configure({\n                styleSet,\n                definitions: theme.definitions,\n                priorities: theme.priorities,\n                labelPriorities: theme.labelPriorities,\n                languages\n            });\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n    /**\n     * Get the [[DataProvider]] that has been passed in with the options.\n     */\n    dataProvider() {\n        return this.m_options.dataProvider;\n    }\n    /** @override */\n    getTilingScheme() {\n        return this.m_options.tilingScheme;\n    }\n    /**\n     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will\n     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is\n     * initialized with default copyrights, concatenated with copyrights from copyright provider of\n     * this data source.\n     *\n     * @param tileKey - Quadtree address of the requested tile.\n     * @param delayLoad - If true, the Tile will be created, but Tile.load will not be called.\n     * @default false.\n     * @override\n     */\n    getTile(tileKey, delayLoad = false) {\n        const tile = this.m_tileFactory.create(this, tileKey);\n        tile.copyrightInfo = this.m_options.copyrightInfo;\n        if (this.m_options.copyrightProvider !== undefined) {\n            this.m_options.copyrightProvider\n                .getCopyrights(tile.geoBox, tileKey.level)\n                .then(copyrightInfo => {\n                tile.copyrightInfo =\n                    tile.copyrightInfo === undefined\n                        ? copyrightInfo\n                        : [...tile.copyrightInfo, ...copyrightInfo];\n                this.requestUpdate();\n            });\n        }\n        if (!delayLoad) {\n            tile.load();\n        }\n        return tile;\n    }\n    /**\n     * Get [[TileInfo]] of a tile.\n     *\n     * @param tileKey - Quadtree address of the requested tile.\n     * @returns A promise which will contain the [[TileInfo]] when resolved.\n     */\n    getTileInfo(tileKey) {\n        const promise = new Promise((resolve, reject) => {\n            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder);\n            tileLoader.loadAndDecode().then(loaderState => {\n                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {\n                    resolve(tileLoader.tileInfo);\n                }\n                else {\n                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));\n                }\n            });\n        });\n        return promise;\n    }\n}\nexports.TileDataSource = TileDataSource;\n//# sourceMappingURL=TileDataSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileInfoLoader = exports.TileLoader = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst ITileLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/ITileLoader */ \"./node_modules/@here/harp-mapview/lib/ITileLoader.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * Logger to write to console etc.\n */\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileLoader\");\n/**\n * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by\n * the [[TileDataSource]].\n */\nclass TileLoader extends harp_mapview_1.BaseTileLoader {\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource - The [[DataSource]] the tile belongs to.\n     * @param tileKey - The quadtree address of a [[Tile]].\n     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.\n     * @param tileDecoder - The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].\n     */\n    constructor(dataSource, tileKey, dataProvider, tileDecoder) {\n        super(dataSource, tileKey);\n        this.dataSource = dataSource;\n        this.tileKey = tileKey;\n        this.dataProvider = dataProvider;\n        this.tileDecoder = tileDecoder;\n    }\n    /**\n     * @override\n     */\n    get priority() {\n        return this.m_priority;\n    }\n    /**\n     * @override\n     */\n    set priority(priority) {\n        this.m_priority = priority;\n        if (this.requestController !== undefined) {\n            this.requestController.priority = priority;\n        }\n    }\n    /**\n     * @override\n     */\n    loadImpl(abortSignal, onDone, onError) {\n        this.dataProvider\n            .getTile(this.tileKey, abortSignal)\n            .then(payload => {\n            if (abortSignal.aborted) {\n                // safety belt if getTile doesn't really support cancellation tokens\n                const err = new Error(\"Aborted\");\n                err.name = \"AbortError\";\n                throw err;\n            }\n            this.onLoaded(payload, onDone, onError);\n        })\n            .catch(error => {\n            // Handle abort messages from fetch and also our own.\n            if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                return;\n            }\n            onError(error);\n        });\n    }\n    /**\n     * @override\n     */\n    cancelImpl() {\n        if (this.state === ITileLoader_1.TileLoaderState.Decoding && this.requestController) {\n            // we should cancel any decodes already in progress!\n            this.requestController.abort();\n            this.requestController = undefined;\n        }\n    }\n    /**\n     * Start decoding the payload.\n     */\n    startDecodeTile(onDone, onError) {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n        this.state = ITileLoader_1.TileLoaderState.Decoding;\n        this.payload = undefined;\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);\n        this.requestController = requestController;\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)\n            .then(decodedTile => {\n            if (requestController.signal.aborted) {\n                // our flow is cancelled, silently return\n                return;\n            }\n            this.onDecoded(decodedTile, onDone);\n        })\n            .catch(error => {\n            // Handle abort messages from fetch and also our own.\n            if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                // our flow is cancelled, silently return\n                return;\n            }\n            onError(error);\n        });\n    }\n    /**\n     * Called when binary data has been loaded. The loading state is now progressing to decoding.\n     *\n     * @param payload - Binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    onLoaded(payload, onDone, onError) {\n        this.state = ITileLoader_1.TileLoaderState.Loaded;\n        this.payload = payload;\n        const byteLength = payload.byteLength;\n        if (byteLength === 0 ||\n            (payload.constructor === Object && Object.keys(payload).length === 0)) {\n            // Object is empty\n            this.onDecoded({\n                geometries: [],\n                techniques: []\n            }, onDone);\n            return;\n        }\n        // TBD: we might suspend decode if tile is not visible ... ?\n        this.startDecodeTile(onDone, onError);\n    }\n    /**\n     * Called when the decoding is finished, and the [[DecodedTile]] has been created.\n     *\n     * @param decodedTile - The [[DecodedTile]].\n     */\n    onDecoded(decodedTile, onDone) {\n        this.decodedTile = decodedTile;\n        onDone(ITileLoader_1.TileLoaderState.Ready);\n    }\n}\nexports.TileLoader = TileLoader;\n/**\n * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta\n * data, not the tile data itself.\n */\nclass TileInfoLoader extends TileLoader {\n    /** @override */\n    startDecodeTile(onDone, onError) {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileInfoLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n        this.state = ITileLoader_1.TileLoaderState.Decoding;\n        this.payload = undefined;\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);\n        this.requestController = requestController;\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)\n            .then(tileInfo => {\n            if (requestController.signal.aborted) {\n                // our flow is cancelled, silently return\n                return;\n            }\n            this.tileInfo = tileInfo;\n            onDone(ITileLoader_1.TileLoaderState.Ready);\n        })\n            .catch(error => {\n            // Handle abort messages from fetch and also our own.\n            if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                // our flow is cancelled, silently return\n                return;\n            }\n            onError(error);\n        });\n    }\n}\nexports.TileInfoLoader = TileInfoLoader;\n//# sourceMappingURL=TileLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@here/harp-mapview/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Functionality needed to render a map.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ \"./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/BaseTileLoader */ \"./node_modules/@here/harp-mapview/lib/BaseTileLoader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/BoundsGenerator */ \"./node_modules/@here/harp-mapview/lib/BoundsGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/CameraMovementDetector */ \"./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ClipPlanesEvaluator */ \"./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/composing */ \"./node_modules/@here/harp-mapview/lib/composing/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightElementHandler */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightInfo */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightCoverageProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/copyrights/UrlCopyrightProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DataSource */ \"./node_modules/@here/harp-mapview/lib/DataSource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/EventDispatcher */ \"./node_modules/@here/harp-mapview/lib/EventDispatcher.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PolarTileDataSource */ \"./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DepthPrePass */ \"./node_modules/@here/harp-mapview/lib/DepthPrePass.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DisplacementMap */ \"./node_modules/@here/harp-mapview/lib/DisplacementMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ElevationProvider */ \"./node_modules/@here/harp-mapview/lib/ElevationProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ElevationRangeSource */ \"./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ITileLoader */ \"./node_modules/@here/harp-mapview/lib/ITileLoader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/image/Image */ \"./node_modules/@here/harp-mapview/lib/image/Image.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/image/ImageCache */ \"./node_modules/@here/harp-mapview/lib/image/ImageCache.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/image/MapViewImageCache */ \"./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapAnchors */ \"./node_modules/@here/harp-mapview/lib/MapAnchors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapViewAtmosphere */ \"./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapViewFog */ \"./node_modules/@here/harp-mapview/lib/MapViewFog.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapViewPoints */ \"./node_modules/@here/harp-mapview/lib/MapViewPoints.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/poi/PoiManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/poi/PoiTableManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/text/TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/text/TextStyleCache */ \"./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TextureLoader */ \"./node_modules/@here/harp-mapview/lib/TextureLoader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ThemeLoader */ \"./node_modules/@here/harp-mapview/lib/ThemeLoader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ \"./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/geometry/TileGeometry */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/VisibleTileSet */ \"./node_modules/@here/harp-mapview/lib/VisibleTileSet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/WorkerBasedTiler */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/workers/WorkerLoader */ \"./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnimatedExtrusionHandler = exports.AnimatedExtrusionState = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * Animation states for extrusion effect\n */\nvar AnimatedExtrusionState;\n(function (AnimatedExtrusionState) {\n    AnimatedExtrusionState[AnimatedExtrusionState[\"None\"] = 0] = \"None\";\n    AnimatedExtrusionState[AnimatedExtrusionState[\"Started\"] = 1] = \"Started\";\n    AnimatedExtrusionState[AnimatedExtrusionState[\"Finished\"] = 2] = \"Finished\";\n})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));\nconst DEFAULT_EXTRUSION_DURATION = 750; // milliseconds\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n/**\n * Handles animated extrusion effect of the buildings in {@link MapView}.\n */\nclass AnimatedExtrusionHandler {\n    /**\n     * Creates an {@link AnimatedExtrusionHandler} in {@link MapView}.\n     *\n     * @param m_mapView - Instance of {@link MapView} on which the animation will run.\n     */\n    constructor(m_mapView) {\n        this.m_mapView = m_mapView;\n        /**\n         * Animate the extrusion of the buildings if set to `true`.\n         */\n        this.enabled = true;\n        /**\n         * Duration of the building's extrusion in milliseconds\n         */\n        this.duration = DEFAULT_EXTRUSION_DURATION;\n        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;\n        this.m_forceEnabled = false;\n        this.m_dataSourceMap = new Map();\n        this.m_state = AnimatedExtrusionState.None;\n        this.m_startTime = -1;\n    }\n    /**\n     * Returns whether the extrusion animation is force enabled or not.\n     */\n    get forceEnabled() {\n        return this.m_forceEnabled;\n    }\n    /**\n     * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`\n     * values from [[extrudedPolygonTechnique]] will be ignored and\n     * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used\n     */\n    set forceEnabled(force) {\n        this.m_forceEnabled = force;\n        this.duration = DEFAULT_EXTRUSION_DURATION;\n    }\n    /**\n     * Gets min zoom level at which extruded animation is enabled.\n     */\n    get minZoomLevel() {\n        return this.m_minZoomLevel;\n    }\n    /**\n     * Sets the extrusion animation properties obtained from a given technique.\n     * @internal\n     * @param technique - The technique where the extrusion animation properties are defined.\n     * @param env - The environment used to evaluate technique properties.\n     * @returns True if the technique has animation enabled (or animation is forced), false\n     * otherwise.\n     */\n    setAnimationProperties(technique, env) {\n        if (!harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n            return false;\n        }\n        if (technique.hasOwnProperty(\"minZoomLevel\")) {\n            this.m_minZoomLevel = technique.minZoomLevel;\n        }\n        if (this.forceEnabled) {\n            return this.enabled;\n        }\n        if (technique.animateExtrusionDuration !== undefined) {\n            this.duration = technique.animateExtrusionDuration;\n        }\n        const animateExtrusionValue = harp_datasource_protocol_1.getPropertyValue(technique.animateExtrusion, env);\n        if (animateExtrusionValue === null) {\n            return this.enabled;\n        }\n        return typeof animateExtrusionValue === \"boolean\"\n            ? animateExtrusionValue\n            : typeof animateExtrusionValue === \"number\"\n                ? animateExtrusionValue !== 0\n                : false;\n    }\n    /**\n     * Updates the extrusion animation for every frame.\n     * @internal\n     */\n    update(zoomLevel) {\n        const extrusionVisible = this.m_dataSourceMap.size > 0 && zoomLevel >= this.m_minZoomLevel;\n        if (this.m_state === AnimatedExtrusionState.None && extrusionVisible) {\n            this.m_state = AnimatedExtrusionState.Started;\n        }\n        else if (this.m_state !== AnimatedExtrusionState.None && !extrusionVisible) {\n            this.resetAnimation(true);\n        }\n        this.animateExtrusion();\n    }\n    /**\n     * Adds a tile to be animated.\n     * @internal\n     * @param tile - The tile to be animated.\n     * @param materials - Extruded materials belonging to the tile.\n     */\n    add(tile, materials) {\n        tile.addDisposeCallback(this.removeTile.bind(this));\n        let animated = false;\n        if (this.m_state !== AnimatedExtrusionState.None) {\n            animated = this.skipAnimation(tile);\n            if (animated) {\n                // Set extrusion ratio to 1 if the tile skips the animation.\n                this.setTileExtrusionRatio(materials, 1);\n            }\n            else if (this.m_state === AnimatedExtrusionState.Finished) {\n                // Otherwise, if animation was finished, restart animation but leave already\n                //  animated tiles untouched.\n                this.resetAnimation(false);\n            }\n        }\n        this.getOrCreateTileMap(tile.dataSource).set(tile.tileKey.mortonCode(), {\n            materials,\n            animated\n        });\n    }\n    /**\n     * Is `true` if there's any extrusion animation ongoing.\n     */\n    get isAnimating() {\n        return (this.m_state !== AnimatedExtrusionState.Finished &&\n            this.m_state !== AnimatedExtrusionState.None);\n    }\n    getTileMap(dataSource, create = false) {\n        return this.m_dataSourceMap.get(dataSource);\n    }\n    getOrCreateTileMap(dataSource) {\n        let tileMap = this.m_dataSourceMap.get(dataSource);\n        if (!tileMap) {\n            tileMap = new Map();\n            this.m_dataSourceMap.set(dataSource, tileMap);\n        }\n        return tileMap;\n    }\n    skipAnimation(tile) {\n        return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);\n    }\n    wasAnyAncestorAnimated(tile) {\n        var _a, _b;\n        const minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);\n        const distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);\n        const levelsUp = Math.min(distanceToMinLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp);\n        const tileMap = this.getTileMap(tile.dataSource);\n        if (!tileMap) {\n            return false;\n        }\n        let lastTileKey = tile.tileKey;\n        for (let deltaUp = 1; deltaUp <= levelsUp; ++deltaUp) {\n            lastTileKey = lastTileKey.parent();\n            if ((_b = (_a = tileMap.get(lastTileKey.mortonCode())) === null || _a === void 0 ? void 0 : _a.animated) !== null && _b !== void 0 ? _b : false) {\n                return true;\n            }\n        }\n        return false;\n    }\n    wasAnyDescendantAnimated(tile) {\n        var _a, _b;\n        const distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;\n        const levelsDown = Math.min(distanceToMaxLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown);\n        const tileMap = this.getTileMap(tile.dataSource);\n        if (!tileMap) {\n            return false;\n        }\n        const tilingScheme = tile.dataSource.getTilingScheme();\n        let nextTileKeys = [tile.tileKey];\n        let childTileKeys = [];\n        for (let deltaDown = 1; deltaDown <= levelsDown; ++deltaDown) {\n            childTileKeys.length = 0;\n            for (const tileKey of nextTileKeys) {\n                for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                    if ((_b = (_a = tileMap.get(childTileKey.mortonCode())) === null || _a === void 0 ? void 0 : _a.animated) !== null && _b !== void 0 ? _b : false) {\n                        return true;\n                    }\n                    childTileKeys.push(childTileKey);\n                }\n            }\n            // swap\n            [nextTileKeys, childTileKeys] = [childTileKeys, nextTileKeys];\n        }\n        return false;\n    }\n    removeTile(tile) {\n        const tileMap = this.getTileMap(tile.dataSource);\n        if (!tileMap) {\n            return;\n        }\n        tileMap.delete(tile.tileKey.mortonCode());\n        // Remove tile map if it's empty. That way, counting the number of data sources in the\n        // map is enough to know if there's any tile.\n        if (tileMap.size === 0) {\n            this.m_dataSourceMap.delete(tile.dataSource);\n        }\n    }\n    animateExtrusion() {\n        if (this.m_state !== AnimatedExtrusionState.Started) {\n            return;\n        }\n        const currentTime = Date.now();\n        if (this.m_startTime < 0) {\n            this.m_startTime = currentTime;\n        }\n        const duration = this.duration;\n        const timeProgress = Math.min(currentTime - this.m_startTime, duration);\n        const extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / duration);\n        this.setExtrusionRatio(extrusionRatio);\n        if (timeProgress >= duration) {\n            this.m_state = AnimatedExtrusionState.Finished;\n        }\n        this.m_mapView.update();\n    }\n    resetAnimation(resetTiles) {\n        this.m_state = AnimatedExtrusionState.None;\n        this.m_startTime = -1;\n        if (resetTiles) {\n            this.m_dataSourceMap.forEach(tileMap => {\n                tileMap.forEach(state => {\n                    state.animated = false;\n                });\n            });\n        }\n    }\n    setExtrusionRatio(value) {\n        this.m_dataSourceMap.forEach(tileMap => {\n            tileMap.forEach(state => {\n                if (!state.animated) {\n                    this.setTileExtrusionRatio(state.materials, value);\n                    if (value >= 1) {\n                        state.animated = true;\n                    }\n                }\n            });\n        });\n    }\n    setTileExtrusionRatio(materials, value) {\n        materials.forEach(material => {\n            material.extrusionRatio = value;\n        });\n    }\n}\nexports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;\n//# sourceMappingURL=AnimatedExtrusionHandler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BackgroundDataSource = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst DataSource_1 = __webpack_require__(/*! ./DataSource */ \"./node_modules/@here/harp-mapview/lib/DataSource.js\");\nconst AddGroundPlane_1 = __webpack_require__(/*! ./geometry/AddGroundPlane */ \"./node_modules/@here/harp-mapview/lib/geometry/AddGroundPlane.js\");\nconst Tile_1 = __webpack_require__(/*! ./Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\");\n/**\n * Provides background geometry for all tiles.\n */\nclass BackgroundDataSource extends DataSource_1.DataSource {\n    constructor() {\n        super({ name: \"background\" });\n        this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        this.cacheable = true;\n        this.addGroundPlane = true;\n        this.enablePicking = false;\n    }\n    updateStorageLevelOffset() {\n        let storageLevelOffset;\n        this.mapView.dataSources.forEach(ds => {\n            if (ds === this) {\n                return;\n            }\n            const tilingScheme = ds.getTilingScheme();\n            if (tilingScheme === this.m_tilingScheme) {\n                storageLevelOffset =\n                    storageLevelOffset === undefined\n                        ? ds.storageLevelOffset\n                        : Math.max(storageLevelOffset, ds.storageLevelOffset);\n            }\n        });\n        if (storageLevelOffset === undefined) {\n            storageLevelOffset = 0;\n        }\n        if (storageLevelOffset !== this.storageLevelOffset) {\n            this.storageLevelOffset = storageLevelOffset;\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n    /** @override */\n    async setTheme(theme, languages) {\n        this.mapView.clearTileCache(this.name);\n    }\n    setTilingScheme(tilingScheme) {\n        const newScheme = tilingScheme !== null && tilingScheme !== void 0 ? tilingScheme : BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        if (newScheme === this.m_tilingScheme) {\n            return;\n        }\n        this.m_tilingScheme = newScheme;\n        this.updateStorageLevelOffset();\n        this.mapView.clearTileCache(this.name);\n    }\n    /** @override */\n    getTilingScheme() {\n        return this.m_tilingScheme;\n    }\n    /** @override */\n    getTile(tileKey) {\n        const tile = new Tile_1.Tile(this, tileKey);\n        tile.forceHasGeometry(true);\n        AddGroundPlane_1.addGroundPlane(tile, BackgroundDataSource.GROUND_RENDER_ORDER);\n        return tile;\n    }\n}\nexports.BackgroundDataSource = BackgroundDataSource;\nBackgroundDataSource.GROUND_RENDER_ORDER = Number.MIN_SAFE_INTEGER;\nBackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;\n//# sourceMappingURL=BackgroundDataSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/BaseTileLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/BaseTileLoader.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseTileLoader = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst ITileLoader_1 = __webpack_require__(/*! ./ITileLoader */ \"./node_modules/@here/harp-mapview/lib/ITileLoader.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"BaseTileLoader\");\n/**\n * @internal\n * Base class for tile loaders that provides state handling, request abortion and a load promise.\n */\nclass BaseTileLoader {\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource - The [[DataSource]] the tile belongs to.\n     * @param tileKey - The quadtree address of a [[Tile]].\n     */\n    constructor(dataSource, tileKey) {\n        this.dataSource = dataSource;\n        this.tileKey = tileKey;\n        this.state = ITileLoader_1.TileLoaderState.Initialized;\n        this.m_priority = 0;\n        /**\n         * The abort controller notifying the [[DataProvider]] to cancel loading.\n         */\n        this.loadAbortController = new AbortController();\n    }\n    /**\n     * @override\n     */\n    get priority() {\n        return this.m_priority;\n    }\n    /**\n     * @override\n     */\n    set priority(value) {\n        this.m_priority = value;\n    }\n    /**\n     * @override\n     */\n    loadAndDecode() {\n        switch (this.state) {\n            case ITileLoader_1.TileLoaderState.Loading:\n            case ITileLoader_1.TileLoaderState.Loaded:\n            case ITileLoader_1.TileLoaderState.Decoding:\n                // tile is already loading\n                return this.donePromise;\n            case ITileLoader_1.TileLoaderState.Ready:\n            case ITileLoader_1.TileLoaderState.Failed:\n            case ITileLoader_1.TileLoaderState.Initialized:\n            case ITileLoader_1.TileLoaderState.Canceled:\n                // restart loading\n                this.load();\n                return this.donePromise;\n        }\n    }\n    /**\n     * @override\n     */\n    waitSettled() {\n        if (!this.donePromise) {\n            return Promise.resolve(this.state);\n        }\n        return this.donePromise;\n    }\n    /**\n     * @override\n     */\n    cancel() {\n        if (this.state === ITileLoader_1.TileLoaderState.Loading) {\n            this.loadAbortController.abort();\n            this.loadAbortController = new AbortController();\n        }\n        this.cancelImpl();\n        this.onDone(ITileLoader_1.TileLoaderState.Canceled);\n    }\n    /**\n     * @override\n     */\n    get isFinished() {\n        return (this.state === ITileLoader_1.TileLoaderState.Ready ||\n            this.state === ITileLoader_1.TileLoaderState.Canceled ||\n            this.state === ITileLoader_1.TileLoaderState.Failed);\n    }\n    /**\n     * Called on load cancelation, may be overriden to extend behaviour.\n     */\n    cancelImpl() { }\n    /**\n     * Start loading. Only call if loading did not start yet.\n     */\n    load() {\n        this.loadImpl(this.loadAbortController.signal, this.onDone.bind(this), this.onError.bind(this));\n        if (this.donePromise === undefined) {\n            this.donePromise = new Promise((resolve, reject) => {\n                this.resolveDonePromise = resolve;\n                this.rejectedDonePromise = reject;\n            });\n        }\n        this.state = ITileLoader_1.TileLoaderState.Loading;\n    }\n    /**\n     * Called when loading and decoding has finished successfully. Resolves loading promise if the\n     * state is Ready, otherwise it rejects the promise with the supplied state.\n     *\n     * @param doneState - The latest state of loading.\n     */\n    onDone(doneState) {\n        if (this.resolveDonePromise && doneState === ITileLoader_1.TileLoaderState.Ready) {\n            this.resolveDonePromise(doneState);\n        }\n        else if (this.rejectedDonePromise) {\n            this.rejectedDonePromise(doneState);\n        }\n        this.resolveDonePromise = undefined;\n        this.rejectedDonePromise = undefined;\n        this.donePromise = undefined;\n        this.state = doneState;\n    }\n    /**\n     * Called when loading or decoding has finished with an error.\n     *\n     * @param error - Error object describing the failing.\n     */\n    onError(error) {\n        if (this.state === ITileLoader_1.TileLoaderState.Canceled) {\n            // If we're canceled, we should simply ignore any state transitions and errors from\n            // underlying load/decode ops.\n            return;\n        }\n        const dataSource = this.dataSource;\n        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);\n        this.error = error;\n        this.onDone(ITileLoader_1.TileLoaderState.Failed);\n    }\n}\nexports.BaseTileLoader = BaseTileLoader;\n//# sourceMappingURL=BaseTileLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/BaseTileLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/BoundsGenerator.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/BoundsGenerator.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BoundsGenerator = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst SphereHorizon_1 = __webpack_require__(/*! ./SphereHorizon */ \"./node_modules/@here/harp-mapview/lib/SphereHorizon.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\n// Rough, empirical rule to compute the number of divisions needed for a geopolygon edge to keep\n// the deviation from the view bound edge it must follow within acceptable values.\nfunction computeEdgeDivisionsForSphere(geoStart, geoEnd) {\n    const maxLatitudeSpan = 20;\n    const maxLongitudeSpan = 5;\n    const latitudeSpan = Math.abs(geoEnd.latitude - geoStart.latitude);\n    const longitudeSpan = geoStart.minLongitudeSpanTo(geoEnd);\n    return Math.ceil(Math.max(latitudeSpan / maxLatitudeSpan, longitudeSpan / maxLongitudeSpan));\n}\nfunction nextCanvasSide(side) {\n    return (side + 1) % 4;\n}\nfunction previousCanvasSide(side) {\n    return (side + 3) % 4;\n}\nconst ccwCanvasCornersNDC = [\n    { x: -1, y: -1 },\n    { x: 1, y: -1 },\n    { x: 1, y: 1 },\n    { x: -1, y: 1 } // top left\n];\n/**\n * Generates Bounds for a camera view and a projection\n *\n * @beta, @internal\n */\nclass BoundsGenerator {\n    constructor(m_camera, m_projection, tileWrappingEnabled = false) {\n        this.m_camera = m_camera;\n        this.m_projection = m_projection;\n        this.tileWrappingEnabled = tileWrappingEnabled;\n        this.m_groundPlaneNormal = new three_1.Vector3(0, 0, 1);\n        this.m_groundPlane = new three_1.Plane(this.m_groundPlaneNormal.clone());\n    }\n    set projection(projection) {\n        this.m_projection = projection;\n    }\n    /**\n     * Generates an Array of GeoCoordinates covering the visible map.\n     * The coordinates are sorted to ccw winding, so a polygon could be drawn with them.\n     */\n    generate() {\n        return this.m_projection.type === harp_geoutils_1.ProjectionType.Planar\n            ? this.generateOnPlane()\n            : this.generateOnSphere();\n    }\n    createPolygon(coordinates, sort, wrapAround = false) {\n        if (coordinates.length > 2) {\n            return new harp_geoutils_1.GeoPolygon(coordinates, sort, wrapAround);\n        }\n        return undefined;\n    }\n    addSideSegmentSubdivisionsOnSphere(coordinates, NDCStart, NDCEnd, geoStart, geoEnd) {\n        coordinates.push(geoStart);\n        const divisionCount = computeEdgeDivisionsForSphere(geoStart, geoEnd);\n        if (divisionCount <= 1) {\n            return;\n        }\n        const NDCStep = new three_1.Vector2(NDCEnd.x - NDCStart.x, NDCEnd.y - NDCStart.y).multiplyScalar(1 / divisionCount);\n        const NDCDivision = new three_1.Vector2(NDCStart.x, NDCStart.y);\n        for (let i = 0; i < divisionCount - 1; i++) {\n            NDCDivision.add(NDCStep);\n            const intersection = Utils_1.MapViewUtils.rayCastWorldCoordinates({ camera: this.m_camera, projection: this.m_projection }, NDCDivision.x, NDCDivision.y);\n            if (intersection) {\n                coordinates.push(this.m_projection.unprojectPoint(intersection));\n            }\n        }\n    }\n    addSideIntersectionsOnSphere(coordinates, side, geoStartCorner, geoEndCorner, horizon) {\n        harp_utils_1.assert(this.m_projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        const startNDCCorner = ccwCanvasCornersNDC[side];\n        const endNDCCorner = ccwCanvasCornersNDC[nextCanvasSide(side)];\n        if (geoStartCorner && geoEndCorner) {\n            // No horizon visible on this side of the canvas, generate polygon vertices from\n            // intersections of the canvas side with the world.\n            this.addSideSegmentSubdivisionsOnSphere(coordinates, startNDCCorner, endNDCCorner, geoStartCorner, geoEndCorner);\n            return;\n        }\n        if (!horizon) {\n            return;\n        }\n        // Bounds on this side of the canvas need to be completed with the horizon.\n        const horizonIntersections = horizon.getSideIntersections(side);\n        if (horizonIntersections.length === 0) {\n            return;\n        }\n        if (geoStartCorner) {\n            // Generate polygon vertices from intersections of this canvas side with the world\n            // from its starting corner till the last intersection with the horizon.\n            const worldHorizonPoint = horizon.getPoint(horizonIntersections[horizonIntersections.length - 1]);\n            const geoHorizonPoint = this.m_projection.unprojectPoint(worldHorizonPoint);\n            this.addSideSegmentSubdivisionsOnSphere(coordinates, startNDCCorner, worldHorizonPoint.project(this.m_camera), geoStartCorner, geoHorizonPoint);\n        }\n        else {\n            // Subdivide horizon from last horizon intersection on previous side to this side first.\n            const prevSide = previousCanvasSide(side);\n            let prevSideIntersections = horizon.getSideIntersections(prevSide);\n            if (prevSideIntersections.length === 0) {\n                // When bottom canvas side cuts the horizon above its center, right horizon\n                // tangent is not visible. Last horizon tangent is top one.\n                prevSideIntersections = horizon.getSideIntersections(previousCanvasSide(prevSide));\n            }\n            harp_utils_1.assert(prevSideIntersections.length > 0);\n            horizon.getDivisionPoints(point => {\n                coordinates.push(this.m_projection.unprojectPoint(point));\n            }, prevSideIntersections[prevSideIntersections.length - 1], horizonIntersections[0]);\n        }\n        if (horizonIntersections.length > 1) {\n            // Subdivide side segment between two horizon intersections.\n            const worldHorizonStart = horizon.getPoint(horizonIntersections[0]);\n            const worldHorizonEnd = horizon.getPoint(horizonIntersections[1]);\n            const geoHorizonStart = this.m_projection.unprojectPoint(worldHorizonStart);\n            const geoHorizonEnd = this.m_projection.unprojectPoint(worldHorizonEnd);\n            this.addSideSegmentSubdivisionsOnSphere(coordinates, worldHorizonStart.project(this.m_camera), worldHorizonEnd.project(this.m_camera), geoHorizonStart, geoHorizonEnd);\n        }\n        if (geoEndCorner) {\n            // Subdivice side segment from last horizon intersection to the ending corner of this\n            // canvas side.\n            const worldHorizonPoint = horizon.getPoint(horizonIntersections[0]);\n            const geoHorizonPoint = this.m_projection.unprojectPoint(worldHorizonPoint);\n            this.addSideSegmentSubdivisionsOnSphere(coordinates, worldHorizonPoint.project(this.m_camera), endNDCCorner, geoHorizonPoint, geoEndCorner);\n        }\n    }\n    findBoundsIntersectionsOnSphere() {\n        harp_utils_1.assert(this.m_projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        const cornerCoordinates = [];\n        const coordinates = [];\n        this.addCanvasCornerIntersection(cornerCoordinates);\n        // Horizon points need to be added to complete the bounds if not all canvas corners\n        // intersect with the world.\n        const horizon = cornerCoordinates.length < 4 ? new SphereHorizon_1.SphereHorizon(this.m_camera) : undefined;\n        if (cornerCoordinates.length === 0 && horizon.isFullyVisible) {\n            // Bounds are generated entirely from equidistant points obtained from the horizon\n            // circle.\n            horizon.getDivisionPoints(point => {\n                coordinates.push(this.m_projection.unprojectPoint(point));\n            });\n            return coordinates;\n        }\n        cornerCoordinates.length = 4;\n        for (let side = SphereHorizon_1.CanvasSide.Bottom; side < 4; side++) {\n            const startCorner = cornerCoordinates[side];\n            const endCorner = cornerCoordinates[nextCanvasSide(side)];\n            this.addSideIntersectionsOnSphere(coordinates, side, startCorner, endCorner, horizon);\n        }\n        return coordinates;\n    }\n    wrapAroundPoles(coordinates) {\n        // If one of the poles is inside the view bounds, the polygon would have to cover the pole,\n        // which is not possible in geo space. Instead, additional vertices (numbered in order from\n        // 1 to 6 in the diagram below) are added to the polygon so that it wraps around the pole,\n        // covering the same area(except for the pole circle that cannot be mapped to geospace).\n        // The globe is cut in two hemispheres by the meridians at the camera longitude (camLon) and\n        // its antimeridian (at camLon+180). Then, the polygon side crossing the camera antimeridian\n        // is found, and the new pole wrapping vertices are inserted between its start and end\n        // vertices.\n        //\n        //    (end) hem.crossing side (start)\n        //        \\|<-------------->|/\n        // x-------x------6!--------x--------x\n        // |         , - ~5!1 ~ -,           |\n        // |     , '       !       ' ,       |\n        // |   ,           !           ,     |\n        // |  ,            !            ,    |\n        // | ,             !             ,   |\n        // | 4           POLE            2   | <- Bounds polygon\n        // | ,             !             ,   |\n        // |  ,            !            ,    |\n        // |   ,           !           ,     |\n        // |     ,         !         ,'      |\n        // |       ' -_, _ ! _ ,_ -'         |\n        // |               3                 |\n        // x---------------!-----------------x\n        //                 ! <- hemisphere partition\n        const northPoleCenter = new three_1.Vector3(0, 0, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);\n        const southPoleCenter = new three_1.Vector3(0, 0, -harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);\n        const northPoleInView = Utils_1.MapViewUtils.closeToFrustum(northPoleCenter, this.m_camera);\n        const southPoleInView = Utils_1.MapViewUtils.closeToFrustum(southPoleCenter, this.m_camera);\n        if (!northPoleInView && !southPoleInView) {\n            return;\n        }\n        // Create first wrapping vertex (number 1 in the diagram above).\n        const camLon = this.m_projection.unprojectPoint(this.m_camera.position).lng;\n        const wrapLat = northPoleInView ? 90 : -90;\n        const wrapLon = northPoleInView ? camLon + 180 : camLon - 180;\n        const geoWrapTopRight = new harp_geoutils_1.GeoCoordinates(wrapLat, wrapLon);\n        const geoWrapTopRightNorm = geoWrapTopRight.normalized();\n        // Find the polygon side crossing the camera antimeridian.\n        const crossLon = geoWrapTopRightNorm.lng;\n        let prevLon = coordinates[coordinates.length - 1].lng;\n        // Check whether the camera antimeridian crossing also crosses greenwich antimerdian.\n        let isGwAntimerCross = false;\n        const hSphereCrossEndIndex = coordinates.findIndex((value) => {\n            const crossesAntimer = harp_geoutils_1.isAntimeridianCrossing(prevLon, value.lng);\n            const sameSign = Math.sign(crossLon - value.lng) === Math.sign(crossLon - prevLon);\n            if (sameSign === crossesAntimer) {\n                isGwAntimerCross = crossesAntimer;\n                return true;\n            }\n            prevLon = value.lng;\n            return false;\n        });\n        if (hSphereCrossEndIndex < 0) {\n            // No polygon side crosses the camera antimeridian, meaning that the polygon doesn't\n            // actually go above the pole to the other side of the world, no wrapping needed.\n            return;\n        }\n        // Create rest of wrapping vertices at pole's latitude (vertices 2-5 in diagram above).\n        const wrapSideOffset = northPoleInView ? 90 : -90;\n        const wrapCornerOffset = northPoleInView ? 0.00001 : -0.00001;\n        // Added to ensure antimeridian crossing detection when coordinates are wrapped around it by\n        // GeoPolygon (all polygon sides must have longitude spans smaller than 180 degrees).\n        const geoWrapRight = new harp_geoutils_1.GeoCoordinates(wrapLat, camLon + wrapSideOffset).normalized();\n        const geoWrapBottom = new harp_geoutils_1.GeoCoordinates(wrapLat, camLon).normalized();\n        // Added to ensure antimeridian crossing detection when coordinates are wrapped around it by\n        // GeoPolygon (all polygon sides must have longitude spans smaller than 180 degrees).\n        const geoWrapLeft = new harp_geoutils_1.GeoCoordinates(wrapLat, camLon - wrapSideOffset).normalized();\n        const geoWrapTopLeft = new harp_geoutils_1.GeoCoordinates(wrapLat, wrapLon + wrapCornerOffset).normalized();\n        const hSphereCrossStartIndex = (hSphereCrossEndIndex + coordinates.length - 1) % coordinates.length;\n        const crossStart = coordinates[hSphereCrossStartIndex];\n        const crossEnd = coordinates[hSphereCrossEndIndex];\n        // Last wrapping vertex (number 6) is linearly interpolated at the polygon side crossing the\n        // camera antimeridian.\n        let crossLerp = harp_geoutils_1.GeoCoordinates.lerp(crossStart, crossEnd, 0.01, isGwAntimerCross);\n        if (isGwAntimerCross && northPoleInView) {\n            crossLerp.longitude -= 360;\n        }\n        else {\n            crossLerp = crossLerp.normalized();\n        }\n        // Add the wrapping vertices to the array in the proper order (see diagram above).\n        coordinates.splice(hSphereCrossEndIndex, 0, wrapLon < -180 ? geoWrapTopRight : geoWrapTopRightNorm, // 1\n        geoWrapRight, // 2\n        geoWrapBottom, // 3\n        geoWrapLeft, // 4\n        geoWrapTopLeft, // 5\n        crossLerp // 6\n        );\n    }\n    generateOnSphere() {\n        harp_utils_1.assert(this.m_projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        const coordinates = this.findBoundsIntersectionsOnSphere();\n        this.wrapAroundPoles(coordinates);\n        return this.createPolygon(coordinates, false, true);\n    }\n    generateOnPlane() {\n        //!!!!!!!ALTITUDE IS NOT TAKEN INTO ACCOUNT!!!!!!!!!\n        const coordinates = [];\n        // 1.) Raycast into all four corners of the canvas\n        //     => if an intersection is found, add it to the polygon\n        this.addCanvasCornerIntersection(coordinates);\n        // => All 4 corners found an intersection, therefore the screen is covered with the map\n        // and the polygon complete\n        if (coordinates.length === 4) {\n            return this.createPolygon(coordinates, true);\n        }\n        //2.) Raycast into the two corners of the horizon cutting the canvas sides\n        //    => if an intersection is found, add it to the polygon\n        this.addHorizonIntersection(coordinates);\n        //Setup the frustum for further checks\n        const frustum = new three_1.Frustum().setFromProjectionMatrix(new three_1.Matrix4().multiplyMatrices(this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse));\n        // Setup the world corners for further checks.\n        // Cast to TileCorners as it cannot be undefined here, due to the forced\n        // PlanarProjection above\n        const worldCorners = this.getWorldConers(this.m_projection);\n        if (!this.tileWrappingEnabled) {\n            // 3.) If no wrapping, check if any corners of the world plane are inside the view\n            //     => if true, add it to the polygon\n            [worldCorners.ne, worldCorners.nw, worldCorners.se, worldCorners.sw].forEach(corner => {\n                this.addPointInFrustum(corner, frustum, coordinates);\n            });\n        }\n        //4.) Check for any edges of the world plane intersecting with the frustum?\n        //    => if true, add to polygon\n        if (!this.tileWrappingEnabled) {\n            // if no tile wrapping:\n            //       check with limited lines around the world edges\n            [\n                new three_1.Line3(worldCorners.sw, worldCorners.se),\n                new three_1.Line3(worldCorners.ne, worldCorners.nw),\n                new three_1.Line3(worldCorners.se, worldCorners.ne),\n                new three_1.Line3(worldCorners.nw, worldCorners.sw) //  west edge\n            ].forEach(edge => {\n                this.addFrustumIntersection(edge, frustum, coordinates);\n            });\n        }\n        else {\n            // if tile wrapping:\n            //       check for intersections with rays along the south and north edges\n            const directionEast = new three_1.Vector3() //west -> east\n                .subVectors(worldCorners.sw, worldCorners.se)\n                .normalize();\n            const directionWest = new three_1.Vector3() //east -> west\n                .subVectors(worldCorners.se, worldCorners.sw)\n                .normalize();\n            [\n                new three_1.Ray(worldCorners.se, directionEast),\n                new three_1.Ray(worldCorners.se, directionWest),\n                new three_1.Ray(worldCorners.ne, directionEast),\n                new three_1.Ray(worldCorners.ne, directionWest) //  north west ray\n            ].forEach(ray => {\n                this.addFrustumIntersection(ray, frustum, coordinates);\n            });\n        }\n        // 5.) Create the Polygon and set needsSort to `true`as we expect it to be convex and\n        //     sortable\n        return this.createPolygon(coordinates, true);\n    }\n    getWorldConers(projection) {\n        if (projection.type !== harp_geoutils_1.ProjectionType.Planar) {\n            return;\n        }\n        const worldBox = projection.worldExtent(0, 0);\n        return {\n            sw: worldBox.min,\n            se: new three_1.Vector3(worldBox.max.x, worldBox.min.y, 0),\n            nw: new three_1.Vector3(worldBox.min.x, worldBox.max.y, 0),\n            ne: worldBox.max\n        };\n    }\n    addNDCRayIntersection(ndcPoints, geoPolygon) {\n        ndcPoints.forEach(corner => {\n            const intersection = Utils_1.MapViewUtils.rayCastWorldCoordinates({ camera: this.m_camera, projection: this.m_projection }, corner[0], corner[1]);\n            if (intersection) {\n                this.validateAndAddToGeoPolygon(intersection, geoPolygon);\n            }\n        });\n    }\n    addHorizonIntersection(geoPolygon) {\n        if (this.m_projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            const verticalHorizonPosition = this.getVerticalHorizonPositionInNDC();\n            if (!verticalHorizonPosition) {\n                return;\n            }\n            this.addNDCRayIntersection([\n                [-1, verticalHorizonPosition],\n                [1, verticalHorizonPosition] //horizon right\n            ], geoPolygon);\n        }\n    }\n    addCanvasCornerIntersection(geoPolygon) {\n        this.addNDCRayIntersection([\n            [-1, -1],\n            [1, -1],\n            [1, 1],\n            [-1, 1] //upper left\n        ], geoPolygon);\n    }\n    validateAndAddToGeoPolygon(point, geoPolygon) {\n        if (this.isInVisibleMap(point)) {\n            geoPolygon.push(this.m_projection.unprojectPoint(point));\n        }\n    }\n    isInVisibleMap(point) {\n        if (this.m_projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            if (point.y < 0 || point.y > harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE) {\n                return false;\n            }\n            if (!this.tileWrappingEnabled &&\n                (point.x < 0 || point.x > harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    addPointInFrustum(point, frustum, geoPolygon) {\n        if (frustum.containsPoint(point)) {\n            const geoPoint = this.m_projection.unprojectPoint(point);\n            geoPoint.altitude = 0;\n            geoPolygon.push(geoPoint);\n        }\n    }\n    addFrustumIntersection(edge, frustum, geoPolygon) {\n        frustum.planes.forEach(plane => {\n            let intersection = null;\n            const target = new three_1.Vector3();\n            if (edge instanceof three_1.Ray && edge.intersectsPlane(plane)) {\n                intersection = edge.intersectPlane(plane, target);\n            }\n            else if (edge instanceof three_1.Line3 && plane.intersectsLine(edge)) {\n                intersection = plane.intersectLine(edge, target);\n            }\n            if (intersection) {\n                //uses this check to fix inaccuracies\n                if (Utils_1.MapViewUtils.closeToFrustum(intersection, this.m_camera)) {\n                    const geoIntersection = this.m_projection.unprojectPoint(intersection);\n                    //correct altitude caused by inaccuracies, due to large numbers to 0\n                    geoIntersection.altitude = 0;\n                    geoPolygon.push(geoIntersection);\n                }\n            }\n        });\n    }\n    getVerticalHorizonPositionInNDC() {\n        if (this.m_projection.type !== harp_geoutils_1.ProjectionType.Planar) {\n            return undefined;\n        }\n        const bottomMidFarPoint = new three_1.Vector3(-1, -1, 1)\n            .unproject(this.m_camera)\n            .add(new three_1.Vector3(1, -1, 1).unproject(this.m_camera))\n            .multiplyScalar(0.5);\n        const topMidFarPoint = new three_1.Vector3(-1, 1, 1)\n            .unproject(this.m_camera)\n            .add(new three_1.Vector3(1, 1, 1).unproject(this.m_camera))\n            .multiplyScalar(0.5);\n        const farPlaneVerticalCenterLine = new three_1.Line3(bottomMidFarPoint, topMidFarPoint);\n        const verticalHorizonPosition = new three_1.Vector3();\n        if (!this.m_groundPlane.intersectLine(farPlaneVerticalCenterLine, verticalHorizonPosition)) {\n            return undefined;\n        }\n        return verticalHorizonPosition.project(this.m_camera).y;\n    }\n}\nexports.BoundsGenerator = BoundsGenerator;\n//# sourceMappingURL=BoundsGenerator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/BoundsGenerator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CameraMovementDetector = void 0;\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\n/**\n * The default value for camera movement throttling, in milliseconds.\n */\nconst DEFAULT_THROTTLING_TIMEOUT = 300;\n/**\n * The `CameraMovementDetector` class checks for changes in camera position and orientation, to\n * detect continuous movements without the animation mode activated in {@link MapView}. If the\n * interaction is not continuous enough, you can use a throttling timer to reduce the number of\n * callbacks.\n */\nclass CameraMovementDetector {\n    /**\n     * Initializes the detector with timeout value and callbacks. {@link MapView} also provides\n     * events for client code to be notified when these cues occur.\n     *\n     * @param m_throttlingTimeout - The delay, in milliseconds, between the last user interaction\n     * detected and the call to `m_movementFinishedFunc`; the default is `300`.\n     * @param m_movementStartedFunc - Callback function, called when the user starts interacting.\n     * @param m_movementFinishedFunc - Callback function, called when the user stops interacting.\n     */\n    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {\n        this.m_throttlingTimeout = m_throttlingTimeout;\n        this.m_movementStartedFunc = m_movementStartedFunc;\n        this.m_movementFinishedFunc = m_movementFinishedFunc;\n        this.m_lastCameraPos = new three_1.Vector3();\n        this.m_newCameraPos = new three_1.Vector3();\n        this.m_throttlingTimerId = undefined;\n        this.m_movementDetectorDeadline = 0;\n        this.onDeadlineTimer = () => {\n            this.m_throttlingTimerId = undefined;\n            const now = performance.now();\n            if (now >= this.m_movementDetectorDeadline) {\n                this.movementFinished();\n            }\n            else {\n                this.startMovementFinishedTimer(now);\n            }\n        };\n        if (this.m_throttlingTimeout === undefined) {\n            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;\n        }\n    }\n    /**\n     * Checks if the camera has moved since the last time it was checked. The\n     * `m_movementStartedFunc` is called when a movement starts. If no movement\n     * is detected, a timer for `m_movementFinishedFunc` starts.\n     *\n     * @param mapView - [[Mapview]]'s position and camera are checked for modifications.\n     */\n    checkCameraMoved(mapView, now) {\n        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        if (this.m_lastAttitude === undefined) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n            return false;\n        }\n        const cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) ||\n            newAttitude.yaw !== this.m_lastAttitude.yaw ||\n            newAttitude.pitch !== this.m_lastAttitude.pitch ||\n            newAttitude.roll !== this.m_lastAttitude.roll;\n        if (cameraMoved) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n        }\n        if (cameraMoved !== this.m_cameraMovedLastFrame) {\n            if (cameraMoved) {\n                this.movementStarted();\n            }\n            this.m_cameraMovedLastFrame = cameraMoved;\n        }\n        if (cameraMoved) {\n            // Start timer\n            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;\n            this.startMovementFinishedTimer(now);\n        }\n        return this.m_cameraMovedLastFrame;\n    }\n    /**\n     * Reset the saved camera position. Next time checkCameraMoved is called, it will return\n     * `false`.\n     */\n    clear(mapView) {\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);\n        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);\n        this.m_lastAttitude = newAttitude;\n    }\n    /**\n     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.\n     */\n    forceMoved() {\n        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);\n    }\n    /**\n     * Returns `true` if the camera of this {@link MapView} is currently moving. In this case the\n     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.\n     */\n    get cameraIsMoving() {\n        return this.m_throttlingTimerId !== undefined;\n    }\n    /**\n     * Disposes resources and kills the throttling timer.\n     */\n    dispose() {\n        this.removeMovementFinishedTimer();\n        this.m_movementStartedFunc = undefined;\n        this.m_movementFinishedFunc = undefined;\n    }\n    /**\n     * Returns `true` if the camera has moved in the last frame.\n     */\n    get cameraMovedLastFrame() {\n        return this.m_cameraMovedLastFrame === true;\n    }\n    movementStarted() {\n        if (this.m_movementStartedFunc !== undefined) {\n            this.m_movementStartedFunc();\n        }\n    }\n    movementFinished() {\n        this.removeMovementFinishedTimer();\n        if (this.m_movementFinishedFunc !== undefined) {\n            this.m_movementFinishedFunc();\n        }\n    }\n    startMovementFinishedTimer(now) {\n        if (this.m_throttlingTimerId === undefined) {\n            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);\n            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);\n        }\n    }\n    removeMovementFinishedTimer() {\n        if (this.m_throttlingTimerId !== undefined) {\n            clearTimeout(this.m_throttlingTimerId);\n            this.m_throttlingTimerId = undefined;\n        }\n    }\n}\nexports.CameraMovementDetector = CameraMovementDetector;\n//# sourceMappingURL=CameraMovementDetector.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDefaultClipPlanesEvaluator = exports.FixedClipPlanesEvaluator = exports.TiltViewClipPlanesEvaluator = exports.TopViewClipPlanesEvaluator = exports.ElevationBasedClipPlanesEvaluator = exports.InterpolatedClipPlanesEvaluator = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst epsilon = 0.000001;\n/**\n * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.\n *\n * @remarks\n * At general ground distance to camera along the surface normal is used as reference point for\n * planes evaluation, where near plane distance is set as fraction of this distance refereed as\n * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],\n * which is applied to near plane and offset giving finally far plane distance.\n * This evaluator supports both planar and spherical projections, although it's behavior is\n * slightly different in each case. General algorithm sets near plane between camera and\n * ground level, while far plane is just calculated using scale and bias approach with far offset\n * and multiplier.\n * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which\n * is widely used in examples thus is still kept for backward compatibility and comparisons.\n */\nclass InterpolatedClipPlanesEvaluator {\n    constructor(nearMin = 0.1, nearMultiplier = 0.1, nearFarMultiplier = 50.0, farOffset = 200.0) {\n        this.nearMin = nearMin;\n        this.nearMultiplier = nearMultiplier;\n        this.nearFarMultiplier = nearFarMultiplier;\n        this.farOffset = farOffset;\n        this.m_tmpVectors = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tmpQuaternion = new THREE.Quaternion();\n        harp_utils_1.assert(nearMin > 0);\n        harp_utils_1.assert(nearFarMultiplier >= 0);\n        harp_utils_1.assert(farOffset >= 0);\n        this.farMin = nearMin * nearFarMultiplier + farOffset;\n    }\n    set minElevation(elevation) { }\n    get minElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    set maxElevation(elevation) { }\n    get maxElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    evaluateClipPlanes(camera, projection, elevationProvider) {\n        let nearPlane = this.nearMin;\n        let farPlane = this.farMin;\n        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n            const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n            const d = camera.position.length();\n            const alpha = Math.asin(r / d);\n            // Extract X, Y, Z axes into tmp vectors array.\n            camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);\n            // Setup quaternion based on X axis.\n            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);\n            // Acquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).\n            const fwd = this.m_tmpVectors[2].negate();\n            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].\n            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);\n            // Store camera position tmpVectors[0] and reference it with p.\n            const p = this.m_tmpVectors[0].copy(camera.position);\n            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));\n            farPlane = p.sub(camera.position).dot(fwd) + this.farOffset;\n            nearPlane = Math.max(this.nearMin, projection.groundDistance(camera.position) * this.nearMultiplier);\n        }\n        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            const groundDistance = projection.groundDistance(camera.position);\n            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);\n            // Will be already clamped to minFar due to clamping above.\n            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;\n        }\n        else {\n            harp_utils_1.assert(false, \"Unsupported projection type\");\n        }\n        const viewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farPlane\n        };\n        return viewRanges;\n    }\n}\nexports.InterpolatedClipPlanesEvaluator = InterpolatedClipPlanesEvaluator;\n/**\n * Abstract evaluator class that adds support for elevation constraints.\n *\n * @remarks\n * Classes derived from this should implement algorithms that takes into account rendered\n * features height (elevations), such as ground plane is no more flat (or spherical), but\n * contains geometry that should be overlapped by frustum planes.\n */\nclass ElevationBasedClipPlanesEvaluator {\n    constructor(maxElevation, minElevation) {\n        harp_utils_1.assert(maxElevation >= minElevation);\n        this.m_minElevation = minElevation;\n        this.m_maxElevation = maxElevation;\n    }\n    /**\n     * Set maximum elevation above sea level to be rendered.\n     *\n     * @remarks\n     * @param elevation - the elevation (altitude) value in world units (meters).\n     * @note If you set this exactly to the maximum rendered feature height (altitude above\n     * the sea, you may notice some flickering or even polygons disappearing related to rounding\n     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little\n     * bit offset to your assumed maximum elevation.\n     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values\n     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and\n     * [[EarthConstant.MAX_ELEVATION]] respectively.\n     * @see minElevation for more information about precision and rounding errors.\n     */\n    set maxElevation(elevation) {\n        this.m_maxElevation = elevation;\n        // Min elevation should be at least equal or smaller to max elevation.\n        this.m_minElevation = Math.min(elevation, this.m_minElevation);\n    }\n    /**\n     * Get maximum elevation to be covered by camera frustum.\n     */\n    get maxElevation() {\n        return this.m_maxElevation;\n    }\n    /**\n     * Set minimum elevation to be rendered, values beneath the sea level are negative.\n     *\n     * @remarks\n     * @param elevation - the minimum elevation (depression) in world units (meters).\n     * @note If you set this parameter to zero you may not see any features rendered if they are\n     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to\n     * -100m and rendered features lays exactly in such depression, you may notice that problem.\n     * The errors usually come from projection precision loss and depth buffer nature (significant\n     * precision loss closer to far plane). Thus is such cases either increase the margin (if you\n     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].\n     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes\n     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is\n     * the highest point our planet.\n     * @see https://developer.nvidia.com/content/depth-precision-visualized\n     */\n    set minElevation(elevation) {\n        this.m_minElevation = elevation;\n        // Max elevation should be at least equal or bigger than min elevation.\n        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);\n    }\n    /**\n     * Get minimum elevation to be covered by camera frustum.\n     */\n    get minElevation() {\n        return this.m_minElevation;\n    }\n}\nexports.ElevationBasedClipPlanesEvaluator = ElevationBasedClipPlanesEvaluator;\n/**\n * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.\n *\n * @remarks\n * This evaluator supports both planar and spherical projections, although it behavior is\n * slightly different in each case. General algorithm sets near plane and far plane close\n * to ground level, but taking into account maximum and minimum elevation of features on the ground.\n *\n * @note This evaluator supports only cameras which are always looking down the ground surface\n * (top-down view) along surface normal and does not preserve correct clip planes when\n * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera\n * settings.\n */\nclass TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {\n    /**\n     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea\n     * level as also minimum near plane and maximum far plane distance constraints.\n     *\n     * @remarks\n     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near\n     * and far planes to avoid flickering.\n     * @param maxElevation - defines near plane offset from the ground in the surface normal\n     * direction, positive values allows to render elevated terrain features (mountains,\n     * buildings). Defaults to Burj Khalifa building height.\n     * @param minElevation - defines far plane offset from the ground surface, negative values moves\n     * far plane below the ground level (use it to render depressions). Default zero - sea level.\n     * @param nearMin - minimum allowable near plane distance from camera, must be bigger than zero.\n     * @param nearFarMarginRatio - minimum distance between near and far plane, as a ratio of\n     * average near/far plane distance, it have to be significantly bigger than zero (especially if\n     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when\n     * rendering, or even render empty scene if frustum planes are almost equal.\n     * @param farMaxRatio - maximum ratio between ground and far plane distance, allows to limit\n     * viewing distance at overall. Have to be bigger than 1.0.\n     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation\n     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],\n     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires\n     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes\n     * anyway.\n     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and\n     * minimum renderable elevation respectively along the surface normal, when camera is\n     * constantly looking downwards (top-down view). If you need {@link ClipPlanesEvaluator} for\n     * cameras that support tilt or yaw please use {@link TiltViewClipPlanesEvaluator}.\n     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,\n     * the algorithm used there estimates distance to point on tangent where line from camera\n     * touches the sphere horizon and there is no reason to clamp it.\n     */\n    constructor(maxElevation = harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT, minElevation = 0, nearMin = 1.0, nearFarMarginRatio = 0.05, farMaxRatio = 6.0) {\n        super(maxElevation, minElevation);\n        this.nearMin = nearMin;\n        this.nearFarMarginRatio = nearFarMarginRatio;\n        this.farMaxRatio = farMaxRatio;\n        /**\n         * Helper for reducing number of objects created at runtime.\n         */\n        this.m_tmpVectors = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        /**\n         * Helper object for reducing performance impact.\n         */\n        this.m_tmpQuaternion = new THREE.Quaternion();\n        harp_utils_1.assert(nearMin > 0);\n        harp_utils_1.assert(nearFarMarginRatio > epsilon);\n        harp_utils_1.assert(farMaxRatio > 1.0);\n        const nearFarMargin = nearFarMarginRatio * nearMin;\n        this.m_minimumViewRange = {\n            near: nearMin,\n            far: nearMin + nearFarMargin,\n            minimum: this.nearMin,\n            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)\n        };\n        this.m_sphere = new THREE.Sphere(new THREE.Vector3(), harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);\n    }\n    /** @override */\n    evaluateClipPlanes(camera, projection, elevationProvider) {\n        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            return this.evaluateDistanceSphericalProj(camera, projection, elevationProvider);\n        }\n        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            return this.evaluateDistancePlanarProj(camera, projection, elevationProvider);\n        }\n        harp_utils_1.assert(false, \"Unsupported projection type\");\n        return Object.assign({}, this.minimumViewRange);\n    }\n    /**\n     * Get minimum view range that is possible to achieve with current evaluator settings.\n     * @note This value will not change after evaluator is constructed.\n     */\n    get minimumViewRange() {\n        return this.m_minimumViewRange;\n    }\n    /**\n     * Calculate camera altitude (closest distance) to ground level in world units.\n     * @param camera -\n     * @param projection -\n     */\n    getCameraAltitude(camera, projection) {\n        return projection.groundDistance(camera.position);\n    }\n    evaluateDistancePlanarProj(camera, projection, elevationProvider) {\n        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        let nearPlane = this.nearMin;\n        let farPlane = this.nearMin * this.farMaxRatio;\n        // Calculate distance to closest point on the ground.\n        const groundDistance = this.getCameraAltitude(camera, projection);\n        const farMax = groundDistance * this.farMaxRatio;\n        // We could at least try to keep margins along the eye vector (center of the view) in\n        // tact with pitch angle changes, but this does not solve all tilt angle problems,\n        // rather use more sophisticated evaluator.\n        nearPlane = groundDistance - this.maxElevation;\n        farPlane = groundDistance - this.minElevation;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.min(farPlane, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n        const viewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: Math.max(farMax, farPlane)\n        };\n        return viewRanges;\n    }\n    evaluateDistanceSphericalProj(camera, projection, elevationProvider) {\n        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        let nearPlane = this.nearMin;\n        let farPlane = this.nearMin * this.farMaxRatio;\n        // The near plane calculus is quite straight forward and works the same as for planar\n        // projections. We simply search for the closest point of the ground just above\n        // the camera, then we apply margin (elevation) to it along the sphere surface normal:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        nearPlane = cameraAltitude - this.maxElevation;\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n        let d = camera.position.length();\n        d = d === 0 ? epsilon : d;\n        if (camera.type === \"PerspectiveCamera\") {\n            // This solution computes near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n            // The far plane distance calculus requires finding the sphere tangent line that is\n            // co-linear with (goes thru) camera position, such tangent creates right angle\n            // with sphere diameter where it touches its surface (point T). Given that sphere is\n            // always at world origin and camera orbits around it we have (see\n            // #getTangentBasedFarPlane):\n            // angle(OTC) = 90\n            // sin(OCT) = sin(alpha) = r / d\n            // alpha = asin(r / d)\n            const alpha = Math.asin(r / d);\n            // If alpha it bigger than half fov angle, our visibility limit is set by tangent\n            // line, otherwise we need to find top (or right) plane intersection with sphere,\n            // which is definitely closer than the tangent point mentioned above.\n            const cam = camera;\n            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n            let halfFovAngle = THREE.MathUtils.degToRad(cam.fov / 2);\n            // If width > height, then we have to compute the horizontal FOV.\n            if (cam.aspect > 1) {\n                halfFovAngle = Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.MathUtils.degToRad(cam.fov), cam.aspect);\n            }\n            const farTangent = this.getTangentBasedFarPlane(cam, d, r, alpha);\n            farPlane =\n                halfFovAngle > alpha\n                    ? farTangent\n                    : this.getFovBasedFarPlane(cam, d, r, 2 * halfFovAngle, projection);\n        }\n        // Orthographic camera projection\n        else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n        // In extreme cases the largest depression assumed may be further than tangent\n        // based far plane distance, take it into account\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = cameraAltitude * this.farMaxRatio;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.max(farPlane, farMin);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n        const viewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farMax\n        };\n        return viewRanges;\n    }\n    /**\n     * Calculate distance from a point to the tangent point of a sphere.\n     *\n     * @remarks\n     * Returns zero if point is below surface or only very slightly above surface of sphere.\n     * @param d - Distance from point to center of sphere\n     * @param r - Radius of sphere\n     */\n    getTangentDistance(d, r) {\n        // There may be situations when maximum elevation still remains below sea level\n        // (elevation < 0) or it is negligible (elevation ~ epsilon)\n        if (d - r < epsilon) {\n            return 0;\n        }\n        // The distance to tangent point may be described as:\n        // t = sqrt(d^2 - r^2)\n        return Math.sqrt(d * d - r * r);\n    }\n    /**\n     * Calculate far plane depending on furthest visible distance from camera position.\n     *\n     * @remarks\n     * Furthest visible distance is assumed to be distance from camera to horizon\n     * plus distance from elevated geometry to horizon(so that high objects behind horizon\n     * remain visible).\n     * @param camera - The camera of the mapview\n     * @param d - Distance from camera to origin\n     * @param r - Radius of earth\n     * @param alpha - Angle between camera eye vector and tangent\n     */\n    getTangentBasedFarPlane(camera, d, r, alpha) {\n        // Find tangent point intersection distance\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,        E\n        //   ,           .           ,    . ' far + elev\n        //  ,            .   r + e   , '   /\n        // ,             .     ,  '    ,  /\n        // ,             . O '         , / te\n        // ,             | .           ,/\n        //  ,            |   .  r     ,/\n        //   ,           |      .    ,\n        //     ,         |        , '_____ far\n        //       ' -_, _ | _ ,  ' / T\n        //     near      |      /\n        //               |    / t\n        //             d |  /\n        //               |/\n        //               C\n        const t = this.getTangentDistance(d, r);\n        // Because we would like to see elevated geometry that may be visible beyond\n        // the tangent point on ground surface, we need to extend viewing distance along\n        // the tangent line by te (see graph above).\n        const te = this.getTangentDistance(r + this.maxElevation, r);\n        // Next step is to project CE vector(length t + te) onto camera eye (forward) vector\n        // to get maximum camera far plane distance.\n        //\n        // Knowing that:\n        // tangentVec.dot(cameraFwdVec) = cos(alpha) * len(tangentVec) * len(cameraFwdVec).\n        // where:\n        // ||cameraFwdVec|| == 1 ^ ||tangentVec|| == t + te\n        // Formula simplifies to:\n        const far = Math.cos(alpha) * (t + te);\n        return far;\n    }\n    getFovBasedFarPlane(camera, d, r, fovAngle, projection) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n        // Vector from camera to world center\n        const dVec = camera.position;\n        // Extract camera X, Y, Z orientation axes into tmp vectors array.\n        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);\n        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.\n        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);\n        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).\n        const cameraFwdVec = this.m_tmpVectors[2];\n        // Apply quaternion to forward vector, creating intersection vector, which is\n        // parallel to top or right frustum plane (depending on the aspect ratio).\n        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);\n        // Calculate camera to origin vector projection onto frustum plane (top or right).\n        // This gives us the length of CTA segment:\n        const cta = dVec.dot(tVec);\n        // If it is negative, it means that the dVec and the tVec points in\n        // opposite directions - there is no intersection - or intersection could\n        // potentially be behind the intersection ray's origin (camera position).\n        if (cta < 0) {\n            // Intersection points are behind camera, camera looks in wrong direction.\n            const groundDistance = this.getCameraAltitude(camera, projection);\n            // Setup far plane to maximum distance.\n            return groundDistance * this.farMaxRatio;\n        }\n        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|\n        // segment from it to get far plane distance.\n        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to\n        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:\n        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta\n        // a^2 = d^2 - cta^2\n        const a2 = dVec.dot(dVec) - cta * cta;\n        // Note that if a is greater than sphere radius the ray misses the sphere and\n        // thus there is no intersection at all.\n        const r2 = r * r;\n        harp_utils_1.assert(a2 <= r2, \"Please use this evaluator only for top view camera poses.\");\n        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle\n        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is\n        // equal to |T1TA|, and |OT0| segment is simply sphere radius.\n        // In order to find |T0TA| length we again use Pythagorean theorem, which says:\n        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a\n        // |T0TA|^2 = r^2 - a^2\n        const tota = Math.sqrt(r2 - a2);\n        // Finally our far plane (intersection point) is defined as:\n        return cta - tota;\n    }\n    getOrthoBasedFarPlane(d, r) {\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,     E\n        //   ,            .--------- ,-.'- far + elev\n        // | ,            .   r + e , `, |\n        // |,             .     , '     ,| te\n        // |,             . O '.........,|..\n        // |,             |        r    ,|  far\n        // | ,            |            , |\n        // |  ,           |           ,  | t\n        // |    ,         |        , '   |\n        // |      ' -_, _ | _ ,  '       |\n        // |    near      | \\/___________| near - elev\n        // |              |              |\n        // |            d |              |\n        // |              |              |\n        //                C\n        // The distance to tangent point may be described as:\n        const t = d;\n        // Tangent extension due to terrain elevation behind the horizon may be calculated\n        // based on the right triangle:\n        // (r+maxElev)^2 = r^2 + te^2\n        // te = sqrt((r+maxElev)^2 - r^2)\n        // although we may not calculate it if elevation is negligible:\n        const te = this.maxElevation < epsilon\n            ? 0\n            : Math.sqrt(r + this.maxElevation) * (r + this.maxElevation) - r * r;\n        // Both near and far planes distances are directly applied to frustum, because tangents'\n        // lines are parallel to camera look at vector.\n        // Now far plane distance is constituted with:\n        return t + te;\n    }\n}\nexports.TopViewClipPlanesEvaluator = TopViewClipPlanesEvaluator;\n/**\n * Evaluates camera clipping planes taking into account ground distance and camera angles.\n *\n * @remarks\n * This evaluator provides support for camera with varying tilt (pitch) angle, the angle\n * between camera __look at__ vector and the ground surface normal.\n */\nclass TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {\n    constructor() {\n        super(...arguments);\n        this.m_ray = new THREE.Ray();\n    }\n    /**\n     * Calculate the lengths of frustum planes intersection with the ground plane.\n     *\n     * @remarks\n     * This evaluates distances between eye vector (or eye plane in orthographic projection) and\n     * ground intersections of top and bottom frustum planes.\n     * @note This method assumes the world surface (ground) to be flat and\n     * works only with planar projections.\n     *\n     * @param camera - The [[THREE.Camera]] instance in use,\n     * @param projection - The geo-projection used to convert geographic to world coordinates.\n     */\n    getFrustumGroundIntersectionDist(camera, projection) {\n        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        // This algorithm computes the length of frustum planes before intersecting with a flat\n        // ground surface. Entire computation is split over two projections method and performed\n        // for top and bottom plane, with addition of terrain (ground) elevation which is taken\n        // into account.\n        // The following diagram may help explain the algorithm below.\n        //   \n        //   C\n        //   |\\\n        //   |.\\ .\n        //   | . \\  . t\n        // z |  .  \\   .c2\n        //   |  c1.  \\e ___. max elev\n        //   |     .   \\      .\n        //___|a___D1.____\\E1_____.D2______ g\n        //   C1      .     \\ __. min elev\n        //            .      \\.E2\n        //          b  .    .\n        //              . .\n        //               .\n        // Where:\n        // - C gives the camera position.\n        // - z is the height of the camera above the ground.\n        // - z1 == z2 == z, for perspective camera all planes origin its the same\n        // - a is a right angle.\n        // - e is the look at vector of the camera.\n        // - t and b are the frustum planes of the camera (top and bottom respectively).\n        // - angle between c1 to c2 is the fov.\n        // - c1, c2 - vectors from camera to the ground along frustum planes.\n        // - angles between c1 and e or e and c2 splits fov on equal halves.\n        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.\n        // - angle between z and e is the pitch of the camera.\n        // - angle between g and e is the tilt angle.\n        // - g is the ground/world surface\n        //\n        // The goal is to find distance for top/bottom planes intersections of frustum with ground\n        // plane.\n        // This are the distances from C->D1 and C->D2, and are described as\n        // c1 and c2. Then we may compensate/correct those distances with actual\n        // ground elevations, which is done by simply offsetting camera altitude, as it is\n        // opposite to elevating ground level.\n        const halfPiLimit = Math.PI / 2 - epsilon;\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        const cameraTilt = Utils_1.MapViewUtils.extractCameraTilt(camera, projection);\n        // Angle between z and c2\n        let topAngleRad;\n        // Angle between z and c1\n        let bottomAngleRad;\n        // Bottom plane origin altitude\n        let z1;\n        // Top plane origin altitude\n        let z2;\n        // For perspective projection:\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = camera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // Half fov angle in radians\n            const halfFovAngle = THREE.MathUtils.degToRad(cam.fov / 2);\n            topAngleRad = THREE.MathUtils.clamp(cameraTilt + halfFovAngle, -halfPiLimit, halfPiLimit);\n            bottomAngleRad = THREE.MathUtils.clamp(cameraTilt - halfFovAngle, -halfPiLimit, halfPiLimit);\n            z1 = z2 = cameraAltitude;\n        }\n        // For orthographic projection:\n        else {\n            const cam = camera;\n            // For orthogonal camera projections we may simply ignore FOV and use 0 for FOV\n            // the top/bottom planes are simply parallel to the eye vector:\n            topAngleRad = bottomAngleRad = cameraTilt;\n            // Although the ray origin is not always the same (eye position) as for\n            // the perspective projections, thus we need to compensate for ortho-cube\n            // dimensions:\n            // sin(tilt) = zc2 / top\n            // sin(tilt) = zc1 / bottom\n            // zc2 = sin(tilt) * top\n            // zc1 = sin(tilt) * bottom\n            const sinBeta = Math.sin(cameraTilt);\n            z2 = cameraAltitude + sinBeta * cam.top;\n            z1 = cameraAltitude - sinBeta * cam.bottom;\n        }\n        // Distance along the top plane to the ground - c2\n        // cos(topAngle) = (z2 - minElev) / |c2|\n        // |c2| = (z2 - minElev) / cos(topAngle)\n        const topDist = (z2 - this.minElevation) / Math.cos(topAngleRad);\n        // Distance along the bottom plane to the ground - c1\n        // cos(bottomAngle) = (z - minElev) / |c1|\n        // |c1| = (z - minElev) / cos(bottomAngle)\n        const bottomDist = (z1 - this.maxElevation) / Math.cos(bottomAngleRad);\n        return {\n            top: Math.max(topDist, 0),\n            bottom: Math.max(bottomDist, 0)\n        };\n    }\n    /** @override */\n    evaluateDistancePlanarProj(camera, projection, elevationProvider) {\n        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        const viewRanges = Object.assign({}, this.minimumViewRange);\n        // Generally near/far planes are set to keep top/bottom planes intersection distance.\n        // Then elevations margins are applied. Here margins (min/max elevations) are meant to\n        // be defined as distance along the ground normal vector thus during camera\n        // tilt they may affect near/far planes positions differently.\n        const planesDist = this.getFrustumGroundIntersectionDist(camera, projection);\n        // Project clipping plane distances for the top/bottom frustum planes (edges), but\n        // only if we deal with perspective camera type, this step is not required\n        // for orthographic projections, cause all clip planes are parallel to eye vector.\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = camera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // Half fov angle in radians\n            const halfFovAngle = THREE.MathUtils.degToRad(cam.fov / 2);\n            const cosHalfFov = Math.cos(halfFovAngle);\n            // cos(halfFov) = near / bottomDist\n            // near = cos(halfFov) * bottomDist\n            viewRanges.near = planesDist.bottom * cosHalfFov;\n            // cos(halfFov) = far / topDist\n            // far = cos(halfFov) * topDist\n            viewRanges.far = planesDist.top * cosHalfFov;\n        }\n        // Orthographic camera projection.\n        else {\n            viewRanges.near = planesDist.bottom;\n            viewRanges.far = planesDist.top;\n        }\n        // Compute target (focus) point distance.\n        const { distance } = Utils_1.MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider);\n        // Clamp values to constraints.\n        const farMax = distance * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = Math.min(viewRanges.far, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n        return viewRanges;\n    }\n    /** @override */\n    evaluateDistanceSphericalProj(camera, projection, elevationProvider) {\n        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        const viewRanges = Object.assign({}, this.minimumViewRange);\n        // Near plane calculus is pretty straightforward and does not depend on camera tilt:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        viewRanges.near = cameraAltitude - this.maxElevation;\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n        const cameraToOrigin = this.m_tmpVectors[0].copy(camera.position).negate();\n        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n        const d = cameraToOrigin.length();\n        let farPlane;\n        if (camera instanceof THREE.PerspectiveCamera) {\n            const halfVerticalFovAngle = THREE.MathUtils.degToRad(camera.fov / 2);\n            // Ratio of the depth of the camera compared to the distance between the center of the\n            // screen and the middle of the top of the screen (here set to be value 1). We just need\n            // this to be a ratio because we are interested in just computing the direction of the\n            // upper right corner and not any specific length.\n            const zLength = 1 / Math.tan(halfVerticalFovAngle);\n            // Camera space direction vector along the top right frustum edge (of the camera).\n            const upperRightDirection = this.m_tmpVectors[2];\n            upperRightDirection.set(camera.aspect, 1, -zLength);\n            // Now we need to account for camera tilt and frustum volume, so the longest\n            // frustum edge does not intersects with sphere, it takes the worst case\n            // scenario regardless of camera tilt, so may be improved little bit with more\n            // sophisticated algorithm.\n            viewRanges.near *= Math.cos(halfVerticalFovAngle);\n            // Step-wise calculate angle between camera eye vector and tangent\n            // Calculate angle between surface normal(below camera position) and tangent.\n            const alpha = Math.asin(r / d);\n            // Calculate angle between look at and surface normal(below camera position)\n            const cameraPitch = this.getCameraPitch(cameraToOrigin, camera);\n            // Calculate angle between camera eye vector and tangent (center of the top of the\n            // screen)\n            const modifiedAlpha = Math.abs(alpha - cameraPitch);\n            // Transform the vector to world space\n            upperRightDirection.applyMatrix4(camera.matrixWorld);\n            // Transform the vector to be relative from the camera\n            upperRightDirection.sub(camera.position);\n            // Ray must be given normalized vector, otherwise it won't work\n            upperRightDirection.normalize();\n            this.m_ray.set(camera.position, upperRightDirection);\n            // World space intersection with sphere or null\n            const worldSpaceFrustumSphereIntersection = this.m_ray.intersectSphere(this.m_sphere, this.m_tmpVectors[0]);\n            // Use tangent based far plane if horizon is within field of view\n            farPlane =\n                worldSpaceFrustumSphereIntersection === null\n                    ? this.getTangentBasedFarPlane(camera, d, r, modifiedAlpha)\n                    : this.getFarPlaneBasedOnFovIntersection(worldSpaceFrustumSphereIntersection, camera);\n        }\n        else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n        viewRanges.far = farPlane;\n        // Compute the focus point (target) distance for current camera and projection setup,\n        // in a same way the MapView component does.\n        const { distance } = Utils_1.MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider);\n        // Apply the constraints.\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = distance * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = THREE.MathUtils.clamp(viewRanges.far, farMin, farMax);\n        // Apply margins.\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);\n        // Set minimum and maximum view range.\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n        return viewRanges;\n    }\n    // Computes the far plane given the point where the upper right edg of the FOV intersects with\n    // the earth's sphere projected (dot product) along the camera's view direction.\n    getFarPlaneBasedOnFovIntersection(worldSpaceIntersection, camera) {\n        const toIntersection = this.m_tmpVectors[1];\n        toIntersection.copy(worldSpaceIntersection);\n        toIntersection.sub(camera.position);\n        const cameraDirection = this.m_tmpVectors[2];\n        camera.getWorldDirection(cameraDirection);\n        cameraDirection.normalize();\n        return toIntersection.dot(cameraDirection);\n    }\n    getCameraPitch(cameraToOrigin, camera) {\n        cameraToOrigin.normalize();\n        const lookAt = camera.getWorldDirection(this.m_tmpVectors[1]).normalize();\n        const cosAlpha1 = cameraToOrigin.dot(lookAt);\n        const cameraPitch = Math.acos(THREE.MathUtils.clamp(cosAlpha1, -1.0, 1.0));\n        return cameraPitch;\n    }\n}\nexports.TiltViewClipPlanesEvaluator = TiltViewClipPlanesEvaluator;\n/**\n * Provides the most basic evaluation concept giving fixed values with some constraints.\n */\nclass FixedClipPlanesEvaluator {\n    constructor(minNear = 1, minFarOffset = 10) {\n        this.minNear = minNear;\n        this.minFarOffset = minFarOffset;\n        this.minFar = minNear + minFarOffset;\n        this.m_nearPlane = minNear;\n        this.m_farPlane = this.minFar;\n    }\n    get nearPlane() {\n        return this.m_nearPlane;\n    }\n    set nearPlane(fixedNear) {\n        this.invalidatePlanes(fixedNear, this.m_farPlane);\n    }\n    get farPlane() {\n        return this.m_farPlane;\n    }\n    set farPlane(fixedFar) {\n        this.invalidatePlanes(this.m_nearPlane, fixedFar);\n    }\n    set minElevation(elevation) { }\n    get minElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    set maxElevation(elevation) { }\n    get maxElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    /** @override */\n    evaluateClipPlanes(camera, projection, elevationProvider) {\n        // We do not need to perform actual evaluation cause results are precomputed and\n        // kept stable until somebody changes the properties.\n        const viewRanges = {\n            near: this.m_nearPlane,\n            far: this.m_farPlane,\n            minimum: this.minNear,\n            maximum: this.m_farPlane\n        };\n        return viewRanges;\n    }\n    invalidatePlanes(near, far) {\n        // When clamping prefer to extend far plane at about minimum distance, giving\n        // near distance setup priority over far.\n        const nearDist = Math.max(this.minNear, near);\n        const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);\n        this.m_nearPlane = nearDist;\n        this.m_farPlane = farDist;\n    }\n}\nexports.FixedClipPlanesEvaluator = FixedClipPlanesEvaluator;\n/**\n * Factory function that creates default {@link ClipPlanesEvaluator}\n * that calculates near plane based\n * on ground distance and camera orientation.\n *\n * Creates {@link TiltViewClipPlanesEvaluator}.\n * @internal\n */\nconst createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();\nexports.createDefaultClipPlanesEvaluator = createDefaultClipPlanesEvaluator;\n//# sourceMappingURL=ClipPlanesEvaluator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ColorCache.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ColorCache.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorCache = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Use `ColorCache` to reuse a color specified by name and save allocation as well as\n * setup time.\n *\n * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.\n */\nclass ColorCache {\n    constructor() {\n        this.m_map = new Map();\n    }\n    /**\n     * Return instance of `ColorCache`.\n     */\n    static get instance() {\n        return this.m_instance;\n    }\n    /**\n     * Returns the color for the given `colorCode`. This function may reuse a previously generated\n     * color, so you cannot modify the contents of the color.\n     *\n     * @param colorCode - ThreeJS color code or name. You must provide a valid color code or name,\n     * as this function does not do any validation.\n     */\n    getColor(colorCode) {\n        if (typeof colorCode === \"number\") {\n            colorCode = \"#\" + colorCode.toString(16).padStart(6, \"0\");\n        }\n        let color = this.m_map.get(colorCode);\n        if (color !== undefined) {\n            return color;\n        }\n        color = new THREE.Color(colorCode);\n        this.m_map.set(colorCode, color);\n        return color;\n    }\n    /**\n     * Returns the number of elements in the cache.\n     */\n    get size() {\n        return this.m_map.size;\n    }\n    /**\n     * Clears the cache. Only references to the THREE.Color are removed from the cache.\n     * Consequently, clearing the cache does not cause any negative visual impact.\n     */\n    clear() {\n        this.m_map.clear();\n    }\n}\nexports.ColorCache = ColorCache;\nColorCache.m_instance = new ColorCache();\n//# sourceMappingURL=ColorCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ColorCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConcurrentDecoderFacade = void 0;\nconst ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ \"./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js\");\nconst WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js\");\n/**\n * Default concurrent decoder helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to {@link WorkerBasedDecoder}s for data sources.\n */\nclass ConcurrentDecoderFacade {\n    /**\n     * Returns a {@link WorkerBasedDecoder} instance.\n     *\n     * @param decoderServiceType - The name of the decoder service type.\n     * @param scriptUrl - The optional URL with the workers' script.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getTileDecoder(decoderServiceType, scriptUrl, workerCount) {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n        return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);\n    }\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl - The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl, workerCount) {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n    /**\n     * Destroys this [[ConcurrentDecoderFacade]] if all of the [[ConcurrentWorkerSet]]s are\n     * terminated.\n     */\n    static destroyIfTerminated() {\n        let allWorkerSetsTerminated = true;\n        Object.keys(this.workerSets).forEach(name => {\n            if (!this.workerSets[name].terminated) {\n                allWorkerSetsTerminated = false;\n            }\n        });\n        if (allWorkerSetsTerminated) {\n            ConcurrentDecoderFacade.destroy();\n        }\n    }\n}\nexports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;\n/**\n * The URL containing a script to fall back (default) to when looking for worker sets\n * and decoders.\n */\nConcurrentDecoderFacade.defaultScriptUrl = \"./decoder.bundle.js\";\n/**\n * The default number of workers.\n */\nConcurrentDecoderFacade.defaultWorkerCount = undefined;\n/**\n * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n */\nConcurrentDecoderFacade.workerSets = {};\n//# sourceMappingURL=ConcurrentDecoderFacade.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConcurrentTilerFacade = void 0;\nconst ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ \"./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js\");\nconst WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js\");\n/**\n * Default concurrent tiler helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to {@link WorkerBasedTiler}s for data sources.\n */\nclass ConcurrentTilerFacade {\n    /**\n     * Returns a {@link WorkerBasedTiler} instance.\n     *\n     * @param tilerServiceType - The name of the tiler service type.\n     * @param scriptUrl - The optional URL with the workers' script.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getTiler(tilerServiceType, scriptUrl, workerCount) {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n        return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);\n    }\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl - The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl, workerCount) {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n    /**\n     * Destroys this [[ConcurrentTilerFacade]] if all of the [[ConcurrentWorkerSet]]s are\n     * terminated.\n     */\n    static destroyIfTerminated() {\n        let allWorkerSetsTerminated = true;\n        Object.keys(this.workerSets).forEach(name => {\n            if (!this.workerSets[name].terminated) {\n                allWorkerSetsTerminated = false;\n            }\n        });\n        if (allWorkerSetsTerminated) {\n            ConcurrentTilerFacade.destroy();\n        }\n    }\n}\nexports.ConcurrentTilerFacade = ConcurrentTilerFacade;\n/**\n * The URL containing a script to fall back (default) to when looking for worker sets\n * and tilers.\n */\nConcurrentTilerFacade.defaultScriptUrl = \"./decoder.bundle.js\";\n/**\n * The default number of workers.\n */\nConcurrentTilerFacade.defaultWorkerCount = 1;\n/**\n * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n */\nConcurrentTilerFacade.workerSets = {};\n//# sourceMappingURL=ConcurrentTilerFacade.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConcurrentWorkerSet = exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = exports.isLoggingMessage = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ \"./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"ConcurrentWorkerSet\");\nfunction isLoggingMessage(message) {\n    return message && typeof message.level === \"number\" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;\n}\nexports.isLoggingMessage = isLoggingMessage;\n/**\n * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.\n */\nconst DEFAULT_WORKER_COUNT = 2;\n/**\n * The default timeout for first message from worker.\n *\n * @see {@link WorkerLoader.startWorker}\n */\nexports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;\n/**\n * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances\n * running in Web Workers.\n *\n * Starts and manages a certain number of web workers and provides a means to communicate\n * with them using various communication schemes, such as:\n *  - [[addEventListener]] : receive a unidirectional messages\n *  - [[broadcastMessage]] : send unidirectional broadcast message\n *  - [[invokeRequest]] : send a request that waits for a response, with load balancing\n *  - [[postMessage]] : send a unidirectional message, with load balancing\n *\n * The request queue holds all requests before they are stuffed into the event queue, allows for\n * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage\n * when they return their previous result, or if they are idle. When they are idle, they are stored\n * in m_availableWorkers.\n */\nclass ConcurrentWorkerSet {\n    /**\n     * Creates a new `ConcurrentWorkerSet`.\n     *\n     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided\n     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in\n     * `navigator.hardwareConcurrency` is used instead.\n     *\n     * The worker set is implicitly started when constructed.\n     */\n    constructor(m_options) {\n        this.m_options = m_options;\n        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create(\"WorkerChannel\");\n        this.m_eventListeners = new Map();\n        this.m_workers = new Array();\n        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce\n        // memory consumption in idle workers.\n        this.m_availableWorkers = new Array();\n        this.m_workerPromises = new Array();\n        this.m_readyPromises = new Map();\n        this.m_requests = new Map();\n        this.m_workerRequestQueue = [];\n        this.m_nextMessageId = 0;\n        this.m_stopped = true;\n        this.m_referenceCount = 0;\n        /**\n         * Handles messages received from workers. This method is protected so that the message\n         * reception can be simulated through an extended class, to avoid relying on real workers.\n         *\n         * @param workerId - The workerId of the web worker.\n         * @param event - The event to dispatch.\n         */\n        this.onWorkerMessage = (workerId, event) => {\n            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {\n                const response = event.data;\n                if (response.messageId === null) {\n                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);\n                    return;\n                }\n                const entry = this.m_requests.get(response.messageId);\n                if (entry === undefined) {\n                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);\n                    return;\n                }\n                if (workerId >= 0 && workerId < this.m_workers.length) {\n                    const worker = this.m_workers[workerId];\n                    this.m_availableWorkers.push(worker);\n                    // Check if any new work has been put into the queue.\n                    this.checkWorkerRequestQueue();\n                }\n                else {\n                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);\n                }\n                if (response.errorMessage !== undefined) {\n                    const error = new Error(response.errorMessage);\n                    if (response.errorStack !== undefined) {\n                        error.stack = response.errorStack;\n                    }\n                    entry.resolver(error);\n                }\n                else {\n                    entry.resolver(undefined, response.response);\n                }\n            }\n            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {\n                const readyPromise = this.getReadyPromise(event.data.service);\n                if (++readyPromise.count === this.m_workerPromises.length) {\n                    readyPromise.resolve();\n                }\n            }\n            else if (isLoggingMessage(event.data)) {\n                switch (event.data.level) {\n                    case harp_utils_1.LogLevel.Trace:\n                        this.m_workerChannelLogger.trace(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Debug:\n                        this.m_workerChannelLogger.debug(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Log:\n                        this.m_workerChannelLogger.log(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Info:\n                        this.m_workerChannelLogger.info(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Warn:\n                        this.m_workerChannelLogger.warn(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Error:\n                        this.m_workerChannelLogger.error(...event.data.message);\n                        break;\n                }\n            }\n            else {\n                this.eventHandler(event);\n            }\n        };\n        this.start();\n    }\n    /**\n     * Adds an external reference and increments the internal reference counter by one.\n     *\n     * To implement a reference-count based automatic resource cleanup, use this function with\n     * [[removeReference]].\n     */\n    addReference() {\n        this.m_referenceCount += 1;\n        if (this.m_referenceCount === 1 && this.m_stopped) {\n            this.start();\n        }\n    }\n    /**\n     * Decrements the internal reference counter by 1.\n     *\n     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the\n     * resources.\n     *\n     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.\n     */\n    removeReference() {\n        this.m_referenceCount -= 1;\n        if (this.m_referenceCount === 0) {\n            this.destroy();\n        }\n    }\n    /**\n     * Starts workers.\n     *\n     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.\n     *\n     * Note: The worker set is implicitly started on construction - no need to call [[start]] on\n     * fresh instance.\n     *\n     * @param options - optional, new worker set options\n     */\n    start(options) {\n        if (options !== undefined) {\n            this.m_options = options;\n        }\n        if (!this.m_stopped) {\n            throw new Error(\"ConcurrentWorker set already started\");\n        }\n        this.m_workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== \"undefined\" && navigator.hardwareConcurrency !== undefined\n            ? // We need to have at least one worker\n                THREE.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2)\n            : undefined, DEFAULT_WORKER_COUNT);\n        // Initialize the workers. The workers now have an ID to identify specific workers and\n        // handle their busy state.\n        const timeout = harp_utils_1.getOptionValue(this.m_options.workerConnectionTimeout, exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT);\n        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {\n            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(worker => {\n                const listener = (evt) => {\n                    this.onWorkerMessage(workerId, evt);\n                };\n                worker.addEventListener(\"message\", listener);\n                this.m_workers.push(worker);\n                this.m_availableWorkers.push(worker);\n                return {\n                    worker,\n                    listener\n                };\n            });\n            this.m_workerPromises.push(workerPromise);\n        }\n        this.m_stopped = false;\n    }\n    /**\n     * The number of workers started for this worker set. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount() {\n        return this.m_workerCount;\n    }\n    /**\n     * Stops workers.\n     *\n     * Waits for all pending requests to be finished and stops all workers.\n     *\n     * Use [[start]] to start this worker again.\n     *\n     * @returns `Promise` that resolves when all workers are destroyed.\n     */\n    async stop() {\n        this.m_stopped = true;\n        await this.waitForAllResponses().then(() => {\n            this.terminateWorkers();\n        });\n    }\n    /**\n     * Destroys all workers immediately.\n     *\n     * Resolves all pending request promises with a `worker destroyed` error.\n     *\n     * Use [[start]] to start this worker again.\n     */\n    destroy() {\n        this.m_stopped = true;\n        // respond with all pending request\n        this.m_requests.forEach(entry => {\n            entry.resolver(new Error(\"worker destroyed\"));\n        });\n        this.m_requests.clear();\n        this.m_workerRequestQueue = [];\n        this.terminateWorkers();\n        // clean other stuff\n        this.m_eventListeners.clear();\n    }\n    /**\n     * Is `true` if the workers have been terminated.\n     */\n    get terminated() {\n        return this.m_workers.length === 0;\n    }\n    /**\n     * Waits for `service` to be initialized in all workers.\n     *\n     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that\n     * it has started successfully. This method resolves when all workers in a set have\n     * `service` initialized.\n     *\n     * Promise is rejected if any of worker fails to start.\n     *\n     * @param serviceId - The service identifier.\n     */\n    async connect(serviceId) {\n        this.ensureStarted();\n        await Promise.all(this.m_workerPromises);\n        return await this.getReadyPromise(serviceId).promise;\n    }\n    /**\n     * Registers an event listener for events that originated in a web worker, for a given\n     * `serviceId`. You can only set one event listener per `serviceId`.\n     *\n     * @param serviceId - The service to listen to.\n     * @param callback - The callback to invoke for matching events.\n     */\n    addEventListener(serviceId, callback) {\n        this.m_eventListeners.set(serviceId, callback);\n    }\n    /**\n     * Removes a previously set event listener for the given `serviceId`.\n     *\n     * @param serviceId - The service from which to remove the event listeners.\n     */\n    removeEventListener(serviceId) {\n        this.m_eventListeners.delete(serviceId);\n    }\n    /**\n     * Invokes a request that expects a response from a random worker.\n     *\n     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from\n     * workers. Use this function when interfacing with \"RPC-like\" calls to services.\n     *\n     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request - The request to process.\n     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.\n     * @param requestController - An optional [[RequestController]] to store state of cancelling.\n     *\n     * @returns A `Promise` that resolves with a response from the service.\n     */\n    invokeRequest(serviceId, request, transferList, requestController) {\n        this.ensureStarted();\n        const messageId = this.m_nextMessageId++;\n        let resolver;\n        const promise = new Promise((resolve, reject) => {\n            resolver = (error, response) => {\n                this.m_requests.delete(messageId);\n                if (error !== undefined) {\n                    reject(error);\n                }\n                else {\n                    resolve(response);\n                }\n            };\n        });\n        this.m_requests.set(messageId, {\n            promise,\n            resolver: resolver\n        });\n        const message = {\n            service: serviceId,\n            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,\n            messageId,\n            request\n        };\n        this.postRequestMessage(message, transferList, requestController);\n        return promise;\n    }\n    /**\n     * Invokes a request that expects responses from all workers.\n     *\n     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching\n     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers\n     * before proceeding (like synchronous worker service creation).\n     *\n     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request - The request to process.\n     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.\n     *\n     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified\n     * order).\n     */\n    broadcastRequest(serviceId, request, transferList) {\n        const promises = [];\n        for (const worker of this.m_workers) {\n            const messageId = this.m_nextMessageId++;\n            let resolver;\n            const promise = new Promise((resolve, reject) => {\n                resolver = (error, response) => {\n                    this.m_requests.delete(messageId);\n                    if (error !== undefined) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(response);\n                    }\n                };\n            });\n            promises.push(promise);\n            this.m_requests.set(messageId, {\n                promise,\n                resolver: resolver\n            });\n            const message = {\n                service: serviceId,\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,\n                messageId,\n                request\n            };\n            if (transferList !== undefined) {\n                worker.postMessage(message, transferList);\n            }\n            else {\n                worker.postMessage(message);\n            }\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * Posts a message to all workers.\n     *\n     * @param message - The message to send.\n     * @param buffers - Optional buffers to transfer to the workers.\n     */\n    broadcastMessage(message, buffers) {\n        this.ensureStarted();\n        if (buffers !== undefined) {\n            this.m_workers.forEach(worker => worker.postMessage(message, buffers));\n        }\n        else {\n            this.m_workers.forEach(worker => worker.postMessage(message));\n        }\n    }\n    /**\n     * The size of the request queue for debugging and profiling.\n     */\n    get requestQueueSize() {\n        return this.m_workerRequestQueue.length;\n    }\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numWorkers() {\n        return this.m_workers.length;\n    }\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numIdleWorkers() {\n        return this.m_availableWorkers.length;\n    }\n    /**\n     * Subclasses must call this function when a worker emits an event.\n     *\n     * @param event - The event to dispatch.\n     */\n    eventHandler(event) {\n        if (typeof event.data.type !== \"string\") {\n            return; // not an event generated by us, ignore.\n        }\n        this.dispatchEvent(event.data.type, event);\n    }\n    /**\n     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is\n     * available, the request is put into a queue.\n     *\n     * @param message - The message to send.\n     * @param buffers - Optional buffers to transfer to the worker.\n     * @param requestController - An optional [[RequestController]] to store state of cancelling.\n     */\n    postRequestMessage(message, buffers, requestController) {\n        this.ensureStarted();\n        if (this.m_workers.length === 0) {\n            throw new Error(\"ConcurrentWorkerSet#postMessage: no workers started\");\n        }\n        // Check if the requestController has received the abort signal, in which case the request\n        // is ignored.\n        if (requestController !== undefined && requestController.signal.aborted) {\n            const entry = this.m_requests.get(message.messageId);\n            if (entry === undefined) {\n                logger.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);\n                return;\n            }\n            const err = new Error(\"Aborted\");\n            err.name = \"AbortError\";\n            entry.resolver(err, undefined);\n            return;\n        }\n        if (this.m_availableWorkers.length > 0) {\n            const worker = this.m_availableWorkers.pop();\n            if (buffers !== undefined) {\n                worker.postMessage(message, buffers);\n            }\n            else {\n                worker.postMessage(message);\n            }\n        }\n        else {\n            // We need a priority to keep sorting stable, so we have to add a RequestController.\n            if (requestController === undefined) {\n                requestController = new harp_datasource_protocol_1.RequestController(0);\n            }\n            if (requestController.priority === 0) {\n                // If the requests do not get a priority, they should keep their sorting order.\n                requestController.priority = -this.m_nextMessageId;\n            }\n            this.m_workerRequestQueue.unshift({\n                message,\n                buffers,\n                requestController\n            });\n        }\n    }\n    ensureStarted() {\n        if (this.m_stopped) {\n            throw new Error(\"ConcurrentWorkerSet stopped\");\n        }\n    }\n    async waitForAllResponses() {\n        const promises = new Array();\n        this.m_requests.forEach(entry => {\n            promises.push(entry.promise);\n        });\n        await Promise.all(promises);\n    }\n    dispatchEvent(id, message) {\n        const callback = this.m_eventListeners.get(id);\n        if (callback === undefined) {\n            return;\n        } // unknown event, ignore.\n        callback(message);\n    }\n    terminateWorkers() {\n        // terminate all workers\n        this.m_workerPromises.forEach(workerPromise => {\n            workerPromise.then(workerEntry => {\n                if (workerEntry === undefined) {\n                    return;\n                }\n                workerEntry.worker.removeEventListener(\"message\", workerEntry.listener);\n                workerEntry.worker.terminate();\n            });\n        });\n        this.m_workers = [];\n        this.m_workerPromises = [];\n        this.m_availableWorkers = [];\n        this.m_readyPromises.clear();\n    }\n    getReadyPromise(id) {\n        const readyPromise = this.m_readyPromises.get(id);\n        if (readyPromise !== undefined) {\n            return readyPromise;\n        }\n        const newPromise = {\n            count: 0,\n            promise: undefined,\n            resolve: () => {\n                /* placeholder */\n            },\n            reject: (error) => {\n                newPromise.error = error;\n            },\n            error: undefined\n        };\n        newPromise.promise = new Promise((resolve, reject) => {\n            const that = newPromise;\n            if (that.error !== undefined) {\n                reject(that.error);\n            }\n            else if (that.count === this.m_workerPromises.length) {\n                resolve();\n            }\n            that.resolve = resolve;\n            that.reject = reject;\n        });\n        this.m_readyPromises.set(id, newPromise);\n        return newPromise;\n    }\n    /**\n     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,\n     * they will be executed with postRequestMessage. The requests in the queue are sorted before\n     * the request with the highest priority is selected for processing.\n     */\n    checkWorkerRequestQueue() {\n        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {\n            return;\n        }\n        this.m_workerRequestQueue.sort((a, b) => {\n            return a.requestController.priority - b.requestController.priority;\n        });\n        // Get the request with the highest priority and send it (again).\n        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {\n            const request = this.m_workerRequestQueue.pop();\n            this.postRequestMessage(request.message, request.buffers, request.requestController);\n        }\n    }\n}\nexports.ConcurrentWorkerSet = ConcurrentWorkerSet;\n//# sourceMappingURL=ConcurrentWorkerSet.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DataSource.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DataSource.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataSource = void 0;\nconst ExprPool_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ExprPool */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"DataSource\");\n/**\n * Derive a class from `DataSource` to contribute data and geometries to the {@link MapView}.\n */\nclass DataSource extends THREE.EventDispatcher {\n    /**\n     * Constructs a new `DataSource`.\n     *\n     * @param options - The options to create the data source.\n     */\n    constructor(options = {}) {\n        super();\n        /**\n         * Keep the update event here to avoid a global reference to the datasource (and thus prevent garbage collection).\n         */\n        this.UPDATE_EVENT = { type: \"update\" };\n        /**\n         * Set to `true` if this `DataSource` is enabled; `false` otherwise.\n         */\n        this.enabled = true;\n        /**\n         * Set to `true` if the {@link MapView} can cache tiles produced by this `DataSource`.\n         */\n        this.cacheable = false;\n        /**\n         * Set to `true` if the loader should be used to get the tile contents.\n         */\n        this.useGeometryLoader = false;\n        /**\n         * Whether the datasource should have a ground plane (this plane covers the tile entirely and\n         * has the minimum possible renderOrder), this can be required in some cases when fallback\n         * parent tiles need to be covered by the children, otherwise the content will overlap.\n         * Default is false\n         */\n        this.addGroundPlane = false;\n        /**\n         * The minimum zoom level at which data is available.\n         */\n        this.minDataLevel = 1;\n        /**\n         * The maximum zoom level at which data is available.\n         */\n        this.maxDataLevel = 20;\n        /**\n         * The minimum zoom level at which {@link DataSource} is displayed.\n         */\n        this.minDisplayLevel = 1;\n        /**\n         * The maximum zoom level at which {@link DataSource} is displayed.\n         */\n        this.maxDisplayLevel = 20;\n        this.allowOverlappingTiles = true;\n        this.enablePicking = true;\n        /**\n         * Overrides the default rendering order of this `DataSource`.\n         *\n         * @remarks\n         * When `dataSourceOrder` is defined, all the objects created by this `DataSource`\n         * will be rendered on top of the objects created by other `DataSource`s with\n         * lower `dataSourceOrder` values.\n         *\n         * @defaultValue undefined\n         */\n        this.dataSourceOrder = 0;\n        /**\n         * @internal\n         * @hidden\n         */\n        this.exprPool = new ExprPool_1.ExprPool();\n        /**\n         * Current value of [[maxGeometryHeight]] property.\n         */\n        this.m_maxGeometryHeight = 0;\n        /**\n         * Current value of [[minGeometryHeight]] property.\n         */\n        this.m_minGeometryHeight = 0;\n        /**\n         * Storage level offset applied to this `DataSource`.\n         */\n        this.m_storageLevelOffset = 0;\n        this.m_featureStateMap = new Map();\n        let { name } = options;\n        const { styleSetName, languages, minZoomLevel, maxZoomLevel, minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset, allowOverlappingTiles, enablePicking, minGeometryHeight, maxGeometryHeight, dataSourceOrder } = options;\n        if (name === undefined || name.length === 0) {\n            name = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;\n        }\n        this.name = name;\n        this.styleSetName = styleSetName;\n        if (languages !== undefined) {\n            this.languages = languages;\n        }\n        if (minDataLevel !== undefined) {\n            this.minDataLevel = minDataLevel;\n        }\n        if (maxDataLevel !== undefined) {\n            this.maxDataLevel = maxDataLevel;\n        }\n        if (minZoomLevel !== undefined) {\n            this.minZoomLevel = minZoomLevel;\n        }\n        if (maxZoomLevel !== undefined) {\n            this.maxZoomLevel = maxZoomLevel;\n        }\n        if (minDisplayLevel !== undefined) {\n            this.minDisplayLevel = minDisplayLevel;\n        }\n        if (maxDisplayLevel !== undefined) {\n            this.maxDisplayLevel = maxDisplayLevel;\n        }\n        if (storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = storageLevelOffset;\n        }\n        if (allowOverlappingTiles !== undefined) {\n            this.allowOverlappingTiles = allowOverlappingTiles;\n        }\n        if (enablePicking !== undefined) {\n            this.enablePicking = enablePicking;\n        }\n        if (minGeometryHeight !== undefined) {\n            this.minGeometryHeight = minGeometryHeight;\n        }\n        if (maxGeometryHeight !== undefined) {\n            this.maxGeometryHeight = maxGeometryHeight;\n        }\n        if (dataSourceOrder) {\n            this.dataSourceOrder = dataSourceOrder;\n        }\n    }\n    /**\n     * Gets the state of the given feature id.\n     *\n     * @param featureId - The id of the feature.\n     */\n    getFeatureState(featureId) {\n        return this.m_featureStateMap.get(featureId);\n    }\n    /**\n     * Clears the state of all the features of this {@link DataSource}.\n     */\n    clearFeatureState() {\n        this.m_featureStateMap.clear();\n    }\n    /**\n     * Sets the state of the given feature id.\n     *\n     * ```typescript\n     * dataSource.setFeatureState(featureId, { enabled: true });\n     * ```\n     *\n     * @param featureId - The id of the feature.\n     * @param state - The new state of the feature.\n     */\n    setFeatureState(featureId, state) {\n        this.m_featureStateMap.set(featureId, state);\n    }\n    /**\n     * Removes the state associated to the given feature.\n     *\n     * @param featureId - The id of the feature.\n     */\n    removeFeatureState(featureId) {\n        this.m_featureStateMap.delete(featureId);\n    }\n    /**\n     * Returns the name of the [[StyleSet]] to use for the decoding.\n     */\n    get styleSetName() {\n        return this.m_styleSetName;\n    }\n    /**\n     * Sets the name of the [[StyleSet]] to use for the decoding.\n     * If this {@link DataSource} is already\n     * attached to a {@link MapView}, this setter then reapplies\n     * [[StyleSet]] with this name found in\n     * {@link MapView}s theme.\n     */\n    set styleSetName(styleSetName) {\n        if (styleSetName !== this.m_styleSetName) {\n            this.m_styleSetName = styleSetName;\n            this.clearCache();\n            this.requestUpdate();\n        }\n    }\n    /**\n     * Destroys this `DataSource`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Purges all the caching done by this `DataSource`\n     */\n    clearCache() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Boolean which says whether a {@link DataSource} produces\n     * tiles that fully cover the tile, i.e.\n     * tiles underneath are completely hidden. Must be\n     * overridden for {@link DataSource}'s that don't\n     * have a ground plane, but which still fully\n     * cover the tile, e.g. web tiles.\n     */\n    isFullyCovering() {\n        return this.addGroundPlane;\n    }\n    /**\n     * Returns `true` if this `DataSource` is ready\n     * and the {@link MapView} can invoke `getTile()` to\n     * start requesting data.\n     */\n    ready() {\n        return true;\n    }\n    /**\n     * The {@link MapView} that is holding this `DataSource`.\n     */\n    get mapView() {\n        if (this.m_mapView === undefined) {\n            throw new Error(\"This DataSource was not added to MapView\");\n        }\n        return this.m_mapView;\n    }\n    /**\n     * The {@link @here/harp-geoutils#Projection} used by\n     * the {@link MapView} that is holding this `DataSource`.\n     *\n     * An `Error` is thrown if you call this method\n     * before this `DataSource` has been added\n     * to a {@link MapView}.\n     */\n    get projection() {\n        return this.mapView.projection;\n    }\n    /**\n     * This method is called when the `DataSource` is added to a {@link MapView}. Override this\n     * method to provide any custom initialization, such as, to establish a network connection,\n     * or to initialize complex data structures.\n     */\n    async connect() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * This method is called when this `DataSource` is added to a {@link MapView}.\n     *\n     * Overrides of this method must invoke the definition of the super class.\n     *\n     * @param mapView - The instance of the {@link MapView}.\n     */\n    attach(mapView) {\n        this.m_mapView = mapView;\n    }\n    /**\n     * This method is called when this `DataSource` is removed from a {@link MapView}.\n     *\n     * Overrides of this method must invoke the definition of the super class.\n     *\n     * @param mapView - The instance of the {@link MapView}.\n     */\n    detach(mapView) {\n        harp_utils_1.assert(this.m_mapView === mapView);\n        this.m_mapView = undefined;\n    }\n    /**\n     * @return Whether this `DataSource` is detached from the `MapView`\n     */\n    isDetached() {\n        return this.m_mapView === undefined;\n    }\n    /**\n     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.\n     *\n     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update\n     * its tiles' geometry.\n     *\n     * @param theme - The Theme to be applied\n     * @param languages - optional: The languages in priority order to be applied\n     *\n     * @deprecated use setTheme( Theme | FlatTheme) and setLanguages(string[]) instead\n     */\n    async setTheme(theme, languages) {\n        // to be overwritten by subclasses\n    }\n    /**\n     * Used to configure the languages used by the `DataSource` according to priority;\n     * the first language in the array has the highest priority.\n     *\n     * @param languages - An array of ISO 639-1 language codes.\n     */\n    setLanguages(languages) {\n        this.languages = languages;\n        // to be overloaded by subclasses\n    }\n    /**\n     * Used to express different country point of view (political view).\n     *\n     * @note Set to `undefined` (or empty string) if you want to reset to default point of view.\n     * @param pov - The country code which point of view should be presented in lower-case\n     * ISO 3166-1 alpha-2 format.\n     */\n    setPoliticalView(pov) {\n        // to be overloaded by subclasses\n    }\n    /**\n     * This method is called by {@link MapView} before the\n     * tile needs to be updated, for example after\n     * a theme change.\n     *\n     * @param tile - The {@link Tile} to update.\n     */\n    updateTile(tile) {\n        // to be overloaded by subclasses\n    }\n    /**\n     * This method is called by the {@link MapView} to determine if the content of the surrounding\n     * tiles must be preloaded.\n     *\n     * @returns `true` if the {@link MapView} should try to preload tiles surrounding the visible\n     * tiles; `false` otherwise. The default is `false`.\n     */\n    shouldPreloadTiles() {\n        return false;\n    }\n    /**\n     * The minimum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.\n     */\n    get minZoomLevel() {\n        logger.warn(\"DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.\");\n        return this.minDataLevel;\n    }\n    set minZoomLevel(level) {\n        logger.warn(\"DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.\");\n        this.minDataLevel = level;\n    }\n    /**\n     * The maximum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.\n     */\n    get maxZoomLevel() {\n        logger.warn(\"DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.\");\n        return this.maxDataLevel;\n    }\n    set maxZoomLevel(level) {\n        logger.warn(\"DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.\");\n        this.maxDataLevel = level;\n    }\n    /**\n     * Maximum geometry height above ground level this `DataSource` can produce.\n     *\n     * Used in first stage of frustum culling before\n     * {@link Tile.maxGeometryHeight} data is available.\n     *\n     * @default 0.\n     */\n    get maxGeometryHeight() {\n        return this.m_maxGeometryHeight;\n    }\n    set maxGeometryHeight(value) {\n        this.m_maxGeometryHeight = value;\n    }\n    /**\n     * Minimum geometry height below ground level this `DataSource` can produce. A negative number\n     * specifies a value below ground level.\n     *\n     * Used in first stage of frustum culling before\n     * {@link Tile.minGeometryHeight} data is available.\n     *\n     * @default 0.\n     */\n    get minGeometryHeight() {\n        return this.m_minGeometryHeight;\n    }\n    set minGeometryHeight(value) {\n        this.m_minGeometryHeight = value;\n    }\n    /**\n     * The difference between storage level and display level of tile.\n     *\n     * Storage level offset is a value applied (added) to current zoom level giving\n     * a final tile level being displayed. This way we may differentiate current\n     * zoom level from the storage level that is displayed, giving fine grained\n     * control over the tiles being decoded an displayed.\n     */\n    get storageLevelOffset() {\n        return this.m_storageLevelOffset;\n    }\n    /**\n     * Setup the relative offset between storage level and display level of tile.\n     *\n     * @param levelOffset - Difference between zoom level and display level.\n     */\n    set storageLevelOffset(levelOffset) {\n        this.m_storageLevelOffset = levelOffset;\n    }\n    /**\n     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources\n     * supporting this feature.\n     *\n     * @param value - True to enable, false to disable.\n     */\n    setEnableElevationOverlay(enable) {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Computes the data zoom level to use.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @returns The data zoom level to use.\n     */\n    getDataZoomLevel(zoomLevel) {\n        return THREE.MathUtils.clamp(zoomLevel + this.m_storageLevelOffset, this.minDataLevel, this.maxDataLevel);\n    }\n    /**\n     * Returns `true` if {@link DataSource} should be displayed for the zoom level.\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     */\n    isVisible(zoomLevel) {\n        return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;\n    }\n    /**\n     * Returns `true` if {@link DataSource} can load tile with\n     * given {@link @here/harp-geoutils#TileKey} and zoom level.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the tile for the given {@link @here/harp-geoutils#TileKey} can be loaded.\n     */\n    canGetTile(zoomLevel, tileKey) {\n        return tileKey.level <= zoomLevel;\n    }\n    /**\n     * Returns `true` if {@link MapView} should traverse tiles\n     * further with given {@link @here/harp-geoutils#TileKey} and\n     * zoom level.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the subtiles of the given {@link @here/harp-geoutils#TileKey} should be\n     * checked for collisions.\n     */\n    shouldSubdivide(zoomLevel, tileKey) {\n        return tileKey.level <= zoomLevel;\n    }\n    /**\n     * Returns `true` if {@link MapView} should render the text\n     * elements with the given {@link @here/harp-geoutils#TileKey} and\n     * zoom level.\n     *\n     * @remarks\n     * This is an additional check for the tiles that are already selected for rendering so the\n     * default implementation returns `true`.\n     *\n     * @param zoomLevel - The zoom level.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the text elements created for the\n     *          given {@link @here/harp-geoutils#TileKey} should be rendered.\n     */\n    shouldRenderText(zoomLevel, tileKey) {\n        return true;\n    }\n    /**\n     * Sends a request to the {@link MapView} to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(this.UPDATE_EVENT);\n    }\n}\nexports.DataSource = DataSource;\n/**\n * A counter to generate unique names for each `DataSource`, if no name is provided in the\n * constructor.\n */\nDataSource.uniqueNameCounter = 0;\n//# sourceMappingURL=DataSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DebugContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DebugContext.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.debugContext = exports.DebugContext = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst isNode = typeof window === \"undefined\";\n/**\n * A `DebugOption` is a pair that consists of an option value and an array of change listeners.\n * Listeners are called up when setting the option's value.\n */\nclass DebugOption extends THREE.EventDispatcher {\n    /**\n     * Constructs the `DebugOption`.\n     *\n     * @param value - The value of the option.\n     */\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /**\n     * Updates the value of a given option.\n     *\n     * @param value - The new value for the option.\n     * @param name - The name of the option to set.\n     */\n    set(value, name) {\n        this.value = value;\n        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });\n    }\n}\nDebugOption.SET_EVENT_TYPE = \"set\";\n/**\n * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their\n * names.\n */\nclass DebugContext {\n    /**\n     * Builds a `DebugContext`.\n     */\n    constructor() {\n        this.m_optionsMap = new Map();\n        // If we have a `window` object, we store the context in it to make it available in the\n        // console.\n        if (!isNode && typeof window !== \"undefined\" && window) {\n            const debugInfo = window;\n            debugInfo.__debugContext = this;\n        }\n    }\n    /**\n     * Sets the value of an option. Calls change listeners of that option, even if the value has\n     * not been changed. The change listeners provided here are not called during this set\n     * operation.\n     *\n     * @param name - Name of the option.\n     * @param value - Value of the option.\n     */\n    setValue(name, value) {\n        let opt = this.m_optionsMap.get(name);\n        if (!opt) {\n            opt = new DebugOption(value);\n            this.m_optionsMap.set(name, opt);\n        }\n        else {\n            opt.set(value, name);\n        }\n    }\n    /**\n     * Gets the option value.\n     *\n     * @param name - Name of option.\n     */\n    getValue(name) {\n        const opt = this.m_optionsMap.get(name);\n        return opt ? opt.value : undefined;\n    }\n    /**\n     * Determines if the option is registered.\n     *\n     * @param name - Name of option.\n     */\n    hasOption(name) {\n        return this.m_optionsMap.get(name) !== undefined;\n    }\n    /**\n     * Adds a listener to a debug option.\n     *\n     * @param name - Name of the option that requires a listener.\n     * @param listener - The listener function to add.\n     */\n    addEventListener(name, listener) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        }\n        else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n    /**\n     * Checks for a listener in a debug option.\n     *\n     * @param name - Name of the option to check for.\n     * @param listener - The listener function to check for.\n     */\n    hasEventListener(name, listener) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        }\n        else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n    /**\n     * Removes a listener from a debug option.\n     *\n     * @param name - Name of the option from which to remove a listener.\n     * @param listener - The listener function to remove.\n     */\n    removeEventListener(name, listener) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        }\n        else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n    /**\n     * Provides access to the options map. This method is useful for creating an automatic\n     * browser GUI.\n     */\n    get options() {\n        return this.m_optionsMap;\n    }\n    /**\n     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API\n     * to remove all event listeners.\n     */\n    clear() {\n        this.m_optionsMap.forEach(option => {\n            option.set(undefined, \"\");\n        });\n    }\n}\nexports.DebugContext = DebugContext;\nexports.debugContext = new DebugContext();\n//# sourceMappingURL=DebugContext.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DebugContext.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.evaluateColorProperty = exports.applyBaseColorToMaterial = exports.applySecondaryColorToMaterial = exports.evaluateBaseColorProperty = exports.buildMetricValueEvaluator = exports.getMaterialConstructor = exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = exports.buildObject = exports.usesObject3D = exports.getBufferAttribute = exports.createMaterial = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst TechniqueDescriptors_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/TechniqueDescriptors */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptors.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DisplacedMesh_1 = __webpack_require__(/*! ./geometry/DisplacedMesh */ \"./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js\");\nconst SolidLineMesh_1 = __webpack_require__(/*! ./geometry/SolidLineMesh */ \"./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js\");\nconst MapMaterialAdapter_1 = __webpack_require__(/*! ./MapMaterialAdapter */ \"./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js\");\nconst MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ \"./node_modules/@here/harp-mapview/lib/MapViewPoints.js\");\nconst ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ \"./node_modules/@here/harp-mapview/lib/ThemeHelpers.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"DecodedTileHelpers\");\n/**\n * Create a material, depending on the rendering technique provided in the options.\n *\n * @param rendererCapabilities - The capabilities of the renderer that will use the material.\n * @param options - The material options the subsequent functions need.\n * @param materialUpdateCallback - Optional callback when the material gets updated,\n *                               e.g. after texture loading.\n *\n * @returns new material instance that matches `technique.name`\n *\n * @internal\n */\nfunction createMaterial(rendererCapabilities, options, textureReadyCallback) {\n    const technique = options.technique;\n    const Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);\n    const settings = {};\n    if (Constructor === undefined) {\n        return undefined;\n    }\n    if (Constructor.prototype instanceof harp_materials_1.RawShaderMaterial) {\n        settings.rendererCapabilities = rendererCapabilities;\n        if (Constructor !== harp_materials_1.HighPrecisionLineMaterial) {\n            settings.fog = options.fog;\n        }\n    }\n    if (options.shadowsEnabled === true && technique.name === \"fill\") {\n        settings.removeDiffuseLight = true;\n    }\n    const material = new Constructor(settings);\n    if (technique.id !== undefined) {\n        material.name = technique.id;\n    }\n    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n        material.flatShading = true;\n    }\n    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;\n    if (harp_datasource_protocol_1.isStandardTechnique(technique) ||\n        harp_datasource_protocol_1.isTerrainTechnique(technique) ||\n        harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {\n            const textureProperty = technique[texturePropertyName];\n            if (textureProperty === undefined) {\n                return;\n            }\n            const onLoad = (texture) => {\n                const properties = technique[texturePropertyName + \"Properties\"];\n                if (properties !== undefined) {\n                    if (properties.wrapS !== undefined) {\n                        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);\n                    }\n                    if (properties.wrapT !== undefined) {\n                        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);\n                    }\n                    if (properties.magFilter !== undefined) {\n                        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);\n                    }\n                    if (properties.minFilter !== undefined) {\n                        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);\n                    }\n                    if (properties.flipY !== undefined) {\n                        texture.flipY = properties.flipY;\n                    }\n                    if (properties.repeatU !== undefined) {\n                        texture.repeat.x = properties.repeatU;\n                    }\n                    if (properties.repeatV !== undefined) {\n                        texture.repeat.y = properties.repeatV;\n                    }\n                }\n                material[texturePropertyName] = texture;\n                texture.needsUpdate = true;\n                material.needsUpdate = true;\n                if (textureReadyCallback) {\n                    textureReadyCallback(texture);\n                }\n            };\n            const onError = (error) => {\n                logger.error(\"#createMaterial: Failed to load texture: \", error);\n            };\n            let textureUrl;\n            if (typeof textureProperty === \"string\") {\n                textureUrl = textureProperty;\n            }\n            else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {\n                if (textureProperty.type === \"image/raw\") {\n                    const properties = textureProperty.dataTextureProperties;\n                    if (properties !== undefined) {\n                        const textureDataType = properties.type\n                            ? ThemeHelpers_1.toTextureDataType(properties.type)\n                            : undefined;\n                        const textureBuffer = getTextureBuffer(textureProperty.buffer, textureDataType);\n                        const texture = new THREE.DataTexture(textureBuffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);\n                        onLoad(texture);\n                    }\n                    else {\n                        onError(\"no data texture properties provided.\");\n                    }\n                }\n                else {\n                    const textureBlob = new Blob([textureProperty.buffer], {\n                        type: textureProperty.type\n                    });\n                    textureUrl = URL.createObjectURL(textureBlob);\n                }\n            }\n            if (textureUrl) {\n                new THREE.TextureLoader().load(textureUrl, onLoad, undefined, // onProgress\n                onError);\n            }\n        });\n    }\n    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {\n        // Special case for ShaderTechnique.\n        applyShaderTechniqueToMaterial(technique, material);\n    }\n    else {\n        MapMaterialAdapter_1.MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));\n    }\n    return material;\n}\nexports.createMaterial = createMaterial;\n/**\n * Returns a [[THREE.BufferAttribute]] created from a provided\n * {@link @here/harp-datasource-protocol#BufferAttribute} object.\n *\n * @param attribute - BufferAttribute a WebGL compliant buffer\n * @internal\n */\nfunction getBufferAttribute(attribute) {\n    switch (attribute.type) {\n        case \"float\":\n            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);\n        case \"uint8\":\n            return new THREE.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"uint16\":\n            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"uint32\":\n            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"int8\":\n            return new THREE.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"int16\":\n            return new THREE.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"int32\":\n            return new THREE.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        default:\n            throw new Error(`unsupported buffer of type ${attribute.type}`);\n    } // switch\n}\nexports.getBufferAttribute = getBufferAttribute;\n/**\n * Determines if a technique uses THREE.Object3D instances.\n * @param technique - The technique to check.\n * @returns true if technique uses THREE.Object3D, false otherwise.\n * @internal\n */\nfunction usesObject3D(technique) {\n    const name = technique.name;\n    return (name !== undefined &&\n        name !== \"text\" &&\n        name !== \"labeled-icon\" &&\n        name !== \"line-marker\" &&\n        name !== \"label-rejection-line\");\n}\nexports.usesObject3D = usesObject3D;\n/**\n * Builds the object associated with the given technique.\n *\n * @param technique - The technique.\n * @param geometry - The object's geometry.\n * @param material - The object's material.\n * @param tile - The tile where the object is located.\n * @param elevationEnabled - True if elevation is enabled, false otherwise.\n *\n * @internal\n */\nfunction buildObject(technique, geometry, material, tile, elevationEnabled) {\n    harp_utils_1.assert(technique.name !== undefined);\n    switch (technique.name) {\n        case \"extruded-line\":\n        case \"standard\":\n        case \"extruded-polygon\":\n        case \"fill\":\n            return elevationEnabled\n                ? new DisplacedMesh_1.DisplacedMesh(geometry, material, () => ({\n                    min: tile.elevationRange.minElevation,\n                    max: tile.elevationRange.maxElevation\n                }))\n                : new THREE.Mesh(geometry, material);\n        case \"terrain\":\n            return new THREE.Mesh(geometry, material);\n        case \"dashed-line\":\n        case \"solid-line\":\n            return elevationEnabled\n                ? new DisplacedMesh_1.DisplacedMesh(geometry, material, () => ({\n                    min: tile.elevationRange.minElevation,\n                    max: tile.elevationRange.maxElevation\n                }), SolidLineMesh_1.SolidLineMesh.raycast)\n                : new SolidLineMesh_1.SolidLineMesh(geometry, material);\n        case \"circles\":\n            return new MapViewPoints_1.Circles(geometry, material);\n        case \"squares\":\n            return new MapViewPoints_1.Squares(geometry, material);\n        case \"line\":\n            return new THREE.LineSegments(geometry, material);\n        case \"segments\":\n            return new THREE.LineSegments(geometry, material);\n        case \"shader\": {\n            harp_utils_1.assert(harp_datasource_protocol_1.isShaderTechnique(technique), \"Invalid technique\");\n            switch (technique.primitive) {\n                case \"line\":\n                    return new THREE.Line(geometry, material);\n                case \"segments\":\n                    return new THREE.LineSegments(geometry, material);\n                case \"point\":\n                    return new THREE.Points(geometry, material);\n                case \"mesh\":\n                    return new THREE.Mesh(geometry, material);\n            }\n        }\n    }\n    harp_utils_1.assert(false, \"Invalid technique\");\n    return new THREE.Object3D();\n}\nexports.buildObject = buildObject;\n/**\n * Non material properties of `BaseTechnique`.\n * @internal\n */\nexports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = [\"name\", \"id\", \"renderOrder\", \"transient\"];\n/**\n * Returns a `MaterialConstructor` basing on provided technique object.\n *\n * @param technique - `Technique` object which the material will be based on.\n * @param shadowsEnabled - Whether the material can accept shadows, this is required for some\n *                         techniques to decide which material to create.\n *\n * @internal\n */\nfunction getMaterialConstructor(technique, shadowsEnabled) {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n    switch (technique.name) {\n        case \"extruded-line\":\n            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                throw new Error(\"Invalid extruded-line technique\");\n            }\n            return technique.shading === \"standard\"\n                ? harp_materials_1.MapMeshStandardMaterial\n                : harp_materials_1.MapMeshBasicMaterial;\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n            return harp_materials_1.MapMeshStandardMaterial;\n        case \"dashed-line\":\n        case \"solid-line\":\n            return harp_materials_1.SolidLineMaterial;\n        case \"fill\":\n            return shadowsEnabled ? harp_materials_1.MapMeshStandardMaterial : harp_materials_1.MapMeshBasicMaterial;\n        case \"squares\":\n            return THREE.PointsMaterial;\n        case \"circles\":\n            return harp_materials_1.CirclePointsMaterial;\n        case \"line\":\n        case \"segments\":\n            return THREE.LineBasicMaterial;\n        case \"shader\":\n            return THREE.ShaderMaterial;\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\nexports.getMaterialConstructor = getMaterialConstructor;\n/**\n * Styled properties of main material (created by [[createMaterial]]) managed by\n * [[MapObjectAdapter]].\n */\nfunction getMainMaterialStyledProps(technique) {\n    var _a;\n    const automaticAttributes = TechniqueDescriptors_1.getTechniqueAutomaticAttrs(technique);\n    switch (technique.name) {\n        case \"dashed-line\":\n        case \"solid-line\": {\n            const baseProps = harp_utils_1.pick(technique, automaticAttributes);\n            baseProps.lineWidth = buildMetricValueEvaluator((_a = technique.lineWidth) !== null && _a !== void 0 ? _a : 0, // Compatibility: `undefined` lineWidth means hidden.\n            technique.metricUnit);\n            baseProps.outlineWidth = buildMetricValueEvaluator(technique.outlineWidth, technique.metricUnit);\n            baseProps.dashSize = buildMetricValueEvaluator(technique.dashSize, technique.metricUnit);\n            baseProps.gapSize = buildMetricValueEvaluator(technique.gapSize, technique.metricUnit);\n            baseProps.offset = buildMetricValueEvaluator(technique.offset, technique.metricUnit);\n            return baseProps;\n        }\n        case \"fill\":\n            return harp_utils_1.pick(technique, automaticAttributes);\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\": {\n            const baseProps = harp_utils_1.pick(technique, automaticAttributes);\n            if (technique.vertexColors !== true) {\n                baseProps.color = technique.color;\n            }\n            return baseProps;\n        }\n        case \"circles\":\n        case \"squares\":\n            return harp_utils_1.pick(technique, automaticAttributes);\n        case \"extruded-line\":\n            return harp_utils_1.pick(technique, [\n                \"color\",\n                \"wireframe\",\n                \"transparent\",\n                \"opacity\",\n                \"polygonOffset\",\n                \"polygonOffsetFactor\",\n                \"polygonOffsetUnits\",\n                ...automaticAttributes\n            ]);\n        case \"line\":\n        case \"segments\":\n            return harp_utils_1.pick(technique, automaticAttributes);\n        default:\n            return {};\n    }\n}\n/**\n * Convert metric style property to expression that accounts {@link MapView.pixelToWorld} if\n * `metricUnit === 'Pixel'`.\n * @internal\n */\nfunction buildMetricValueEvaluator(value, metricUnit) {\n    if (value === undefined || value === null) {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        if (value.endsWith(\"px\")) {\n            metricUnit = \"Pixel\";\n            value = Number.parseFloat(value);\n        }\n        else if (value.endsWith(\"m\")) {\n            value = Number.parseFloat(value);\n        }\n    }\n    if (metricUnit === \"Pixel\") {\n        return (context) => {\n            var _a;\n            const pixelToWorld = (_a = context.env.lookup(\"$pixelToMeters\")) !== null && _a !== void 0 ? _a : 1;\n            const evaluated = harp_datasource_protocol_1.getPropertyValue(value, context.env);\n            return pixelToWorld * evaluated;\n        };\n    }\n    else {\n        return value;\n    }\n}\nexports.buildMetricValueEvaluator = buildMetricValueEvaluator;\n/**\n * Allows to easy parse/encode technique's base color property value as number coded color.\n *\n * @remarks\n * Function takes care about property parsing, interpolation and encoding if neccessary.\n *\n * @see ColorUtils\n * @param technique - the technique where we search for base (transparency) color value\n * @param env - {@link @here/harp-datasource-protocol#Env} instance\n *              used to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of `Technique`\n * @returns `number` encoded color value (in custom #TTRRGGBB) format or `undefined` if\n * base color property is not defined in the technique passed.\n *\n * @internal\n */\nfunction evaluateBaseColorProperty(technique, env) {\n    const baseColorProp = getBaseColorProp(technique);\n    if (baseColorProp !== undefined) {\n        return evaluateColorProperty(baseColorProp, env);\n    }\n    return undefined;\n}\nexports.evaluateBaseColorProperty = evaluateBaseColorProperty;\n/**\n * Apply `ShaderTechnique` parameters to material.\n *\n * @param technique - the `ShaderTechnique` which requires special handling\n * @param material - material to which technique will be applied\n *\n * @internal\n */\nfunction applyShaderTechniqueToMaterial(technique, material) {\n    if (technique.transparent) {\n        harp_materials_1.enableBlending(material);\n    }\n    else {\n        harp_materials_1.disableBlending(material);\n    }\n    // The shader technique takes the argument from its `params' member.\n    const params = technique.params;\n    // Remove base color and transparency properties from the processed set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;\n    const props = Object.getOwnPropertyNames(params).filter(propertyName => {\n        // Omit base color and related transparency attributes if its defined in technique\n        if (baseColorPropName === propertyName ||\n            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.includes(propertyName))) {\n            return false;\n        }\n        const prop = propertyName;\n        if (prop === \"name\") {\n            // skip reserved property names\n            return false;\n        }\n        return true;\n    });\n    // Apply all technique properties omitting base color and transparency attributes.\n    props.forEach(propertyName => {\n        // TODO: Check if properties values should not be interpolated, possible bug in old code!\n        // This behavior is kept in the new version too, level is set to undefined.\n        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);\n    });\n    if (hasBaseColor) {\n        const propColor = baseColorPropName;\n        // Finally apply base color and related properties to material (opacity, transparent)\n        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);\n    }\n}\n/**\n * Apply single and generic technique property to corresponding material parameter.\n *\n * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it\n * does not provide constructor that would take [[string]] or [[number]] values.\n *\n * @param material - target material\n * @param propertyName - material and technique parameter name (or index) that is to be transferred\n * @param techniqueAttrValue - technique property value which will be applied to material attribute\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of [[Technique]]\n */\nfunction applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, env) {\n    const m = material;\n    if (m[propertyName] instanceof THREE.Color) {\n        applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, env);\n    }\n    else {\n        const value = evaluateProperty(techniqueAttrValue, env);\n        if (value !== null) {\n            m[propertyName] = value;\n        }\n    }\n}\n/**\n * Apply technique color to material taking special care with transparent (RGBA) colors.\n *\n * @remarks\n * @note This function is intended to be used with secondary, triary etc. technique colors,\n * not the base ones that may contain transparency information. Such colors should be processed\n * with [[applyTechniqueBaseColorToMaterial]] function.\n *\n * @param technique - an technique the applied color comes from\n * @param material - the material to which color is applied\n * @param prop - technique property (color) name\n * @param value - color value\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of `Technique`.\n *\n * @internal\n */\nfunction applySecondaryColorToMaterial(materialColor, techniqueColor, env) {\n    let value = evaluateColorProperty(techniqueColor, env);\n    if (value === undefined) {\n        return;\n    }\n    if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(value)) {\n        logger.warn(\"Used RGBA value for technique color without transparency support!\");\n        // Just for clarity remove transparency component, even if that would be ignored\n        // by THREE.Color.setHex() function.\n        value = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(value);\n    }\n    materialColor.setHex(value);\n}\nexports.applySecondaryColorToMaterial = applySecondaryColorToMaterial;\n/**\n * Apply technique base color (transparency support) to material with modifying material opacity.\n *\n * @remarks\n * This method applies main (or base) technique color with transparency support to the corresponding\n * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__\n * attributes.\n *\n * @note Transparent colors should be processed as the very last technique attributes,\n * since their effect on material properties like [[THREE.Material.opacity]] and\n * [[THREE.Material.transparent]] could be overridden by corresponding technique params.\n *\n * @param technique - an technique the applied color comes from\n * @param material - the material to which color is applied\n * @param prop - technique property (color) name\n * @param value - color value in custom number format\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n *\n * @internal\n */\nfunction applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, env) {\n    const colorValue = evaluateColorProperty(techniqueColor, env);\n    if (colorValue === undefined) {\n        return;\n    }\n    const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(colorValue);\n    // Override material opacity and blending by mixing technique defined opacity\n    // with main color transparency\n    const tech = technique;\n    let opacity = a;\n    if (tech.opacity !== undefined) {\n        opacity *= evaluateProperty(tech.opacity, env);\n    }\n    opacity = THREE.MathUtils.clamp(opacity, 0, 1);\n    if (material instanceof harp_materials_1.RawShaderMaterial) {\n        material.setOpacity(opacity);\n    }\n    else {\n        material.opacity = opacity;\n    }\n    materialColor.setRGB(r, g, b);\n    const opaque = opacity >= 1.0;\n    if (!opaque) {\n        harp_materials_1.enableBlending(material);\n    }\n    else {\n        harp_materials_1.disableBlending(material);\n    }\n}\nexports.applyBaseColorToMaterial = applyBaseColorToMaterial;\n/**\n * Calculates the value of the technique defined property.\n *\n * Function takes care about property interpolation (when @param `env` is set) as also parsing\n * string encoded numbers.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value - the value of color property defined in technique\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n */\nfunction evaluateProperty(value, env) {\n    if (env !== undefined && harp_datasource_protocol_1.Expr.isExpr(value)) {\n        value = harp_datasource_protocol_1.getPropertyValue(value, env);\n    }\n    return value;\n}\n/**\n * Calculates the numerical value of the technique defined color property.\n *\n * @remarks\n * Function takes care about color interpolation (when @param `env is set) as also parsing\n * string encoded colors.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value - the value of color property defined in technique\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n * @internal\n */\nfunction evaluateColorProperty(value, env) {\n    value = evaluateProperty(value, env);\n    if (value === undefined || value === null) {\n        return undefined;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        const parsed = harp_datasource_protocol_1.parseStringEncodedColor(value);\n        if (parsed !== undefined) {\n            return parsed;\n        }\n    }\n    logger.error(`Unsupported color format: '${value}'`);\n    return undefined;\n}\nexports.evaluateColorProperty = evaluateColorProperty;\n/**\n * Allows to access base color property value for given technique.\n *\n * The color value may be encoded in [[number]], [[string]] or even as\n * [[InterpolateProperty]].\n *\n * @param technique - The techniqe where we seach for base color property.\n * @returns The value of technique color used to apply transparency.\n */\nfunction getBaseColorProp(technique) {\n    const baseColorPropName = getBaseColorPropName(technique);\n    if (baseColorPropName !== undefined) {\n        if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {\n            const propColor = baseColorPropName;\n            return technique[propColor];\n        }\n        else {\n            const params = technique.params;\n            const propColor = baseColorPropName;\n            return params[propColor];\n        }\n    }\n    return undefined;\n}\nfunction getBaseColorPropName(technique) {\n    var _a;\n    return (_a = TechniqueDescriptors_1.getTechniqueDescriptor(technique)) === null || _a === void 0 ? void 0 : _a.attrTransparencyColor;\n}\nfunction getTextureBuffer(buffer, textureDataType) {\n    if (textureDataType === undefined) {\n        return new Uint8Array(buffer);\n    }\n    switch (textureDataType) {\n        case THREE.UnsignedByteType:\n            return new Uint8Array(buffer);\n        case THREE.ByteType:\n            return new Int8Array(buffer);\n        case THREE.ShortType:\n            return new Int16Array(buffer);\n        case THREE.UnsignedShortType:\n            return new Uint16Array(buffer);\n        case THREE.IntType:\n            return new Int32Array(buffer);\n        case THREE.UnsignedIntType:\n            return new Uint32Array(buffer);\n        case THREE.FloatType:\n            return new Float32Array(buffer);\n        case THREE.HalfFloatType:\n            return new Uint16Array(buffer);\n    }\n    throw new Error(\"Unsupported texture data type\");\n}\n//# sourceMappingURL=DecodedTileHelpers.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DepthPrePass.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setDepthPrePassStencil = exports.createDepthPrePassMesh = exports.isDepthPrePassMesh = exports.createDepthPrePassMaterial = exports.isRenderDepthPrePassEnabled = exports.DEPTH_PRE_PASS_STENCIL_MASK = void 0;\nconst ColorUtils_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\n/**\n * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position\n * from rendering color.\n * @internal\n */\nexports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;\n/**\n * Render order offset for the depth pre-pass to ensure that it's rendered first.\n */\nconst DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;\n/**\n * Check if technique requires (and not disables) use of depth prepass.\n *\n * @remarks\n * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly\n * disabled by `enableDepthPrePass` option.\n *\n * @param technique - `BaseStandardTechnique` instance to be checked\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of `Technique`\n *\n * @internal\n */\nfunction isRenderDepthPrePassEnabled(technique, env) {\n    // Depth pass explicitly disabled\n    if (technique.enableDepthPrePass === false) {\n        return false;\n    }\n    let transparent = technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;\n    // If not opaque then check if transparency may be modified via alpha in base color.\n    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,\n    // will always produce some transparency effect.\n    if (!transparent) {\n        // We do not support switching depth pass during alpha interpolation, ignore zoom level\n        // when calculating base color value.\n        const color = DecodedTileHelpers_1.evaluateBaseColorProperty(technique, env);\n        if (color !== undefined) {\n            const alpha = ColorUtils_1.ColorUtils.getAlphaFromHex(color);\n            transparent = alpha > 0.0 && alpha < 1.0;\n        }\n    }\n    return transparent;\n}\nexports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;\n/**\n * Creates material for depth prepass.\n *\n * @remarks\n * Creates material that writes only to the z-buffer. Updates the original material instance, to\n * support depth prepass.\n *\n * @param baseMaterial - The base material of mesh that is updated to work with depth prepass\n *     and then used. This parameter is a template for depth prepass material that is returned.\n * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.\n *\n * @internal\n */\nfunction createDepthPrePassMaterial(baseMaterial) {\n    baseMaterial.depthWrite = false;\n    baseMaterial.depthFunc = THREE.EqualDepth;\n    baseMaterial.colorWrite = true;\n    harp_materials_1.enforceBlending(baseMaterial);\n    const depthPassMaterial = baseMaterial.clone();\n    depthPassMaterial.isDepthPrepassMaterial = true;\n    depthPassMaterial.depthWrite = true;\n    depthPassMaterial.depthTest = true;\n    depthPassMaterial.depthFunc = THREE.LessDepth;\n    depthPassMaterial.colorWrite = false;\n    depthPassMaterial.opacity = 1.0;\n    depthPassMaterial.blending = THREE.NoBlending;\n    return depthPassMaterial;\n}\nexports.createDepthPrePassMaterial = createDepthPrePassMaterial;\n/**\n * Checks if a given object is a depth prepass mesh.\n *\n * @param object - The object to check whether it's a depth prepass mesh.\n * @returns `true` if the object is a depth prepass mesh, `false` otherwise.\n *\n * @internal\n */\nfunction isDepthPrePassMesh(object) {\n    if (object.isMesh !== true) {\n        return false;\n    }\n    const mesh = object;\n    return mesh.material instanceof Array\n        ? mesh.material.every(material => material.isDepthPrepassMaterial === true)\n        : mesh.material.isDepthPrepassMaterial === true;\n}\nexports.isDepthPrePassMesh = isDepthPrePassMesh;\n/**\n * Clones a given mesh to render it in the depth prepass with another material.\n *\n * @remarks\n * Both the original\n * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass\n * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to\n * support the depth prepass. This method is usable only if the material of this mesh has an\n * opacity value in the range `(0,1)`.\n *\n * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh\n * to ensure that it's rendered first.\n *\n * @param mesh - original mesh\n * @returns `Mesh` depth pre pass\n *\n * @internal\n */\nfunction createDepthPrePassMesh(mesh) {\n    const originalGeometry = mesh.geometry;\n    if (!(originalGeometry instanceof THREE.BufferGeometry)) {\n        throw new Error(\"#createDepthPassMesh only BufferGeometry is supported\");\n    }\n    const positionAttribute = originalGeometry.getAttribute(\"position\");\n    if (!positionAttribute) {\n        throw new Error(\"#createDepthPassMesh position attribute not found\");\n    }\n    const depthPassGeometry = new THREE.BufferGeometry();\n    depthPassGeometry.setAttribute(\"position\", positionAttribute);\n    const uvAttribute = originalGeometry.getAttribute(\"uv\");\n    if (uvAttribute) {\n        depthPassGeometry.setAttribute(\"uv\", uvAttribute);\n    }\n    const normalAttribute = originalGeometry.getAttribute(\"normal\");\n    if (normalAttribute) {\n        depthPassGeometry.setAttribute(\"normal\", normalAttribute);\n    }\n    const extrusionAxisAttribute = originalGeometry.getAttribute(\"extrusionAxis\");\n    if (extrusionAxisAttribute) {\n        depthPassGeometry.setAttribute(\"extrusionAxis\", extrusionAxisAttribute);\n    }\n    if (originalGeometry.index) {\n        depthPassGeometry.setIndex(originalGeometry.index);\n    }\n    for (const group of originalGeometry.groups) {\n        const { start, count, materialIndex } = group;\n        depthPassGeometry.addGroup(start, count, materialIndex);\n    }\n    const depthPassMaterial = mesh.material instanceof Array\n        ? mesh.material.map(createDepthPrePassMaterial)\n        : createDepthPrePassMaterial(mesh.material);\n    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);\n    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;\n    return depthPassMesh;\n}\nexports.createDepthPrePassMesh = createDepthPrePassMesh;\n/**\n * Sets up all the needed stencil logic needed for the depth pre-pass.\n *\n * @remarks\n * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have\n * coplanar triangles inside the same mesh.\n *\n * @param depthMesh - Mesh created by `createDepthPrePassMesh`.\n * @param colorMesh - Original mesh.\n * @internal\n */\nfunction setDepthPrePassStencil(depthMesh, colorMesh) {\n    function setupDepthMaterialStencil(depthMeshMaterial) {\n        // Set up depth mesh stencil logic.\n        // Set the depth pre-pass stencil bit for all processed fragments. We use\n        // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass\n        // the stencil test and write the correct depth value.\n        const depthMaterial = depthMeshMaterial;\n        depthMaterial.stencilWrite = true;\n        depthMaterial.stencilFail = THREE.KeepStencilOp;\n        depthMaterial.stencilZFail = THREE.KeepStencilOp;\n        depthMaterial.stencilZPass = THREE.ReplaceStencilOp;\n        depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;\n        depthMaterial.stencilRef = 0xff;\n        depthMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;\n    }\n    function setupColorMaterialStencil(colorMeshMaterial) {\n        // Set up color mesh stencil logic.\n        // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is\n        // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position\n        // from rendering color again.\n        const colorMaterial = colorMeshMaterial;\n        colorMaterial.stencilWrite = true;\n        colorMaterial.stencilFail = THREE.KeepStencilOp;\n        colorMaterial.stencilZFail = THREE.KeepStencilOp;\n        colorMaterial.stencilZPass = THREE.ZeroStencilOp;\n        colorMaterial.stencilFunc = THREE.EqualStencilFunc;\n        colorMaterial.stencilRef = 0xff;\n        colorMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;\n    }\n    if (depthMesh.material instanceof Array) {\n        depthMesh.material.map(setupDepthMaterialStencil);\n    }\n    else {\n        setupDepthMaterialStencil(depthMesh.material);\n    }\n    if (colorMesh.material instanceof Array) {\n        colorMesh.material.map(setupColorMaterialStencil);\n    }\n    else {\n        setupColorMaterialStencil(colorMesh.material);\n    }\n}\nexports.setDepthPrePassStencil = setDepthPrePassStencil;\n//# sourceMappingURL=DepthPrePass.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DepthPrePass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DisplacementMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DisplacementMap.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=DisplacementMap.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DisplacementMap.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ElevationProvider.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ElevationProvider.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ElevationProvider.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ElevationProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CalculationStatus = void 0;\n/**\n * Status of the elevation range calculation.\n */\nvar CalculationStatus;\n(function (CalculationStatus) {\n    // Calculated approximately. A more precise result may be available later.\n    CalculationStatus[CalculationStatus[\"PendingApproximate\"] = 0] = \"PendingApproximate\";\n    // Calculation completed. The result is final, won't improve upon retrying.\n    CalculationStatus[CalculationStatus[\"FinalPrecise\"] = 1] = \"FinalPrecise\";\n})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));\n//# sourceMappingURL=ElevationRangeSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/EventDispatcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/EventDispatcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventDispatcher = void 0;\n/**\n * JavaScript events for custom objects. Stores all listeners to allow removing all listeners for\n * housekeeping.\n *\n * Will be replaced by `THREE.EventDispatcher` once https://github.com/mrdoob/three.js/pull/19844\n * is released.\n */\nclass EventDispatcher {\n    constructor() {\n        this.m_listeners = new Map();\n    }\n    /**\n     * Destroy this `EventDispatcher` instance.\n     *\n     * Unregister all event handlers used. This is method should be called when you stop\n     * using `EventDispatcher`.\n     */\n    dispose() {\n        this.removeAllEventListeners();\n    }\n    /**\n     * Checks if listener is added to an event type.\n     *\n     * @param type - The type of event to listen to.\n     * @param listener - The function that gets called when the event is fired.\n     */\n    hasEventListener(type, listener) {\n        const listeners = this.m_listeners.get(type);\n        if (listeners === undefined) {\n            return false;\n        }\n        return listener !== undefined ? listeners.includes(listener) : true;\n    }\n    /**\n     * Add a new event listener to the event type.\n     *\n     * @param type - The type of event to listen to.\n     * @param listener - The function that gets called when the event is fired.\n     */\n    addEventListener(type, listener) {\n        let listeners = this.m_listeners.get(type);\n        if (listeners === undefined) {\n            listeners = [];\n            this.m_listeners.set(type, listeners);\n        }\n        if (!listeners.includes(listener)) {\n            listeners.push(listener);\n        }\n    }\n    /**\n     * Remove the listener from the event type.\n     *\n     * @param type - The type of event to listen to.\n     * @param listener - The function that gets called when the event is fired. If the value is\n     * `undefined`, all listeners will be removed.\n     */\n    removeEventListener(type, listener) {\n        const listeners = this.m_listeners.get(type);\n        if (listeners === undefined) {\n            return;\n        }\n        if (listener === undefined) {\n            this.m_listeners.delete(type);\n        }\n        else {\n            const index = listeners.indexOf(listener);\n            if (index !== -1) {\n                listeners.splice(index, 1);\n                if (listeners.length === 0) {\n                    this.m_listeners.delete(type);\n                }\n            }\n        }\n    }\n    /**\n     * Remove all event listeners for housekeeping.\n     */\n    removeAllEventListeners() {\n        const events = Array.from(this.m_listeners.keys());\n        for (const event of events) {\n            this.removeEventListener(event);\n        }\n    }\n    /**\n     * Retrieve the registered event types.\n     *\n     * @returns Array of event types.\n     */\n    get eventTypes() {\n        return Array.from(this.m_listeners.keys());\n    }\n    /**\n     * Retrieve the registered listeners to the specified event.\n     *\n     * @param type - The type of event to listen to.\n     * @returns Array of event listeners.\n     */\n    listeners(type) {\n        return this.m_listeners.get(type);\n    }\n    /**\n     * Dispatch the event to the registered listeners.\n     *\n     * @param event - The event to dispatch.\n     */\n    dispatchEvent(event) {\n        const listeners = this.m_listeners.get(event.type);\n        if (listeners !== undefined) {\n            event.target = this;\n            // Make a copy, in case listeners are removed while iterating.\n            const array = listeners.slice(0);\n            for (let i = 0, l = array.length; i < l; i++) {\n                array[i].call(this, event);\n            }\n        }\n    }\n}\nexports.EventDispatcher = EventDispatcher;\n//# sourceMappingURL=EventDispatcher.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/EventDispatcher.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/FrustumIntersection.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/FrustumIntersection.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FrustumIntersection = exports.TileKeyEntry = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ \"./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js\");\nconst MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ \"./node_modules/@here/harp-mapview/lib/MapTileCuller.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];\nconst tmpVector4 = new THREE.Vector4();\n/**\n * Represents a unique TileKey and the area it takes up on screen.\n *\n * Note, in certain tiling projections, it is possible to have an offset, which represents a tile\n * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which\n * don't require it.\n */\nclass TileKeyEntry {\n    constructor(tileKey, area, offset = 0, elevationRange, distance = 0) {\n        this.tileKey = tileKey;\n        this.area = area;\n        this.offset = offset;\n        this.elevationRange = elevationRange;\n        this.distance = distance;\n    }\n}\nexports.TileKeyEntry = TileKeyEntry;\nfunction getGeoBox(tilingScheme, childTileKey, offset) {\n    const geoBox = tilingScheme.getGeoBox(childTileKey);\n    const longitudeOffset = 360.0 * offset;\n    geoBox.northEast.longitude += longitudeOffset;\n    geoBox.southWest.longitude += longitudeOffset;\n    return geoBox;\n}\n/**\n * Computes the tiles intersected by the frustum defined by the current camera setup.\n */\nclass FrustumIntersection {\n    constructor(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod, m_tilePixelSize = 256) {\n        this.m_camera = m_camera;\n        this.mapView = mapView;\n        this.m_extendedFrustumCulling = m_extendedFrustumCulling;\n        this.m_tileWrappingEnabled = m_tileWrappingEnabled;\n        this.m_enableMixedLod = m_enableMixedLod;\n        this.m_tilePixelSize = m_tilePixelSize;\n        this.m_frustum = new THREE.Frustum();\n        // used to project global coordinates into camera local coordinates\n        this.m_viewProjectionMatrix = new THREE.Matrix4();\n        this.m_rootTileKeys = [];\n        this.m_tileKeyEntries = new Map();\n        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);\n    }\n    /**\n     * Return camera used for generating frustum.\n     */\n    get camera() {\n        return this.m_camera;\n    }\n    /**\n     * Return projection used to convert geo coordinates to world coordinates.\n     */\n    get projection() {\n        return this.mapView.projection;\n    }\n    /**\n     * Updates the frustum to match the current camera setup.\n     */\n    updateFrustum(projectionMatrixOverride) {\n        this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== undefined\n            ? projectionMatrixOverride\n            : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);\n        this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);\n        if (this.m_extendedFrustumCulling) {\n            this.m_mapTileCuller.setup();\n        }\n        this.computeRequiredInitialRootTileKeys(this.m_camera.position);\n    }\n    /**\n     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].\n     *\n     * @param tilingScheme - The tiling scheme used to generate the tiles.\n     * @param elevationRangeSource - Source of elevation range data if any.\n     * @param zoomLevels - A list of zoom levels to render.\n     * @param dataSources - A list of data sources to render.\n     * @returns The computation result, see [[FrustumIntersection.Result]].\n     */\n    compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {\n        this.m_tileKeyEntries.clear();\n        // Compute target tile area in clip space size.\n        // A tile should take up roughly 256x256 pixels on screen in accordance to\n        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].\n        harp_utils_1.assert(this.mapView.viewportHeight !== 0);\n        const targetTileArea = Math.pow(this.m_tilePixelSize / this.mapView.viewportHeight, 2);\n        const useElevationRangeSource = elevationRangeSource !== undefined &&\n            elevationRangeSource.getTilingScheme() === tilingScheme;\n        const obbIntersections = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical || useElevationRangeSource;\n        const uniqueZoomLevels = new Set(zoomLevels);\n        // Gather the minimum and maximum geometry heights of all datasources to enlarge the\n        // bounding boxes of tiles for visibility tests.\n        let minGeometryHeight = 0;\n        let maxGeometryHeight = 0;\n        dataSources.forEach(dataSource => {\n            minGeometryHeight = Math.min(minGeometryHeight, dataSource.minGeometryHeight);\n            maxGeometryHeight = Math.max(maxGeometryHeight, dataSource.maxGeometryHeight);\n        });\n        const cache = {\n            calculationFinal: true,\n            tileBounds: obbIntersections ? new harp_geoutils_1.OrientedBox3() : new THREE.Box3()\n        };\n        // create tile key map per zoom level\n        for (const zoomLevel of uniqueZoomLevels) {\n            this.m_tileKeyEntries.set(zoomLevel, new Map());\n        }\n        for (const tileEntry of this.m_rootTileKeys) {\n            const tileKey = tileEntry.tileKey;\n            const offset = tileEntry.offset;\n            // We even check the root tiles against the frustum b/c it can happen that\n            // computeRequiredInitialRootTileKeys is producing false positives.\n            const tileKeyEntry = this.getTileKeyEntry(tileKey, offset, tilingScheme, cache, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : undefined);\n            if (tileKeyEntry !== undefined) {\n                for (const zoomLevel of uniqueZoomLevels) {\n                    const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);\n                    tileKeyEntries.set(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset), tileKeyEntry);\n                }\n            }\n        }\n        const workList = [...this.m_rootTileKeys.values()];\n        while (workList.length > 0) {\n            const tileEntry = workList.pop();\n            if (tileEntry === undefined) {\n                break;\n            }\n            // Stop subdivision if hightest visible level is reached\n            const tileKey = tileEntry.tileKey;\n            const offset = tileEntry.offset;\n            const subdivide = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));\n            if (!subdivide) {\n                continue;\n            }\n            // Stop subdivision if area of tile is too small(mixed LOD only)\n            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {\n                continue;\n            }\n            const tileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset);\n            // delete parent tile key from applicable zoom levels\n            for (const zoomLevel of uniqueZoomLevels) {\n                if (tileKey.level >= zoomLevel) {\n                    continue;\n                }\n                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);\n                tileKeyEntries.delete(tileKeyAndOffset);\n            }\n            for (const subTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                const subTileEntry = this.getTileKeyEntry(subTileKey, offset, tilingScheme, cache, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : undefined);\n                if (subTileEntry !== undefined) {\n                    // insert sub tile entry into tile entries map per zoom level\n                    for (const zoomLevel of uniqueZoomLevels) {\n                        if (subTileEntry.tileKey.level > zoomLevel) {\n                            continue;\n                        }\n                        const subTileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(subTileKey, offset);\n                        this.m_tileKeyEntries\n                            .get(zoomLevel)\n                            .set(subTileKeyAndOffset, subTileEntry);\n                    }\n                    workList.push(subTileEntry);\n                }\n            }\n        }\n        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal: cache.calculationFinal };\n    }\n    getTileKeyEntry(tileKey, offset, tilingScheme, cache, minGeometryHeight, maxGeometryHeight, elevationRangeSource) {\n        var _a, _b;\n        const geoBox = getGeoBox(tilingScheme, tileKey, offset);\n        // For tiles without elevation range source, default 0 (getGeoBox always\n        // returns box with altitude min/max equal to zero) will be propagated as\n        // min and max elevation, these tiles most probably contains features that\n        // lays directly on the ground surface.\n        if (elevationRangeSource !== undefined) {\n            const range = elevationRangeSource.getElevationRange(tileKey);\n            geoBox.southWest.altitude = range.minElevation;\n            geoBox.northEast.altitude = range.maxElevation;\n            cache.calculationFinal =\n                cache.calculationFinal &&\n                    range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;\n        }\n        // Enlarge the bounding boxes of tiles with min/max geometry height for visibility tests.\n        geoBox.southWest.altitude = ((_a = geoBox.southWest.altitude) !== null && _a !== void 0 ? _a : 0) + minGeometryHeight;\n        geoBox.northEast.altitude = ((_b = geoBox.northEast.altitude) !== null && _b !== void 0 ? _b : 0) + maxGeometryHeight;\n        this.mapView.projection.projectBox(geoBox, cache.tileBounds);\n        const { area, distance } = this.computeTileAreaAndDistance(cache.tileBounds);\n        if (area > 0) {\n            return new TileKeyEntry(tileKey, area, offset, {\n                minElevation: geoBox.southWest.altitude,\n                maxElevation: geoBox.northEast.altitude\n            }, distance);\n        }\n        return undefined;\n    }\n    /**\n     * Estimate screen space area of tile and distance to center of tile\n     * @param tileBounds - The bounding volume of a tile\n     * @return Area estimate and distance to tile center in clip space\n     */\n    computeTileAreaAndDistance(tileBounds) {\n        if (tileBounds instanceof THREE.Box3) {\n            if ((this.m_extendedFrustumCulling &&\n                !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||\n                !this.m_frustum.intersectsBox(tileBounds)) {\n                return {\n                    area: 0,\n                    distance: Infinity\n                };\n            }\n        }\n        else if (!tileBounds.intersects(this.m_frustum)) {\n            return {\n                area: 0,\n                distance: Infinity\n            };\n        }\n        // Project tile bounds center\n        const center = tileBounds.getCenter(tmpVectors3[0]);\n        const projectedPoint = tmpVector4\n            .set(center.x, center.y, center.z, 1.0)\n            .applyMatrix4(this.m_viewProjectionMatrix);\n        // Estimate objects screen space size with diagonal of bounds\n        // Dividing by w projects object size to screen space\n        const size = tileBounds.getSize(tmpVectors3[1]);\n        const objectSize = (0.5 * size.length()) / projectedPoint.w;\n        return {\n            area: objectSize * objectSize,\n            //Dividing by w means we loose information for whether the point is behind the camera\n            //(i.e. it is in front of the near plane) or beyond the far plane, hence we first clamp\n            //to [-1, 1] range, before doing the division.\n            distance: projectedPoint.z <= -projectedPoint.w\n                ? -1\n                : projectedPoint.z >= projectedPoint.w\n                    ? 1\n                    : projectedPoint.z / projectedPoint.w\n        };\n    }\n    /**\n     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0\n     * and have an offset (see {@link Tile}) based on:\n     * - the current position [[worldCenter]].\n     * - the height of the camera above the world.\n     * - the field of view of the camera (the maximum value between the horizontal / vertical\n     *   values)\n     * - the tilt of the camera (because we see more tiles when tilted).\n     *\n     * @param worldCenter - The center of the camera in world space.\n     */\n    computeRequiredInitialRootTileKeys(worldCenter) {\n        this.m_rootTileKeys = [];\n        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);\n        const tileWrappingEnabled = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Planar;\n        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0));\n            return;\n        }\n        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);\n        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);\n        // This algorithm computes the number of offsets we need to test. The following diagram may\n        // help explain the algorithm below.\n        //\n        //   |\n        //   |.\\ .\n        //   | . \\  .\n        // z |  .  \\   .c2\n        //   |  c1.  \\b    .\n        //   |     .   \\      .\n        //___|a___d1.____\\e______.d2______f\n        //\n        // Where:\n        // -  is the camera\n        // - z is the height of the camera above the ground.\n        // - a is a right angle.\n        // - b is the look at vector of the camera.\n        // - c1 and c2 are the frustum planes of the camera.\n        // - c1 to c2 is the fov.\n        // - d1 and d2 are the intersection points of the frustum with the world plane.\n        // - e is the tilt/pitch of the camera.\n        // - f is the world\n        //\n        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it\n        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).\n        // To find e->d2, we use the right triangle , a, d2 and subtract the distance a->d2 with\n        // a->e.\n        // a->d2 is found using the angle between a and d2 from the , this is simply e (because of\n        // similar triangles, angle between a,  and e equals the tilt) + half of the fov (because\n        // we need the angle between e,  and d2) and using trigonometry, result is therefore:\n        // (tan(a->d2) * z).\n        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).\n        const camera = this.m_camera;\n        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this.mapView, camera).pitch;\n        // Ensure that the aspect is >= 1.\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.\n        const totalAngleRad = THREE.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;\n        // Length a->d2\n        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;\n        // Length a->e\n        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;\n        // Length e -> d2\n        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;\n        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);\n        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);\n        // We multiply by SQRT2 because we need to account for a rotated view (in which case there\n        // are more tiles that can be seen).\n        const offsetRange = THREE.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, \n        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift\n        // value which is used currently in the VisibleTileSet methods) hence we can have a\n        // maximum range of 7 (because 2*7+1 = 15).\n        7);\n        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset));\n        }\n    }\n}\nexports.FrustumIntersection = FrustumIntersection;\n//# sourceMappingURL=FrustumIntersection.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/FrustumIntersection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ITileLoader.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ITileLoader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileLoaderState = void 0;\n/**\n * The state the {@link ITileLoader}.\n */\nvar TileLoaderState;\n(function (TileLoaderState) {\n    TileLoaderState[TileLoaderState[\"Initialized\"] = 0] = \"Initialized\";\n    TileLoaderState[TileLoaderState[\"Loading\"] = 1] = \"Loading\";\n    TileLoaderState[TileLoaderState[\"Loaded\"] = 2] = \"Loaded\";\n    TileLoaderState[TileLoaderState[\"Decoding\"] = 3] = \"Decoding\";\n    TileLoaderState[TileLoaderState[\"Ready\"] = 4] = \"Ready\";\n    TileLoaderState[TileLoaderState[\"Canceled\"] = 5] = \"Canceled\";\n    TileLoaderState[TileLoaderState[\"Failed\"] = 6] = \"Failed\";\n})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));\n//# sourceMappingURL=ITileLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ITileLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapAnchors.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapAnchors.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAnchors = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Container holding [[MapAnchor]] objects.\n */\nclass MapAnchors {\n    constructor() {\n        this.m_anchors = [];\n        this.m_priorities = [];\n    }\n    /**\n     * All currently added [[MapAnchor]]s.\n     */\n    get children() {\n        return this.m_anchors;\n    }\n    /**\n     * Add a [[MapAnchor]].\n     * @param mapAnchor [[MapAnchor]] instance to add.\n     */\n    add(mapAnchor) {\n        this.m_anchors.push(mapAnchor);\n    }\n    /**\n     * Remove a [[MapAnchor]].\n     * @param mapAnchor - [[MapAnchor]] instance to remove.\n     *\n     * @note This method is potentially slow when removing a lot of anchors.\n     * [[clear]]ing and [[add]]ing anchors should be considered in that case.\n     */\n    remove(mapAnchor) {\n        const index = this.m_anchors.findIndex(element => element === mapAnchor);\n        if (index > -1) {\n            this.m_anchors.splice(index, 1);\n        }\n    }\n    /**\n     * Remove all [[MapAnchor]]s.\n     */\n    clear() {\n        this.m_anchors.length = 0;\n    }\n    setPriorities(priorities) {\n        this.m_priorities = priorities;\n    }\n    /**\n     * Update the map anchors.\n     * @param projection - Current projection\n     * @param cameraPosition - Current camera position\n     * @param rootNode - Node where normal anchors will be inserted.\n     * @param overlayRootNode - Node where overlay anchors will be insterted.\n     * @param priorities - Optional theme priority list\n     *\n     * @internal\n     * @hidden\n     */\n    update(projection, cameraPosition, rootNode, overlayRootNode) {\n        const worldPosition = new THREE.Vector3();\n        this.m_anchors.forEach((mapAnchor) => {\n            var _a;\n            if (mapAnchor.styleSet !== undefined) {\n                const priority = (_a = this.m_priorities) === null || _a === void 0 ? void 0 : _a.findIndex(entry => entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category);\n                if (priority !== undefined && priority !== -1) {\n                    mapAnchor.renderOrder = (priority + 1) * 10;\n                }\n            }\n            const anchor = mapAnchor.geoPosition !== undefined ? mapAnchor.geoPosition : mapAnchor.anchor;\n            if (anchor !== undefined) {\n                if (harp_geoutils_1.isVector3Like(anchor)) {\n                    worldPosition.set(anchor.x, anchor.y, anchor.z);\n                }\n                else if (harp_geoutils_1.isGeoCoordinatesLike(anchor)) {\n                    projection.projectPoint(anchor, worldPosition);\n                }\n                mapAnchor.position.copy(worldPosition).sub(cameraPosition);\n            }\n            if (mapAnchor.overlay === true) {\n                overlayRootNode.add(mapAnchor);\n            }\n            else {\n                rootNode.add(mapAnchor);\n            }\n        });\n    }\n}\nexports.MapAnchors = MapAnchors;\n//# sourceMappingURL=MapAnchors.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapAnchors.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapMaterialAdapter = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\n/**\n * @hidden\n *\n * {@link MapView} specific data assigned to `THREE.Material` instance in installed in `userData`.\n *\n * [[MapMaterialAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Material`.\n */\nclass MapMaterialAdapter {\n    constructor(material, styledProperties) {\n        this.m_lastUpdateFrameNumber = -1;\n        this.material = material;\n        this.styledProperties = styledProperties;\n        this.currentStyledProperties = {};\n        this.m_dynamicProperties = [];\n        for (const propName in styledProperties) {\n            if (!styledProperties.hasOwnProperty(propName)) {\n                continue;\n            }\n            const propDefinition = styledProperties[propName];\n            if (harp_datasource_protocol_1.Expr.isExpr(propDefinition) || typeof propDefinition === \"function\") {\n                this.m_dynamicProperties.push([propName, propDefinition]);\n            }\n            else {\n                this.currentStyledProperties[propName] = propDefinition;\n            }\n        }\n        this.setupStaticProperties();\n    }\n    /**\n     * Resolve `MapMaterialAdapter` associated with `material`.\n     */\n    static get(material) {\n        var _a;\n        const mapAdapter = (_a = material.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter;\n        if (mapAdapter instanceof MapMaterialAdapter) {\n            return mapAdapter;\n        }\n        else if (mapAdapter !== undefined) {\n            // NOTE: we can rebuild MapMaterialAdapter here if userData.mapAdapter contains\n            // stylesed etc, this can be done to rebuild previously saved scene\n            return undefined;\n        }\n        else {\n            return undefined;\n        }\n    }\n    static install(objData) {\n        if (!objData.material.userData) {\n            objData.material.userData = {};\n        }\n        return (objData.material.userData.mapAdapter = objData);\n    }\n    static create(material, styledProperties) {\n        return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));\n    }\n    static ensureUpdated(material, context) {\n        var _a, _b;\n        return (_b = (_a = MapMaterialAdapter.get(material)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Serialize contents.\n     *\n     * `THREE.Material.userData` is serialized during `clone`/`toJSON`, so we need to ensure that\n     * we emit only \"data\" set of this object.\n     */\n    toJSON() {\n        return { styledProperties: this.styledProperties };\n    }\n    /**\n     * Ensure that underlying object is updated to current state of {@link MapView}.\n     *\n     * Updates dynamically styled properties of material by evaluating scene dependent expressions.\n     *\n     * Executes updates only once per frame basing on [[MapView.frameNumber]].\n     *\n     * @returns `true` if object performed some kind of update, `false` if no update was needed.\n     */\n    ensureUpdated(context) {\n        if (this.m_lastUpdateFrameNumber === context.frameNumber) {\n            return false;\n        }\n        this.m_lastUpdateFrameNumber = context.frameNumber;\n        return this.updateDynamicProperties(context);\n    }\n    /**\n     * Applies static properties to target material.\n     */\n    setupStaticProperties() {\n        var _a, _b;\n        let updateBaseColor = false;\n        for (const propName in this.styledProperties) {\n            if (!this.styledProperties.hasOwnProperty(propName)) {\n                continue;\n            }\n            const currentValue = this.currentStyledProperties[propName];\n            if (currentValue === undefined || currentValue === null) {\n                continue;\n            }\n            if (propName === \"color\" || propName === \"opacity\") {\n                updateBaseColor = true;\n            }\n            else {\n                this.applyMaterialGenericProp(propName, currentValue);\n            }\n        }\n        if (updateBaseColor) {\n            const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;\n            const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;\n            this.applyMaterialBaseColor(color, opacity);\n        }\n    }\n    /**\n     * Applies static properties to target material.\n     */\n    updateDynamicProperties(context) {\n        var _a, _b;\n        let somethingChanged = false;\n        if (this.m_dynamicProperties.length > 0) {\n            let updateBaseColor = false;\n            for (const [propName, propDefinition] of this.m_dynamicProperties) {\n                const newValue = harp_datasource_protocol_1.Expr.isExpr(propDefinition)\n                    ? harp_datasource_protocol_1.getPropertyValue(propDefinition, context.env)\n                    : propDefinition(context);\n                if (newValue === this.currentStyledProperties[propName]) {\n                    continue;\n                }\n                this.currentStyledProperties[propName] = newValue;\n                // `color` and `opacity` are special properties to support RGBA\n                if (propName === \"color\" || propName === \"opacity\") {\n                    updateBaseColor = true;\n                }\n                else {\n                    this.applyMaterialGenericProp(propName, newValue);\n                    somethingChanged = true;\n                }\n            }\n            if (updateBaseColor) {\n                const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;\n                const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;\n                this.applyMaterialBaseColor(color, opacity);\n                somethingChanged = true;\n            }\n        }\n        return somethingChanged;\n    }\n    applyMaterialGenericProp(propName, value) {\n        const m = this.material;\n        if (m[propName] instanceof THREE.Color) {\n            let colorValue = value;\n            if (typeof colorValue !== \"number\") {\n                const parsed = DecodedTileHelpers_1.evaluateColorProperty(colorValue);\n                if (parsed === undefined) {\n                    return;\n                }\n                colorValue = parsed;\n            }\n            const rgbValue = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(colorValue);\n            m[propName].set(rgbValue);\n        }\n        else {\n            m[propName] = value;\n        }\n    }\n    applyMaterialBaseColor(color, opacity) {\n        if (typeof color !== \"number\") {\n            const parsed = DecodedTileHelpers_1.evaluateColorProperty(color);\n            if (parsed === undefined) {\n                return;\n            }\n            color = parsed;\n        }\n        const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(color !== null && color !== void 0 ? color : 0xff0000);\n        const actualOpacity = a * THREE.MathUtils.clamp(opacity !== null && opacity !== void 0 ? opacity : 1, 0, 1);\n        if (this.material instanceof harp_materials_1.RawShaderMaterial) {\n            this.material.setOpacity(actualOpacity);\n        }\n        else {\n            this.material.opacity = actualOpacity;\n        }\n        this.material.color.setRGB(r, g, b);\n        const opaque = actualOpacity >= 1.0;\n        if (!opaque) {\n            harp_materials_1.enableBlending(this.material);\n        }\n        else {\n            harp_materials_1.disableBlending(this.material);\n        }\n    }\n}\nexports.MapMaterialAdapter = MapMaterialAdapter;\n//# sourceMappingURL=MapMaterialAdapter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapObjectAdapter = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst MapMaterialAdapter_1 = __webpack_require__(/*! ./MapMaterialAdapter */ \"./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js\");\n/**\n * @hidden\n *\n * {@link MapView} specific data assigned to `THREE.Object3D` instance in installed in `userData`.\n *\n * `MapObjectAdapter` is registered in `usedData.mapAdapter` property of `THREE.Object3D`.\n */\nclass MapObjectAdapter {\n    constructor(object, params) {\n        var _a;\n        this.m_lastUpdateFrameNumber = -1;\n        this.m_notCompletlyTransparent = true;\n        this.object = object;\n        this.technique = params.technique;\n        this.kind = params.kind;\n        this.dataSource = params.dataSource;\n        this.m_pickable = (_a = params.pickable) !== null && _a !== void 0 ? _a : true;\n        this.m_notCompletlyTransparent = this.getObjectMaterials().some(material => material.opacity > 0);\n        this.level = params.level;\n    }\n    /**\n     * Resolve `MapObjectAdapter` associated with `object`.\n     */\n    static get(object) {\n        var _a;\n        return ((_a = object.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter) instanceof MapObjectAdapter\n            ? object.userData.mapAdapter\n            : undefined;\n    }\n    static install(objData) {\n        if (!objData.object.userData) {\n            objData.object.userData = {};\n        }\n        return (objData.object.userData.mapAdapter = objData);\n    }\n    static create(object, params) {\n        return MapObjectAdapter.install(new MapObjectAdapter(object, params));\n    }\n    static ensureUpdated(object, context) {\n        var _a, _b;\n        return (_b = (_a = MapObjectAdapter.get(object)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Serialize contents.\n     *\n     * `THREE.Object3d.userData` is serialized during `clone`/`toJSON`, so we need to ensure that\n     * we emit only \"data\" set of this object.\n     */\n    toJSON() {\n        return { kind: this.kind, technique: this.technique };\n    }\n    /**\n     * Ensure that underlying object is updated to current state of {@link MapView}.\n     *\n     * Updates object and attachments like materials to current state by evaluating scene dependent\n     * expressions.\n     *\n     * Executes updates only once per frame basing on [[MapView.frameNumber]].\n     *\n     * Delegates updates of materials to [[MapMaterialAdapter.ensureUpdated]].\n     *\n     * @returns `true` if object performed some kind of update, `false` if no update was needed.\n     */\n    ensureUpdated(context) {\n        if (this.m_lastUpdateFrameNumber === context.frameNumber) {\n            return false;\n        }\n        this.m_lastUpdateFrameNumber = context.frameNumber;\n        return this.updateMaterials(context);\n    }\n    /**\n     * Whether underlying `THREE.Object3D` is actually visible in scene.\n     */\n    isVisible() {\n        return this.object.visible && this.m_notCompletlyTransparent;\n    }\n    /**\n     * Whether underlying `THREE.Object3D` should be pickable by {@link PickHandler}.\n     * @param env - Property lookup environment.\n     */\n    isPickable(env) {\n        var _a;\n        // An object is pickable only if it's visible, not transient and it's not explicitely marked\n        // as non-pickable.\n        return (this.m_pickable &&\n            this.isVisible() &&\n            harp_datasource_protocol_1.getPropertyValue((_a = this.technique) === null || _a === void 0 ? void 0 : _a.transient, env) !== true);\n    }\n    updateMaterials(context) {\n        let somethingChanged = false;\n        const materials = this.getObjectMaterials();\n        for (const material of materials) {\n            const changed = MapMaterialAdapter_1.MapMaterialAdapter.ensureUpdated(material, context);\n            somethingChanged = somethingChanged || changed;\n        }\n        if (somethingChanged) {\n            this.m_notCompletlyTransparent = materials.some(material => material.opacity > 0);\n        }\n        return somethingChanged;\n    }\n    getObjectMaterials() {\n        const object = this.object;\n        return Array.isArray(object.material)\n            ? object.material\n            : object.material !== undefined\n                ? [object.material]\n                : [];\n    }\n}\nexports.MapObjectAdapter = MapObjectAdapter;\n//# sourceMappingURL=MapObjectAdapter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapTileCuller.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapTileCuller.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapTileCuller = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Second step tile culling: Do additional check for intersection of box and frustum by checking if\n * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of\n * the standard frustum test, which excludes many cases where the large terrain tiles straddle the\n * planes of the frustum.\n *\n * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\n */\nclass MapTileCuller {\n    /**\n     * Constructs a `MapTileCuller`.\n     *\n     * @param m_camera - A `THREE.Camera`.\n     */\n    constructor(m_camera) {\n        this.m_camera = m_camera;\n        this.m_globalFrustumMin = new THREE.Vector3();\n        this.m_globalFrustumMax = new THREE.Vector3();\n        this.m_frustumCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n    }\n    /**\n     * Sets up culling and computes frustum corners. You mus call this function before the culling\n     * starts.\n     */\n    setup() {\n        const frustumCorners = this.getFrustumCorners();\n        const matrix = this.m_camera.matrixWorld;\n        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        for (const frustumCorner of frustumCorners) {\n            frustumCorner.applyMatrix4(matrix);\n            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);\n            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);\n            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);\n            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);\n            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);\n            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);\n        }\n    }\n    /**\n     * Checks if the tile's bounding box intersects with the current view's frustum.\n     *\n     * @param tileBounds - The bounding box for the tile.\n     */\n    frustumIntersectsTileBox(tileBounds) {\n        const globalFrustumMin = this.m_globalFrustumMin;\n        const globalFrustumMax = this.m_globalFrustumMax;\n        if (globalFrustumMax.x < tileBounds.min.x ||\n            globalFrustumMax.y < tileBounds.min.y ||\n            globalFrustumMax.z < tileBounds.min.z ||\n            globalFrustumMin.x > tileBounds.max.x ||\n            globalFrustumMin.y > tileBounds.max.y ||\n            globalFrustumMin.z > tileBounds.max.z) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the eight corners of the frustum.\n     */\n    getFrustumCorners() {\n        const frustumCorners = this.m_frustumCorners;\n        const invProjMatrix = this.m_camera.projectionMatrixInverse;\n        let cornerIndex = 0;\n        function addPoint(x, y, z) {\n            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);\n        }\n        const w = 1;\n        const h = 1;\n        const n = -1;\n        const f = 1;\n        // near\n        addPoint(-w, -h, n);\n        addPoint(w, -h, n);\n        addPoint(-w, h, n);\n        addPoint(w, h, n);\n        // far\n        addPoint(-w, -h, f);\n        addPoint(w, -h, f);\n        addPoint(-w, h, f);\n        addPoint(w, h, f);\n        return frustumCorners;\n    }\n}\nexports.MapTileCuller = MapTileCuller;\n//# sourceMappingURL=MapTileCuller.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapTileCuller.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapView.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapView.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapView = exports.MapViewPowerPreference = exports.MapViewEventNames = exports.TileTaskGroups = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ \"./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js\");\nconst CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ \"./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js\");\nconst ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ \"./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js\");\nconst composing_1 = __webpack_require__(/*! ./composing */ \"./node_modules/@here/harp-mapview/lib/composing/index.js\");\nconst ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js\");\nconst ConcurrentTilerFacade_1 = __webpack_require__(/*! ./ConcurrentTilerFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js\");\nconst CopyrightInfo_1 = __webpack_require__(/*! ./copyrights/CopyrightInfo */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js\");\nconst EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ \"./node_modules/@here/harp-mapview/lib/EventDispatcher.js\");\nconst FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ \"./node_modules/@here/harp-mapview/lib/FrustumIntersection.js\");\nconst overlayOnElevation_1 = __webpack_require__(/*! ./geometry/overlayOnElevation */ \"./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js\");\nconst TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js\");\nconst MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ \"./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js\");\nconst MapAnchors_1 = __webpack_require__(/*! ./MapAnchors */ \"./node_modules/@here/harp-mapview/lib/MapAnchors.js\");\nconst MapViewEnvironment_1 = __webpack_require__(/*! ./MapViewEnvironment */ \"./node_modules/@here/harp-mapview/lib/MapViewEnvironment.js\");\nconst MapViewTaskScheduler_1 = __webpack_require__(/*! ./MapViewTaskScheduler */ \"./node_modules/@here/harp-mapview/lib/MapViewTaskScheduler.js\");\nconst MapViewThemeManager_1 = __webpack_require__(/*! ./MapViewThemeManager */ \"./node_modules/@here/harp-mapview/lib/MapViewThemeManager.js\");\nconst PickHandler_1 = __webpack_require__(/*! ./PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\");\nconst PickingRaycaster_1 = __webpack_require__(/*! ./PickingRaycaster */ \"./node_modules/@here/harp-mapview/lib/PickingRaycaster.js\");\nconst PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiManager.js\");\nconst PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js\");\nconst PolarTileDataSource_1 = __webpack_require__(/*! ./PolarTileDataSource */ \"./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js\");\nconst ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ \"./node_modules/@here/harp-mapview/lib/ScreenProjector.js\");\nconst Statistics_1 = __webpack_require__(/*! ./Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst MapViewState_1 = __webpack_require__(/*! ./text/MapViewState */ \"./node_modules/@here/harp-mapview/lib/text/MapViewState.js\");\nconst TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\");\nconst TileObjectsRenderer_1 = __webpack_require__(/*! ./TileObjectsRenderer */ \"./node_modules/@here/harp-mapview/lib/TileObjectsRenderer.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ \"./node_modules/@here/harp-mapview/lib/VisibleTileSet.js\");\n// Cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = \"development\" === \"production\";\nif (isProduction) {\n    // In production: silence logging below error.\n    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Error);\n}\nelse {\n    // In dev: silence logging below log (silences \"debug\" and \"trace\" levels).\n    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Log);\n}\nvar TileTaskGroups;\n(function (TileTaskGroups) {\n    TileTaskGroups[\"FETCH_AND_DECODE\"] = \"fetch\";\n    //DECODE = \"decode\",\n    TileTaskGroups[\"CREATE\"] = \"create\";\n    //UPLOAD = \"upload\"\n})(TileTaskGroups = exports.TileTaskGroups || (exports.TileTaskGroups = {}));\nvar MapViewEventNames;\n(function (MapViewEventNames) {\n    /** Called before this `MapView` starts to render a new frame. */\n    MapViewEventNames[\"Update\"] = \"update\";\n    /** Called when the WebGL canvas is resized. */\n    MapViewEventNames[\"Resize\"] = \"resize\";\n    /** Called when the frame is about to be rendered. */\n    MapViewEventNames[\"Render\"] = \"render\";\n    /** Called after a frame has been rendered. */\n    MapViewEventNames[\"AfterRender\"] = \"didrender\";\n    /** Called after the first frame has been rendered. */\n    MapViewEventNames[\"FirstFrame\"] = \"first-render\";\n    /**\n     * Called when the rendered frame was complete, i.e. all the necessary tiles and resources\n     * are loaded and rendered.\n     */\n    MapViewEventNames[\"FrameComplete\"] = \"frame-complete\";\n    /** Called when the theme has been loaded with the internal {@link ThemeLoader}. */\n    MapViewEventNames[\"ThemeLoaded\"] = \"theme-loaded\";\n    /** Called when the animation mode has started. */\n    MapViewEventNames[\"AnimationStarted\"] = \"animation-started\";\n    /** Called when the animation mode has stopped. */\n    MapViewEventNames[\"AnimationFinished\"] = \"animation-finished\";\n    /** Called when a camera interaction has been detected. */\n    MapViewEventNames[\"MovementStarted\"] = \"movement-started\";\n    /** Called when a camera interaction has been stopped. */\n    MapViewEventNames[\"MovementFinished\"] = \"movement-finished\";\n    /** Called when a data source has been connected or failed to connect. */\n    MapViewEventNames[\"DataSourceConnect\"] = \"datasource-connect\";\n    /** Emitted when copyright info of rendered map has been changed. */\n    MapViewEventNames[\"CopyrightChanged\"] = \"copyright-changed\";\n    /** Called when the WebGL context is lost. */\n    MapViewEventNames[\"ContextLost\"] = \"webglcontext-lost\";\n    /** Called when the WebGL context is restored. */\n    MapViewEventNames[\"ContextRestored\"] = \"webglcontext-restored\";\n    /** Called when camera position has been changed. */\n    MapViewEventNames[\"CameraPositionChanged\"] = \"camera-changed\";\n    /** Called when dispose has been called, before any cleanup is done. */\n    MapViewEventNames[\"Dispose\"] = \"dispose\";\n})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));\nconst logger = harp_utils_1.LoggerManager.instance.create(\"MapView\");\nconst DEFAULT_FOV_CALCULATION = { type: \"dynamic\", fov: 40 };\nconst DEFAULT_CAM_NEAR_PLANE = 0.1;\nconst DEFAULT_CAM_FAR_PLANE = 4000000;\nconst MAX_FIELD_OF_VIEW = 140;\nconst MIN_FIELD_OF_VIEW = 10;\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n/**\n * Default maximum zoom level.\n */\nconst DEFAULT_MAX_ZOOM_LEVEL = 20;\n/**\n * Default minimum camera height.\n */\nconst DEFAULT_MIN_CAMERA_HEIGHT = 20;\n/**\n * Style set used by {@link PolarTileDataSource} by default.\n */\nconst DEFAULT_POLAR_STYLE_SET_NAME = \"polar\";\nconst cache = {\n    vector2: [new THREE.Vector2()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    rayCaster: new THREE.Raycaster(),\n    groundPlane: new THREE.Plane(),\n    groundSphere: new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS),\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transform: [\n        {\n            position: new THREE.Vector3(),\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3()\n        }\n    ],\n    color: new THREE.Color()\n};\n/**\n * Hint for the WebGL implementation on which power mode to prefer.\n *\n * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12\n */\nvar MapViewPowerPreference;\n(function (MapViewPowerPreference) {\n    /** Default value. */\n    MapViewPowerPreference[\"Default\"] = \"default\";\n    /** Lower power mode, used to conserve energy. */\n    MapViewPowerPreference[\"LowPower\"] = \"low-power\";\n    /** Maximum performance. */\n    MapViewPowerPreference[\"HighPerformance\"] = \"high-performance\";\n})(MapViewPowerPreference = exports.MapViewPowerPreference || (exports.MapViewPowerPreference = {}));\n/**\n * Default settings used by {@link MapView} collected in one place.\n * @internal\n */\nconst MapViewDefaults = {\n    projection: harp_geoutils_1.mercatorProjection,\n    addBackgroundDatasource: true,\n    maxVisibleDataSourceTiles: 100,\n    extendedFrustumCulling: true,\n    tileCacheSize: 200,\n    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,\n    quadTreeSearchDistanceUp: 3,\n    quadTreeSearchDistanceDown: 2,\n    pixelRatio: typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n        ? window.devicePixelRatio\n        : 1.0,\n    target: new harp_geoutils_1.GeoCoordinates(25, 0),\n    zoomLevel: 5,\n    tilt: 0,\n    heading: 0,\n    theme: {},\n    maxTilesPerFrame: 0\n};\n/**\n * The core class of the library to call in order to create a map visualization. It needs to be\n * linked to datasources.\n */\nclass MapView extends EventDispatcher_1.EventDispatcher {\n    /**\n     * Constructs a new `MapView` with the given options or canvas element.\n     *\n     * @param options - The `MapView` options or the HTML canvas element used to display the map.\n     */\n    constructor(options) {\n        var _a, _b;\n        super();\n        /**\n         * Keep the events here to avoid a global reference to MapView (and thus prevent garbage collection).\n         */\n        this.UPDATE_EVENT = { type: MapViewEventNames.Update };\n        this.RENDER_EVENT = { type: MapViewEventNames.Render };\n        this.DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };\n        this.FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };\n        this.FRAME_COMPLETE_EVENT = {\n            type: MapViewEventNames.FrameComplete\n        };\n        this.THEME_LOADED_EVENT = {\n            type: MapViewEventNames.ThemeLoaded\n        };\n        this.ANIMATION_STARTED_EVENT = {\n            type: MapViewEventNames.AnimationStarted\n        };\n        this.ANIMATION_FINISHED_EVENT = {\n            type: MapViewEventNames.AnimationFinished\n        };\n        this.MOVEMENT_STARTED_EVENT = {\n            type: MapViewEventNames.MovementStarted\n        };\n        this.MOVEMENT_FINISHED_EVENT = {\n            type: MapViewEventNames.MovementFinished\n        };\n        this.CONTEXT_LOST_EVENT = {\n            type: MapViewEventNames.ContextLost\n        };\n        this.CONTEXT_RESTORED_EVENT = {\n            type: MapViewEventNames.ContextRestored\n        };\n        this.COPYRIGHT_CHANGED_EVENT = {\n            type: MapViewEventNames.CopyrightChanged\n        };\n        this.DISPOSE_EVENT = { type: MapViewEventNames.Dispose };\n        this.m_renderLabels = true;\n        this.m_visibleTileSetLock = false;\n        this.m_tileWrappingEnabled = true;\n        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;\n        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;\n        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;\n        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;\n        /**\n         * Relative to eye camera.\n         *\n         * This camera is internal camera used to improve precision\n         * when rendering geometries.\n         */\n        this.m_rteCamera = new THREE.PerspectiveCamera();\n        this.m_yaw = 0;\n        this.m_pitch = 0;\n        this.m_roll = 0;\n        this.m_focalLength = 0;\n        this.m_targetDistance = 0;\n        this.m_targetGeoPos = harp_geoutils_1.GeoCoordinates.fromObject(MapViewDefaults.target);\n        // Focus point world coords may be calculated after setting projection, use dummy value here.\n        this.m_targetWorldPos = new THREE.Vector3();\n        this.m_viewRanges = {\n            near: DEFAULT_CAM_NEAR_PLANE,\n            far: DEFAULT_CAM_FAR_PLANE,\n            minimum: DEFAULT_CAM_NEAR_PLANE,\n            maximum: DEFAULT_CAM_FAR_PLANE\n        };\n        /** Default scene for map objects and map anchors */\n        this.m_scene = new THREE.Scene();\n        /** Separate scene for overlay map anchors */\n        this.m_overlayScene = new THREE.Scene();\n        /** Root node of [[m_scene]] that gets cleared every frame. */\n        this.m_sceneRoot = new THREE.Object3D();\n        /** Root node of [[m_overlayScene]] that gets cleared every frame. */\n        this.m_overlaySceneRoot = new THREE.Object3D();\n        this.m_mapAnchors = new MapAnchors_1.MapAnchors();\n        this.m_animationCount = 0;\n        this.m_drawing = false;\n        this.m_updatePending = false;\n        this.m_frameNumber = 0;\n        this.m_forceCameraAspect = undefined;\n        // type any as it returns different types depending on the environment\n        this.m_taskSchedulerTimeout = undefined;\n        //\n        // sources\n        //\n        this.m_tileDataSources = [];\n        this.m_connectedDataSources = new Set();\n        this.m_failedDataSources = new Set();\n        this.m_enablePolarDataSource = true;\n        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);\n        this.m_firstFrameRendered = false;\n        this.m_firstFrameComplete = false;\n        this.m_initialTextPlacementDone = false;\n        this.m_userImageCache = new MapViewImageCache_1.MapViewImageCache();\n        this.m_env = new harp_datasource_protocol_1.MapEnv({});\n        this.m_poiManager = new PoiManager_1.PoiManager(this);\n        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);\n        this.m_lastTileIds = \"\";\n        this.m_copyrightInfo = [];\n        // `true` if dispose() has been called on `MapView`.\n        this.m_disposed = false;\n        /**\n         * Default handler for webglcontextlost event.\n         *\n         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n         */\n        this.onWebGLContextLost = (event) => {\n            this.dispatchEvent(this.CONTEXT_LOST_EVENT);\n            logger.warn(\"WebGL context lost\", event);\n        };\n        /**\n         * Default handler for webglcontextrestored event.\n         *\n         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n         */\n        this.onWebGLContextRestored = (event) => {\n            this.dispatchEvent(this.CONTEXT_RESTORED_EVENT);\n            if (this.m_renderer !== undefined) {\n                this.textElementsRenderer.restoreRenderers(this.m_renderer);\n                this.getTheme().then(theme => {\n                    this.m_sceneEnvironment.updateClearColor(theme.clearColor, theme.clearAlpha);\n                    this.update();\n                });\n            }\n            logger.warn(\"WebGL context restored\", event);\n        };\n        // make a copy to avoid unwanted changes to the original options.\n        this.m_options = Object.assign({}, options);\n        this.m_uriResolver = this.m_options.uriResolver;\n        if (this.m_options.minZoomLevel !== undefined) {\n            this.m_minZoomLevel = this.m_options.minZoomLevel;\n        }\n        if (this.m_options.maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = this.m_options.maxZoomLevel;\n        }\n        if (this.m_options.minCameraHeight !== undefined) {\n            this.m_minCameraHeight = this.m_options.minCameraHeight;\n        }\n        if (this.m_options.maxBounds !== undefined) {\n            this.m_geoMaxBounds = this.m_options.maxBounds;\n        }\n        if (this.m_options.decoderUrl !== undefined) {\n            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver\n                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)\n                : this.m_options.decoderUrl;\n        }\n        if (this.m_options.decoderCount !== undefined) {\n            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;\n        }\n        this.m_visibleTileSetOptions = Object.assign(Object.assign({}, MapViewDefaults), { clipPlanesEvaluator: options.clipPlanesEvaluator !== undefined\n                ? options.clipPlanesEvaluator\n                : ClipPlanesEvaluator_1.createDefaultClipPlanesEvaluator() });\n        if (options.projection !== undefined) {\n            this.m_visibleTileSetOptions.projection = options.projection;\n        }\n        if (options.extendedFrustumCulling !== undefined) {\n            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;\n        }\n        if (options.maxVisibleDataSourceTiles !== undefined) {\n            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =\n                options.maxVisibleDataSourceTiles;\n        }\n        if (options.tileCacheSize !== undefined) {\n            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;\n        }\n        if (options.resourceComputationType !== undefined) {\n            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;\n        }\n        if (options.quadTreeSearchDistanceUp !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =\n                options.quadTreeSearchDistanceUp;\n        }\n        if (options.quadTreeSearchDistanceDown !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =\n                options.quadTreeSearchDistanceDown;\n        }\n        if (options.enablePolarDataSource !== undefined) {\n            this.m_enablePolarDataSource = options.enablePolarDataSource;\n        }\n        this.m_pixelRatio = options.pixelRatio;\n        this.m_options.maxFps = (_a = this.m_options.maxFps) !== null && _a !== void 0 ? _a : 0;\n        this.m_options.enableStatistics = this.m_options.enableStatistics === true;\n        this.m_languages = this.m_options.languages;\n        this.m_politicalView = this.m_options.politicalView;\n        this.handleRequestAnimationFrame = this.renderLoop.bind(this);\n        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enablePickTechnique === true);\n        if (this.m_options.tileWrappingEnabled !== undefined) {\n            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;\n        }\n        // Initialization of the stats\n        this.setupStats(this.m_options.enableStatistics);\n        this.canvas.addEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.addEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n        // Initialization of the renderer, enable backward compatibility with three.js <= 0.117\n        this.m_renderer = new ((_b = THREE.WebGL1Renderer) !== null && _b !== void 0 ? _b : THREE.WebGLRenderer)({\n            canvas: this.canvas,\n            context: this.m_options.context,\n            antialias: this.nativeWebglAntialiasEnabled,\n            alpha: this.m_options.alpha,\n            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,\n            powerPreference: this.m_options.powerPreference === undefined\n                ? MapViewPowerPreference.Default\n                : this.m_options.powerPreference\n        });\n        this.m_renderer.autoClear = false;\n        this.m_renderer.debug.checkShaderErrors = !isProduction;\n        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info\n        // When using several WebGLRenderer#render calls per frame, it is the only way to get\n        // correct rendering data from ThreeJS.\n        this.m_renderer.info.autoReset = false;\n        this.m_tileObjectRenderer = new TileObjectsRenderer_1.TileObjectRenderer(this.m_env, this.m_renderer);\n        this.setupRenderer(this.m_tileObjectRenderer);\n        this.m_options.fovCalculation =\n            this.m_options.fovCalculation === undefined\n                ? DEFAULT_FOV_CALCULATION\n                : this.m_options.fovCalculation;\n        this.m_options.fovCalculation.fov = THREE.MathUtils.clamp(this.m_options.fovCalculation.fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n        // Initialization of mCamera and mVisibleTiles\n        const { width, height } = this.getCanvasClientSize();\n        const aspect = width / height;\n        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);\n        this.m_camera.up.set(0, 0, 1);\n        this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);\n        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.\n        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);\n        // Scheduler must be initialized before VisibleTileSet.\n        this.m_taskScheduler = new MapViewTaskScheduler_1.MapViewTaskScheduler(this.maxFps);\n        this.m_tileGeometryManager = new TileGeometryManager_1.TileGeometryManager(this);\n        if (options.enableMixedLod !== undefined) {\n            this.m_enableMixedLod = options.enableMixedLod;\n        }\n        if (options.lodMinTilePixelSize !== undefined) {\n            this.m_lodMinTilePixelSize = options.lodMinTilePixelSize;\n        }\n        // this.m_visibleTiles is set in createVisibleTileSet, set it here again only to let tsc\n        // know the member is set in the constructor.\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.m_sceneEnvironment = new MapViewEnvironment_1.MapViewEnvironment(this, options);\n        // setup camera with initial position\n        this.setupCamera();\n        this.m_raycaster = new PickingRaycaster_1.PickingRaycaster(width, height, this.m_env);\n        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());\n        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;\n        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);\n        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);\n        if (this.m_enablePolarDataSource) {\n            const styleSetName = options.polarStyleSetName !== undefined\n                ? options.polarStyleSetName\n                : DEFAULT_POLAR_STYLE_SET_NAME;\n            this.m_polarDataSource = new PolarTileDataSource_1.PolarTileDataSource({\n                styleSetName,\n                geometryLevelOffset: options.polarGeometryLevelOffset\n            });\n            this.updatePolarDataSource();\n        }\n        this.m_taskScheduler.addEventListener(MapViewEventNames.Update, () => {\n            this.update();\n        });\n        if (options.throttlingEnabled !== undefined) {\n            this.m_taskScheduler.throttlingEnabled = options.throttlingEnabled;\n        }\n        this.m_themeManager = new MapViewThemeManager_1.MapViewThemeManager(this, this.m_uriResolver);\n        // will initialize with an empty theme and updated when theme is loaded and set\n        this.m_textElementsRenderer = this.createTextRenderer();\n        this.setTheme(harp_utils_1.getOptionValue(this.m_options.theme, MapViewDefaults.theme));\n        this.update();\n    }\n    /**\n     * @returns The lights configured by the theme, this is just a convenience method, because the\n     * lights can still be accessed by traversing the children of the [[scene]].\n     */\n    get lights() {\n        return this.m_sceneEnvironment.lights;\n    }\n    get taskQueue() {\n        return this.m_taskScheduler.taskQueue;\n    }\n    /**\n     * @returns Whether label rendering is enabled.\n     */\n    get renderLabels() {\n        return this.m_renderLabels;\n    }\n    /**\n     * Enables or disables rendering of labels.\n     * @param value - `true` to enable labels `false` to disable them.\n     */\n    set renderLabels(value) {\n        this.m_renderLabels = value;\n    }\n    /**\n     * @returns Whether adding of new labels during interaction is enabled.\n     */\n    get delayLabelsUntilMovementFinished() {\n        return this.textElementsRenderer.delayLabelsUntilMovementFinished;\n    }\n    /**\n     * Enables or disables adding of  new labels during interaction. Has no influence on already\n     * placed labels\n     * @param value - `true` to enable adding `false` to disable them.\n     */\n    set delayLabelsUntilMovementFinished(value) {\n        this.textElementsRenderer.delayLabelsUntilMovementFinished = value;\n    }\n    /**\n     * @hidden\n     * The {@link TextElementsRenderer} select the visible {@link TextElement}s and renders them.\n     */\n    get textElementsRenderer() {\n        return this.m_textElementsRenderer;\n    }\n    /**\n     * @hidden\n     * The {@link CameraMovementDetector} detects camera movements. Made available for performance\n     * measurements.\n     */\n    get cameraMovementDetector() {\n        return this.m_movementDetector;\n    }\n    /**\n     * The {@link AnimatedExtrusionHandler} controls animated extrusion effect\n     * of the extruded objects in the {@link Tile}\n     */\n    get animatedExtrusionHandler() {\n        return this.m_animatedExtrusionHandler;\n    }\n    /**\n     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of\n     * specified [[GeometryKind]]s.\n     */\n    get tileGeometryManager() {\n        return this.m_tileGeometryManager;\n    }\n    get enableMixedLod() {\n        return this.m_enableMixedLod;\n    }\n    set enableMixedLod(enableMixedLod) {\n        // Skip unnecessary update\n        if (this.m_enableMixedLod === enableMixedLod) {\n            return;\n        }\n        this.m_enableMixedLod = enableMixedLod;\n        this.createVisibleTileSet();\n        this.update();\n    }\n    get tileWrappingEnabled() {\n        return this.m_tileWrappingEnabled;\n    }\n    set tileWrappingEnabled(enabled) {\n        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            logger.warn(\"Setting this with spherical projection has no affect. Was this intended?\");\n            return;\n        }\n        if (enabled !== this.m_tileWrappingEnabled) {\n            this.m_tileWrappingEnabled = enabled;\n            this.createVisibleTileSet();\n        }\n        this.update();\n    }\n    /**\n     * Disposes this `MapView`.\n     * @override\n     *\n     * @param freeContext - `true` to force ThreeJS to loose the context. Supply `false` to keep\n     * the context for further use.\n     *\n     * @remarks\n     * This function cleans the resources that are managed manually including those that exist in\n     * shared caches.\n     *\n     * Note: This function does not try to clean objects that can be disposed off easily by\n     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full\n     * cleanup, you must ensure that all references to this `MapView` are removed.\n     */\n    dispose(freeContext = true) {\n        // Enforce listeners that we are about to dispose.\n        this.DISPOSE_EVENT.time = Date.now();\n        this.dispatchEvent(this.DISPOSE_EVENT);\n        this.m_disposed = true;\n        if (this.m_movementFinishedUpdateTimerId) {\n            clearTimeout(this.m_movementFinishedUpdateTimerId);\n            this.m_movementFinishedUpdateTimerId = undefined;\n        }\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n        this.canvas.removeEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.removeEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.dispose();\n        }\n        this.m_visibleTiles.clearTileCache();\n        this.m_textElementsRenderer.clearRenderStates();\n        this.m_renderer.dispose();\n        if (freeContext) {\n            // See for a discussion of using this call to force freeing the context:\n            //   https://github.com/mrdoob/three.js/pull/17588\n            // The patch to call forceContextLoss() upon WebGLRenderer.dispose() had been merged,\n            // but has been reverted later:\n            //   https://github.com/mrdoob/three.js/pull/19022\n            this.m_renderer.forceContextLoss();\n        }\n        this.m_themeManager.dispose();\n        this.m_tileGeometryManager.clear();\n        this.m_movementDetector.dispose();\n        // Destroy the facade if the there are no workers active anymore.\n        ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.destroyIfTerminated();\n        ConcurrentTilerFacade_1.ConcurrentTilerFacade.destroyIfTerminated();\n        this.m_taskScheduler.clearQueuedTasks();\n        // Remove all event handlers.\n        super.dispose();\n    }\n    /**\n     * Is `true` if dispose() as been called on `MapView`.\n     */\n    get disposed() {\n        return this.m_disposed;\n    }\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType() {\n        return this.m_visibleTiles.resourceComputationType;\n    }\n    set resourceComputationType(value) {\n        this.m_visibleTiles.resourceComputationType = value;\n    }\n    /**\n     * Returns the cache size.\n     */\n    getCacheSize() {\n        return this.m_visibleTiles.getDataSourceCacheSize();\n    }\n    /**\n     * Sets the cache size in number of tiles.\n     *\n     * @param size - The cache size in tiles.\n     * @param numVisibleTiles - The number of tiles visible, which is size/2 by default.\n     */\n    setCacheSize(size, numVisibleTiles) {\n        this.m_visibleTiles.setDataSourceCacheSize(size);\n        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;\n        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));\n        this.m_themeManager.updateCache();\n        this.m_textElementsRenderer.invalidateCache();\n        this.update();\n    }\n    /**\n     * Specifies whether extended frustum culling is enabled or disabled.\n     */\n    get extendedFrustumCulling() {\n        return this.m_options.extendedFrustumCulling !== undefined\n            ? this.m_visibleTileSetOptions.extendedFrustumCulling\n            : true;\n    }\n    /**\n     * Enable of disable extended frustum culling.\n     */\n    set extendedFrustumCulling(value) {\n        this.m_visibleTileSetOptions.extendedFrustumCulling = value;\n    }\n    /**\n     * Returns the status of frustum culling after each update.\n     */\n    get lockVisibleTileSet() {\n        return this.m_visibleTileSetLock;\n    }\n    /**\n     * Enable of disable frustum culling after each update.\n     */\n    set lockVisibleTileSet(value) {\n        this.m_visibleTileSetLock = value;\n    }\n    /**\n     * Gets the optional camera used to render the scene.\n     */\n    get pointOfView() {\n        return this.m_pointOfView;\n    }\n    /**\n     * Sets the optional camera used to render the scene.\n     */\n    set pointOfView(pointOfView) {\n        this.m_pointOfView = pointOfView;\n        this.update();\n    }\n    /**\n     * Loads a post effects definition file.\n     *\n     * @param postEffectsFile - File URL describing the post effects.\n     */\n    loadPostEffects(postEffectsFile) {\n        fetch(postEffectsFile)\n            .then(response => response.json())\n            .then((postEffects) => {\n            this.m_postEffects = postEffects;\n            this.setPostEffects();\n        });\n    }\n    /**\n     * The abstraction of the {@link MapRenderingManager} API for post effects.\n     */\n    get postEffects() {\n        return this.m_postEffects;\n    }\n    set postEffects(postEffects) {\n        this.m_postEffects = postEffects;\n        this.setPostEffects();\n    }\n    /**\n     * Gets the current `Theme` used by this `MapView` to style map elements.\n     * @deprecated\n     */\n    get theme() {\n        return this.m_themeManager.theme;\n    }\n    /**\n     * Changes the `Theme` used by this `MapView` to style map elements.\n     * @deprecated use MapView.setTheme instead\n     */\n    set theme(theme) {\n        this.setTheme(theme);\n    }\n    /**\n     * Changes the `Theme`used by this `MapView`to style map elements.\n     */\n    async setTheme(theme) {\n        const newTheme = await this.m_themeManager.setTheme(theme);\n        this.THEME_LOADED_EVENT.time = Date.now();\n        this.dispatchEvent(this.THEME_LOADED_EVENT);\n        this.update();\n        return newTheme;\n    }\n    /**\n     * Returns the currently set `Theme` as a `Promise` as it might be still loading/updating.\n     */\n    async getTheme() {\n        return await this.m_themeManager.getTheme();\n    }\n    /**\n     * {@link @here/harp-utils#UriResolver} used to resolve application/deployment\n     * specific `URI`s into actual `URLs` that can be loaded with `fetch`.\n     */\n    get uriResolver() {\n        return this.m_uriResolver;\n    }\n    /**\n     * Gets the value of the forced custom camera aspect.\n     * Every time a frame is rendered, `MapView` resets the camera aspect.\n     *\n     * You can disable this behavior by setting the value to `undefined`.\n     */\n    get forceCameraAspect() {\n        return this.m_forceCameraAspect;\n    }\n    /**\n     * Sets the custom forced camera aspect ratio to use while rendering.\n     */\n    set forceCameraAspect(aspect) {\n        this.m_forceCameraAspect = aspect;\n    }\n    /**\n     * Lists the ISO 639-1 language codes for DataSources to use.\n     */\n    get languages() {\n        return this.m_languages;\n    }\n    /**\n     * Sets the list of ISO 639-1 language codes for DataSources to use.\n     */\n    set languages(languages) {\n        this.m_languages = languages;\n        this.m_tileDataSources.forEach((dataSource) => {\n            dataSource.setLanguages(this.m_languages);\n        });\n        this.update();\n    }\n    /**\n     * Get currently presented political point of view - the country code.\n     *\n     * @note Country code is stored in lower-case ISO 3166-1 alpha-2 standard.\n     * @return Country code or undefined if default\n     * (majorly accepted) point of view is used.\n     */\n    get politicalView() {\n        return this.m_politicalView;\n    }\n    /**\n     * Set the political view (country code) to be used when rendering disputed features (borders).\n     *\n     * @note Country code should be encoded in lower-case ISO 3166-1 alpha-2 standard.\n     * @param pov - The code of the country which point of view should be presented,\n     * if `undefined` or empty string is set then \"defacto\" or most widely accepted point of view\n     * will be presented.\n     */\n    set politicalView(pov) {\n        if (this.m_politicalView === pov) {\n            return;\n        }\n        this.m_politicalView = pov;\n        this.m_tileDataSources.forEach((dataSource) => {\n            dataSource.setPoliticalView(pov);\n        });\n    }\n    get copyrightInfo() {\n        return this.m_copyrightInfo;\n    }\n    /**\n     * @hidden\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable) {\n        this.m_textElementsRenderer.disableFading = disable;\n    }\n    get disableFading() {\n        return this.m_textElementsRenderer.disableFading;\n    }\n    /**\n     * @hidden\n     * Return current frame number.\n     */\n    get frameNumber() {\n        return this.m_frameNumber;\n    }\n    /**\n     * @hidden\n     * Reset the frame number to 0.\n     */\n    resetFrameNumber() {\n        this.m_frameNumber = 0;\n        this.m_previousFrameTimeStamp = undefined;\n    }\n    // overrides with THREE.js base classes are not recognized by tslint.\n    addEventListener(type, listener) {\n        super.addEventListener(type, listener);\n    }\n    // overrides with THREE.js base classes are not recognized by tslint.\n    removeEventListener(type, listener) {\n        super.removeEventListener(type, listener);\n    }\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get canvas() {\n        return this.m_options.canvas;\n    }\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get collisionDebugCanvas() {\n        return this.m_collisionDebugCanvas;\n    }\n    /**\n     * The THREE.js scene used by this `MapView`.\n     */\n    get scene() {\n        return this.m_scene;\n    }\n    /**\n     * The THREE.js overlay scene\n     */\n    get overlayScene() {\n        return this.m_overlayScene;\n    }\n    /**\n     * The MapViewEnvironment used by this `MapView`.\n     * @internal\n     */\n    get sceneEnvironment() {\n        return this.m_sceneEnvironment;\n    }\n    /**\n     * The THREE.js camera used by this `MapView` to render the main scene.\n     *\n     * @remarks\n     * When modifying the camera all derived properties like:\n     * - {@link MapView.target}\n     * - {@link MapView.zoomLevel}\n     * - {@link MapView.tilt}\n     * - {@link MapView.heading}\n     * could change.\n     * These properties are cached internally and will only be updated in the next animation frame.\n     * FIXME: Unfortunately THREE.js is not dispatching any events when camera properties change\n     * so we should have an API for enforcing update of cached values.\n     */\n    get camera() {\n        return this.m_camera;\n    }\n    /**\n     * The THREE.js `WebGLRenderer` used by this scene.\n     */\n    get renderer() {\n        return this.m_renderer;\n    }\n    /**\n     * The color used to clear the view.\n     */\n    get clearColor() {\n        const rendererClearColor = this.m_renderer.getClearColor(cache.color);\n        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n    }\n    /**\n     * The color used to clear the view.\n     */\n    set clearColor(color) {\n        this.m_renderer.setClearColor(color);\n    }\n    /**\n     * The alpha used to clear the view.\n     */\n    get clearAlpha() {\n        const rendererClearAlpha = this.m_renderer.getClearAlpha();\n        return rendererClearAlpha !== undefined ? rendererClearAlpha : 0;\n    }\n    /**\n     * The alpha used to clear the view.\n     */\n    set clearAlpha(alpha) {\n        this.m_renderer.setClearAlpha(alpha);\n    }\n    /**\n     * The projection used to project geo coordinates to world coordinates.\n     */\n    get projection() {\n        return this.m_visibleTileSetOptions.projection;\n    }\n    /**\n     * Changes the projection at run time.\n     *\n     * @param projection - The {@link @here/harp-geoutils#Projection} instance to use.\n     */\n    set projection(projection) {\n        // Remember tilt and heading before setting the projection.\n        const tilt = this.tilt;\n        const heading = this.heading;\n        this.m_visibleTileSetOptions.projection = projection;\n        this.updatePolarDataSource();\n        this.clearTileCache();\n        this.textElementsRenderer.clearRenderStates();\n        this.m_visibleTiles = this.createVisibleTileSet();\n        // Set geo max bounds to compute world bounds with new projection.\n        this.geoMaxBounds = this.geoMaxBounds;\n        this.lookAtImpl({ tilt, heading });\n    }\n    /**\n     * Get camera clipping planes evaluator used.\n     */\n    get clipPlanesEvaluator() {\n        return this.m_visibleTileSetOptions.clipPlanesEvaluator;\n    }\n    /**\n     * Changes the clip planes evaluator at run time.\n     */\n    set clipPlanesEvaluator(clipPlanesEvaluator) {\n        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;\n    }\n    /**\n     * The distance (in pixels) between the screen and the camera.\n     */\n    get focalLength() {\n        return this.m_focalLength;\n    }\n    /**\n     * Get geo coordinates of camera focus (target) point.\n     *\n     * @remarks\n     * This point is not necessarily on the ground, i.e.:\n     *  - if the tilt is high and projection is {@link @here/harp-geoutils#sphereProjection}`\n     *  - if the camera was modified directly and is not pointing to the ground.\n     * In any case the projection of the target point will be in the center of the screen.\n     *\n     * @returns geo coordinates of the camera focus point.\n     */\n    get target() {\n        return this.m_targetGeoPos;\n    }\n    /** @internal\n     * Get world coordinates of camera focus point.\n     *\n     * @remarks\n     * @note The focus point coordinates are updated with each camera update so you don't need\n     * to re-calculate it, although if the camera started looking to the void, the last focus\n     * point is stored.\n     *\n     * @returns world coordinates of the camera focus point.\n     */\n    get worldTarget() {\n        return this.m_targetWorldPos;\n    }\n    /** @internal\n     * Get distance from camera to the point of focus in world units.\n     *\n     * @note If camera does not point to any ground anymore the last focus point distance is\n     * then returned.\n     *\n     * @returns Last known focus point distance.\n     */\n    get targetDistance() {\n        return this.m_targetDistance;\n    }\n    /**\n     * Get object describing frustum planes distances and min/max visibility range for actual\n     * camera setup.\n     *\n     * @remarks\n     * Near and far plane distance are self explanatory while minimum and maximum visibility range\n     * describes the extreme near/far planes distances that may be achieved with current camera\n     * settings, meaning at current zoom level (ground distance) and any possible orientation.\n     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines\n     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change\n     * whenever zoom level changes. Distance is measured in world units which may be approximately\n     * equal to meters, but this depends on the distortion related to projection type used.\n     * @internal\n     */\n    get viewRanges() {\n        return this.m_viewRanges;\n    }\n    /**\n     * The position in geo coordinates of the center of the scene.\n     * @internal\n     */\n    get geoCenter() {\n        return this.projection.unprojectPoint(this.m_camera.position).normalized();\n    }\n    /**\n     * The position in geo coordinates of the center of the scene.\n     *\n     * @remarks\n     * Longitude values outside of -180 and +180 are acceptable.\n     */\n    set geoCenter(geoCenter) {\n        if (geoCenter.altitude !== undefined) {\n            this.projection.projectPoint(geoCenter, this.m_camera.position);\n        }\n        else {\n            // Preserve the current altitude\n            const altitude = this.geoCenter.altitude;\n            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);\n        }\n        this.update();\n    }\n    /**\n     * The node in this MapView's scene containing the user {@link MapAnchor}s.\n     *\n     * @remarks\n     * All (first level) children of this node will be positioned in world space according to the\n     * [[MapAnchor.geoPosition]].\n     * Deeper level children can be used to position custom objects relative to the anchor node.\n     */\n    get mapAnchors() {\n        return this.m_mapAnchors;\n    }\n    /**\n     * The position in world coordinates of the center of the scene.\n     */\n    get worldCenter() {\n        return this.m_camera.position;\n    }\n    /**\n     * Get the [[PickHandler]] for this `mapView`.\n     */\n    get pickHandler() {\n        return this.m_pickHandler;\n    }\n    /**\n     * @internal\n     * Get the {@link ImageCache} that belongs to this `MapView`.\n     *\n     * Images stored in this cache are primarily used for POIs (icons) and they are used with the\n     * current theme. Although images can be explicitly added and removed from the cache, it is\n     * advised not to remove images from this cache. If an image that is part of client code\n     * should be removed at any point other than changing the theme, the {@link useImageCache}\n     * should be used instead.\n     */\n    get imageCache() {\n        return this.m_themeManager.imageCache;\n    }\n    /**\n     * Get the {@link ImageCache} for user images that belongs to this `MapView`.\n     *\n     * Images added to this cache can be removed if no longer required.\n     */\n    get userImageCache() {\n        return this.m_userImageCache;\n    }\n    /**\n     * @hidden\n     * @internal\n     * Get the {@link PoiManager} that belongs to this `MapView`.\n     */\n    get poiManager() {\n        return this.m_poiManager;\n    }\n    /**\n     * @hidden\n     * Get the array of {@link PoiTableManager} that belongs to this `MapView`.\n     */\n    get poiTableManager() {\n        return this.m_poiTableManager;\n    }\n    /**\n     * The minimum camera height in meters.\n     */\n    get minCameraHeight() {\n        return this.m_minCameraHeight;\n    }\n    /**\n     * The minimum zoom level.\n     */\n    get minZoomLevel() {\n        return this.m_minZoomLevel;\n    }\n    /**\n     * The minimum zoom level.\n     */\n    set minZoomLevel(zoomLevel) {\n        this.m_minZoomLevel = zoomLevel;\n        this.update();\n    }\n    /**\n     * The maximum zoom level. Default is 14.\n     */\n    get maxZoomLevel() {\n        return this.m_maxZoomLevel;\n    }\n    /**\n     * The maximum zoom level.\n     */\n    set maxZoomLevel(zoomLevel) {\n        this.m_maxZoomLevel = zoomLevel;\n        this.update();\n    }\n    /**\n     * The view's maximum bounds in geo coordinates if any.\n     */\n    get geoMaxBounds() {\n        return this.m_geoMaxBounds;\n    }\n    /**\n     * Sets or clears the view's maximum bounds in geo coordinates.\n     *\n     * @remarks\n     * If set, the view will be\n     * constrained to the given geo bounds.\n     */\n    set geoMaxBounds(bounds) {\n        this.m_geoMaxBounds = bounds;\n        this.m_worldMaxBounds = this.m_geoMaxBounds\n            ? this.projection.projectBox(this.m_geoMaxBounds, this.projection.type === harp_geoutils_1.ProjectionType.Planar\n                ? new THREE.Box3()\n                : new harp_geoutils_1.OrientedBox3())\n            : undefined;\n    }\n    /**\n     * @hidden\n     * @internal\n     * The view's maximum bounds in world coordinates if any.\n     */\n    get worldMaxBounds() {\n        return this.m_worldMaxBounds;\n    }\n    /**\n     * Returns the zoom level for the given camera setup.\n     */\n    get zoomLevel() {\n        return this.m_zoomLevel;\n    }\n    set zoomLevel(zoomLevel) {\n        this.lookAtImpl({ zoomLevel });\n    }\n    /**\n     * Returns tilt angle in degrees.\n     */\n    get tilt() {\n        return THREE.MathUtils.radToDeg(this.m_pitch);\n    }\n    /**\n     * Set the tilt angle of the map.\n     * @param tilt -: New tilt angle in degrees.\n     */\n    set tilt(tilt) {\n        this.lookAtImpl({ tilt });\n    }\n    /**\n     * Returns heading angle in degrees.\n     */\n    get heading() {\n        return -THREE.MathUtils.radToDeg(this.m_yaw);\n    }\n    /**\n     * Set the heading angle of the map.\n     * @param heading -: New heading angle in degrees.\n     */\n    set heading(heading) {\n        this.lookAtImpl({ heading });\n    }\n    /**\n     * Environment used to evaluate dynamic scene expressions.\n     */\n    get env() {\n        return this.m_env;\n    }\n    /**\n     * Returns the storage level for the given camera setup.\n     * @remarks\n     * Actual storage level of the rendered data also depends\n     * on {@link DataSource.storageLevelOffset}.\n     */\n    get storageLevel() {\n        return THREE.MathUtils.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);\n    }\n    /**\n     * Returns height of the viewport in pixels.\n     */\n    get viewportHeight() {\n        return this.canvas.height;\n    }\n    /**\n     * Returns `true` if the native WebGL antialiasing is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    get nativeWebglAntialiasEnabled() {\n        return this.m_options.enableNativeWebglAntialias === undefined\n            ? this.pixelRatio < 2.0\n            : this.m_options.enableNativeWebglAntialias;\n    }\n    /**\n     * Returns {@link DataSource}s displayed by this `MapView`.\n     */\n    get dataSources() {\n        return this.m_tileDataSources;\n    }\n    /**\n     * Set's the way in which the fov is calculated on the map view.\n     *\n     * @remarks\n     * Note, for this to take visual effect, the map should be rendered\n     * after calling this function.\n     * @param fovCalculation - How the FOV is calculated.\n     */\n    setFovCalculation(fovCalculation) {\n        this.m_options.fovCalculation = fovCalculation;\n        this.calculateFocalLength(this.m_renderer.getSize(cache.vector2[0]).height);\n        this.updateCameras();\n    }\n    /**\n     * Returns the unique {@link DataSource} matching the given name.\n     */\n    getDataSourceByName(dataSourceName) {\n        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);\n    }\n    /**\n     * Returns the array of {@link DataSource}s referring to the same [[StyleSet]].\n     */\n    getDataSourcesByStyleSetName(styleSetName) {\n        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);\n    }\n    /**\n     * Returns true if the specified {@link DataSource} is enabled.\n     */\n    isDataSourceEnabled(dataSource) {\n        return (dataSource.enabled &&\n            dataSource.ready() &&\n            this.m_connectedDataSources.has(dataSource.name) &&\n            dataSource.isVisible(this.zoomLevel));\n    }\n    /**\n     * Adds a new {@link DataSource} to this `MapView`.\n     *\n     * @remarks\n     * `MapView` needs at least one {@link DataSource} to display something.\n     * @param dataSource - The data source.\n     */\n    async addDataSource(dataSource) {\n        var _a;\n        const twinDataSource = this.getDataSourceByName(dataSource.name);\n        if (twinDataSource !== undefined) {\n            throw new Error(`A DataSource with the name \"${dataSource.name}\" already exists in this MapView.`);\n        }\n        dataSource.attach(this);\n        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);\n        this.m_tileDataSources.push(dataSource);\n        (_a = this.m_sceneEnvironment) === null || _a === void 0 ? void 0 : _a.updateBackgroundDataSource();\n        try {\n            await dataSource.connect();\n            const alreadyRemoved = !this.m_tileDataSources.includes(dataSource);\n            if (alreadyRemoved) {\n                return;\n            }\n            dataSource.addEventListener(MapViewEventNames.Update, () => {\n                this.update();\n            });\n            const theme = await this.getTheme();\n            dataSource.setLanguages(this.m_languages);\n            if (theme !== undefined && theme.styles !== undefined) {\n                await dataSource.setTheme(theme);\n            }\n            this.m_connectedDataSources.add(dataSource.name);\n            this.dispatchEvent({\n                type: MapViewEventNames.DataSourceConnect,\n                dataSourceName: dataSource.name\n            });\n            this.update();\n        }\n        catch (error) {\n            logger.error(`Failed to connect to datasource ${dataSource.name}: ${error.message}`);\n            this.m_failedDataSources.add(dataSource.name);\n            this.dispatchEvent({\n                type: MapViewEventNames.DataSourceConnect,\n                dataSourceName: dataSource.name,\n                error\n            });\n        }\n    }\n    /**\n     * Removes {@link DataSource} from this `MapView`.\n     *\n     * @param dataSource - The data source to be removed\n     */\n    removeDataSource(dataSource) {\n        const dsIndex = this.m_tileDataSources.indexOf(dataSource);\n        if (dsIndex === -1) {\n            return;\n        }\n        dataSource.detach(this);\n        this.m_visibleTiles.removeDataSource(dataSource);\n        this.m_tileDataSources.splice(dsIndex, 1);\n        this.m_connectedDataSources.delete(dataSource.name);\n        this.m_failedDataSources.delete(dataSource.name);\n        this.m_sceneEnvironment.updateBackgroundDataSource();\n        this.update();\n    }\n    /**\n     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.\n     */\n    get visibleTileSet() {\n        return this.m_visibleTiles;\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    addOverlayText(textElements) {\n        this.m_textElementsRenderer.addOverlayText(textElements);\n        this.update();\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    clearOverlayText() {\n        this.m_textElementsRenderer.clearOverlayText();\n    }\n    lookAt(targetOrParams, distance, tiltDeg, headingDeg) {\n        if (harp_geoutils_1.isGeoCoordinatesLike(targetOrParams)) {\n            const zoomLevel = distance !== undefined\n                ? Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, distance)\n                : undefined;\n            const params = {\n                target: targetOrParams,\n                zoomLevel,\n                tilt: tiltDeg,\n                heading: headingDeg\n            };\n            this.lookAtImpl(params);\n        }\n        else if (typeof targetOrParams === \"object\") {\n            this.lookAtImpl(targetOrParams);\n        }\n    }\n    /**\n     * Moves the camera to the specified {@link @here/harp-geoutils#GeoCoordinates},\n     * sets the desired `zoomLevel` and\n     * adjusts the yaw and pitch.\n     *\n     * @remarks\n     * The pitch of the camera is\n     * always curbed so that the camera cannot\n     * look above the horizon. This paradigm is necessary\n     * in {@link @here/harp-map-controls#MapControls}, where the center of\n     * the screen is used for the orbiting interaction (3 fingers / right mouse button).\n     *\n     * @param geoPos - Geolocation to move the camera to.\n     * @param zoomLevel - Desired zoom level.\n     * @param yawDeg - Camera yaw in degrees, counter-clockwise (as opposed to heading), starting\n     * north.\n     * @param pitchDeg - Camera pitch in degrees.\n     * @deprecated Use {@link (MapView.lookAt:WITH_PARAMS)} instead.\n     */\n    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {\n        this.geoCenter = geoPos;\n        let limitedPitch = Math.min(Utils_1.MapViewUtils.MAX_TILT_DEG, pitchDeg);\n        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            const maxPitchRadWithCurvature = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS /\n                (Utils_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +\n                    harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS));\n            const maxPitchDegWithCurvature = THREE.MathUtils.radToDeg(maxPitchRadWithCurvature);\n            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);\n        }\n        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);\n        Utils_1.MapViewUtils.setRotation(this, yawDeg, limitedPitch);\n        this.update();\n    }\n    /**\n     * Updates the value of a dynamic property.\n     *\n     * @remarks\n     * Property names starting with a `$`-sign are reserved and any attempt to change their value\n     * will result in an error.\n     *\n     * Themes can access dynamic properties using the `Expr` operator `[\"dynamic-properties\"]`,\n     * for example:\n     *\n     *   `[\"get\", \"property name\", [\"dynamic-properties\"]]`\n     *\n     * @param name - The name of the property.\n     * @param value - The value of the property.\n     */\n    setDynamicProperty(name, value) {\n        if (name.startsWith(\"$\")) {\n            throw new Error(`failed to update the value of the dynamic property '${name}'`);\n        }\n        this.m_env.entries[name] = value;\n        this.update();\n    }\n    /**\n     * Removes the given dynamic property from this {@link MapView}.\n     *\n     * @remarks\n     * Property names starting with a `$`-sign are reserved and any attempt to change their value\n     * will result in an error.\n     *\n     * @param name - The name of the property to remove.\n     */\n    removeDynamicProperty(name) {\n        if (name.startsWith(\"$\")) {\n            throw new Error(`failed to remove the dynamic property '${name}'`);\n        }\n        delete this.m_env.entries[name];\n        this.update();\n    }\n    /**\n     * Returns `true` if this `MapView` is constantly redrawing the scene.\n     */\n    get animating() {\n        return this.m_animationCount > 0;\n    }\n    /**\n     * Begin animating the scene.\n     */\n    beginAnimation() {\n        if (this.m_animationCount++ === 0) {\n            this.update();\n            this.ANIMATION_STARTED_EVENT.time = Date.now();\n            this.dispatchEvent(this.ANIMATION_STARTED_EVENT);\n        }\n    }\n    /**\n     * Stop animating the scene.\n     */\n    endAnimation() {\n        if (this.m_animationCount > 0) {\n            --this.m_animationCount;\n        }\n        if (this.m_animationCount === 0) {\n            this.ANIMATION_FINISHED_EVENT.time = Date.now();\n            this.dispatchEvent(this.ANIMATION_FINISHED_EVENT);\n        }\n    }\n    /**\n     * Returns `true` if the camera moved in the last frame.\n     */\n    get cameraIsMoving() {\n        return this.m_movementDetector.cameraIsMoving;\n    }\n    /**\n     * Returns `true` if the current frame will immediately be followed by another frame.\n     */\n    get isDynamicFrame() {\n        return (this.cameraIsMoving ||\n            this.animating ||\n            this.m_updatePending ||\n            this.m_animatedExtrusionHandler.isAnimating);\n    }\n    /**\n     * Returns the ratio between a pixel and a world unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get pixelToWorld() {\n        if (this.m_pixelToWorld === undefined) {\n            // At this point fov calculation should be always defined.\n            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);\n            // NOTE: Look at distance is the distance to camera focus (and pivot) point.\n            // In screen space this point is located in the center of canvas.\n            // Given that zoom level is not modified (clamped by camera pitch), the following\n            // formulas are all equivalent:\n            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);\n            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);\n            // Here we may use precalculated target distance (once pre frame):\n            const lookAtDistance = this.m_targetDistance;\n            // Find world space object size that corresponds to one pixel on screen.\n            this.m_pixelToWorld = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.m_focalLength, lookAtDistance, 1);\n        }\n        return this.m_pixelToWorld;\n    }\n    /**\n     * Returns the ratio between a world and a pixel unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get worldToPixel() {\n        return 1.0 / this.pixelToWorld;\n    }\n    get pixelRatio() {\n        if (this.m_pixelRatio !== undefined) {\n            return this.m_pixelRatio;\n        }\n        return typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0;\n    }\n    /**\n     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens\n     * (HiDPI).\n     *\n     * @remarks\n     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value\n     * of `1.0` will disable the use of HiDPI on all devices.\n     *\n     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)\n     * they may appear in the wrong size now. To ensure proper display of data, a call to\n     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.\n     *\n     * @memberof MapView\n     */\n    set pixelRatio(pixelRatio) {\n        this.m_pixelRatio = pixelRatio;\n        if (this.renderer.getPixelRatio() !== this.pixelRatio) {\n            this.renderer.setPixelRatio(this.pixelRatio);\n        }\n    }\n    /**\n     * Maximum FPS (Frames Per Second).\n     *\n     * @remarks\n     * If VSync in enabled, the specified number may not be\n     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate\n     * divided by an integer number.\n     *\n     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`\n     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of\n     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.\n     */\n    set maxFps(value) {\n        this.m_options.maxFps = value;\n        this.m_taskScheduler.maxFps = value;\n    }\n    get maxFps() {\n        //this cannot be undefined, as it is defaulting to 0 in the constructor\n        return this.m_options.maxFps;\n    }\n    /**\n     * PixelRatio ratio for rendering when the camera is moving or an animation is running.\n     *\n     * @remarks\n     * Useful when rendering on high resolution displays with low performance GPUs\n     * that may be fill-rate-limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    set dynamicPixelRatio(ratio) {\n        this.mapRenderingManager.lowResPixelRatio = ratio;\n    }\n    get dynamicPixelRatio() {\n        return this.mapRenderingManager.lowResPixelRatio;\n    }\n    /**\n     * Returns the screen position of the given geo or world position.\n     *\n     * @param pos - The position as a {@link @here/harp-geoutils#GeoCoordLike} or\n     * {@link https://threejs.org/docs/#api/en/math/Vector3 | THREE.Vector3} world position.\n     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or\n     * `undefined`.\n     */\n    getScreenPosition(pos) {\n        if (harp_geoutils_1.isVector3Like(pos)) {\n            cache.vector3[0].copy(pos);\n        }\n        else {\n            this.projection.projectPoint(harp_geoutils_1.GeoCoordinates.fromObject(pos), cache.vector3[0]);\n        }\n        const p = this.m_screenProjector.project(cache.vector3[0]);\n        if (p !== undefined) {\n            const { width, height } = this.getCanvasClientSize();\n            p.x = p.x + width / 2;\n            p.y = height - (p.y + height / 2);\n        }\n        return p;\n    }\n    /**\n     * Returns a ray caster using the supplied screen positions.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     *\n     * @alpha\n     *\n     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen\n     * points.\n     */\n    raycasterFromScreenPoint(x, y) {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);\n        return this.m_raycaster;\n    }\n    /**\n     * Returns the world space position from the given screen position.\n     *\n     * @remarks\n     * If `fallback !== true` the return value can be `null`, in case the camera has a high tilt\n     * and the given `(x, y)` value is not intersecting the ground plane.\n     * If `fallback === true` the return value will always exist but it might not be on the earth\n     * surface.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     * @param fallback - Whether to compute a fallback position if the earth surface is not hit.\n     */\n    getWorldPositionAt(x, y, fallback) {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);\n        const worldPos = this.projection.type === harp_geoutils_1.ProjectionType.Spherical\n            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])\n            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);\n        if (worldPos === null && fallback === true) {\n            // Fall back to the far plane\n            const cosAlpha = this.m_camera\n                .getWorldDirection(cache.vector3[0])\n                .dot(this.m_raycaster.ray.direction);\n            return cache.vector3[0]\n                .copy(this.m_raycaster.ray.direction)\n                .multiplyScalar(this.m_camera.far / cosAlpha)\n                .add(this.m_camera.position);\n        }\n        return worldPos;\n    }\n    getGeoCoordinatesAt(x, y, fallback) {\n        const worldPosition = this.getWorldPositionAt(x, y, fallback);\n        if (!worldPosition) {\n            return null;\n        }\n        const geoPos = this.projection.unprojectPoint(worldPosition);\n        if (!this.tileWrappingEnabled && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            // When the map is not wrapped we clamp the longitude\n            geoPos.longitude = THREE.MathUtils.clamp(geoPos.longitude, -180, 180);\n        }\n        return geoPos;\n    }\n    /**\n     * Returns the normalized screen coordinates from the given pixel position.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     */\n    getNormalizedScreenCoordinates(x, y) {\n        // use clientWidth and clientHeight as it does not apply the pixelRatio and\n        // therefore supports also HiDPI devices\n        const { width, height } = this.getCanvasClientSize();\n        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);\n    }\n    /**\n     * Do a raycast on all objects in the scene. Useful for picking.\n     *\n     * @remarks\n     * Limited to objects that THREE.js can raycast, the solid lines\n     * that get their geometry in the shader cannot be tested\n     * for intersection.\n     *\n     * Note, if a {@link DataSource} adds an [[Object3D]]\n     * to a {@link Tile}, it will be only pickable once\n     * {@link MapView.render} has been called, this is because\n     * {@link MapView.render} method creates the\n     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.\n     * This method will not test for intersection custom objects added to the scene by for\n     * example calling directly the [[scene.add]] method from THREE.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     * @param parameters - The intersection test behaviour may be adjusted by providing an instance\n     * of {@link IntersectParams}.\n     * @returns The list of intersection results.\n     */\n    intersectMapObjects(x, y, parameters) {\n        return this.m_pickHandler.intersectMapObjects(x, y, parameters);\n    }\n    /**\n     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.\n     *\n     * @param width - The new width.\n     * @param height - The new height.\n     */\n    resize(width, height) {\n        this.m_renderer.setSize(width, height, false);\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n        if (this.mapRenderingManager !== undefined) {\n            this.mapRenderingManager.setSize(width, height);\n        }\n        if (this.collisionDebugCanvas !== undefined) {\n            this.collisionDebugCanvas.width = width;\n            this.collisionDebugCanvas.height = height;\n        }\n        this.updateCameras();\n        this.update();\n        this.dispatchEvent({\n            type: MapViewEventNames.Resize,\n            size: {\n                width,\n                height\n            }\n        });\n    }\n    /**\n     * Redraws scene immediately\n     *\n     * @remarks\n     * @note Before using this method, set `synchronousRendering` to `true`\n     * in the {@link MapViewOptions}\n     *\n     * @param frameStartTime - Optional timestamp for start of frame.\n     * Default: [[PerformanceTimer.now()]]\n     */\n    renderSync(frameStartTime) {\n        if (frameStartTime === undefined) {\n            frameStartTime = harp_utils_1.PerformanceTimer.now();\n        }\n        this.render(frameStartTime);\n    }\n    /**\n     * Requests a redraw of the scene.\n     */\n    update() {\n        if (this.disposed) {\n            logger.warn(\"update(): MapView has been disposed of.\");\n            return;\n        }\n        this.dispatchEvent(this.UPDATE_EVENT);\n        // Skip if update is already in progress\n        if (this.m_updatePending) {\n            return;\n        }\n        // Set update flag\n        this.m_updatePending = true;\n        this.startRenderLoop();\n    }\n    /**\n     * Returns `true` if an update has already been requested, such that after a currently rendering\n     * frame, the next frame will be rendered immediately.\n     */\n    get updatePending() {\n        return this.m_updatePending;\n    }\n    /**\n     * Requests a redraw of the scene.\n     * @deprecated Use the [[update]] method instead.\n     */\n    requestUpdateIfNeeded() {\n        this.update();\n    }\n    /**\n     * Clear the tile cache.\n     *\n     * @remarks\n     * Remove the {@link Tile} objects created by cacheable\n     * {@link DataSource}s. If a {@link DataSource} name is\n     * provided, this method restricts the eviction the {@link DataSource} with the given name.\n     *\n     * @param dataSourceName - The name of the {@link DataSource}.\n     * @param filter Optional tile filter\n     */\n    clearTileCache(dataSourceName, filter) {\n        if (this.m_visibleTiles === undefined) {\n            // This method is called in the shadowsEnabled function, which is initialized in the\n            // setupRenderer function,\n            return;\n        }\n        if (dataSourceName !== undefined) {\n            const dataSource = this.getDataSourceByName(dataSourceName);\n            if (dataSource) {\n                this.m_visibleTiles.clearTileCache(dataSource, filter);\n                dataSource.clearCache();\n            }\n        }\n        else {\n            this.m_visibleTiles.clearTileCache(undefined, filter);\n            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());\n        }\n        if (this.m_elevationProvider !== undefined) {\n            this.m_elevationProvider.clearCache();\n        }\n    }\n    /**\n     * Apply visitor to all visible tiles.\n     *\n     * @param fun - Visitor function\n     */\n    forEachVisibleTile(fun) {\n        this.m_visibleTiles.forEachVisibleTile(fun);\n    }\n    /**\n     * Apply a visitor function to all tiles in the cache.\n     *\n     * @param visitor - Visitor function\n     */\n    forEachCachedTile(visitor) {\n        this.m_visibleTiles.forEachCachedTile(visitor);\n    }\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     * @remarks\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance\n     * are processed. If `undefined`, tiles from all {@link DataSource}s are processed.\n     * @param filter Optional tile filter\n     */\n    markTilesDirty(dataSource, filter) {\n        this.m_visibleTiles.markTilesDirty(dataSource, filter);\n        this.update();\n    }\n    /**\n     * Sets the DataSource which contains the elevations, the elevation range source, and the\n     * elevation provider.\n     *\n     * @remarks\n     * Only a single elevation source is possible per {@link MapView}.\n     * If the terrain-datasource is merged with this repository, we could internally construct\n     * the {@link ElevationRangeSource} and the {@link ElevationProvider}\n     * and access would be granted to\n     * the application when it asks for it, to simplify the API.\n     *\n     * @param elevationSource - The datasource containing the terrain tiles.\n     * @param elevationRangeSource - Allows access to the elevation min / max per tile.\n     * @param elevationProvider - Allows access to the elevation at a given location or a ray\n     *      from the camera.\n     */\n    async setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {\n        // Remove previous elevation source if present\n        if (this.m_elevationSource && this.m_elevationSource !== elevationSource) {\n            this.removeDataSource(this.m_elevationSource);\n        }\n        // Add as datasource if it was not added before\n        const isPresent = this.m_tileDataSources.includes(elevationSource);\n        if (!isPresent) {\n            await this.addDataSource(elevationSource);\n        }\n        this.m_elevationSource = elevationSource;\n        this.m_elevationRangeSource = elevationRangeSource;\n        if (!this.m_elevationRangeSource.ready()) {\n            await this.m_elevationRangeSource.connect();\n        }\n        this.m_elevationProvider = elevationProvider;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(true);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback((tile) => {\n            overlayOnElevation_1.overlayOnElevation(tile);\n        });\n        this.clearTileCache();\n    }\n    /**\n     * Clears any elevation sources and provider previously set.\n     * @param elevationSource - The datasource to be cleared.\n     */\n    clearElevationSource(elevationSource) {\n        this.removeDataSource(elevationSource);\n        this.m_elevationSource = undefined;\n        this.m_elevationRangeSource = undefined;\n        this.m_elevationProvider = undefined;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(false);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback(undefined);\n        this.clearTileCache();\n    }\n    /**\n     * Public access to {@link MapViewFog} allowing to toggle it by setting its `enabled` property.\n     */\n    get fog() {\n        return this.m_sceneEnvironment.fog;\n    }\n    setPostEffects() {\n        // First clear all the effects, then enable them from what is specified.\n        this.mapRenderingManager.bloom.enabled = false;\n        this.mapRenderingManager.outline.enabled = false;\n        this.mapRenderingManager.vignette.enabled = false;\n        this.mapRenderingManager.sepia.enabled = false;\n        if (this.m_postEffects !== undefined) {\n            if (this.m_postEffects.bloom !== undefined) {\n                this.mapRenderingManager.bloom = this.m_postEffects.bloom;\n            }\n            if (this.m_postEffects.outline !== undefined) {\n                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;\n                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);\n            }\n            if (this.m_postEffects.vignette !== undefined) {\n                this.mapRenderingManager.vignette = this.m_postEffects.vignette;\n            }\n            if (this.m_postEffects.sepia !== undefined) {\n                this.mapRenderingManager.sepia = this.m_postEffects.sepia;\n            }\n        }\n    }\n    /**\n     * Returns the elevation provider.\n     */\n    get elevationProvider() {\n        return this.m_elevationProvider;\n    }\n    /**\n     * @beta\n     */\n    get throttlingEnabled() {\n        return this.m_taskScheduler.throttlingEnabled === true;\n    }\n    /**\n     * @beta\n     */\n    set throttlingEnabled(enabled) {\n        this.m_taskScheduler.throttlingEnabled = enabled;\n    }\n    get shadowsEnabled() {\n        return this.m_options.enableShadows === true;\n    }\n    set shadowsEnabled(enabled) {\n        // shadowMap is undefined if we are testing (three.js always set it to be defined).\n        if (this.m_renderer.shadowMap === undefined ||\n            enabled === this.m_renderer.shadowMap.enabled) {\n            return;\n        }\n        this.m_options.enableShadows = enabled;\n        // There is a bug in three.js where this doesn't currently work once enabled.\n        this.m_renderer.shadowMap.enabled = enabled;\n        // TODO: Make this configurable. Note, there is currently issues when using the\n        // VSMShadowMap type, this should be investigated if this type is requested.\n        this.m_renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        this.clearTileCache();\n    }\n    extractAttitude() {\n        const camera = this.m_camera;\n        const projection = this.projection;\n        const cameraPos = cache.vector3[1];\n        const transform = cache.transform[0];\n        const tangentSpaceMatrix = cache.matrix4[1];\n        // 1. Build the matrix of the tangent space of the camera.\n        cameraPos.setFromMatrixPosition(camera.matrixWorld); // Ensure using world position.\n        projection.localTangentSpace(this.m_targetGeoPos, transform);\n        tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].copy(tangentSpaceMatrix).invert().multiply(camera.matrixWorld);\n        transform.xAxis.setFromMatrixColumn(cache.matrix4[0], 0);\n        transform.yAxis.setFromMatrixColumn(cache.matrix4[0], 1);\n        transform.zAxis.setFromMatrixColumn(cache.matrix4[0], 2);\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const epsilon = 1e-10;\n        const d = transform.zAxis.dot(cameraPos.set(0, 0, 1));\n        if (d < 1.0 - epsilon) {\n            if (d > -1.0 + epsilon) {\n                yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);\n                pitch = Math.acos(transform.zAxis.z);\n                roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);\n            }\n            else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);\n                pitch = 180;\n                roll = 0;\n            }\n        }\n        else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n    lookAtImpl(params) {\n        const tilt = Math.min(harp_utils_1.getOptionValue(params.tilt, this.tilt), Utils_1.MapViewUtils.MAX_TILT_DEG);\n        const heading = harp_utils_1.getOptionValue(params.heading, this.heading);\n        const distance = params.zoomLevel !== undefined\n            ? Utils_1.MapViewUtils.calculateDistanceFromZoomLevel(this, THREE.MathUtils.clamp(params.zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel))\n            : params.distance !== undefined\n                ? params.distance\n                : this.m_targetDistance;\n        let target;\n        if (params.bounds !== undefined) {\n            let geoPoints;\n            if (params.bounds instanceof harp_geoutils_1.GeoBox) {\n                target = params.target\n                    ? harp_geoutils_1.GeoCoordinates.fromObject(params.target)\n                    : params.bounds.center;\n                geoPoints = Utils_1.MapViewUtils.geoBoxToGeoPoints(params.bounds);\n            }\n            else if (params.bounds instanceof harp_geoutils_1.GeoPolygon) {\n                target = params.bounds.getCentroid();\n                geoPoints = params.bounds.coordinates;\n            }\n            else if (harp_geoutils_1.isGeoBoxExtentLike(params.bounds)) {\n                target = params.target ? harp_geoutils_1.GeoCoordinates.fromObject(params.target) : this.target;\n                const box = harp_geoutils_1.GeoBox.fromCenterAndExtents(target, params.bounds);\n                geoPoints = Utils_1.MapViewUtils.geoBoxToGeoPoints(box);\n            }\n            else if (Array.isArray(params.bounds)) {\n                geoPoints = params.bounds;\n                if (params.target !== undefined) {\n                    target = harp_geoutils_1.GeoCoordinates.fromObject(params.target);\n                }\n            }\n            else {\n                throw Error(\"#lookAt: Invalid 'bounds' value\");\n            }\n            if (\n            // if the points are created from the corners of the geoBox don't cluster them\n            !(params.bounds instanceof harp_geoutils_1.GeoBox || params.bounds instanceof harp_geoutils_1.GeoPolygon) &&\n                this.m_tileWrappingEnabled &&\n                this.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n                // In flat projection, with wrap around enabled, we should detect clusters of\n                // points around  anti-meridian and possible move some points to sibling worlds.\n                //\n                // Here, we fit points into minimal geo box taking world wrapping into account.\n                geoPoints = Utils_1.MapViewUtils.wrapGeoPointsToScreen(geoPoints, target);\n            }\n            const worldPoints = geoPoints.map(point => this.projection.projectPoint(harp_geoutils_1.GeoCoordinates.fromObject(point), new THREE.Vector3()));\n            const worldTarget = new THREE.Vector3();\n            if (target === undefined) {\n                const box = new THREE.Box3().setFromPoints(worldPoints);\n                box.getCenter(worldTarget);\n                this.projection.scalePointToSurface(worldTarget);\n                target = this.projection.unprojectPoint(worldTarget);\n            }\n            else {\n                this.projection.projectPoint(target, worldTarget);\n            }\n            if (params.zoomLevel !== undefined || params.distance !== undefined) {\n                return this.lookAtImpl({\n                    tilt,\n                    heading,\n                    distance,\n                    target\n                });\n            }\n            return this.lookAtImpl(Utils_1.MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {\n                tilt,\n                heading,\n                minDistance: Utils_1.MapViewUtils.calculateDistanceFromZoomLevel(this, this.maxZoomLevel),\n                projection: this.projection,\n                camera: this.camera\n            }));\n        }\n        target =\n            params.target !== undefined ? harp_geoutils_1.GeoCoordinates.fromObject(params.target) : this.target;\n        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.\n        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put\n        // the camera on the target, so the tilt can be passed to getRotation as a pitch.\n        Utils_1.MapViewUtils.getCameraRotationAtTarget(this.projection, target, -heading, tilt, this.camera.quaternion);\n        Utils_1.MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -heading, tilt, this.projection, this.camera.position);\n        this.camera.updateMatrixWorld(true);\n        // Make sure to update all properties that are accessible via API (e.g. zoomlevel) b/c\n        // otherwise they would be updated as recently as in the next animation frame.\n        this.updateLookAtSettings();\n        this.update();\n    }\n    /**\n     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise\n     */\n    updatePolarDataSource() {\n        const dataSource = this.m_polarDataSource;\n        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {\n            const twinDataSource = this.getDataSourceByName(dataSource.name);\n            if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n                if (twinDataSource === undefined) {\n                    this.addDataSource(dataSource);\n                }\n            }\n            else {\n                if (twinDataSource !== undefined) {\n                    this.removeDataSource(dataSource);\n                }\n            }\n        }\n    }\n    /**\n     * Updates the camera and the projections and resets the screen collisions,\n     * note, setupCamera must be called before this is called.\n     *\n     * @remarks\n     * @param viewRanges - optional parameter that supplies new view ranges, most importantly\n     * near/far clipping planes distance. If parameter is not provided view ranges will be\n     * calculated from [[ClipPlaneEvaluator]] used in {@link VisibleTileSet}.\n     */\n    updateCameras(viewRanges) {\n        var _a;\n        // Update look at settings first, so that other components (e.g. ClipPlanesEvaluator) get\n        // the up to date tilt, targetDistance, ...\n        this.m_camera.updateMatrixWorld(false);\n        this.updateLookAtSettings();\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.aspect =\n            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;\n        this.setFovOnCamera(this.m_options.fovCalculation, height);\n        // When calculating clip planes account for the highest building on the earth,\n        // multiplying its height by projection scaling factor. This approach assumes\n        // constantHeight property of extruded polygon technique is set as default false,\n        // otherwise the near plane margins will be bigger then required, but still correct.\n        const projectionScale = this.projection.getScaleFactor(this.camera.position);\n        const maxGeometryHeightScaled = projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);\n        const minGeometryHeightScaled = projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.min(r, ds.minGeometryHeight), 0);\n        // Copy all properties from new view ranges to our readonly object.\n        // This allows to keep all view ranges references valid and keeps up-to-date\n        // information within them. Works the same as copping all properties one-by-one.\n        Object.assign(this.m_viewRanges, viewRanges === undefined\n            ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled, minGeometryHeightScaled)\n            : viewRanges);\n        this.m_camera.near = this.m_viewRanges.near;\n        this.m_camera.far = this.m_viewRanges.far;\n        this.m_camera.updateProjectionMatrix();\n        // Update the \"relative to eye\" camera. Copy the public camera parameters\n        // and place the \"relative to eye\" at the world's origin.\n        this.m_rteCamera.copy(this.m_camera);\n        this.m_rteCamera.position.setScalar(0);\n        this.m_rteCamera.updateMatrixWorld(true);\n        (_a = this.m_textElementsRenderer) === null || _a === void 0 ? void 0 : _a.updateCamera();\n        this.m_screenProjector.update(this.camera, width, height);\n        this.m_pixelToWorld = undefined;\n        this.m_sceneEnvironment.update();\n    }\n    /**\n     * Derive the look at settings (i.e. target, zoom, ...) from the current camera.\n     */\n    updateLookAtSettings() {\n        let { target, distance, final } = Utils_1.MapViewUtils.getTargetAndDistance(this.projection, this.camera, this.elevationProvider);\n        if (!final) {\n            this.update();\n        }\n        if (this.geoMaxBounds) {\n            ({ target, distance } = Utils_1.MapViewUtils.constrainTargetAndDistanceToViewBounds(target, distance, this));\n        }\n        this.m_targetWorldPos.copy(target);\n        this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);\n        this.m_targetDistance = distance;\n        this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);\n        const { yaw, pitch, roll } = this.extractAttitude();\n        this.m_yaw = yaw;\n        this.m_pitch = pitch;\n        this.m_roll = roll;\n    }\n    /**\n     * Update `Env` instance used for style `Expr` evaluations.\n     */\n    updateEnv() {\n        this.m_env.entries.$zoom = this.m_zoomLevel;\n        // This one introduces unnecessary calculation of pixelToWorld, even if it's barely\n        // used in our styles.\n        this.m_env.entries.$pixelToMeters = this.pixelToWorld;\n        this.m_env.entries.$frameNumber = this.m_frameNumber;\n    }\n    /**\n     * Transfer the NDC point to view space.\n     * @param vector - Vector to transform.\n     * @param result - Result to place calculation.\n     */\n    ndcToView(vector, result) {\n        result\n            .set(vector.x, vector.y, vector.z)\n            .applyMatrix4(this.camera.projectionMatrixInverse)\n            // Make sure to apply rotation, hence use the rte camera\n            .applyMatrix4(this.m_rteCamera.matrixWorld);\n        return result;\n    }\n    /**\n     * Render loop callback that should only be called by [[requestAnimationFrame]].\n     * Will trigger [[requestAnimationFrame]] again if updates are pending or  animation is running.\n     * @param frameStartTime - The start time of the current frame\n     */\n    renderLoop(frameStartTime) {\n        // Render loop shouldn't run when synchronous rendering is enabled or if `MapView` has been\n        // disposed of.\n        if (this.m_options.synchronousRendering === true || this.disposed) {\n            return;\n        }\n        if (this.maxFps === 0) {\n            // Render with max fps\n            this.render(frameStartTime);\n        }\n        else {\n            // Limit fps by skipping frames\n            // Magic ingredient to compensate time flux.\n            const fudgeTimeInMs = 3;\n            const frameInterval = 1000 / this.maxFps;\n            const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;\n            const targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;\n            if (frameStartTime >= targetTime) {\n                this.render(frameStartTime);\n            }\n        }\n        // Continue rendering if update is pending or animation is running\n        if (this.m_updatePending || this.animating) {\n            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n        }\n        else {\n            // Stop rendering if no update is pending\n            this.m_animationFrameHandle = undefined;\n        }\n    }\n    /**\n     * Start render loop if not already running.\n     */\n    startRenderLoop() {\n        if (this.m_animationFrameHandle !== undefined || this.m_options.synchronousRendering) {\n            return;\n        }\n        this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n    }\n    /**\n     * Returns the list of the enabled data sources.\n     */\n    getEnabledTileDataSources() {\n        // ### build this list once decoders && datasources are ready\n        const enabledDataSources = [];\n        for (const dataSource of this.m_tileDataSources) {\n            if (this.isDataSourceEnabled(dataSource)) {\n                enabledDataSources.push(dataSource);\n            }\n        }\n        return enabledDataSources;\n    }\n    /**\n     * Renders the current frame.\n     */\n    render(frameStartTime) {\n        if (this.m_drawing) {\n            return;\n        }\n        if (this.disposed) {\n            logger.warn(\"render(): MapView has been disposed of.\");\n            return;\n        }\n        this.RENDER_EVENT.time = frameStartTime;\n        this.dispatchEvent(this.RENDER_EVENT);\n        this.m_tileObjectRenderer.prepareRender();\n        ++this.m_frameNumber;\n        let currentFrameEvent;\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        const gatherStatistics = stats.enabled;\n        if (gatherStatistics) {\n            currentFrameEvent = stats.currentFrame;\n            if (this.m_previousFrameTimeStamp !== undefined) {\n                // In contrast to fullFrameTime we also measure the application code\n                // for the FPS. This means FPS != 1000 / fullFrameTime.\n                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;\n                currentFrameEvent.setValue(\"render.fps\", 1000 / timeSincePreviousFrame);\n            }\n            // We store the last frame statistics at the beginning of the next frame b/c additional\n            // work (i.e. geometry creation) is done outside of the animation frame but still needs\n            // to be added to the `fullFrameTime` (see [[TileGeometryLoader]]).\n            stats.storeAndClearFrameInfo();\n            currentFrameEvent = currentFrameEvent;\n            currentFrameEvent.setValue(\"renderCount.frameNumber\", this.m_frameNumber);\n        }\n        this.m_previousFrameTimeStamp = frameStartTime;\n        let setupTime;\n        let cullTime;\n        let textPlacementTime;\n        let drawTime;\n        let textDrawTime;\n        let endTime;\n        this.m_renderer.info.reset();\n        this.m_updatePending = false;\n        this.m_thisFrameTilesChanged = undefined;\n        this.m_drawing = true;\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n        this.updateCameras();\n        this.updateEnv();\n        this.m_renderer.clear();\n        // clear the scenes\n        this.m_sceneRoot.children.length = 0;\n        this.m_overlaySceneRoot.children.length = 0;\n        if (gatherStatistics) {\n            setupTime = harp_utils_1.PerformanceTimer.now();\n        }\n        // TBD: Update renderList only any of its params (camera, etc...) has changed.\n        if (!this.lockVisibleTileSet) {\n            const viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_frameNumber, this.m_elevationRangeSource);\n            // View ranges has changed due to features (with elevation) that affects clip planes\n            // positioning, update cameras with new clip planes positions.\n            if (viewRangesStatus.viewRangesChanged) {\n                this.updateCameras(viewRangesStatus.viewRanges);\n            }\n        }\n        if (gatherStatistics) {\n            cullTime = harp_utils_1.PerformanceTimer.now();\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n        // no need to check everything if we're not going to create text renderer.\n        renderList.forEach(({ zoomLevel, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                this.m_tileObjectRenderer.render(tile, zoomLevel, this.zoomLevel, this.m_camera.position, this.m_sceneRoot);\n                //We know that rendered tiles are visible (in the view frustum), so we update the\n                //frame number, note we don't do this for the visibleTiles because some may still be\n                //loading (and therefore aren't visible in the sense of being seen on the screen).\n                //Note also, this number isn't currently used anywhere so should be considered to be\n                //removed in the future (though could be good for debugging purposes).\n                tile.frameNumLastVisible = this.m_frameNumber;\n            });\n        });\n        // Check if this is the time to place the labels for the first time. Pretty much everything\n        // should have been loaded, and no animation should be running.\n        if (!this.m_initialTextPlacementDone &&\n            !this.m_firstFrameComplete &&\n            !this.isDynamicFrame &&\n            !this.m_themeManager.isUpdating() &&\n            this.m_poiTableManager.finishedLoading &&\n            this.m_visibleTiles.allVisibleTilesLoaded &&\n            this.m_connectedDataSources.size + this.m_failedDataSources.size ===\n                this.m_tileDataSources.length &&\n            !this.m_textElementsRenderer.loading) {\n            this.m_initialTextPlacementDone = true;\n        }\n        this.m_mapAnchors.update(this.projection, this.camera.position, this.m_sceneRoot, this.m_overlaySceneRoot);\n        this.m_animatedExtrusionHandler.update(this.zoomLevel);\n        if (currentFrameEvent !== undefined) {\n            // Make sure the counters all have a value.\n            currentFrameEvent.addValue(\"renderCount.numTilesRendered\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesVisible\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesLoading\", 0);\n            // Increment the counters for all data sources.\n            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {\n                currentFrameEvent.addValue(\"renderCount.numTilesRendered\", renderedTiles.size);\n                currentFrameEvent.addValue(\"renderCount.numTilesVisible\", visibleTiles.length);\n                currentFrameEvent.addValue(\"renderCount.numTilesLoading\", numTilesLoading);\n            });\n        }\n        if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {\n            //FIXME: Shouldn't we use target here?\n            const { latitude, longitude, altitude } = this.geoCenter;\n            this.dispatchEvent({\n                type: MapViewEventNames.CameraPositionChanged,\n                latitude,\n                longitude,\n                altitude,\n                // FIXME: Can we remove yaw, pitch and roll\n                yaw: this.m_yaw,\n                pitch: this.m_pitch,\n                roll: this.m_roll,\n                tilt: this.tilt,\n                heading: this.heading,\n                zoom: this.zoomLevel\n            });\n        }\n        // The camera used to render the scene.\n        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;\n        if (this.renderLabels && !this.m_pointOfView) {\n            this.m_textElementsRenderer.placeText(renderList, frameStartTime);\n        }\n        if (gatherStatistics) {\n            textPlacementTime = harp_utils_1.PerformanceTimer.now();\n        }\n        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);\n        if (gatherStatistics) {\n            drawTime = harp_utils_1.PerformanceTimer.now();\n        }\n        if (this.renderLabels && !this.m_pointOfView) {\n            this.m_textElementsRenderer.renderText(this.m_viewRanges.maximum);\n        }\n        if (this.m_overlaySceneRoot.children.length > 0) {\n            this.m_renderer.render(this.m_overlayScene, camera);\n        }\n        if (gatherStatistics) {\n            textDrawTime = harp_utils_1.PerformanceTimer.now();\n        }\n        if (!this.m_firstFrameRendered) {\n            this.m_firstFrameRendered = true;\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrame\", frameStartTime);\n            }\n            this.FIRST_FRAME_EVENT.time = frameStartTime;\n            this.dispatchEvent(this.FIRST_FRAME_EVENT);\n        }\n        this.m_visibleTiles.disposePendingTiles();\n        this.m_drawing = false;\n        this.checkCopyrightUpdates();\n        // do this post paint therefore use a Timeout, if it has not been executed cancel and\n        // create a new one\n        if (this.m_taskSchedulerTimeout !== undefined) {\n            clearTimeout(this.m_taskSchedulerTimeout);\n        }\n        this.m_taskSchedulerTimeout = setTimeout(() => {\n            this.m_taskSchedulerTimeout = undefined;\n            this.m_taskScheduler.processPending(frameStartTime);\n        }, 0);\n        if (currentFrameEvent !== undefined) {\n            endTime = harp_utils_1.PerformanceTimer.now();\n            const frameRenderTime = endTime - frameStartTime;\n            currentFrameEvent.setValue(\"render.setupTime\", setupTime - frameStartTime);\n            currentFrameEvent.setValue(\"render.cullTime\", cullTime - setupTime);\n            currentFrameEvent.setValue(\"render.textPlacementTime\", textPlacementTime - cullTime);\n            currentFrameEvent.setValue(\"render.drawTime\", drawTime - textPlacementTime);\n            currentFrameEvent.setValue(\"render.textDrawTime\", textDrawTime - drawTime);\n            currentFrameEvent.setValue(\"render.cleanupTime\", endTime - textDrawTime);\n            currentFrameEvent.setValue(\"render.frameRenderTime\", frameRenderTime);\n            // Initialize the fullFrameTime with the frameRenderTime If we also create geometry in\n            // this frame, this number will be increased in the TileGeometryLoader.\n            currentFrameEvent.setValue(\"render.fullFrameTime\", frameRenderTime);\n            currentFrameEvent.setValue(\"render.geometryCreationTime\", 0);\n            // Add THREE.js statistics\n            stats.addWebGLInfo(this.m_renderer.info);\n            // Add memory statistics\n            // FIXME:\n            // This will only measure the memory of the rendering and not of the geometry creation.\n            // Assuming the garbage collector is not kicking in immediately we will at least see\n            // the geometry creation memory consumption accounted in the next frame.\n            stats.addMemoryInfo();\n        }\n        this.DID_RENDER_EVENT.time = frameStartTime;\n        this.dispatchEvent(this.DID_RENDER_EVENT);\n        // After completely rendering this frame, it is checked if this frame was the first complete\n        // frame, with no more tiles, geometry and labels waiting to be added, and no animation\n        // running. The initial placement of text in this render call may have changed the loading\n        // state of the TextElementsRenderer, so this has to be checked again.\n        // HARP-10919: Fading is currently ignored by the frame complete event.\n        if (!this.textElementsRenderer.loading &&\n            this.m_visibleTiles.allVisibleTilesLoaded &&\n            this.m_initialTextPlacementDone &&\n            !this.m_animatedExtrusionHandler.isAnimating) {\n            if (this.m_firstFrameComplete === false) {\n                this.m_firstFrameComplete = true;\n                if (gatherStatistics) {\n                    stats.appResults.set(\"firstFrameComplete\", frameStartTime);\n                }\n            }\n            this.FRAME_COMPLETE_EVENT.time = frameStartTime;\n            this.dispatchEvent(this.FRAME_COMPLETE_EVENT);\n        }\n    }\n    setupCamera() {\n        harp_utils_1.assert(this.m_visibleTiles !== undefined);\n        const { width, height } = this.getCanvasClientSize();\n        this.calculateFocalLength(height);\n        this.m_options.target = harp_geoutils_1.GeoCoordinates.fromObject(harp_utils_1.getOptionValue(this.m_options.target, MapViewDefaults.target));\n        // ensure that look at target has height of 0\n        this.m_options.target.altitude = 0;\n        this.m_options.tilt = harp_utils_1.getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);\n        this.m_options.heading = harp_utils_1.getOptionValue(this.m_options.heading, MapViewDefaults.heading);\n        this.m_options.zoomLevel = harp_utils_1.getOptionValue(this.m_options.zoomLevel, MapViewDefaults.zoomLevel);\n        this.lookAtImpl(this.m_options);\n        // ### move & customize\n        this.resize(width, height);\n    }\n    createVisibleTileSet() {\n        harp_utils_1.assert(this.m_tileGeometryManager !== undefined);\n        if (this.m_visibleTiles) {\n            // Dispose of all resources before the old instance is replaced.\n            this.m_visibleTiles.clearTileCache();\n            this.m_visibleTiles.disposePendingTiles();\n        }\n        const enableMixedLod = this.m_enableMixedLod === undefined\n            ? this.projection.type === harp_geoutils_1.ProjectionType.Spherical\n            : this.m_enableMixedLod;\n        this.m_visibleTiles = new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod, this.m_lodMinTilePixelSize), this.m_tileGeometryManager, this.m_visibleTileSetOptions, this.taskQueue);\n        return this.m_visibleTiles;\n    }\n    movementStarted() {\n        this.m_textElementsRenderer.movementStarted();\n        this.MOVEMENT_STARTED_EVENT.time = Date.now();\n        this.dispatchEvent(this.MOVEMENT_STARTED_EVENT);\n    }\n    movementFinished() {\n        this.m_textElementsRenderer.movementFinished();\n        this.MOVEMENT_FINISHED_EVENT.time = Date.now();\n        this.dispatchEvent(this.MOVEMENT_FINISHED_EVENT);\n        // render at the next possible time.\n        if (!this.animating) {\n            if (this.m_movementFinishedUpdateTimerId !== undefined) {\n                clearTimeout(this.m_movementFinishedUpdateTimerId);\n            }\n            this.m_movementFinishedUpdateTimerId = setTimeout(() => {\n                this.m_movementFinishedUpdateTimerId = undefined;\n                this.update();\n            }, 0);\n        }\n    }\n    /**\n     * Check if the set of visible tiles changed since the last frame.\n     *\n     * May be called multiple times per frame.\n     *\n     * Equality is computed by creating a string containing the IDs of the tiles.\n     */\n    checkIfTilesChanged() {\n        if (this.m_thisFrameTilesChanged !== undefined) {\n            return this.m_thisFrameTilesChanged;\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n        const tileIdList = [];\n        tileIdList.length = 0;\n        renderList.forEach(({ dataSource, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                tileIdList.push(dataSource.name + \"-\" + tile.tileKey.mortonCode());\n            });\n        });\n        tileIdList.sort();\n        const newTileIds = tileIdList.join(\"#\");\n        if (newTileIds !== this.m_lastTileIds) {\n            this.m_lastTileIds = newTileIds;\n            this.m_thisFrameTilesChanged = true;\n        }\n        else {\n            this.m_thisFrameTilesChanged = false;\n        }\n        return this.m_thisFrameTilesChanged;\n    }\n    checkCopyrightUpdates() {\n        if (!this.checkIfTilesChanged()) {\n            return;\n        }\n        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();\n        if (newCopyrightInfo === this.m_copyrightInfo) {\n            return;\n        }\n        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {\n            let allEqual = true;\n            for (let i = 0; i < newCopyrightInfo.length; i++) {\n                const a = newCopyrightInfo[i];\n                const b = this.m_copyrightInfo[i];\n                if (a.label !== b.label) {\n                    allEqual = false;\n                    break;\n                }\n            }\n            if (allEqual) {\n                return;\n            }\n        }\n        this.m_copyrightInfo = newCopyrightInfo;\n        this.dispatchEvent(this.COPYRIGHT_CHANGED_EVENT);\n    }\n    getRenderedTilesCopyrightInfo() {\n        let result = [];\n        for (const tileList of this.m_visibleTiles.dataSourceTileList) {\n            for (const tile of tileList.renderedTiles.values()) {\n                const tileCopyrightInfo = tile.copyrightInfo;\n                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {\n                    continue;\n                }\n                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);\n            }\n        }\n        return result;\n    }\n    setupStats(enable) {\n        new Statistics_1.PerformanceStatistics(enable, 1000);\n    }\n    setupRenderer(tileObjectRenderer) {\n        var _a;\n        this.m_scene.add(this.m_sceneRoot);\n        this.m_overlayScene.add(this.m_overlaySceneRoot);\n        this.shadowsEnabled = (_a = this.m_options.enableShadows) !== null && _a !== void 0 ? _a : false;\n        tileObjectRenderer.setupRenderer();\n    }\n    createTextRenderer() {\n        const updateCallback = () => {\n            this.update();\n        };\n        return new TextElementsRenderer_1.TextElementsRenderer(new MapViewState_1.MapViewState(this, this.checkIfTilesChanged.bind(this)), updateCallback, this.m_screenProjector, this.m_poiManager, this.m_renderer, [this.imageCache, this.userImageCache], this.m_options);\n    }\n    /**\n     * @internal\n     * @param fontCatalogs\n     * @param textStyles\n     * @param defaultTextStyle\n     */\n    async resetTextRenderer(fontCatalogs, textStyles, defaultTextStyle) {\n        await this.m_textElementsRenderer.updateFontCatalogs(fontCatalogs);\n        await this.m_textElementsRenderer.updateTextStyles(textStyles, defaultTextStyle);\n        this.update();\n    }\n    limitFov(fov, aspect) {\n        fov = THREE.MathUtils.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n        let hFov = THREE.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.MathUtils.degToRad(fov), aspect));\n        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {\n            hFov = THREE.MathUtils.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n            fov = THREE.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateVerticalFovByHorizontalFov(THREE.MathUtils.degToRad(hFov), aspect));\n        }\n        return fov;\n    }\n    /**\n     * Sets the field of view calculation, and applies it immediately to the camera.\n     *\n     * @param type - How to calculate the FOV\n     */\n    setFovOnCamera(fovCalculation, height) {\n        let fov = 0;\n        if (fovCalculation.type === \"fixed\") {\n            this.calculateFocalLength(height);\n            fov = fovCalculation.fov;\n        }\n        else {\n            harp_utils_1.assert(this.m_focalLength !== 0);\n            fov = Utils_1.MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);\n        }\n        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);\n    }\n    /**\n     * Sets the focal length based on the supplied fov and the height of the canvas. This must be\n     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is\n     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas\n     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is\n     * fixed but the FOV changes.\n     * @param height - Height of the canvas in css / client pixels.\n     */\n    calculateFocalLength(height) {\n        harp_utils_1.assert(this.m_options.fovCalculation !== undefined);\n        this.m_focalLength = Utils_1.MapViewUtils.calculateFocalLengthByVerticalFov(THREE.MathUtils.degToRad(this.m_options.fovCalculation.fov), height);\n    }\n    /**\n     * Get canvas client size in css/client pixels.\n     *\n     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by\n     * calculating it from actual canvas size and current pixel ratio.\n     */\n    getCanvasClientSize() {\n        const { clientWidth, clientHeight } = this.canvas;\n        if (clientWidth === 0 ||\n            clientHeight === 0 ||\n            typeof clientWidth !== \"number\" ||\n            typeof clientHeight !== \"number\") {\n            const pixelRatio = this.m_renderer.getPixelRatio();\n            return {\n                width: Math.round(this.canvas.width / pixelRatio),\n                height: Math.round(this.canvas.height / pixelRatio)\n            };\n        }\n        else {\n            return { width: clientWidth, height: clientHeight };\n        }\n    }\n}\nexports.MapView = MapView;\n//# sourceMappingURL=MapView.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapView.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewAtmosphere = exports.AtmosphereLightMode = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ \"./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js\");\n/**\n * Atmosphere effect variants.\n */\nvar AtmosphereVariant;\n(function (AtmosphereVariant) {\n    AtmosphereVariant[AtmosphereVariant[\"Ground\"] = 1] = \"Ground\";\n    AtmosphereVariant[AtmosphereVariant[\"Sky\"] = 2] = \"Sky\";\n    AtmosphereVariant[AtmosphereVariant[\"SkyAndGround\"] = 3] = \"SkyAndGround\";\n})(AtmosphereVariant || (AtmosphereVariant = {}));\n/**\n * Atmosphere shader variants.\n */\nvar AtmosphereShadingVariant;\n(function (AtmosphereShadingVariant) {\n    AtmosphereShadingVariant[AtmosphereShadingVariant[\"ScatteringShader\"] = 0] = \"ScatteringShader\";\n    AtmosphereShadingVariant[AtmosphereShadingVariant[\"SimpleColor\"] = 1] = \"SimpleColor\";\n    AtmosphereShadingVariant[AtmosphereShadingVariant[\"Wireframe\"] = 2] = \"Wireframe\";\n})(AtmosphereShadingVariant || (AtmosphereShadingVariant = {}));\n/**\n * Lists light modes.\n */\nvar AtmosphereLightMode;\n(function (AtmosphereLightMode) {\n    AtmosphereLightMode[AtmosphereLightMode[\"LightOverhead\"] = 0] = \"LightOverhead\";\n    AtmosphereLightMode[AtmosphereLightMode[\"LightDynamic\"] = 1] = \"LightDynamic\";\n})(AtmosphereLightMode = exports.AtmosphereLightMode || (exports.AtmosphereLightMode = {}));\n/**\n * Maximum altitude that atmosphere reaches as the percent of the Earth radius.\n */\nconst SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;\n/**\n * Maximum altitude that ground atmosphere is visible as the percent of the Earth radius.\n */\nconst GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 0.0001;\n/**\n * Utility cache for holding temporary values.\n */\nconst cache = {\n    clipPlanes: { near: 0, far: 0 }\n};\n/**\n * Class that provides {@link MapView}'s atmospheric scattering effect.\n */\nclass MapViewAtmosphere {\n    /**\n     * Creates and adds `Atmosphere` effects to the scene.\n     *\n     * @note Currently works only with globe projection.\n     *\n     * @param m_mapAnchors - The {@link MapAnchors} instance where the effect will be added.\n     * @param m_sceneCamera - The camera used to render entire scene.\n     * @param m_projection - The geo-projection used to transform geo coordinates to\n     *                       cartesian space.\n     * @param m_rendererCapabilities The capabilities of the WebGL renderer.\n     * @param m_updateCallback - The optional callback to that should be called whenever atmosphere\n     * configuration changes, may be used to inform related components (`MapView`) to redraw.\n     * @param m_atmosphereVariant - The optional atmosphere configuration variant enum\n     * [[AtmosphereVariant]], which denotes where the atmosphere scattering effect should be\n     * applied, it may be ground or sky atmosphere only or most realistic for both, which is\n     * chosen by default.\n     * @param m_materialVariant - The optional material variant to be used, mainly for\n     * testing and tweaking purposes.\n     */\n    constructor(m_mapAnchors, m_sceneCamera, m_projection, m_rendererCapabilities, m_updateCallback, m_atmosphereVariant = AtmosphereVariant.SkyAndGround, m_materialVariant = AtmosphereShadingVariant.ScatteringShader) {\n        this.m_mapAnchors = m_mapAnchors;\n        this.m_sceneCamera = m_sceneCamera;\n        this.m_projection = m_projection;\n        this.m_rendererCapabilities = m_rendererCapabilities;\n        this.m_updateCallback = m_updateCallback;\n        this.m_atmosphereVariant = m_atmosphereVariant;\n        this.m_materialVariant = m_materialVariant;\n        this.m_enabled = true;\n        this.m_clipPlanesEvaluator = new ClipPlanesEvaluator_1.TiltViewClipPlanesEvaluator(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR, 0, 1.0, 0.05, 10000000.0);\n        // TODO: Support for Theme definition should be added.\n        //private m_cachedTheme: Theme = { styles: {} };\n        this.m_lightDirection = new THREE.Vector3(0.0, 1.0, 0.0);\n        if (this.m_atmosphereVariant & AtmosphereVariant.Sky) {\n            this.createSkyGeometry();\n        }\n        if (this.m_atmosphereVariant & AtmosphereVariant.Ground) {\n            this.createGroundGeometry();\n        }\n        this.addToMapAnchors(this.m_mapAnchors);\n    }\n    /**\n     * Check if map anchors have already atmosphere effect added.\n     *\n     * @param mapAnchors - MapAnchors to check.\n     */\n    static isPresent(mapAnchors) {\n        for (const mapAnchor of mapAnchors.children) {\n            if (mapAnchor.name === MapViewAtmosphere.SkyAtmosphereUserName ||\n                mapAnchor.name === MapViewAtmosphere.GroundAtmosphereUserName) {\n                return true;\n            }\n        }\n        return false;\n    }\n    get skyMesh() {\n        return this.m_skyMesh;\n    }\n    get groundMesh() {\n        return this.m_groundMesh;\n    }\n    /**\n     * Allows to enable/disable the atmosphere effect, regardless of the theme settings.\n     *\n     * Use this method to change the setup in runtime without defining corresponding theme setup.\n     *\n     * @param enable - A boolean that specifies whether the atmosphere should be enabled or\n     *                 disabled.\n     */\n    set enabled(enable) {\n        // Check already disposed.\n        if (this.disposed) {\n            return;\n        }\n        if (this.m_enabled === enable) {\n            return;\n        }\n        this.m_enabled = enable;\n        const isAdded = MapViewAtmosphere.isPresent(this.m_mapAnchors);\n        if (enable && !isAdded) {\n            this.addToMapAnchors(this.m_mapAnchors);\n        }\n        else if (!enable && isAdded) {\n            this.removeFromMapAnchors(this.m_mapAnchors);\n        }\n    }\n    /**\n     * Returns the current atmosphere status, enabled or disabled.\n     */\n    get enabled() {\n        return this.m_enabled;\n    }\n    set lightMode(lightMode) {\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            return;\n        }\n        const dynamicLight = lightMode === AtmosphereLightMode.LightDynamic;\n        if (this.m_groundMaterial !== undefined) {\n            const groundMat = this.m_groundMaterial;\n            groundMat.setDynamicLighting(dynamicLight);\n        }\n        if (this.m_skyMaterial !== undefined) {\n            const skyMat = this.m_skyMaterial;\n            skyMat.setDynamicLighting(dynamicLight);\n        }\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        var _a, _b, _c, _d;\n        // Unlink from scene and mapview anchors\n        if (this.enabled) {\n            this.enabled = false;\n        }\n        (_a = this.m_skyMaterial) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this.m_groundMaterial) === null || _b === void 0 ? void 0 : _b.dispose();\n        (_c = this.m_skyGeometry) === null || _c === void 0 ? void 0 : _c.dispose();\n        (_d = this.m_groundGeometry) === null || _d === void 0 ? void 0 : _d.dispose();\n        // After disposal we may no longer enable effect.\n        this.m_skyGeometry = undefined;\n        this.m_groundGeometry = undefined;\n        this.m_skyMaterial = undefined;\n        this.m_groundMaterial = undefined;\n        this.m_skyMesh = undefined;\n        this.m_groundMesh = undefined;\n    }\n    /**\n     * Sets the atmosphere depending on the\n     * {@link @here/harp-datasource-protocol#Theme} instance provided.\n     *\n     * This function is called when a theme is loaded. Atmosphere is added only if the theme\n     * contains a atmosphere definition with a:\n     * - `color` property, used to set the atmosphere color.\n     *\n     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.\n     */\n    reset(theme) {\n        //this.m_cachedTheme = theme;\n    }\n    get disposed() {\n        return this.m_skyMesh === undefined && this.m_groundMesh === undefined;\n    }\n    /**\n     * Handles atmosphere effect adding.\n     */\n    addToMapAnchors(mapAnchors) {\n        harp_utils_1.assert(!MapViewAtmosphere.isPresent(mapAnchors), \"Atmosphere already added\");\n        if (this.m_skyMesh !== undefined) {\n            mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));\n        }\n        if (this.m_groundMesh !== undefined) {\n            mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));\n        }\n        // Request an update once the anchor is added to {@link MapView}.\n        if (this.m_updateCallback) {\n            this.m_updateCallback();\n        }\n    }\n    /**\n     * Handles atmosphere effect removal.\n     */\n    removeFromMapAnchors(mapAnchors) {\n        if (!MapViewAtmosphere.isPresent(mapAnchors)) {\n            return;\n        }\n        let update = false;\n        if (this.m_skyMesh !== undefined) {\n            mapAnchors.remove(this.m_skyMesh);\n            update = true;\n        }\n        if (this.m_groundMesh !== undefined) {\n            mapAnchors.remove(this.m_groundMesh);\n            update = true;\n        }\n        if (update && this.m_updateCallback) {\n            this.m_updateCallback();\n        }\n    }\n    createSkyGeometry() {\n        let skyGeometry;\n        switch (this.m_projection.type) {\n            case harp_geoutils_1.ProjectionType.Spherical:\n                skyGeometry = new THREE.SphereGeometry(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);\n                break;\n            default: {\n                skyGeometry = new THREE.PlaneGeometry(200, 200);\n                break;\n            }\n        }\n        skyGeometry.translate(0, 0, 0);\n        this.m_skyGeometry = new THREE.BufferGeometry();\n        this.m_skyGeometry.fromGeometry(skyGeometry);\n        skyGeometry.dispose();\n        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {\n            this.m_skyMaterial = new harp_materials_1.SkyAtmosphereMaterial({\n                rendererCapabilities: this.m_rendererCapabilities\n            });\n        }\n        else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {\n            this.m_skyMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0xc4f8ed),\n                opacity: 0.4,\n                transparent: false,\n                depthTest: true,\n                depthWrite: false,\n                side: THREE.BackSide,\n                blending: THREE.NormalBlending,\n                fog: false\n            });\n        }\n        else {\n            this.m_skyMaterial = new THREE.MeshStandardMaterial({\n                color: 0x7fffff,\n                depthTest: false,\n                depthWrite: false,\n                normalScale: new THREE.Vector2(-1, -1),\n                side: THREE.BackSide,\n                wireframe: true\n            });\n        }\n        this.m_skyMesh = new THREE.Mesh(this.m_skyGeometry, this.m_skyMaterial);\n        // Assign custom name so sky object may be easily recognized withing the scene.\n        this.m_skyMesh.name = MapViewAtmosphere.SkyAtmosphereUserName;\n        this.setupSkyForRendering();\n    }\n    createGroundGeometry() {\n        let groundGeometry;\n        switch (this.m_projection.type) {\n            case harp_geoutils_1.ProjectionType.Spherical:\n                groundGeometry = new THREE.SphereGeometry(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);\n                break;\n            default: {\n                groundGeometry = new THREE.PlaneGeometry(200, 200);\n                break;\n            }\n        }\n        groundGeometry.translate(0, 0, 0);\n        this.m_groundGeometry = new THREE.BufferGeometry();\n        this.m_groundGeometry.fromGeometry(groundGeometry);\n        groundGeometry.dispose();\n        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {\n            this.m_groundMaterial = new harp_materials_1.GroundAtmosphereMaterial({\n                rendererCapabilities: this.m_rendererCapabilities\n            });\n        }\n        else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {\n            this.m_groundMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0x00c5ff),\n                opacity: 0.4,\n                transparent: true,\n                depthTest: false,\n                depthWrite: false,\n                side: THREE.FrontSide,\n                blending: THREE.NormalBlending,\n                fog: false\n            });\n        }\n        else {\n            this.m_groundMaterial = new THREE.MeshStandardMaterial({\n                color: 0x11899a,\n                depthTest: true,\n                depthWrite: false,\n                side: THREE.FrontSide,\n                wireframe: true\n            });\n        }\n        this.m_groundMesh = new THREE.Mesh(this.m_groundGeometry, this.m_groundMaterial);\n        // Assign name so object may be recognized withing the scene.\n        this.m_groundMesh.name = MapViewAtmosphere.GroundAtmosphereUserName;\n        this.setupGroundForRendering();\n    }\n    setupSkyForRendering() {\n        if (this.m_skyMesh === undefined) {\n            return;\n        }\n        // Depending on material variant we need to update uniforms or only\n        // update camera near/far planes cause camera need to see further then\n        // actual earth geometry.\n        let onBeforeCallback;\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            // Setup only further clip planes before rendering.\n            onBeforeCallback = (camera, _material) => {\n                this.overrideClipPlanes(camera);\n            };\n        }\n        else {\n            // Setup proper clip planes and update uniforms values.\n            onBeforeCallback = (camera, material) => {\n                this.overrideClipPlanes(camera);\n                // Check material wasn't swapped.\n                harp_utils_1.assert(material instanceof harp_materials_1.SkyAtmosphereMaterial);\n                const mat = this.m_skyMaterial;\n                mat.updateUniforms(mat, this.m_skyMesh, camera, this.m_lightDirection);\n            };\n        }\n        // Sky material should be already created with mesh.\n        harp_utils_1.assert(this.m_skyMaterial !== undefined);\n        this.m_skyMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {\n            onBeforeCallback(camera, material);\n        };\n        this.m_skyMesh.onAfterRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            this.revertClipPlanes(camera);\n        };\n    }\n    setupGroundForRendering() {\n        if (this.m_groundMesh === undefined) {\n            return;\n        }\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            return;\n        }\n        // Ground material should be already created.\n        harp_utils_1.assert(this.m_groundMaterial !== undefined);\n        // Ground mesh does not need custom clip planes and uses the same camera setup as\n        // real (data source based) geometry.\n        this.m_groundMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {\n            harp_utils_1.assert(material instanceof harp_materials_1.GroundAtmosphereMaterial);\n            const mat = this.m_groundMaterial;\n            mat.updateUniforms(mat, this.m_groundMesh, camera, this.m_lightDirection);\n        };\n    }\n    overrideClipPlanes(rteCamera) {\n        // Store current clip planes used by global camera before modifying them.\n        const sceneCam = this.m_sceneCamera;\n        cache.clipPlanes.near = sceneCam.near;\n        cache.clipPlanes.far = sceneCam.far;\n        // Calculate view ranges using world camera.\n        // NOTE: ElevationProvider is not passed to evaluator, leaves min/max altitudes unchanged.\n        const viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(this.m_sceneCamera, this.m_projection);\n        // Update relative to eye camera used internally in rendering.\n        harp_utils_1.assert(rteCamera instanceof THREE.PerspectiveCamera);\n        const c = rteCamera;\n        c.near = viewRanges.near;\n        // Small margin ensures that we never cull small triangles just below or at\n        // horizon - possible due to frustum culling in-precisions.\n        c.far = viewRanges.far + harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * 0.1;\n        c.updateProjectionMatrix();\n    }\n    revertClipPlanes(rteCamera) {\n        harp_utils_1.assert(rteCamera instanceof THREE.PerspectiveCamera);\n        const c = rteCamera;\n        // Restore scene camera clip planes.\n        c.near = cache.clipPlanes.near;\n        c.far = cache.clipPlanes.far;\n        c.updateProjectionMatrix();\n    }\n}\nexports.MapViewAtmosphere = MapViewAtmosphere;\n/**\n * User data name attribute assigned to created mesh.\n */\nMapViewAtmosphere.SkyAtmosphereUserName = \"SkyAtmosphere\";\n/**\n * User data name attribute assigned to created mesh.\n */\nMapViewAtmosphere.GroundAtmosphereUserName = \"GroundAtmosphere\";\nfunction createMapAnchor(mesh, renderOrder) {\n    const anchor = mesh;\n    anchor.renderOrder = renderOrder;\n    anchor.pickable = false;\n    anchor.anchor = new THREE.Vector3(0, 0, 0);\n    return anchor;\n}\n//# sourceMappingURL=MapViewAtmosphere.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewEnvironment.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewEnvironment.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewEnvironment = exports.DEFAULT_CLEAR_COLOR = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ \"./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js\");\nconst MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ \"./node_modules/@here/harp-mapview/lib/MapViewFog.js\");\nconst SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ \"./node_modules/@here/harp-mapview/lib/SkyBackground.js\");\nconst ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ \"./node_modules/@here/harp-mapview/lib/ThemeHelpers.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"MapViewEnvironment\");\n//  the default breaks the ibct tests, seems it had not been used in all cases before\nexports.DEFAULT_CLEAR_COLOR = 0xffffff; //0xefe9e1;\nconst cache = {\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    frustumPoints: [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ]\n};\n/**\n * Class handling the Scene Environment, like fog, sky, background datasource, clearColor etc\n *  for MapView\n */\nclass MapViewEnvironment {\n    constructor(m_mapView, options) {\n        this.m_mapView = m_mapView;\n        this.m_fog = new MapViewFog_1.MapViewFog(this.m_mapView.scene);\n        if (options.addBackgroundDatasource !== false) {\n            this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();\n            this.m_mapView.addDataSource(this.m_backgroundDataSource);\n        }\n        if (options.backgroundTilingScheme !== undefined &&\n            this.m_backgroundDataSource !== undefined) {\n            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);\n        }\n        this.updateClearColor();\n    }\n    get lights() {\n        var _a;\n        return (_a = this.m_createdLights) !== null && _a !== void 0 ? _a : [];\n    }\n    get fog() {\n        return this.m_fog;\n    }\n    updateBackgroundDataSource() {\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n    }\n    clearBackgroundDataSource() {\n        if (this.m_backgroundDataSource !== undefined) {\n            this.m_mapView.clearTileCache(this.m_backgroundDataSource.name);\n        }\n    }\n    update() {\n        this.m_fog.update(this.m_mapView, this.m_mapView.viewRanges.maximum);\n        if (this.m_skyBackground !== undefined &&\n            this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            this.m_skyBackground.updateCamera(this.m_mapView.camera);\n        }\n        this.updateLights();\n    }\n    updateClearColor(clearColor, clearAlpha) {\n        if (clearColor !== undefined) {\n            this.m_mapView.renderer.setClearColor(new THREE.Color(clearColor), clearAlpha);\n        }\n        else {\n            this.m_mapView.renderer.setClearColor(exports.DEFAULT_CLEAR_COLOR, clearAlpha);\n        }\n    }\n    updateSkyBackground(sky, clearColor) {\n        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && sky !== undefined) {\n            // there is a sky in the view and there is a sky option in the theme. Update the colors\n            this.updateSkyBackgroundColors(sky, clearColor);\n        }\n        else if (this.m_skyBackground === undefined && sky !== undefined) {\n            // there is no sky in the view but there is a sky option in the theme\n            this.addNewSkyBackground(sky, clearColor);\n            return;\n        }\n        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && sky === undefined) {\n            // there is a sky in the view, but not in the theme\n            this.removeSkyBackGround();\n        }\n    }\n    updateLighting(lights) {\n        var _a;\n        if (this.m_createdLights) {\n            this.m_createdLights.forEach((light) => {\n                this.m_mapView.scene.remove(light);\n            });\n        }\n        (_a = this.m_overlayCreatedLights) === null || _a === void 0 ? void 0 : _a.forEach(light => {\n            this.m_mapView.overlayScene.remove(light);\n            if (light instanceof THREE.DirectionalLight) {\n                this.m_mapView.overlayScene.remove(light.target);\n            }\n        });\n        if (lights !== undefined) {\n            this.m_createdLights = [];\n            this.m_overlayCreatedLights = [];\n            lights.forEach((lightDescription) => {\n                const light = ThemeHelpers_1.createLight(lightDescription);\n                if (!light) {\n                    logger.warn(`MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);\n                    return;\n                }\n                this.m_mapView.scene.add(light);\n                if (light.isDirectionalLight) {\n                    const directionalLight = light;\n                    // This is needed so that the target is updated automatically, see:\n                    // https://threejs.org/docs/#api/en/lights/DirectionalLight.target\n                    this.m_mapView.scene.add(directionalLight.target);\n                }\n                this.m_createdLights.push(light);\n                const clonedLight = light.clone();\n                this.m_mapView.overlayScene.add(clonedLight);\n                if (clonedLight instanceof THREE.DirectionalLight) {\n                    this.m_mapView.overlayScene.add(clonedLight.target.clone());\n                }\n            });\n        }\n    }\n    /**\n     * Update the directional light camera. Note, this requires the cameras to first be updated.\n     */\n    updateLights() {\n        // TODO: HARP-9479 Globe doesn't support shadows.\n        if (!this.m_mapView.shadowsEnabled ||\n            this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical ||\n            this.m_createdLights === undefined ||\n            this.m_createdLights.length === 0) {\n            return;\n        }\n        const points = [\n            // near plane points\n            { x: -1, y: -1, z: -1 },\n            { x: 1, y: -1, z: -1 },\n            { x: -1, y: 1, z: -1 },\n            { x: 1, y: 1, z: -1 },\n            // far planes points\n            { x: -1, y: -1, z: 1 },\n            { x: 1, y: -1, z: 1 },\n            { x: -1, y: 1, z: 1 },\n            { x: 1, y: 1, z: 1 }\n        ];\n        const transformedPoints = points.map((p, i) => this.m_mapView.ndcToView(p, cache.frustumPoints[i]));\n        this.m_createdLights.forEach(element => {\n            const directionalLight = element;\n            if (directionalLight.isDirectionalLight === true) {\n                const lightDirection = cache.vector3[0];\n                lightDirection.copy(directionalLight.target.position);\n                lightDirection.sub(directionalLight.position);\n                lightDirection.normalize();\n                const normal = cache.vector3[1];\n                if (this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n                    // -Z points to the camera, we can't use Projection.surfaceNormal, because\n                    // webmercator and mercator give different results.\n                    normal.set(0, 0, -1);\n                }\n                else {\n                    // Enable shadows for globe...\n                    //this.projection.surfaceNormal(target, normal);\n                }\n                // The camera of the shadow has the same height as the map camera, and the target is\n                // also the same. The position is then calculated based on the light direction and\n                // the height\n                // using basic trigonometry.\n                const tilt = this.m_mapView.tilt;\n                const cameraHeight = this.m_mapView.targetDistance * Math.cos(THREE.MathUtils.degToRad(tilt));\n                const lightPosHyp = cameraHeight / normal.dot(lightDirection);\n                directionalLight.target.position\n                    .copy(this.m_mapView.worldTarget)\n                    .sub(this.m_mapView.camera.position);\n                directionalLight.position.copy(this.m_mapView.worldTarget);\n                directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);\n                directionalLight.position.sub(this.m_mapView.camera.position);\n                directionalLight.updateMatrixWorld();\n                directionalLight.shadow.updateMatrices(directionalLight);\n                const camera = directionalLight.shadow.camera;\n                const pointsInLightSpace = transformedPoints.map(p => this.viewToLightSpace(p.clone(), camera));\n                const box = new THREE.Box3();\n                pointsInLightSpace.forEach(point => {\n                    box.expandByPoint(point);\n                });\n                camera.left = box.min.x;\n                camera.right = box.max.x;\n                camera.top = box.max.y;\n                camera.bottom = box.min.y;\n                // Moving back to the light the near plane in order to catch high buildings, that\n                // are not visible by the camera, but existing on the scene.\n                camera.near = -box.max.z * 0.95;\n                camera.far = -box.min.z;\n                camera.updateProjectionMatrix();\n            }\n        });\n    }\n    addNewSkyBackground(sky, clearColor) {\n        if (sky.type === \"gradient\" && sky.groundColor === undefined) {\n            sky.groundColor = harp_utils_1.getOptionValue(clearColor, \"#000000\");\n        }\n        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.m_mapView.projection.type, this.m_mapView.camera);\n        this.m_mapView.scene.background = this.m_skyBackground.texture;\n    }\n    removeSkyBackGround() {\n        this.m_mapView.scene.background = null;\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.dispose();\n            this.m_skyBackground = undefined;\n        }\n    }\n    updateSkyBackgroundColors(sky, clearColor) {\n        var _a;\n        if (sky.type === \"gradient\" && sky.groundColor === undefined) {\n            sky.groundColor = harp_utils_1.getOptionValue(clearColor, \"#000000\");\n        }\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.updateTexture(sky, this.m_mapView.projection.type);\n            this.m_mapView.scene.background = (_a = this.m_skyBackground) === null || _a === void 0 ? void 0 : _a.texture;\n        }\n    }\n    /**\n     * Transfer from view space to camera space.\n     * @param viewPos - position in view space, result is stored here.\n     */\n    viewToLightSpace(viewPos, camera) {\n        return viewPos.applyMatrix4(camera.matrixWorldInverse);\n    }\n}\nexports.MapViewEnvironment = MapViewEnvironment;\n//# sourceMappingURL=MapViewEnvironment.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewEnvironment.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewFog.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewFog.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewFog = void 0;\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! @here/harp-materials/lib/RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Manages the fog display in {@link MapView}.\n */\nclass MapViewFog {\n    /**\n     * Constructs a `MapViewFog` instance.\n     *\n     * @param m_scene - The scene used in {@link MapView} that contains the map objects.\n     */\n    constructor(m_scene) {\n        this.m_scene = m_scene;\n        this.m_enabled = true;\n        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.\n        this.m_fogIsDefined = false;\n    }\n    /**\n     * Allows for disabling the fog, even if it is defined in the theme. Use this property for\n     * custom views like the demo app's debug camera. However, if the theme does not define a\n     * fog, enabling this property here has no effect.\n     *\n     * @param value - A boolean that specifies whether the fog should be enabled or disabled.\n     */\n    set enabled(enableFog) {\n        this.m_enabled = enableFog;\n        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {\n            this.add();\n        }\n        else if (!enableFog && this.m_scene.fog !== null) {\n            this.remove();\n        }\n    }\n    /**\n     * Returns the current fog status, enabled or disabled.\n     */\n    get enabled() {\n        return this.m_enabled;\n    }\n    /**\n     * Sets the fog depending on the {@link @here/harp-datasource-protocol#Theme}\n     * instance provided. This function is called when a\n     * theme is loaded. Fog is added only if the theme contains a fog definition with a:\n     * - `color` property, used to set the fog color.\n     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far\n     * clipping plane distance.\n     *\n     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.\n     */\n    reset(fog) {\n        this.m_cachedFog = fog;\n        if (fog !== undefined && fog.color !== undefined && fog.startRatio !== undefined) {\n            this.m_fogIsDefined = true;\n            this.m_fog.color.set(fog.color);\n            if (this.m_enabled && this.m_scene.fog === null) {\n                this.add();\n            }\n        }\n        else {\n            this.m_fogIsDefined = false;\n            if (this.m_scene.fog !== null) {\n                this.remove();\n            }\n        }\n    }\n    /**\n     * Updates the fog at runtime, depending on the camera.\n     *\n     * @param camera - An instance of a `THREE.Camera` with a `far` property.\n     */\n    update(mapView, viewDistance) {\n        if (this.m_scene.fog !== null &&\n            this.m_cachedFog !== undefined &&\n            this.m_cachedFog &&\n            this.m_cachedFog.startRatio !== undefined &&\n            (mapView.camera.far !== undefined || viewDistance !== undefined)) {\n            // If maximum visibility range is available use it instead of camera.far distance,\n            // this makes fog independent from dynamic camera planes and keeps consistent\n            // distance based \"melting\" (fog) effect during a tilt.\n            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;\n            // TODO: We may move below constants to theme Fog definition\n            // Density of the fog when viewing straight along the horizon line.\n            const horizontalDensity = 1.0;\n            // Theoretical density of the fog when viewing straight from top to down.\n            const verticalDensity = 0.0;\n            // The fraction of the maximum viewing distance along the eye vector\n            // to start applying the fog.\n            const startRatio = this.m_cachedFog.startRatio;\n            // The fraction of maximum viewing range at which fog fully covers geometry.\n            const endRatio = 1.0;\n            harp_utils_1.assert(startRatio <= endRatio);\n            const t = Math.abs(Math.cos(mapView.tilt));\n            const density = harp_utils_1.MathUtils.smoothStep(horizontalDensity, verticalDensity, t);\n            this.m_fog.near = THREE.MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);\n            this.m_fog.far = THREE.MathUtils.lerp(viewRange * endRatio, viewRange, density);\n            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);\n            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);\n        }\n    }\n    /**\n     * Handles fog addition.\n     */\n    add() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = this.m_fog;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(true);\n    }\n    /**\n     * Handles fog removal.\n     */\n    remove() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = null;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(false);\n    }\n    /**\n     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified\n     * explicitly.\n     *\n     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298\n     */\n    setFogInRawShaderMaterials(enableFog) {\n        this.m_scene.traverse(object => {\n            if (object instanceof THREE.Mesh) {\n                const material = object.material;\n                if (material instanceof THREE.Material &&\n                    // HighPrecisionLineMaterial does not support fog:\n                    !(material instanceof harp_materials_1.HighPrecisionLineMaterial) &&\n                    // We may skip redundant updates:\n                    material.fog !== enableFog) {\n                    material.fog = enableFog;\n                    if (material instanceof RawShaderMaterial_1.RawShaderMaterial) {\n                        // Fog properties can't be easily changed at runtime (once the material\n                        // is rendered at least once) and thus requires building of new shader\n                        // program - force material update.\n                        material.invalidateFog();\n                    }\n                }\n            }\n        });\n    }\n}\nexports.MapViewFog = MapViewFog;\n//# sourceMappingURL=MapViewFog.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewFog.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewPoints.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Squares = exports.Circles = exports.MapViewPoints = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * `MapViewPoints` is a class to extend for the `\"circles\"` and `\"squares\"` techniques to\n * implement raycasting of `THREE.Points` as expected in {@link MapView},\n * that are in screen space.\n *\n * @remarks\n * It copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its\n * children classes, {@link Circles} and {@link Squares}, who hold the intersection testing in the\n * `testPoint` method. This class also has the ability to dismiss the testing via the\n * `enableRayTesting` flag.\n *\n * Its main motivation is to handle the point styles of XYZ projects.\n *\n * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js\n *\n * @internal\n */\nclass MapViewPoints extends THREE.Points {\n    constructor() {\n        super(...arguments);\n        /**\n         * This allows to discard the ray testing.\n         */\n        this.enableRayTesting = true;\n    }\n    /**\n     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it\n     * then calls the tailored `testPoint` method in the children classes to test intersections\n     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.\n     *\n     * @param raycaster - The raycaster.\n     * @param intersects - The array to fill with the results.\n     */\n    raycast(raycaster, intersects) {\n        if (!this.enableRayTesting) {\n            return;\n        }\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n        const screenCoords = raycaster.ray.origin\n            .clone()\n            .add(raycaster.ray.direction)\n            .project(raycaster.camera);\n        const mouseCoords = new THREE.Vector2(Math.ceil(((screenCoords.x + 1) / 2) * raycaster.width), Math.ceil(((1 - screenCoords.y) / 2) * raycaster.height));\n        if (geometry instanceof THREE.BufferGeometry) {\n            const point = new THREE.Vector3();\n            const index = geometry.index;\n            const attributes = geometry.attributes;\n            const positions = attributes.position.array;\n            if (index !== null) {\n                const indices = index.array;\n                for (let i = 0, il = indices.length; i < il; i++) {\n                    const a = indices[i];\n                    point.fromArray(positions, a * 3);\n                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);\n                    }\n                }\n            }\n            else {\n                for (let i = 0, l = positions.length / 3; i < l; i++) {\n                    point.fromArray(positions, i * 3);\n                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);\n                    }\n                }\n            }\n        }\n        else {\n            const vertices = geometry.vertices;\n            for (let index = 0; index < vertices.length; index++) {\n                const point = vertices[index];\n                const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n                if (pointInfo.pointIsOnScreen) {\n                    this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);\n                }\n            }\n        }\n    }\n}\nexports.MapViewPoints = MapViewPoints;\nfunction getPointInfo(point, matrixWorld, raycaster) {\n    const worldPosition = point.clone();\n    worldPosition.applyMatrix4(matrixWorld);\n    const distance = worldPosition.distanceTo(raycaster.ray.origin);\n    worldPosition.project(raycaster.camera);\n    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n    const pointIsOnScreen = relativeScreenPosition.x < 1 &&\n        relativeScreenPosition.x > -1 &&\n        relativeScreenPosition.y < 1 &&\n        relativeScreenPosition.y > -1;\n    if (pointIsOnScreen) {\n        worldPosition.x = ((worldPosition.x + 1) / 2) * raycaster.width;\n        worldPosition.y = ((1 - worldPosition.y) / 2) * raycaster.height;\n        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n        return {\n            absoluteScreenPosition,\n            pointIsOnScreen,\n            distance\n        };\n    }\n    return {\n        pointIsOnScreen\n    };\n}\n/**\n * Point object that implements the raycasting of circles in screen space.\n * @internal\n */\nclass Circles extends MapViewPoints {\n    /** @override */\n    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const radius = this.material.size / 2;\n        if (dist <= radius) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\nexports.Circles = Circles;\n/**\n * Point object that implements the raycasting of squares in screen space.\n * @internal\n */\nclass Squares extends MapViewPoints {\n    /** @override */\n    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const halfSize = this.material.size / 2;\n        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\nexports.Squares = Squares;\n//# sourceMappingURL=MapViewPoints.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewPoints.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewTaskScheduler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewTaskScheduler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewTaskScheduler = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapView_1 = __webpack_require__(/*! ./MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\nconst Statistics_1 = __webpack_require__(/*! ./Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst DEFAULT_MAX_FPS = 60;\nconst DEFAULT_PROCESSING_ESTIMATE_TIME = 2;\nconst UPDATE_EVENT = { type: \"update\" };\nclass MapViewTaskScheduler extends THREE.EventDispatcher {\n    constructor(m_maxFps = DEFAULT_MAX_FPS) {\n        super();\n        this.m_maxFps = m_maxFps;\n        this.m_throttlingEnabled = false;\n        this.m_taskQueue = new harp_utils_1.TaskQueue({\n            groups: [MapView_1.TileTaskGroups.FETCH_AND_DECODE, MapView_1.TileTaskGroups.CREATE],\n            prioSortFn: (a, b) => {\n                return a.getPriority() - b.getPriority();\n            }\n        });\n        this.maxFps = m_maxFps;\n    }\n    set maxFps(fps) {\n        this.m_maxFps = fps <= 0 ? DEFAULT_MAX_FPS : fps;\n    }\n    get maxFps() {\n        return this.m_maxFps;\n    }\n    get taskQueue() {\n        return this.m_taskQueue;\n    }\n    get throttlingEnabled() {\n        return this.m_throttlingEnabled === true;\n    }\n    set throttlingEnabled(enabled) {\n        this.m_throttlingEnabled = enabled;\n    }\n    /**\n     * Sends a request to the [[MapView]] to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(UPDATE_EVENT);\n    }\n    /**\n     * Processes the pending Tasks of the underlying [[TaskQueue]]\n     * !! This should run at the end of the renderLoop, so the calculations of the available\n     * frame time are better estimated\n     *\n     * @param frameStartTime the start time of the current frame, is used to calculate the\n     * still available time in the frame to process Tasks\n     *\n     */\n    processPending(frameStartTime) {\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        const currentFrameEvent = stats.enabled ? stats.currentFrame : undefined;\n        let startTime;\n        if (stats.enabled) {\n            startTime = harp_utils_1.PerformanceTimer.now();\n        }\n        //update the task queue, to remove expired and sort with priority\n        this.m_taskQueue.update();\n        let numItemsLeft = this.taskQueue.numItemsLeft();\n        currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue(\"TaskScheduler.numPendingTasks\", numItemsLeft);\n        if (this.throttlingEnabled) {\n            // get the available time in this frame to achieve a max fps rate\n            let availableTime = this.spaceInFrame(frameStartTime);\n            // get some buffer to balance the inaccurate estimates\n            availableTime = availableTime > 2 ? availableTime - 2 : availableTime;\n            currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue(\"TaskScheduler.estimatedAvailableTime\", availableTime);\n            let counter = 0;\n            // check if ther is still time available and tasks left\n            while (availableTime > 0 && numItemsLeft > 0) {\n                counter++;\n                // create a processing condition for the tasks\n                function shouldProcess(task) {\n                    var _a, _b;\n                    // if there is a time estimate use it, otherwise default to 1 ms\n                    // TODO: check whats a sane default, 1 seems to do it for now\n                    availableTime -= (_b = (_a = task.estimatedProcessTime) === null || _a === void 0 ? void 0 : _a.call(task)) !== null && _b !== void 0 ? _b : DEFAULT_PROCESSING_ESTIMATE_TIME;\n                    // always process at least 1 Task, so in the worst case the fps over tiles\n                    // paradigma is sacrificed to not have an empty screen\n                    if (availableTime > 0 || counter === 1) {\n                        return true;\n                    }\n                    return false;\n                }\n                // process the CREATE tasks first, as they will have a faster result on the\n                // visual outcome and have already spend time in the application during\n                // fetching and decoding\n                // fetching has lower priority as it wont make to much of a difference if not\n                // called at the exact frame, and the tile might expire in the next anyway\n                [MapView_1.TileTaskGroups.CREATE, MapView_1.TileTaskGroups.FETCH_AND_DECODE].forEach(tag => {\n                    if (this.m_taskQueue.numItemsLeft(tag)) {\n                        //TODO:\n                        // * if one tag task does not fit another might, how to handle this?\n                        // *    ** what if a task of another group could fit instead\n                        // * whats the average of time we have here at this point in the programm?\n                        this.m_taskQueue.processNext(tag, shouldProcess);\n                    }\n                });\n                numItemsLeft = this.m_taskQueue.numItemsLeft();\n            }\n            // if there is tasks left in the TaskQueue, request an update to be able to process them\n            // in a next frame\n            numItemsLeft = this.m_taskQueue.numItemsLeft();\n            if (numItemsLeft > 0) {\n                currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue(\"TaskScheduler.pendingTasksNotYetProcessed\", numItemsLeft);\n                this.requestUpdate();\n            }\n        }\n        else {\n            //if throttling is disabled, process all pending tasks\n            this.m_taskQueue.processNext(MapView_1.TileTaskGroups.CREATE, undefined, this.m_taskQueue.numItemsLeft(MapView_1.TileTaskGroups.CREATE));\n            this.m_taskQueue.processNext(MapView_1.TileTaskGroups.FETCH_AND_DECODE, undefined, this.m_taskQueue.numItemsLeft(MapView_1.TileTaskGroups.FETCH_AND_DECODE));\n        }\n        if (stats.enabled) {\n            currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue(\"TaskScheduler.pendingTasksTime\", harp_utils_1.PerformanceTimer.now() - startTime);\n        }\n    }\n    /**\n     * Removes all tasks that have been queued.\n     */\n    clearQueuedTasks() {\n        this.m_taskQueue.clear();\n    }\n    spaceInFrame(frameStartTime) {\n        const passedTime = (performance || Date).now() - frameStartTime;\n        return Math.max(1000 / this.m_maxFps - passedTime, 0);\n    }\n}\nexports.MapViewTaskScheduler = MapViewTaskScheduler;\n//# sourceMappingURL=MapViewTaskScheduler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewTaskScheduler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewThemeManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewThemeManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewThemeManager = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ \"./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js\");\nconst ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ \"./node_modules/@here/harp-mapview/lib/ThemeLoader.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"MapViewThemeManager\");\n/**\n * Class handling theme updates for MapView\n */\nclass MapViewThemeManager {\n    constructor(m_mapView, m_uriResolver) {\n        this.m_mapView = m_mapView;\n        this.m_uriResolver = m_uriResolver;\n        this.m_abortControllers = [];\n        this.m_theme = {};\n        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache();\n    }\n    async setTheme(theme) {\n        if (this.isUpdating()) {\n            logger.warn(\"Formerly set Theme is still updating, update will be canceled\");\n            this.cancelThemeUpdate();\n        }\n        this.m_updatePromise = this.loadTheme(theme).then(async (theme) => {\n            await this.updateTheme(theme);\n        });\n        await this.m_updatePromise;\n        this.m_updatePromise = undefined;\n        return this.m_theme;\n    }\n    async getTheme() {\n        if (this.isUpdating()) {\n            await this.m_updatePromise;\n        }\n        return this.m_theme;\n    }\n    isUpdating() {\n        return this.m_updatePromise !== undefined;\n    }\n    /**\n     * @deprecated\n     * A helper for the deprecated MapView.theme getter, remove when\n     * after deprecation\n     */\n    get theme() {\n        return this.isUpdating() ? {} : this.m_theme;\n    }\n    async loadTheme(theme) {\n        let loadedTheme = {};\n        if (typeof theme === \"string\" || !ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {\n            try {\n                loadedTheme = await ThemeLoader_1.ThemeLoader.load(theme, {\n                    uriResolver: this.m_uriResolver,\n                    signal: this.createAbortController().signal\n                });\n            }\n            catch (error) {\n                if (error.name === \"AbortError\") {\n                    logger.warn(`theme loading was aborted due to: ${error}`);\n                }\n                else {\n                    logger.error(`failed to load theme: ${error}`);\n                }\n            }\n        }\n        else {\n            loadedTheme = theme;\n        }\n        return loadedTheme;\n    }\n    async updateTheme(theme) {\n        var _a, _b;\n        const environment = this.m_mapView.sceneEnvironment;\n        // Fog and sky.\n        this.m_theme.fog = theme.fog;\n        this.m_theme.sky = theme.sky;\n        environment.updateSkyBackground(theme.sky);\n        environment.fog.reset(theme.fog);\n        this.m_theme.lights = theme.lights;\n        environment.updateLighting(theme.lights);\n        // Clear color.\n        this.m_theme.clearColor = theme.clearColor;\n        this.m_theme.clearAlpha = theme.clearAlpha;\n        environment.updateClearColor(theme.clearColor, theme.clearAlpha);\n        // Images.\n        this.m_theme.images = theme.images;\n        this.m_theme.imageTextures = theme.imageTextures;\n        await this.updateImages(theme.images, theme.imageTextures);\n        // POI tables.\n        this.m_theme.poiTables = theme.poiTables;\n        await this.loadPoiTables(theme.poiTables);\n        // Text.\n        this.m_theme.textStyles = theme.textStyles;\n        this.m_theme.defaultTextStyle = theme.defaultTextStyle;\n        this.m_theme.fontCatalogs = theme.fontCatalogs;\n        await this.m_mapView.resetTextRenderer(theme.fontCatalogs, theme.textStyles, theme.defaultTextStyle);\n        if (Array.isArray(theme.priorities)) {\n            this.m_theme.priorities = theme.priorities;\n        }\n        this.m_mapView.mapAnchors.setPriorities((_a = theme.priorities) !== null && _a !== void 0 ? _a : []);\n        if (Array.isArray(theme.labelPriorities)) {\n            this.m_theme.labelPriorities = theme.labelPriorities;\n        }\n        if (this.m_theme.styles === undefined) {\n            this.m_theme.styles = {};\n        }\n        this.m_theme.styles = (_b = theme.styles) !== null && _b !== void 0 ? _b : {};\n        this.m_theme.definitions = theme.definitions;\n        environment.clearBackgroundDataSource();\n        for (const dataSource of this.m_mapView.dataSources) {\n            await dataSource.setTheme(this.m_theme);\n        }\n    }\n    updateCache() {\n        this.updateImages(this.m_theme.images, this.m_theme.imageTextures);\n        this.m_mapView.sceneEnvironment.updateLighting(this.m_theme.lights);\n        this.m_mapView.sceneEnvironment.updateSkyBackground(this.m_theme.sky, this.m_theme.clearColor);\n    }\n    get imageCache() {\n        return this.m_imageCache;\n    }\n    dispose() {\n        this.m_imageCache.clear();\n    }\n    async loadPoiTables(poiTables) {\n        this.m_mapView.poiTableManager.clear();\n        // Add the POI tables defined in the theme.\n        await this.m_mapView.poiTableManager.loadPoiTables(poiTables);\n    }\n    cancelThemeUpdate() {\n        for (var i = 0; i < this.m_abortControllers.length; i++) {\n            this.m_abortControllers[i].abort();\n        }\n        this.m_abortControllers = [];\n        this.m_imageCache.clear();\n        this.m_mapView.poiManager.clear();\n        this.m_mapView.poiTableManager.clear();\n    }\n    createAbortController() {\n        this.m_abortControllers.push(new AbortController());\n        return this.m_abortControllers[this.m_abortControllers.length - 1];\n    }\n    async updateImages(images, imageTextures) {\n        this.m_imageCache.clear();\n        this.m_mapView.poiManager.clear();\n        if (images !== undefined) {\n            for (const name of Object.keys(images)) {\n                const image = images[name];\n                this.m_imageCache.addImage(name, image.url, image.preload === true);\n                if (typeof image.atlas === \"string\") {\n                    await this.m_mapView.poiManager.addTextureAtlas(name, image.atlas, this.createAbortController().signal);\n                }\n            }\n        }\n        if (imageTextures !== undefined) {\n            imageTextures.forEach((imageTexture) => {\n                this.m_mapView.poiManager.addImageTexture(imageTexture);\n            });\n        }\n    }\n}\nexports.MapViewThemeManager = MapViewThemeManager;\n//# sourceMappingURL=MapViewThemeManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewThemeManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PathBlockingElement.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PathBlockingElement.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathBlockingElement = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * This path in world coordinates is projected to screen space and blocks all other labels.\n *\n * It could be used for example:\n * - Border rejects labels.\n * - Route blocks street labels from being rendered underneath.\n *\n * Could potentially be expanded in future to have a priority, however for now, this isn't required.\n */\nclass PathBlockingElement {\n    /**\n     * Constructs a path from a list of points.\n     * Pre allocates the [[screenSpaceLines]] used to render.\n     * @param points - Points in world coordinates.\n     */\n    constructor(points) {\n        this.points = points;\n        this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);\n        for (let i = 0; i < this.screenSpaceLines.length; i++) {\n            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());\n        }\n    }\n}\nexports.PathBlockingElement = PathBlockingElement;\n//# sourceMappingURL=PathBlockingElement.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PathBlockingElement.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickHandler.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PickHandler = exports.PickObjectType = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ \"./node_modules/@here/harp-mapview/lib/MapViewPoints.js\");\nconst PickListener_1 = __webpack_require__(/*! ./PickListener */ \"./node_modules/@here/harp-mapview/lib/PickListener.js\");\n/**\n * Describes the general type of a picked object.\n */\nvar PickObjectType;\n(function (PickObjectType) {\n    /**\n     * Unspecified.\n     */\n    PickObjectType[PickObjectType[\"Unspecified\"] = 0] = \"Unspecified\";\n    /**\n     * A point object.\n     */\n    PickObjectType[PickObjectType[\"Point\"] = 1] = \"Point\";\n    /**\n     * A line object.\n     */\n    PickObjectType[PickObjectType[\"Line\"] = 2] = \"Line\";\n    /**\n     * An area object.\n     */\n    PickObjectType[PickObjectType[\"Area\"] = 3] = \"Area\";\n    /**\n     * The text part of a {@link TextElement}\n     */\n    PickObjectType[PickObjectType[\"Text\"] = 4] = \"Text\";\n    /**\n     * The Icon of a {@link TextElement}.\n     */\n    PickObjectType[PickObjectType[\"Icon\"] = 5] = \"Icon\";\n    /**\n     * Any general 3D object, for example, a landmark.\n     */\n    PickObjectType[PickObjectType[\"Object3D\"] = 6] = \"Object3D\";\n})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));\nconst tmpOBB = new harp_geoutils_1.OrientedBox3();\n// Intersects the dependent tile objects using the supplied raycaster. Note, because multiple\n// tiles can point to the same dependency we need to store which results we have already\n// raycasted, see checkedDependencies.\nfunction intersectDependentObjects(tile, intersects, rayCaster, checkedDependencies, mapView) {\n    for (const tileKey of tile.dependencies) {\n        const mortonCode = tileKey.mortonCode();\n        if (checkedDependencies.has(mortonCode)) {\n            continue;\n        }\n        checkedDependencies.add(mortonCode);\n        const otherTile = mapView.visibleTileSet.getCachedTile(tile.dataSource, tileKey, tile.offset, mapView.frameNumber);\n        if (otherTile !== undefined) {\n            rayCaster.intersectObjects(otherTile.objects, true, intersects);\n        }\n    }\n}\n/**\n * Handles the picking of scene geometry and roads.\n * @internal\n */\nclass PickHandler {\n    constructor(mapView, camera, enablePickTechnique = false) {\n        this.mapView = mapView;\n        this.camera = camera;\n        this.enablePickTechnique = enablePickTechnique;\n    }\n    /**\n     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to\n     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the\n     * shader cannot be tested for intersection.\n     *\n     * @param x - The X position in CSS/client coordinates, without the applied display ratio.\n     * @param y - The Y position in CSS/client coordinates, without the applied display ratio.\n     * @param parameters - The intersection test behaviour may be adjusted by providing an instance\n     * of {@link IntersectParams}.\n     * @returns the list of intersection results.\n     */\n    intersectMapObjects(x, y, parameters) {\n        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);\n        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);\n        const pickListener = new PickListener_1.PickListener(parameters);\n        if (this.mapView.textElementsRenderer !== undefined) {\n            const { clientWidth, clientHeight } = this.mapView.canvas;\n            const screenX = worldPos.x * clientWidth * 0.5;\n            const screenY = worldPos.y * clientHeight * 0.5;\n            const scenePosition = new THREE.Vector2(screenX, screenY);\n            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickListener);\n        }\n        const intersects = [];\n        const intersectedTiles = this.getIntersectedTiles(rayCaster);\n        // This ensures that we check a given dependency only once (because multiple tiles could\n        // have the same dependency).\n        const checkedDependencies = new Set();\n        for (const { tile, distance } of intersectedTiles) {\n            if (pickListener.done && pickListener.furthestResult.distance < distance) {\n                // Stop when the listener has all results it needs and remaining tiles are further\n                // away than then furthest pick result found so far.\n                break;\n            }\n            intersects.length = 0;\n            rayCaster.intersectObjects(tile.objects, true, intersects);\n            intersectDependentObjects(tile, intersects, rayCaster, checkedDependencies, this.mapView);\n            for (const intersect of intersects) {\n                pickListener.addResult(this.createResult(intersect));\n            }\n        }\n        // Intersect any objects added by the user.\n        intersects.length = 0;\n        for (const child of this.mapView.mapAnchors.children) {\n            rayCaster.intersectObject(child, true, intersects);\n            for (const intersect of intersects) {\n                pickListener.addResult(this.createResult(intersect));\n            }\n        }\n        pickListener.finish();\n        return pickListener.results;\n    }\n    createResult(intersection) {\n        var _a;\n        const pickResult = {\n            type: PickObjectType.Unspecified,\n            point: intersection.point,\n            distance: intersection.distance,\n            intersection\n        };\n        if (intersection.object.userData === undefined ||\n            intersection.object.userData.feature === undefined) {\n            return pickResult;\n        }\n        if (this.enablePickTechnique) {\n            pickResult.technique = intersection.object.userData.technique;\n        }\n        pickResult.renderOrder = (_a = intersection.object) === null || _a === void 0 ? void 0 : _a.renderOrder;\n        const featureData = intersection.object.userData.feature;\n        this.addObjInfo(featureData, intersection, pickResult);\n        if (pickResult.userData) {\n            const featureId = harp_datasource_protocol_1.getFeatureId(pickResult.userData);\n            pickResult.featureId = featureId === 0 ? undefined : featureId;\n        }\n        let pickObjectType;\n        switch (featureData.geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                pickObjectType = PickObjectType.Point;\n                break;\n            case harp_datasource_protocol_1.GeometryType.Line:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                pickObjectType = PickObjectType.Line;\n                break;\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                pickObjectType = PickObjectType.Area;\n                break;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                pickObjectType = PickObjectType.Object3D;\n                break;\n            default:\n                pickObjectType = PickObjectType.Unspecified;\n        }\n        pickResult.type = pickObjectType;\n        return pickResult;\n    }\n    getIntersectedTiles(rayCaster) {\n        const tiles = new Array();\n        const tileList = this.mapView.visibleTileSet.dataSourceTileList;\n        tileList.forEach(dataSourceTileList => {\n            if (!dataSourceTileList.dataSource.enablePicking) {\n                return;\n            }\n            dataSourceTileList.renderedTiles.forEach(tile => {\n                tmpOBB.copy(tile.boundingBox);\n                tmpOBB.position.sub(this.mapView.worldCenter);\n                // This offset shifts the box by the given tile offset, see renderTileObjects in\n                // MapView\n                const worldOffsetX = tile.computeWorldOffsetX();\n                tmpOBB.position.x += worldOffsetX;\n                const distance = tmpOBB.intersectsRay(rayCaster.ray);\n                if (distance !== undefined) {\n                    tiles.push({ tile, distance });\n                }\n            });\n        });\n        tiles.sort((lhs, rhs) => {\n            return lhs.distance - rhs.distance;\n        });\n        return tiles;\n    }\n    addObjInfo(featureData, intersect, pickResult) {\n        if (featureData.objInfos === undefined) {\n            return;\n        }\n        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {\n            pickResult.userData = featureData.objInfos[intersect.index];\n            return;\n        }\n        if (featureData.starts === undefined ||\n            featureData.starts.length === 0 ||\n            (intersect.faceIndex === undefined && intersect.index === undefined)) {\n            if (featureData.objInfos.length === 1) {\n                pickResult.userData = featureData.objInfos[0];\n            }\n            return;\n        }\n        if (featureData.starts.length === 1) {\n            pickResult.userData = featureData.objInfos[0];\n            return;\n        }\n        const intersectIndex = intersect.faceIndex !== undefined ? intersect.faceIndex * 3 : intersect.index;\n        // TODO: Implement binary search.\n        let objInfosIndex = 0;\n        for (const featureStartIndex of featureData.starts) {\n            if (featureStartIndex > intersectIndex) {\n                break;\n            }\n            objInfosIndex++;\n        }\n        pickResult.userData = featureData.objInfos[objInfosIndex - 1];\n    }\n}\nexports.PickHandler = PickHandler;\n//# sourceMappingURL=PickHandler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PickHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickListener.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickListener.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PickListener = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n// Default sorting by distance first and then by reversed render order.\nfunction defaultSort(lhs, rhs) {\n    const distanceDiff = lhs.distance - rhs.distance;\n    const haveRenderOrder = lhs.renderOrder !== undefined && rhs.renderOrder !== undefined;\n    if (distanceDiff !== 0 || !haveRenderOrder) {\n        return distanceDiff;\n    }\n    return rhs.renderOrder - lhs.renderOrder;\n}\n/**\n * Collects results from a picking (intersection) test.\n *\n * @internal\n */\nclass PickListener {\n    /**\n     * Constructs a new `PickListener`.\n     *\n     * @param m_parameters - Optional parameters to customize picking behaviour.\n     */\n    constructor(m_parameters) {\n        this.m_parameters = m_parameters;\n        this.m_results = [];\n        this.m_sorted = true;\n        this.m_finished = true;\n    }\n    /**\n     * Adds a pick result.\n     *\n     * @param result - The result to be added.\n     */\n    addResult(result) {\n        // Add the result only if it's a different feature from the ones already collected.\n        const foundFeatureIdx = this.m_results.findIndex(otherResult => {\n            var _a, _b, _c, _d;\n            const sameType = otherResult.type === result.type;\n            const dataSource = (_b = (_a = result.intersection) === null || _a === void 0 ? void 0 : _a.object.userData) === null || _b === void 0 ? void 0 : _b.dataSource;\n            const sameDataSource = dataSource && ((_d = (_c = otherResult.intersection) === null || _c === void 0 ? void 0 : _c.object.userData) === null || _d === void 0 ? void 0 : _d.dataSource) === dataSource;\n            const sameId = result.featureId !== undefined && otherResult.featureId === result.featureId;\n            const noId = result.featureId === undefined && otherResult.featureId === undefined;\n            const sameUserData = result.userData && otherResult.userData === result.userData;\n            return sameType && sameDataSource && (sameId || (noId && sameUserData));\n        });\n        if (foundFeatureIdx < 0) {\n            this.m_sorted = false;\n            this.m_finished = false;\n            this.m_results.push(result);\n            return;\n        }\n        // Replace the result for the same feature if it's sorted after the new result.\n        const oldResult = this.m_results[foundFeatureIdx];\n        if (defaultSort(result, oldResult) < 0) {\n            this.m_results[foundFeatureIdx] = result;\n            this.m_sorted = false;\n            this.m_finished = false;\n        }\n    }\n    /**\n     * Indicates whether the listener is satisfied with the results already provided.\n     * @returns `True` if the listener doesn't expect more results, `False` otherwise.\n     */\n    get done() {\n        return this.maxResults ? this.m_results.length >= this.maxResults : false;\n    }\n    /**\n     * Orders the collected results by distance first, then by reversed render order\n     * (topmost/highest render order first), and limits the number of results to the maximum\n     * accepted number, see {@link IntersectParams.maxResultCount}.\n     */\n    finish() {\n        // Keep only the closest max results.\n        this.sortResults();\n        if (this.maxResults && this.m_results.length > this.maxResults) {\n            this.m_results.length = this.maxResults;\n        }\n        this.m_finished = true;\n    }\n    /**\n     * Returns the collected results. {@link PickListener.finish} should be called first to ensure\n     * the proper sorting and result count.\n     * @returns The pick results.\n     */\n    get results() {\n        harp_utils_1.assert(this.m_finished, \"finish() was not called before getting the results\");\n        return this.m_results;\n    }\n    /**\n     * Returns the closest result collected so far, following the order documented in\n     * {@link PickListener.finish}\n     * @returns The closest pick result, or `undefined` if no result was collected.\n     */\n    get closestResult() {\n        this.sortResults();\n        return this.m_results.length > 0 ? this.m_results[0] : undefined;\n    }\n    /**\n     * Returns the furtherst result collected so far, following the order documented in\n     * {@link PickListener.results}\n     * @returns The furthest pick result, or `undefined` if no result was collected.\n     */\n    get furthestResult() {\n        this.sortResults();\n        return this.m_results.length > 0 ? this.m_results[this.m_results.length - 1] : undefined;\n    }\n    get maxResults() {\n        var _a, _b;\n        const maxCount = (_b = (_a = this.m_parameters) === null || _a === void 0 ? void 0 : _a.maxResultCount) !== null && _b !== void 0 ? _b : 0;\n        return maxCount > 0 ? maxCount : undefined;\n    }\n    sortResults() {\n        if (!this.m_sorted) {\n            this.m_results.sort(defaultSort);\n            this.m_sorted = true;\n        }\n    }\n}\nexports.PickListener = PickListener;\n//# sourceMappingURL=PickListener.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PickListener.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickingRaycaster.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickingRaycaster.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PickingRaycaster = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ \"./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js\");\nfunction intersectObject(object, raycaster, env, intersects, recursive) {\n    if (object.layers.test(raycaster.layers) && object.visible) {\n        const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);\n        if (!mapObjectAdapter || mapObjectAdapter.isPickable(env)) {\n            object.raycast(raycaster, intersects);\n        }\n    }\n    if (recursive === true) {\n        for (const child of object.children) {\n            intersectObject(child, raycaster, env, intersects, true);\n        }\n    }\n}\n/**\n * Raycasting points is not supported as necessary in Three.js. This class extends a\n * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space\n * geometry.\n *\n * @internal\n */\nclass PickingRaycaster extends THREE.Raycaster {\n    /**\n     * Constructor.\n     *\n     * @param width - the canvas width.\n     * @param height - the canvas height.\n     * @param m_env - the view enviroment.\n     */\n    constructor(width, height, m_env) {\n        super();\n        this.width = width;\n        this.height = height;\n        this.m_env = m_env;\n    }\n    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of\n    // three.js classes.\n    intersectObject(object, recursive, optionalTarget) {\n        const intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];\n        intersectObject(object, this, this.m_env, intersects, recursive);\n        return intersects;\n    }\n    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of\n    // three.js classes.\n    intersectObjects(objects, recursive, optionalTarget) {\n        const intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];\n        for (const object of objects) {\n            intersectObject(object, this, this.m_env, intersects, recursive);\n        }\n        return intersects;\n    }\n}\nexports.PickingRaycaster = PickingRaycaster;\n//# sourceMappingURL=PickingRaycaster.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PickingRaycaster.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PolarTileDataSource = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ \"./node_modules/@here/harp-datasource-protocol/index-decoder.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DataSource_1 = __webpack_require__(/*! ./DataSource */ \"./node_modules/@here/harp-mapview/lib/DataSource.js\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\nconst MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ \"./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js\");\nconst ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ \"./node_modules/@here/harp-mapview/lib/ThemeLoader.js\");\nconst Tile_1 = __webpack_require__(/*! ./Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\");\n/**\n * {@link DataSource} providing geometry for poles\n */\nclass PolarTileDataSource extends DataSource_1.DataSource {\n    constructor({ name = \"polar\", styleSetName = \"polar\", minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset = -2, geometryLevelOffset = 1, debugTiles = false }) {\n        super({\n            name,\n            styleSetName,\n            minDataLevel,\n            maxDataLevel,\n            minDisplayLevel,\n            maxDisplayLevel,\n            storageLevelOffset\n        });\n        this.m_tilingScheme = harp_geoutils_1.polarTilingScheme;\n        this.m_maxLatitude = THREE.MathUtils.radToDeg(harp_geoutils_1.MercatorConstants.MAXIMUM_LATITUDE);\n        this.m_geometryLevelOffset = geometryLevelOffset;\n        this.m_debugTiles = debugTiles;\n        this.cacheable = false;\n        this.enablePicking = false;\n    }\n    /** @override */\n    dispose() {\n        if (this.m_northPoleEntry) {\n            this.m_northPoleEntry.material.dispose();\n            delete this.m_northPoleEntry;\n        }\n        if (this.m_southPoleEntry) {\n            this.m_southPoleEntry.material.dispose();\n            delete this.m_southPoleEntry;\n        }\n        if (this.m_styleSetEvaluator) {\n            delete this.m_styleSetEvaluator;\n        }\n    }\n    createTechiqueEntry(kind) {\n        if (!this.m_styleSetEvaluator) {\n            return undefined;\n        }\n        const env = new index_decoder_1.MapEnv({\n            $geometryType: \"polygon\",\n            $layer: \"earth\",\n            kind\n        });\n        const techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);\n        if (techniques.length === 0) {\n            return undefined;\n        }\n        const technique = techniques[0];\n        const material = DecodedTileHelpers_1.createMaterial(this.mapView.renderer.capabilities, {\n            technique,\n            env: this.mapView.env\n        });\n        if (!material) {\n            return undefined;\n        }\n        return { material, technique };\n    }\n    /** @override */\n    async setTheme(theme) {\n        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.\n        theme = await ThemeLoader_1.ThemeLoader.load(theme);\n        let styleSet;\n        if (this.styleSetName !== undefined && theme.styles !== undefined) {\n            styleSet = theme.styles[this.styleSetName];\n        }\n        this.m_styleSetEvaluator = new index_decoder_1.StyleSetEvaluator({\n            styleSet: styleSet !== null && styleSet !== void 0 ? styleSet : [],\n            definitions: theme.definitions,\n            priorities: theme.priorities,\n            labelPriorities: theme.labelPriorities\n        });\n        this.m_northPoleEntry = this.createTechiqueEntry(\"north_pole\");\n        this.m_southPoleEntry = this.createTechiqueEntry(\"south_pole\");\n        this.mapView.markTilesDirty(this);\n    }\n    /** @override */\n    canGetTile(zoomLevel, tileKey) {\n        if (zoomLevel !== tileKey.level || tileKey.level < 1) {\n            return false;\n        }\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n    /** @override */\n    shouldSubdivide(zoomLevel, tileKey) {\n        if (zoomLevel <= tileKey.level) {\n            return false;\n        }\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n    /** @override */\n    getTilingScheme() {\n        return this.m_tilingScheme;\n    }\n    /** @override */\n    getTile(tileKey) {\n        const tile = new Tile_1.Tile(this, tileKey);\n        this.createTileGeometry(tile);\n        return tile;\n    }\n    get geometryLevelOffset() {\n        return this.m_geometryLevelOffset;\n    }\n    set geometryLevelOffset(geometryLevelOffset) {\n        this.m_geometryLevelOffset = geometryLevelOffset;\n    }\n    intersectEdge(latitude, a, b) {\n        const latA = a.latitude;\n        const latB = b.latitude;\n        let lonA = a.longitude;\n        let lonB = b.longitude;\n        if (Math.abs(latA) === 90) {\n            lonA = lonB;\n        }\n        if (Math.abs(latB) === 90) {\n            lonB = lonA;\n        }\n        const deltaLat = latB - latA;\n        const deltaLon = lonB - lonA;\n        const scale = (latitude - latA) / deltaLat;\n        return new harp_geoutils_1.GeoCoordinates(latitude, lonA + deltaLon * scale, 0);\n    }\n    createTileGeometry(tile) {\n        const { north, south } = tile.geoBox;\n        const isNorthPole = north > 0 && south >= 0;\n        const techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;\n        if (techniqueEntry === undefined) {\n            tile.forceHasGeometry(true);\n            return;\n        }\n        const srcProjection = this.m_tilingScheme.projection;\n        const dstProjection = this.projection;\n        const maxLat = this.m_maxLatitude;\n        const poleLat = isNorthPole ? maxLat : -maxLat;\n        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);\n        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));\n        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));\n        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));\n        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));\n        let points;\n        let needsGeometryCut = false;\n        // special case where tile contains half of the hemisphere\n        if (tile.tileKey.level === 1) {\n            const isLeftHalf = box.min.x === 0;\n            const poleX = isLeftHalf ? box.max.x : box.min.x;\n            const poleY = (box.max.y + box.min.y) / 2;\n            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));\n            // coordinates are not used, needed for right position\n            const pXX = isLeftHalf ? pBL : pBR;\n            points = isNorthPole\n                ? isLeftHalf\n                    ? [pPole, pTR, pXX, pBR]\n                    : [pPole, pBL, pXX, pTL]\n                : isLeftHalf\n                    ? [pPole, pBR, pXX, pTR]\n                    : [pPole, pTL, pXX, pBL];\n            needsGeometryCut = true;\n        }\n        else {\n            // ccw for north, cw for south\n            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];\n            const lats = points.map(p => p.latitude);\n            const lmax = Math.max(...lats);\n            const lmin = Math.min(...lats);\n            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;\n            if (isAllPointsOut) {\n                return;\n            }\n            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;\n            needsGeometryCut = isSomePointsOut;\n            if (needsGeometryCut) {\n                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);\n                if (nearest !== 0) {\n                    for (let i = 0; i < nearest; i++) {\n                        points.push(points.shift());\n                    }\n                }\n            }\n        }\n        if (needsGeometryCut) {\n            const centerX = (box.min.x + box.max.x) / 2;\n            const centerY = (box.min.y + box.max.y) / 2;\n            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));\n            harp_geoutils_1.TransverseMercatorUtils.alignLongitude(points, center);\n            // points aligned as follows:\n            // a - nearest to the pole, always in\n            // b - next to nearest\n            // c - farthes from the pole, always out\n            // d - prev from nearest\n            const a = points[0];\n            const b = points[1];\n            const c = points[2];\n            const d = points[3];\n            const inPointB = Math.abs(b.latitude) >= maxLat;\n            const inPointD = Math.abs(d.latitude) >= maxLat;\n            const cutStart = inPointB\n                ? this.intersectEdge(poleLat, b, c)\n                : this.intersectEdge(poleLat, a, b);\n            const cutEnd = inPointD\n                ? this.intersectEdge(poleLat, d, c)\n                : this.intersectEdge(poleLat, a, d);\n            points.splice(inPointB ? 2 : 1, 4, cutStart);\n            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;\n            const subdivisions = 1 << Math.max(0, level);\n            const step = 360 / subdivisions;\n            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);\n            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);\n            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {\n                points.push(new harp_geoutils_1.GeoCoordinates(poleLat, i * step - 180, 0));\n            }\n            points.push(cutEnd);\n            if (inPointD) {\n                points.push(d);\n            }\n        }\n        const g = new THREE.Geometry();\n        for (const point of points) {\n            const projected = dstProjection.projectPoint(point, new THREE.Vector3());\n            g.vertices.push(projected.sub(tile.center));\n        }\n        for (let i = 1; i < points.length - 1; i++) {\n            g.faces.push(isNorthPole ? new THREE.Face3(0, i, i + 1) : new THREE.Face3(0, i + 1, i));\n        }\n        const geometry = new THREE.BufferGeometry();\n        geometry.fromGeometry(g);\n        g.dispose();\n        const mesh = new THREE.Mesh(geometry, techniqueEntry.material);\n        mesh.userData = {\n            dataSource: this.name,\n            tileKey: tile.tileKey\n        };\n        if (this.m_debugTiles) {\n            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);\n            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });\n            tile.objects.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true })));\n        }\n        MapObjectAdapter_1.MapObjectAdapter.create(mesh, {\n            dataSource: this,\n            technique: techniqueEntry.technique,\n            kind: [isNorthPole ? harp_datasource_protocol_1.StandardGeometryKind.Water : harp_datasource_protocol_1.StandardGeometryKind.Background]\n        });\n        tile.objects.push(mesh);\n    }\n}\nexports.PolarTileDataSource = PolarTileDataSource;\n//# sourceMappingURL=PolarTileDataSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenCollisions.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScreenCollisionsDebug = exports.ScreenCollisions = exports.isLineWithBound = exports.DetailedCollisionBox = exports.CollisionBox = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DebugContext_1 = __webpack_require__(/*! ./DebugContext */ \"./node_modules/@here/harp-mapview/lib/DebugContext.js\");\nconst RBush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/rbush.min.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"ScreenCollissions\");\nclass CollisionBox extends harp_utils_1.Math2D.Box {\n    constructor(box) {\n        super();\n        if (box !== undefined) {\n            this.copy(box);\n        }\n    }\n    copy(box) {\n        if (box instanceof harp_utils_1.Math2D.Box) {\n            this.set(box.x, box.y, box.w, box.h);\n        }\n        else if (box instanceof THREE.Box2) {\n            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);\n        }\n        else {\n            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);\n        }\n        return this;\n    }\n    get minX() {\n        return this.x;\n    }\n    set minX(minX) {\n        this.x = minX;\n    }\n    get maxX() {\n        return this.x + this.w;\n    }\n    set maxX(maxX) {\n        this.w = maxX - this.x;\n    }\n    get minY() {\n        return this.y;\n    }\n    set minY(minY) {\n        this.y = minY;\n    }\n    get maxY() {\n        return this.y + this.h;\n    }\n    set maxY(maxY) {\n        this.h = maxY - this.y;\n    }\n}\nexports.CollisionBox = CollisionBox;\n/**\n * Collision box with additional boxes defining tighter bounds for the enclosed feature\n * (e.g.glyph bounds for text).\n */\nclass DetailedCollisionBox extends CollisionBox {\n    constructor(box, detailBoxes) {\n        super(box);\n        this.detailBoxes = detailBoxes;\n    }\n}\nexports.DetailedCollisionBox = DetailedCollisionBox;\nfunction isLineWithBound(box) {\n    return box.line !== undefined;\n}\nexports.isLineWithBound = isLineWithBound;\nconst tmpCollisionBox = new CollisionBox();\nclass ScreenCollisions {\n    /**\n     * Constructs a new ScreenCollisions object.\n     */\n    constructor() {\n        /** The screen bounding box. */\n        this.screenBounds = new harp_utils_1.Math2D.Box();\n        /** Tree of allocated bounds. */\n        this.rtree = new RBush();\n        //\n    }\n    /**\n     * Resets the list of allocated screen bounds.\n     */\n    reset() {\n        this.rtree.clear();\n    }\n    /**\n     * Updates the screen bounds that are used to check if bounding boxes are visible.\n     *\n     * @param width - The width of the container.\n     * @param height - The height of the container.\n     */\n    update(width, height) {\n        this.screenBounds.set(width / -2, height / -2, width, height);\n        this.reset();\n    }\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds - The bounding box in NDC scaled coordinates (i.e. top left is -width/2,\n     * -height/2)\n     */\n    allocate(bounds) {\n        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;\n        this.rtree.insert(bbox);\n    }\n    /**\n     * Inserts the given bounds into the rtree.\n     *\n     * @param bounds - The bounding boxes (the bounding boxes must be in the space returned from the\n     * ScreenProjector.project method).\n     */\n    allocateIBoxes(bounds) {\n        this.rtree.load(bounds);\n    }\n    /**\n     * Search for all bounds in the tree intersecting with the given box.\n     * @param box - The box used for the search.\n     * @returns An array of all IBoxes intersecting with the given box.\n     */\n    search(box) {\n        return this.rtree.search(box);\n    }\n    /**\n     * Checks if the given bounding box is already allocated.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isAllocated(bounds) {\n        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);\n        const results = this.search(collisionBox);\n        return this.intersectsDetails(collisionBox, results);\n    }\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isVisible(bounds) {\n        return this.screenBounds.intersects(bounds);\n    }\n    /**\n     * Checks if the given screen bounds is contained within the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isFullyVisible(bounds) {\n        return this.screenBounds.containsBox(bounds);\n    }\n    /**\n     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified\n     * [[IBox]]es.\n     *\n     * @param testBox - The box to test for intersection.\n     * @param boxes - The candidate boxes the test box may intersect with. It's assumed that the\n     * global bounds of these boxes intersect with the given test box.\n     * @returns `true` if any intersection found.\n     */\n    intersectsDetails(testBox, boxes) {\n        for (const box of boxes) {\n            if (box instanceof DetailedCollisionBox) {\n                for (const detailBox of box.detailBoxes) {\n                    if (detailBox.intersects(testBox)) {\n                        return true;\n                    }\n                }\n            }\n            else if (isLineWithBound(box)) {\n                const boundedLine = box;\n                if (this.intersectsLine(testBox, boundedLine)) {\n                    return true;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Computes the intersection between the supplied CollisionBox and the LineWithBound.\n     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be\n     * in Screen Coordinate space\n     */\n    intersectsLine(bbox, boundedLine) {\n        const line = boundedLine.line;\n        // Note, these aren't normalized, but it doesn't matter, we are just interested\n        // in the sign.\n        const lineXDiffTransformed = line.end.x - line.start.x;\n        // Sign of bottom left, bottom right, top left and top right corners.\n        let signBL;\n        let signBR;\n        let signTL;\n        let signTR;\n        if (lineXDiffTransformed !== 0) {\n            const lineYDiffTransformed = line.end.y - line.start.y;\n            const normalX = lineYDiffTransformed;\n            const normalY = -lineXDiffTransformed;\n            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;\n            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);\n            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);\n            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);\n            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);\n        }\n        else {\n            signBL = Math.sign(bbox.minX - line.start.x);\n            signBR = Math.sign(bbox.maxX - line.start.x);\n            signTL = Math.sign(bbox.minX - line.start.x);\n            signTR = Math.sign(bbox.maxX - line.start.x);\n        }\n        return signBL !== signBR || signBL !== signTL || signBL !== signTR;\n    }\n}\nexports.ScreenCollisions = ScreenCollisions;\n/**\n * @hidden\n *\n * Shows requests for screen space during labelling in an HTML canvas, which should be sized like\n * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests\n * for screen space were done.\n *\n * Also logs statistics.\n */\nclass ScreenCollisionsDebug extends ScreenCollisions {\n    /**\n     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.\n     */\n    constructor(debugCanvas) {\n        super();\n        /** 2D rendering context. */\n        this.m_renderContext = null;\n        this.m_renderingEnabled = false;\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n        if (debugCanvas !== undefined && debugCanvas !== null) {\n            this.m_renderContext = debugCanvas.getContext(\"2d\");\n        }\n    }\n    /**\n     * Resets the list of allocated bounds and clears the debug canvas.\n     * @override\n     */\n    reset() {\n        super.reset();\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n    }\n    /**\n     * Updates the screen bounds used to check if bounding boxes are visible.\n     *\n     * @param width - The width of the container.\n     * @param height - The height of the container.\n     * @override\n     */\n    update(width, height) {\n        if (this.m_renderingEnabled) {\n            logger.log(`Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);\n        }\n        super.update(width, height);\n        if (this.m_renderContext !== null) {\n            this.m_renderContext.canvas.width = width;\n            this.m_renderContext.canvas.height = height;\n        }\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_SCREEN_COLLISIONS\", true)\n        this.m_renderingEnabled = DebugContext_1.debugContext.getValue(\"DEBUG_SCREEN_COLLISIONS\");\n    }\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds - the bounding box in world coordinates.\n     * @override\n     */\n    allocate(bounds) {\n        super.allocate(bounds);\n        this.m_numAllocations++;\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            this.m_renderContext.strokeStyle = \"#6666ff\";\n            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y, bounds.w, -bounds.h);\n        }\n    }\n    /** @override */\n    allocateIBoxes(boundsArray) {\n        for (const bounds of boundsArray) {\n            this.m_numAllocations++;\n            if (this.m_renderingEnabled && this.m_renderContext !== null) {\n                this.m_renderContext.strokeStyle = \"#aa2222\";\n                this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));\n            }\n        }\n        super.allocateIBoxes(boundsArray);\n    }\n    /** @override */\n    intersectsDetails(testBox, boxes) {\n        const collisionFound = super.intersectsDetails(testBox, boxes);\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            const padding = collisionFound ? 2 : 1;\n            this.m_renderContext.strokeStyle = collisionFound ? \"#FF0000\" : \"#00ff00\";\n            this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - padding, this.screenBounds.y + this.screenBounds.h - testBox.y + padding, testBox.w + 2 * padding, -testBox.h - 2 * padding);\n        }\n        if (collisionFound) {\n            this.m_numFailedTests++;\n        }\n        else {\n            this.m_numSuccessfulTests++;\n        }\n        return collisionFound;\n    }\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     * @override\n     */\n    isVisible(bounds) {\n        const visible = super.isVisible(bounds);\n        if (visible) {\n            this.m_numSuccessfulVisibilityTests++;\n        }\n        else {\n            this.m_numFailedVisibilityTests++;\n        }\n        return visible;\n    }\n}\nexports.ScreenCollisionsDebug = ScreenCollisionsDebug;\n//# sourceMappingURL=ScreenCollisions.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ScreenCollisions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenProjector.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenProjector.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScreenProjector = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.\n * @param ndc - The position to check.\n */\nfunction isOnScreen(ndc) {\n    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;\n}\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is between the near\n * and far plane.\n * @param ndc - The position to check.\n */\nfunction isInRange(ndc) {\n    return ndc.z > -1 && ndc.z < 1;\n}\n/**\n * @hidden\n * Handles the projection of world coordinates to screen coordinates.\n */\nclass ScreenProjector {\n    /**\n     * Constructs a new `ScreenProjector`.\n     *\n     * @param m_camera - Camera to project against.\n     */\n    constructor(m_camera) {\n        this.m_camera = m_camera;\n        this.m_width = 0;\n        this.m_height = 0;\n    }\n    /**\n     * Height of the screen.\n     */\n    get width() {\n        return this.m_width;\n    }\n    /**\n     * Width of the screen.\n     */\n    get height() {\n        return this.m_height;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target')\n     */\n    project(source, target = new THREE.Vector2()) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return this.ndcToScreen(p, target);\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside of the near/far plane. The point may be outside the screen.\n     */\n    projectToScreen(source, target = new THREE.Vector2()) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (isInRange(p)) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n    /**\n     * Test if the area around the specified point is visible on the screen.\n     *\n     * @param {(Vector3Like)} source The centered source vector to project.\n     * @param {(Number)} halfWidth Half of the width of the area in screen space [0..1].\n     * @param {(Number)} halfHeight Half of the height of the area in screen space [0..1].\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * the area is completely outside the screen.\n     */\n    projectAreaToScreen(source, halfWidth, halfHeight, target = new THREE.Vector2()) {\n        halfWidth *= 2;\n        halfHeight *= 2;\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (isInRange(p) &&\n            p.x + halfWidth >= -1 &&\n            p.x - halfWidth <= 1 &&\n            p.y + halfHeight >= -1 &&\n            p.y - halfHeight <= 1) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates. The z component between -1 and 1 is also returned.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project3(source, target = new THREE.Vector3()) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);\n            return target;\n        }\n        return undefined;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector. Stores\n     * result in NDC in the target vector.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target').\n     */\n    projectVector(source, target) {\n        target.set(source.x, source.y, source.z).project(this.m_camera);\n        return target;\n    }\n    /**\n     * Fast test to check if projected point is on screen.\n     *\n     * @returns {boolean} `true` if point is on screen, `false` otherwise.\n     */\n    onScreen(source) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return isOnScreen(p);\n    }\n    /**\n     * Update the `ScreenProjector` with the latest values of the screen and the camera.\n     *\n     * @param {THREE.Camera} camera Camera to project against.\n     * @param {number} width Width of screen/canvas.\n     * @param {number} height Height of screen/canvas.\n     */\n    update(camera, width, height) {\n        this.m_camera = camera;\n        this.m_width = width;\n        this.m_height = height;\n    }\n    ndcToScreen(ndc, screenCoords) {\n        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);\n    }\n}\nexports.ScreenProjector = ScreenProjector;\nScreenProjector.tempV2 = new THREE.Vector2();\nScreenProjector.tempV3 = new THREE.Vector3();\n//# sourceMappingURL=ScreenProjector.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ScreenProjector.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyBackground.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyBackground.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SkyBackground = void 0;\nconst SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ \"./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js\");\nconst SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ \"./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js\");\n/**\n * Class that handles {@link MapView}'s sky background.\n */\nclass SkyBackground {\n    /**\n     * Constructs a new `SkyBackground`.\n     *\n     * @param m_sky - Sky configuration parameters.\n     * @param m_projectionType - {@link MapView}'s projection type.\n     * @param camera - {@link MapView}'s camera.\n     */\n    constructor(m_sky, m_projectionType, camera) {\n        this.m_sky = m_sky;\n        this.m_projectionType = m_projectionType;\n        switch (this.m_sky.type) {\n            case \"gradient\":\n                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);\n                this.updateCamera(camera);\n                break;\n            case \"cubemap\": {\n                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);\n                break;\n            }\n        }\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skyTexture.dispose();\n    }\n    /**\n     * Sky texture.\n     */\n    get texture() {\n        return this.m_skyTexture.texture;\n    }\n    /**\n     * This method updates the skybox based on the camera position (needed for some types of sky).\n     *\n     * @param camera - The camera used in the map view.\n     */\n    updateCamera(camera) {\n        if (this.m_sky.type === \"gradient\") {\n            this.m_skyTexture.update(camera);\n        }\n    }\n    /**\n     * Updates the sky texture with new parameters.\n     *\n     * @param params - New sky configuration parameters.\n     * @param projectionType - Which projection is used, this may also change (in which case the\n     * textures should be recreated).\n     */\n    updateTexture(params, projectionType) {\n        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;\n        switch (params.type) {\n            case \"gradient\":\n                if (isSameSkyType) {\n                    this.m_skyTexture.updateTexture(params);\n                }\n                else {\n                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);\n                }\n                break;\n            case \"cubemap\": {\n                if (isSameSkyType) {\n                    this.m_skyTexture.updateTexture(params);\n                }\n                else {\n                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);\n                }\n                break;\n            }\n        }\n        this.m_projectionType = projectionType;\n        this.m_sky = params;\n    }\n}\nexports.SkyBackground = SkyBackground;\n//# sourceMappingURL=SkyBackground.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SkyBackground.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SkyCubemapTexture = exports.SkyCubemapFaceId = exports.SKY_CUBEMAP_FACE_COUNT = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"SkyCubemapTexture\");\n/**\n * Number of faces that form a [[SkyCubemapTexture]].\n */\nexports.SKY_CUBEMAP_FACE_COUNT = 6;\n/**\n * Maps the faceId to the expected position in the threejs faces array.\n */\nvar SkyCubemapFaceId;\n(function (SkyCubemapFaceId) {\n    SkyCubemapFaceId[SkyCubemapFaceId[\"positiveX\"] = 0] = \"positiveX\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"negativeX\"] = 1] = \"negativeX\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"positiveY\"] = 2] = \"positiveY\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"negativeY\"] = 3] = \"negativeY\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"positiveZ\"] = 4] = \"positiveZ\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"negativeZ\"] = 5] = \"negativeZ\";\n})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));\n/**\n * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].\n */\nclass SkyCubemapTexture {\n    /**\n     * Constructs a new `SkyCubemapTexture`.\n     *\n     * @param sky - Initial [[CubemapSky]] configuration.\n     */\n    constructor(sky) {\n        const faces = this.createCubemapFaceArray(sky);\n        this.m_skybox =\n            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skybox.dispose();\n    }\n    /**\n     * `SkyCubemapTexture`'s texture resource.\n     */\n    get texture() {\n        return this.m_skybox;\n    }\n    /**\n     * Updates the `SkyCubemapTexture` with new parameters.\n     *\n     * @param params - New [[CubemapSky]] configuration.\n     */\n    updateTexture(sky) {\n        const faces = this.createCubemapFaceArray(sky);\n        if (faces === undefined) {\n            return;\n        }\n        this.m_skybox = new three_1.CubeTextureLoader().load(faces);\n    }\n    createCubemapFaceArray(sky) {\n        const faces = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined\n        ];\n        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {\n            const face = sky[SkyCubemapFaceId[i]];\n            if (face === undefined) {\n                logger.error(`Face \"${SkyCubemapFaceId[i]}\" was not defined.`);\n                return;\n            }\n            faces[i] = face;\n        }\n        return faces;\n    }\n}\nexports.SkyCubemapTexture = SkyCubemapTexture;\n//# sourceMappingURL=SkyCubemapTexture.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SkyGradientTexture = exports.DEFAULT_MONOMIAL_POWER = exports.DEFAULT_TEXTURE_SIZE = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nexports.DEFAULT_TEXTURE_SIZE = 512;\nexports.DEFAULT_MONOMIAL_POWER = 1;\n// Vectors used for skybox bitmap computation.\nconst cameraDir = [\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(-1, 0, 0),\n    new three_1.Vector3(0, -1, 0),\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 0, 1),\n    new three_1.Vector3(0, 0, -1)\n];\nconst cameraRight = [\n    new three_1.Vector3(0, 0, -1),\n    new three_1.Vector3(0, 0, 1),\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(-1, 0, 0)\n];\nconst cameraUp = [\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 0, 1),\n    new three_1.Vector3(0, 0, -1),\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 1, 0)\n];\n/**\n * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].\n *\n * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,\n * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom\n *  hemisphere..\n */\nclass SkyGradientTexture {\n    /**\n     * Constructs a new `SkyGradientTexture`.\n     *\n     * @param sky - Initial [[GradientSky]] configuration.\n     * @param m_projectionType - {@link MapView}'s projection type.\n     * @param m_height - Optional height parameter.\n     */\n    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {\n        this.m_projectionType = m_projectionType;\n        this.m_height = m_height;\n        const topColor = new three_1.Color(sky.topColor);\n        const bottomColor = new three_1.Color(sky.bottomColor);\n        const groundColor = new three_1.Color(sky.groundColor);\n        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;\n        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;\n        this.m_faces = [];\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            const data = new Uint8Array(3 * this.m_width * this.m_height);\n            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);\n            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);\n            texture.needsUpdate = true;\n            texture.unpackAlignment = 1;\n            this.m_faces.push(texture);\n        }\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_skybox = new three_1.CubeTexture(this.m_faces);\n            this.m_skybox.needsUpdate = true;\n        }\n        else {\n            this.m_farClipPlaneDividedVertically = new three_1.Line3();\n            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));\n            this.m_bottomMidFarPoint = new three_1.Vector3();\n            this.m_topMidFarPoint = new three_1.Vector3();\n            this.m_horizonPosition = new three_1.Vector3();\n            this.m_farClipPlaneCorners = [\n                new three_1.Vector3(),\n                new three_1.Vector3(),\n                new three_1.Vector3(),\n                new three_1.Vector3()\n            ];\n        }\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.m_faces[i].dispose();\n        }\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_skybox.dispose();\n        }\n    }\n    /**\n     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on\n     * {@link MapView}'s projection).\n     */\n    get texture() {\n        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;\n    }\n    /**\n     * This method updates the position of the texture depending on the camera frustum.\n     *\n     * @param camera - The camera used in the map view.\n     */\n    update(camera) {\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {\n            this.setHorizonPosition(camera);\n            this.updateTexturePosition();\n        }\n    }\n    /**\n     * Updates the `SkyGradientTexture` with new parameters.\n     *\n     * @param params - New [[GradientSky]] configuration.\n     */\n    updateTexture(sky) {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);\n            this.m_faces[i].needsUpdate = true;\n        }\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_skybox.needsUpdate = true;\n        }\n    }\n    // When creating the texture, a Uint8Array is required, because the resulting texture passed\n    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because\n    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.\n    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {\n        const color = new three_1.Color();\n        const dir = new three_1.Vector3();\n        const right = new three_1.Vector3();\n        const up = new three_1.Vector3();\n        const upDir = new three_1.Vector3(0, 0, 1);\n        for (let i = 0; i < this.m_height; ++i) {\n            for (let j = 0; j < this.m_width; ++j) {\n                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n                    const offsetX = right\n                        .copy(cameraRight[faceIdx])\n                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);\n                    const offsetY = up\n                        .copy(cameraUp[faceIdx])\n                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);\n                    dir.copy(cameraDir[faceIdx]).add(offsetX).add(offsetY).normalize();\n                    const t = Math.max(upDir.dot(dir), 0);\n                    color\n                        .copy(groundColor)\n                        .lerp(bottomColor, Math.min(t * 100, 1))\n                        .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))\n                        .multiplyScalar(255);\n                }\n                else {\n                    const t = i / this.m_height;\n                    if (i === 0) {\n                        color.copy(groundColor).multiplyScalar(255);\n                    }\n                    else {\n                        color\n                            .copy(bottomColor)\n                            .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))\n                            .multiplyScalar(255);\n                    }\n                }\n                data[i * this.m_width * 3 + j * 3] = color.r;\n                data[i * this.m_width * 3 + j * 3 + 1] = color.g;\n                data[i * this.m_width * 3 + j * 3 + 2] = color.b;\n            }\n        }\n    }\n    setHorizonPosition(camera) {\n        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);\n        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);\n        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])\n            .add(this.m_farClipPlaneCorners[1])\n            .multiplyScalar(0.5);\n        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])\n            .add(this.m_farClipPlaneCorners[3])\n            .multiplyScalar(0.5);\n        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);\n        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);\n        // When there is no intersection between the ground plane and the\n        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous\n        // intersection point stored in the m_horizonPosition will be considered the valid one.\n        if (!hasIntersection) {\n            this.m_horizonPosition.set(0.0, 0.0, 0.0);\n        }\n    }\n    updateTexturePosition() {\n        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);\n        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();\n        const skyRatio = coveredBySky / frustumHeight;\n        // If there is no intersection between the ground plane and the line that defines the far\n        // clip plane divided vertically, it means that there is no sky visible and therefore the\n        // ground color should be displayed. When there is no intersection, the length of the\n        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with\n        // all the three components to zero.\n        // If there is an intersection, calculate the offset.\n        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;\n        // If the bottom part of the far clipping plane is under the ground plane, scroll the\n        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture\n        // up.\n        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);\n    }\n}\nexports.SkyGradientTexture = SkyGradientTexture;\n//# sourceMappingURL=SkyGradientTexture.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SphereHorizon.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SphereHorizon.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SphereHorizon = exports.CanvasSide = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst twoPi = Math.PI * 2;\n// Keep counter clockwise order.\nvar CanvasSide;\n(function (CanvasSide) {\n    CanvasSide[CanvasSide[\"Bottom\"] = 0] = \"Bottom\";\n    CanvasSide[CanvasSide[\"Right\"] = 1] = \"Right\";\n    CanvasSide[CanvasSide[\"Top\"] = 2] = \"Top\";\n    CanvasSide[CanvasSide[\"Left\"] = 3] = \"Left\";\n})(CanvasSide = exports.CanvasSide || (exports.CanvasSide = {}));\n/**\n * Class computing horizon tangent points and intersections with canvas for spherical projection.\n *\n * @remarks\n *\n * The horizon for a sphere is a circle formed by all intersections of tangent lines passing through\n * the camera with said sphere. It lies on a plane perpendicular to the sphere normal at the camera\n * and it's center is at the line segment joining the sphere center and the camera.\n *\n * The further the camera is, the nearer the horizon center gets to the sphere center, only reaching\n * the sphere center when the camera is at infinity. In other words, the horizon observed from a\n * finite distance is always smaller than a great circle (a circle with the sphere radius, dividing\n * the sphere in two hemispheres, and therefore it's radius is smaller than the sphere's.\n *\n * @internal\n */\nclass SphereHorizon {\n    /**\n     * Constructs the SphereHorizon for the given camera.\n     *\n     * @param m_camera - The camera used as a reference to compute the horizon.\n     */\n    constructor(m_camera) {\n        //\n        //          TL :,,,,,,,,,,,,,,,,,,,,,,,,,,,,! TR canvas corner (proj. on horizon plane)\n        //             >                            +\n        //             >                            +\n        //             ::                           +\n        //              +                           >\n        //              >         `::::::'         !\"\n        //              >     `:::\"      ':::,     +\n        //              +   :!,              .!!`  +\n        //              ,,:;`                   :+`>\n        //              >T                        T# <-- Sphere radius to tangent angle (90 deg).\n        //             !!>                       `+!(`\n        //            =' +                      `.+  {:\n        //           /.  +                     `` >   |:`\n        //          /`   ::                   .`  >    |:.\n        //         /`     >         camZ     '`  `+     /`'`\n        //        ;,      +           *,`   '    !,      ( `'\n        //       ,^       +              `.~     +       ./  .`\n        //       )        +               ' ```  >        !~  `.\n        //      *`        '~             '    ``.>         (    .` tangentDistance\n        //     `\\          +           `'        ?``       '?    `'\n        //     /`          +          `.        :.  ```     )      `.\n        //    `\\           >         `.         >     ```   .=       .`\n        //    |`           +        ``          +        ``` (        `.\n        //    /            \"!      .`           +           `?!         '`\n        //   ,+             !,,,,,!:,,,,,,,,,,,,,             {.`        `.\n        //   /`            BL    '               BR           )  ```       .`\n        //   /                  '                             >`    ``      `'\n        //   /                 '                              `*      ```     .`\n        //  ,:                ' Sphere radius                  )     camZ```   `.\n        //  ?`              `.                                 )           ```   `.\n        //  /              `.                                  )              `.`  '`    camY\n        //  /             ``              horizon radius       /                 ````.   ^\n        //  /            .`          |<----------------------->/                   ``.'` '\n        //  /           .`           |                         /`                     `','  camX\n        //  /          O`````````````C`````````````````````````(,````````````````````````E-----*\n        //             |             |                distanceToHorizonCenter            |\n        //             |             |<------------------------------------------------->|\n        //             |                                                                 |\n        //             |<--------------------------------------------------------------->|\n        //                                      cameraHeight\n        // O -> Sphere center\n        // C -> Horizon center\n        // E -> Camera (eye)\n        // T -> Tangent points (also intersections with projected canvas)\n        this.m_camera = m_camera;\n        this.m_intersections = [];\n        this.m_isFullyVisible = true;\n        const earthRadiusSq = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n        const xAxis = new THREE.Vector3().setFromMatrixColumn(m_camera.matrixWorld, 0).normalize();\n        const zAxis = m_camera.position.clone().normalize();\n        const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis);\n        const cameraHeight = m_camera.position.length();\n        this.m_normalToTangentAngle = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS / cameraHeight);\n        const tangentDistance = Math.sqrt(cameraHeight * cameraHeight - earthRadiusSq);\n        this.m_distanceToHorizonCenter = tangentDistance * Math.cos(this.m_normalToTangentAngle);\n        const horizonCenterLength = cameraHeight - this.m_distanceToHorizonCenter;\n        this.m_radius = Math.sqrt(earthRadiusSq - horizonCenterLength * horizonCenterLength);\n        const horizonCenter = new THREE.Vector3().copy(zAxis).setLength(horizonCenterLength);\n        this.m_matrix = new THREE.Matrix4()\n            .makeBasis(xAxis, yAxis, zAxis)\n            .setPosition(horizonCenter);\n        this.computeIntersections();\n    }\n    /**\n     * Gets the world coordinates of a point in the horizon corresponding to the given parameter.\n     *\n     * @param t - Parameter value in [0,1] corresponding to the point in the horizon circle at\n     * angle t*(arcEnd - arcStart)*2*pi counter clockwise.\n     * @param arcStart - Start of the arc covered by parameter t, corresponds to angle\n     * arcStart*2*pi.\n     * @param arcEnd - End of the arc covered by parameter t, corresponds to angle arcEnd*2*pi.\n     * @param target - Optional target where resulting world coordinates will be set.\n     * @returns the resulting point in world space.\n     */\n    getPoint(t, arcStart = 0, arcEnd = 1, target = new THREE.Vector3()) {\n        const startAngle = arcStart * twoPi;\n        const endAngle = arcEnd >= arcStart ? arcEnd * twoPi : (arcEnd + 1) * twoPi;\n        const deltaAngle = endAngle - startAngle;\n        const angle = startAngle + t * deltaAngle;\n        target.set(this.m_radius * Math.cos(angle), this.m_radius * Math.sin(angle), 0);\n        target.applyMatrix4(this.m_matrix);\n        return target;\n    }\n    /**\n     * Subdivides and arc of the horizon circle, providing the world coordinates of the divisions.\n     *\n     * @param callback - Function called for every division point, getting the the point world\n     * coordinates as parameter.\n     * @param tStart - Angular parameter of the arc's start point [0,1].\n     * @param tEnd - Angular parameter of the arc's end point [0,1].\n     * @param maxNumPoints - Number of division points for the whole horizon. Smaller arcs will\n     * be assigned a proportionally smaller number of points.\n     */\n    getDivisionPoints(callback, tStart = 0, tEnd = 1, maxNumPoints = 10) {\n        const numPoints = Math.max(Math.ceil(((tEnd < tStart ? 1 + tEnd : tEnd) - tStart) * maxNumPoints), 1);\n        // Point corresponding to tEnd is omitted, hence the strict less condition in the loop.\n        for (let d = 0; d < numPoints; d++) {\n            callback(this.getPoint(d / numPoints, tStart, tEnd));\n        }\n    }\n    /**\n     * Indicates whether the horizon circle is fully visible.\n     * @returns 'True' if horizon is fully visible, false otherwise.\n     */\n    get isFullyVisible() {\n        return this.m_isFullyVisible;\n    }\n    /**\n     * Gets the horizon intersections with the specified canvas side, specified in angular\n     * parameters [0,1].\n     * @returns the intersections with the canvas.\n     */\n    getSideIntersections(side) {\n        return this.m_intersections[side];\n    }\n    isTangentVisible(side) {\n        if (side === CanvasSide.Top || side === CanvasSide.Bottom) {\n            const eyeToTangentAngle = side === CanvasSide.Top\n                ? this.m_normalToTangentAngle - this.cameraPitch\n                : this.m_normalToTangentAngle + this.cameraPitch;\n            return this.hFovVertical >= Math.abs(eyeToTangentAngle);\n        }\n        else {\n            const eyeToTangentAngle = this.m_normalToTangentAngle;\n            return (this.hFovHorizontal >= Math.abs(eyeToTangentAngle) &&\n                this.cameraPitch <= this.hFovVertical);\n        }\n    }\n    getTangentOnSide(side) {\n        switch (side) {\n            case CanvasSide.Bottom:\n                return 0.75;\n            case CanvasSide.Right:\n                return 0;\n            case CanvasSide.Top:\n                return 0.25;\n            case CanvasSide.Left:\n                return 0.5;\n        }\n    }\n    computeIntersections() {\n        // Look for the intersections of the canvas sides projected in the horizon plane with the\n        // horizon circle.\n        // Top and bottom canvas sides are horizontal lines at plane coordinates yTop and yBottom\n        // respectively. Left and right sides are lines whose slope depends on the camera pitch.\n        //\n        // Front View (horizon plane):\n        //\n        //                        Top\n        //        TL '{~~~~~~~~~~~~~~~~~~~~~~~~~~}. TR\n        //            (                          (\n        //            ;\"   '!;!!!!!!!!!!!!;!'   ::\n        //             I>^^:                :^^|I <--------- Canvas-Horizon intersection\n        //          ~>+%.                      ,$+>,\n        //        !|~   (                      (   :|!\n        //      ~/'   L (----------C----------`) R   ,/\"\n        //     /;       `/         ^,         )`       ^|\n        //    }'         (         |`         (         '}\n        //   }`          ,^        |`        *.          .}\n        //  ('         BL !::::::::|:::::::::: BR         ,)\n        // ,{                      |`  Bottom              }`\n        // }                   camZ|`                      `}\n        // }                       |`                       }\n        // }                       E----> camX              }\n        // }                                                } Horizon circle\n        // }                                               `}\n        // ~{                                              }.\n        //  {.                                            '(\n        //   }`                                          `}\n        //   `}.                                        .}\n        //     )!                                      !/\n        //      :/.                                  '/:\n        //        ^|'                              ,|^\n        //          :>+.                        .+>:\n        //             !^^;'                ';^^!\n        //                 :;!!!!!!!!!!!!;!;:\n        //\n        // Top-down view (plane defined by camZ and camX):\n        //\n        //                        Top\n        //        TL_______________________________ TR\n        //          \\              |              /\n        //           \\   :;!!!!!!!!!!!!!!;!;:    /\n        //            I^;'         |        ';^^I\n        //         :>+.\\           |           /.+>:\n        //       ^|'    \\          |          /    ,|^ <--- Horizon\n        //     :/.       \\         |         /       '/:\n        //      }         L--------C--------R_________}_________\n        //     }           \\       ^camZ   /           }       ^\n        //      }           \\      |      /           }        |\n        //     :/.           \\     |     /           :/.       |\n        //       ^|'          BL----B----BR_______ !|'         |\n        //         :>+.        \\   |   /        ^              | eyeToHorizon\n        //            !^;'      \\  |  /      ';!|              |\n        //               :;!!!!!!\\ | /!!;!;:!   | eyeToBottom  |\n        //                        \\|/           |              |\n        //                         E----> camX__v______________v\n        const radiusSq = this.m_radius * this.m_radius;\n        const yBottom = this.m_distanceToHorizonCenter * Math.tan(this.cameraPitch - this.hFovVertical);\n        let tTopRight;\n        let tBottomRight;\n        for (let side = CanvasSide.Bottom; side < 4; side++) {\n            const sideIntersections = [];\n            if (this.isTangentVisible(side)) {\n                sideIntersections.push(this.getTangentOnSide(side));\n            }\n            else {\n                this.m_isFullyVisible = false;\n                switch (side) {\n                    case CanvasSide.Bottom: {\n                        const x = Math.sqrt(radiusSq - yBottom * yBottom);\n                        const t = Math.atan2(yBottom, x) / twoPi;\n                        sideIntersections.push(0.5 - t, t > 0 ? t : 1 + t);\n                        break;\n                    }\n                    case CanvasSide.Right: {\n                        // Define right canvas side line by finding the middle and bottom points of\n                        // its projection on the horizon plane.\n                        const eyeToHorizon = this.m_distanceToHorizonCenter / Math.cos(this.cameraPitch);\n                        const yRight = this.m_distanceToHorizonCenter * Math.tan(this.cameraPitch);\n                        const xRight = eyeToHorizon * Math.tan(this.hFovHorizontal);\n                        const eyeToBottom = (this.m_distanceToHorizonCenter * Math.cos(this.hFovVertical)) /\n                            Math.cos(this.cameraPitch - this.hFovVertical);\n                        const xBottomRight = (xRight * eyeToBottom) / eyeToHorizon;\n                        const yBottomRight = yBottom;\n                        const intersections = harp_utils_1.Math2D.intersectLineAndCircle(xBottomRight, yBottomRight, xRight, yRight, this.m_radius);\n                        if (!intersections) {\n                            break;\n                        }\n                        const yTopRight = intersections.y1;\n                        // If there's a second intersection check if it's visible (its above the y\n                        // coordinate of the bottom canvas side).\n                        if (-yTopRight >= yBottom && intersections.x2 !== undefined) {\n                            tBottomRight = Math.atan2(intersections.y2, intersections.x2) / twoPi;\n                            sideIntersections.push(1 + tBottomRight);\n                        }\n                        tTopRight = Math.atan2(intersections.y1, intersections.x1) / twoPi;\n                        sideIntersections.push(tTopRight);\n                        break;\n                    }\n                    case CanvasSide.Top: {\n                        const yTop = this.m_distanceToHorizonCenter *\n                            Math.tan(this.cameraPitch + this.hFovVertical);\n                        const x = Math.sqrt(radiusSq - yTop * yTop);\n                        const t = Math.atan2(yTop, x) / twoPi;\n                        sideIntersections.push(t, 0.5 - t);\n                        break;\n                    }\n                    case CanvasSide.Left: {\n                        // Left side intersections are symmetrical to right ones.\n                        if (tTopRight !== undefined) {\n                            sideIntersections.push(0.5 - tTopRight);\n                        }\n                        if (tBottomRight !== undefined) {\n                            sideIntersections.push(0.5 - tBottomRight);\n                        }\n                        break;\n                    }\n                }\n            }\n            this.m_intersections.push(sideIntersections);\n        }\n    }\n    get cameraPitch() {\n        if (this.m_cameraPitch === undefined) {\n            this.m_cameraPitch = Utils_1.MapViewUtils.extractAttitude({ projection: harp_geoutils_1.sphereProjection }, this.m_camera).pitch;\n        }\n        return this.m_cameraPitch;\n    }\n    get hFovVertical() {\n        if (this.m_hFovVertical === undefined) {\n            this.m_hFovVertical = harp_geoutils_1.MathUtils.degToRad(this.m_camera.fov / 2);\n        }\n        return this.m_hFovVertical;\n    }\n    get hFovHorizontal() {\n        if (this.m_hFovHorizontal === undefined) {\n            this.m_hFovHorizontal =\n                Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(this.hFovVertical * 2, this.m_camera.aspect) / 2;\n        }\n        return this.m_hFovHorizontal;\n    }\n}\nexports.SphereHorizon = SphereHorizon;\n//# sourceMappingURL=SphereHorizon.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SphereHorizon.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Statistics.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Statistics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceStatistics = exports.FrameStatsArray = exports.FrameStats = exports.Statistics = exports.MultiStageTimer = exports.computeArrayAverage = exports.computeArrayStats = exports.SampledTimer = exports.SimpleTimer = exports.RingBuffer = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"Statistics\");\n/**\n * A simple ring buffer to store the last `n` values of the timer. The buffer works on\n * a First-In-First-Out (FIFO) basis.\n */\nclass RingBuffer {\n    /**\n     * Sets up the ring buffer.\n     *\n     * @param capacity - The buffer's capacity.\n     */\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.buffer = new Array(capacity);\n        this.capacity = capacity;\n        this.head = this.tail = this.size = 0;\n    }\n    /**\n     * Clears the contents, removes all elements.\n     */\n    clear() {\n        this.head = this.tail = this.size = 0;\n    }\n    /**\n     * Adds a single element to the ring buffer.\n     *\n     * @param data - Data element.\n     */\n    enqOne(data) {\n        let next = this.head + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size < this.capacity) {\n            this.size++;\n        }\n        this.buffer[this.head] = data;\n        this.head = next;\n        if (this.size === this.capacity) {\n            this.tail = this.head;\n        }\n    }\n    /**\n     * Adds one or more elements.\n     *\n     * @param data - The elements to add.\n     */\n    enq(...data) {\n        for (const v of data) {\n            this.enqOne(v);\n        }\n    }\n    /**\n     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.\n     * Before calling this method, make sure that `size > 0`.\n     */\n    deq() {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n        const data = this.buffer[this.tail];\n        let next = this.tail + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size > 0) {\n            this.size--;\n        }\n        this.tail = next;\n        return data;\n    }\n    /**\n     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get top() {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n        return this.buffer[this.tail];\n    }\n    /**\n     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get bottom() {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n        let previous = this.head - 1;\n        if (previous < 0) {\n            previous = this.capacity - 1;\n        }\n        return this.buffer[previous];\n    }\n    /**\n     * Creates an iterator for the buffer.\n     */\n    iterator() {\n        return new RingBuffer.Iterator(this);\n    }\n    /**\n     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.\n     */\n    asArray() {\n        const array = new Array();\n        for (let i = 0; i < this.size; i++) {\n            array.push(this.buffer[(this.tail + i) % this.capacity]);\n        }\n        return array;\n    }\n}\nexports.RingBuffer = RingBuffer;\n(function (RingBuffer) {\n    /**\n     * A local class for RingBuffer<T>\n     */\n    class Iterator {\n        /**\n         * Creates an iterator for the ring buffer.\n         *\n         * @param m_buffer - `Ringbuffer` to iterate over.\n         * @param m_index - Start index.\n         */\n        constructor(m_buffer, m_index = 0) {\n            this.m_buffer = m_buffer;\n            this.m_index = m_index;\n        }\n        /**\n         * Gets the iterator's current value. This function does not fail even if an overrun occurs.\n         * To detect an overrun, watch the result for [[next]].\n         */\n        get value() {\n            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];\n        }\n        /**\n         * Advances the iterator to the next element.\n         *\n         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.\n         */\n        next() {\n            this.m_index++;\n            return this.m_index < this.m_buffer.size;\n        }\n    }\n    RingBuffer.Iterator = Iterator;\n})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));\n/**\n * A simple timer that stores only the latest measurement.\n *\n * @internal\n */\nclass SimpleTimer {\n    constructor(statistics, name) {\n        this.statistics = statistics;\n        this.name = name;\n        /** `true` if timer has been started. */\n        this.running = false;\n    }\n    /**\n     * Gets the latest measurement. This function may return `undefined` if no measurement\n     * was done.\n     */\n    get value() {\n        return this.m_currentValue;\n    }\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val - The timer's duration.\n     */\n    setValue(val) {\n        this.m_currentValue = val;\n    }\n    /**\n     * Resets the value to be able to start again.\n     */\n    reset() {\n        this.m_currentValue = undefined;\n    }\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start() {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' is already running\");\n        }\n        this.running = true;\n        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());\n    }\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop() {\n        var _a;\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        }\n        else {\n            // this.currentValue is a number now!\n            const t = harp_utils_1.PerformanceTimer.now() - ((_a = this.m_currentValue) !== null && _a !== void 0 ? _a : 0);\n            this.m_currentValue = t;\n            this.setValue(t);\n            this.running = false;\n            return t;\n        }\n    }\n    /**\n     * Samples the timer. Requires that the timer has started.\n     *\n     * @returns the current timer value; `-1` if statistics are disabled.\n     */\n    now() {\n        var _a;\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        }\n        else {\n            const t = harp_utils_1.PerformanceTimer.now() - ((_a = this.m_currentValue) !== null && _a !== void 0 ? _a : 0);\n            return t;\n        }\n    }\n}\nexports.SimpleTimer = SimpleTimer;\n/**\n * A timer that stores the last `n` samples in a ring buffer.\n *\n * @internal\n */\nclass SampledTimer extends SimpleTimer {\n    /**\n     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!\n     *\n     * @param statistics - Statistics to use for management.\n     * @param name - Name of the timer. Use colons to build a hierarchy.\n     */\n    constructor(statistics, name) {\n        super(statistics, name);\n        this.statistics = statistics;\n        this.name = name;\n        /**\n         * The number of times the timer has reset.\n         */\n        this.numResets = 0;\n        /**\n         * Maximum samples until the statistics are reset and updated, which may destroy a median\n         * computation.\n         */\n        this.maxNumSamples = 1000;\n        /**\n         * The array of sampled values, its length cannot exceed `maxNumSamples`.\n         */\n        this.samples = new RingBuffer(this.maxNumSamples);\n    }\n    /**\n     * Resets the timer and clears all of its historical values.\n     * @override\n     */\n    reset() {\n        super.reset();\n        this.getStats();\n        this.samples.clear();\n        this.numResets++;\n    }\n    /**\n     * Add a single measurement to the sample.\n     *\n     * @param val - A measurement to add.\n     * @override\n     */\n    setValue(val) {\n        super.setValue(val);\n        if (val !== undefined) {\n            this.samples.enqOne(val);\n        }\n    }\n    /**\n     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,\n     * as it requires a copy of the sampled values.\n     */\n    getStats() {\n        return computeArrayStats(this.samples.asArray());\n    }\n}\nexports.SampledTimer = SampledTimer;\n/**\n * Only exported for testing\n * @ignore\n *\n * @remarks\n * Compute the [[ArrayStats]] for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the\n *      entries.\n * @returns {(Stats | undefined)}\n *\n * @internal\n */\nfunction computeArrayStats(samples) {\n    if (samples.length === 0) {\n        return undefined;\n    }\n    samples.sort((a, b) => {\n        return a - b;\n    });\n    const min = samples[0];\n    const max = samples[samples.length - 1];\n    let median;\n    let median75;\n    let median90;\n    let median95;\n    let median97;\n    let median99;\n    let median999;\n    if (samples.length === 1) {\n        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];\n    }\n    else if (samples.length === 2) {\n        median = samples[0] * 0.5 + samples[1] * 0.5;\n        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];\n    }\n    else {\n        const mid = Math.floor(samples.length / 2);\n        median =\n            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];\n        const mid75 = Math.round(samples.length * 0.75) - 1;\n        median75 = samples[mid75];\n        const mid90 = Math.round(samples.length * 0.9) - 1;\n        median90 = samples[mid90];\n        const mid95 = Math.round(samples.length * 0.95) - 1;\n        median95 = samples[mid95];\n        const mid97 = Math.round(samples.length * 0.97) - 1;\n        median97 = samples[mid97];\n        const mid99 = Math.round(samples.length * 0.99) - 1;\n        median99 = samples[mid99];\n        const mid999 = Math.round(samples.length * 0.999) - 1;\n        median999 = samples[mid999];\n    }\n    let sum = 0;\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n    const avg = sum / samples.length;\n    return {\n        min,\n        max,\n        avg,\n        median,\n        median75,\n        median90,\n        median95,\n        median97,\n        median99,\n        median999,\n        numSamples: samples.length\n    };\n}\nexports.computeArrayStats = computeArrayStats;\n/**\n * Only exported for testing\n * @ignore\n *\n * @remarks\n * Compute the averages for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values.\n * @returns {(Stats | undefined)}\n *\n * @internal\n */\nfunction computeArrayAverage(samples) {\n    if (samples.length === 0) {\n        return undefined;\n    }\n    let sum = 0;\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n    const avg = sum / samples.length;\n    return avg;\n}\nexports.computeArrayAverage = computeArrayAverage;\n/**\n * Measures a sequence of connected events, such as multiple processing stages in a function.\n *\n * @remarks\n * Each stage is identified with a timer name, that must be a valid timer in the statistics\n * object. Additionally, all timers within a `MultiStageTimer` must be unique.\n *\n * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,\n * one timer stops and the next timer starts.\n *\n * @internal\n */\nclass MultiStageTimer {\n    /**\n     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.\n     *\n     * @param statistics - The statistics object that manages the timers.\n     * @param name - Name of this `MultiStageTimer`.\n     * @param stages - List of timer names.\n     */\n    constructor(statistics, name, stages) {\n        this.statistics = statistics;\n        this.name = name;\n        this.stages = stages;\n        if (stages.length < 1) {\n            throw new Error(\"MultiStageTimer needs stages\");\n        }\n        stages.forEach(stage => {\n            if (!statistics.hasTimer(stage)) {\n                throw new Error(\"Unknown timer: \" + stage);\n            }\n        });\n    }\n    /**\n     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its\n     * last stage, the value is `undefined`.\n     */\n    get value() {\n        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;\n    }\n    /**\n     * Resets the timers across all stages.\n     */\n    reset() {\n        if (!this.statistics.enabled) {\n            return;\n        }\n        this.stages.forEach(stage => {\n            this.statistics.getTimer(stage).reset();\n        });\n    }\n    /**\n     * Starts the `MultiStageTimer` at its first stage.\n     */\n    start() {\n        var _a;\n        this.stage = this.stages[0];\n        return (_a = this.statistics.getTimer(this.stages[0]).value) !== null && _a !== void 0 ? _a : -1;\n    }\n    /**\n     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be\n     * `undefined` if not all stages started.\n     */\n    stop() {\n        this.stage = undefined;\n        return this.value !== undefined ? this.value : -1;\n    }\n    /**\n     * Gets the current stage.\n     */\n    get stage() {\n        return this.currentStage;\n    }\n    /**\n     * Sets the current stage. If a new stage is provided, the current timer (if available) is\n     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,\n     * this is equivalent to calling `stop` on the `MultiStageTimer`.\n     *\n     * @param stage - The next stage to start.\n     */\n    set stage(stage) {\n        if (this.currentStage === stage) {\n            return;\n        }\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).stop();\n        }\n        this.currentStage = stage;\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).start();\n        }\n    }\n}\nexports.MultiStageTimer = MultiStageTimer;\n/**\n * Manages a set of timers.\n *\n * @remarks\n * The main objective of `Statistics` is to log these timers. You can\n * disable statistics to minimize their impact on performance.\n *\n * @internal\n */\nclass Statistics {\n    /**\n     * Sets up a group of timers.\n     *\n     * @param name - The statistics name, for logging purposes.\n     * @param enabled - If `false`, the timers do not measure the performance.\n     */\n    constructor(name, enabled = false) {\n        this.name = name;\n        this.enabled = enabled;\n        this.timers = new Map();\n        this.nullTimer = new SimpleTimer(this, \"<null>\");\n    }\n    /**\n     * Adds a timer, based on the name specified.\n     *\n     * @param name - The timer's name; must be unique.\n     */\n    createTimer(name, keepSamples = true) {\n        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);\n        return this.addTimer(timer);\n    }\n    /**\n     * Adds the timer specified.\n     *\n     * @param timer - The timer's name, which must be unique within this statistics object.\n     */\n    addTimer(timer) {\n        if (this.timers.get(timer.name) !== undefined) {\n            throw new Error(\"Duplicate timer name: '\" + timer.name + \"'\");\n        }\n        this.timers.set(timer.name, timer);\n        return timer;\n    }\n    /**\n     * Gets a timer by name.\n     *\n     * @param name - The timer's name.\n     */\n    getTimer(name) {\n        if (!this.enabled) {\n            return this.nullTimer;\n        }\n        const t = this.timers.get(name);\n        return t === undefined ? this.nullTimer : t;\n    }\n    /**\n     * Checks if a timer with the specified name already exists.\n     *\n     * @param name - The timer's name.\n     * @returns `true` if a timer with `name` already exists; `false` otherwise.\n     */\n    hasTimer(name) {\n        const t = this.timers.get(name);\n        return t !== undefined;\n    }\n    /**\n     * Resets all timers.\n     */\n    reset() {\n        this.timers.forEach((timer) => {\n            timer.reset();\n        });\n    }\n    /**\n     * Prints all values to the console.\n     *\n     * @param header - Optional header line.\n     * @param footer - Optional footer line.\n     */\n    log(header, footer) {\n        if (header !== undefined || this.name !== undefined) {\n            logger.log(header !== undefined ? header : this.name);\n        }\n        let maxNameLength = 0;\n        this.timers.forEach((timer) => {\n            maxNameLength = Math.max(maxNameLength, timer.name.length);\n        });\n        // simple printing function for number limits the number of decimal points.\n        const print = (v) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n        this.timers.forEach((timer) => {\n            let s = timer.name + \": \" + \" \".repeat(maxNameLength - timer.name.length);\n            s += print(timer.value);\n            // sampled timers also update their stats and log them\n            if (timer instanceof SampledTimer) {\n                const simpleStats = timer.getStats();\n                if (simpleStats !== undefined) {\n                    s +=\n                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                            `N=${print(simpleStats.numSamples)} ]`;\n                }\n            }\n            logger.log(s);\n        });\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n}\nexports.Statistics = Statistics;\n/**\n * Class containing all counters, timers and events of the current frame.\n *\n * @internal\n */\nclass FrameStats {\n    constructor() {\n        this.entries = new Map();\n        this.messages = undefined;\n    }\n    /**\n     * Retrieve the value of the performance number.\n     *\n     * @param name - Name of the performance number.\n     * @returns The value of the performance number or `undefined` if it has not been declared by\n     *      `setValue` before.\n     */\n    getValue(name) {\n        return this.entries.get(name);\n    }\n    /**\n     * Set the value of the performance number.\n     *\n     * @param name - Name of the performance number.\n     * @param name - New value of the performance number.\n     */\n    setValue(name, value) {\n        this.entries.set(name, value);\n    }\n    /**\n     * Add a value to the current value of the performance number. If the performance is not known,\n     * it will be initialized with `value`.\n     *\n     * @param name - Name of the performance number.\n     * @param name - Value to be added to the performance number.\n     */\n    addValue(name, value) {\n        const oldValue = this.entries.get(name);\n        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));\n    }\n    /**\n     * Add a text message to the frame, like \"Font XYZ has been loaded\"\n     *\n     * @param message - The message to add.\n     */\n    addMessage(message) {\n        if (this.messages === undefined) {\n            this.messages = [];\n        }\n        this.messages.push(message);\n    }\n    /**\n     * Reset all known performance values to `0` and the messages to `undefined`.\n     */\n    reset() {\n        this.entries.forEach((value, name) => {\n            this.entries.set(name, 0);\n        });\n        this.messages = undefined;\n    }\n}\nexports.FrameStats = FrameStats;\n/**\n * @ignore\n * Only exported for testing.\n *\n * @remarks\n * Instead of passing around an array of objects, we store the frame statistics as an object of\n * arrays. This allows convenient computations from {@link RingBuffer},\n */\nclass FrameStatsArray {\n    constructor(capacity = 0) {\n        this.capacity = capacity;\n        this.frameEntries = new Map();\n        this.messages = new RingBuffer(capacity);\n    }\n    get length() {\n        return this.messages.size;\n    }\n    reset() {\n        this.frameEntries.forEach((buffer, name) => {\n            buffer.clear();\n        });\n        this.messages.clear();\n    }\n    addFrame(frameStats) {\n        const currentSize = this.length;\n        const frameEntries = this.frameEntries;\n        frameStats.entries.forEach((value, name) => {\n            let buffer = frameEntries.get(name);\n            if (buffer === undefined) {\n                // If there is a buffer that has not been known before, add it to the known buffers,\n                // fill it up with with 0 to the size of all the other buffers to make them of equal\n                // size to make PerfViz happy.\n                buffer = new RingBuffer(this.capacity);\n                for (let i = 0; i < currentSize; i++) {\n                    buffer.enqOne(0);\n                }\n                this.frameEntries.set(name, buffer);\n            }\n            buffer.enqOne(value);\n        });\n        this.messages.enq(frameStats.messages);\n    }\n    /**\n     * Prints all values to the console.\n     */\n    log() {\n        let maxNameLength = 0;\n        this.frameEntries.forEach((buffer, name) => {\n            maxNameLength = Math.max(maxNameLength, name.length);\n        });\n        // simple printing function for number limits the number of decimal points.\n        const print = (v) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n        this.frameEntries.forEach((buffer, name) => {\n            let s = name + \": \" + \" \".repeat(maxNameLength - name.length);\n            const simpleStats = computeArrayStats(buffer.asArray());\n            if (simpleStats !== undefined) {\n                s +=\n                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                        `N=${print(simpleStats.numSamples)} ]`;\n            }\n            logger.log(s);\n        });\n    }\n}\nexports.FrameStatsArray = FrameStatsArray;\n/**\n * Performance measurement central.\n *\n * @remarks\n * Maintains the current. Implemented as an instance for easy access.\n *\n * {@link FrameStats}, which holds all individual performance numbers.\n *\n * @internal\n */\nclass PerformanceStatistics {\n    /**\n     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.\n     *\n     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.\n     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.\n     * @memberof PerformanceStatistics\n     */\n    constructor(enabled = true, maxNumFrames = 1000) {\n        this.enabled = enabled;\n        this.maxNumFrames = maxNumFrames;\n        /**\n         * Current frame statistics. Contains all values for the current frame. Will be cleared when\n         * [[PerformanceStatistics#storeFrameInfo]] is called.\n         *\n         * @type {FrameStats}\n         * @memberof PerformanceStatistics\n         */\n        this.currentFrame = new FrameStats();\n        /**\n         * Additional results stored for the current application run, not per frame. Only the last value\n         * is stored.\n         *\n         * @type {(Map<string, number>)}\n         */\n        this.appResults = new Map();\n        /**\n         * Additional configuration values stored for the current application run, not per frame. Only\n         * the last value is stored.\n         *\n         * @type {(Map<string, string>)}\n         * @memberof PerformanceStatistics\n         */\n        this.configs = new Map();\n        PerformanceStatistics.m_instance = this;\n        this.m_frameEvents = new FrameStatsArray(maxNumFrames);\n    }\n    /**\n     * Returns `true` when the maximum number of storable frames is reached.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof PerformanceStatistics\n     */\n    get isFull() {\n        return this.m_frameEvents.length >= this.maxNumFrames;\n    }\n    /**\n     * Global instance to the instance. The current instance can be overridden by creating a new\n     * `PerformanceStatistics`.\n     */\n    static get instance() {\n        if (PerformanceStatistics.m_instance === undefined) {\n            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);\n        }\n        return PerformanceStatistics.m_instance;\n    }\n    /**\n     * @ignore\n     * Only exported for testing.\n     *\n     * Return the array of frame events.\n     */\n    get frameEvents() {\n        return this.m_frameEvents;\n    }\n    /**\n     * Clears all settings, all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clear() {\n        this.clearFrames();\n        this.configs.clear();\n        this.appResults.clear();\n    }\n    /**\n     * Clears only all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clearFrames() {\n        this.m_frameEvents.reset();\n        this.currentFrame.reset();\n    }\n    /**\n     * Add the render state information from [[THREE.WebGLInfo]] to the current frame.\n     * @param {THREE.WebGLInfo} webGlInfo\n     */\n    addWebGLInfo(webGlInfo) {\n        if (webGlInfo.render !== undefined) {\n            this.currentFrame.setValue(\"gl.numCalls\", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);\n            this.currentFrame.setValue(\"gl.numPoints\", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);\n            this.currentFrame.setValue(\"gl.numLines\", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);\n            this.currentFrame.setValue(\"gl.numTriangles\", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);\n        }\n        if (webGlInfo.memory !== undefined) {\n            this.currentFrame.setValue(\"gl.numGeometries\", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);\n            this.currentFrame.setValue(\"gl.numTextures\", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);\n        }\n        if (webGlInfo.programs !== undefined) {\n            this.currentFrame.setValue(\"gl.numPrograms\", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);\n        }\n    }\n    /**\n     * Add memory statistics to the current frame if available.\n     * @note Currently only supported on Chrome\n     */\n    addMemoryInfo() {\n        if (window !== undefined && window.performance !== undefined) {\n            const memory = window.performance.memory;\n            if (memory !== undefined) {\n                this.currentFrame.setValue(\"memory.totalJSHeapSize\", memory.totalJSHeapSize);\n                this.currentFrame.setValue(\"memory.usedJSHeapSize\", memory.usedJSHeapSize);\n                this.currentFrame.setValue(\"memory.jsHeapSizeLimit\", memory.jsHeapSizeLimit);\n            }\n        }\n    }\n    /**\n     * Stores the current frame events into the array of events and clears all values.\n     *\n     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.\n     * @memberof PerformanceStatistics\n     */\n    storeAndClearFrameInfo() {\n        if (this.m_frameEvents.length >= this.maxNumFrames) {\n            return false;\n        }\n        this.m_frameEvents.addFrame(this.currentFrame);\n        this.currentFrame.reset();\n        return true;\n    }\n    /**\n     * Logs all values to the logger.\n     *\n     * @param header - Optional header line.\n     * @param footer - Optional footer line.\n     */\n    log(header, footer) {\n        logger.log(header !== undefined ? header : \"PerformanceStatistics\");\n        const appResults = this.appResults;\n        appResults.forEach((value, name) => {\n            logger.log(name, value);\n        });\n        const configs = this.configs;\n        configs.forEach((value, name) => {\n            logger.log(name, value);\n        });\n        this.m_frameEvents.log();\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsPlainObject(onlyLastFrame = false) {\n        const appResults = {};\n        const configs = {};\n        const frames = {};\n        const plainObject = {\n            configs,\n            appResults,\n            frames\n        };\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value, name) => {\n            appResults[name] = value;\n        });\n        const configValues = this.configs;\n        configValues.forEach((value, name) => {\n            configs[name] = value;\n        });\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.bottom;\n            }\n        }\n        else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.asArray();\n            }\n        }\n        plainObject.messages = this.m_frameEvents.messages.asArray();\n        return plainObject;\n    }\n    /**\n     * Convert the last frame values to a plain object that can be serialized. Required to copy the\n     * test results over to nightwatch.\n     */\n    getLastFrameStatistics() {\n        return this.getAsPlainObject(true);\n    }\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsSimpleFrameStatistics(onlyLastFrame = false) {\n        const configs = new Map();\n        const appResults = new Map();\n        const frames = new Map();\n        const simpleStatistics = {\n            configs,\n            appResults,\n            frames,\n            messages: this.m_frameEvents.messages.asArray()\n        };\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value, name) => {\n            appResults.set(name, value);\n        });\n        const configValues = this.configs;\n        configValues.forEach((value, name) => {\n            configs.set(name, value);\n        });\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.bottom);\n            }\n        }\n        else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.asArray());\n            }\n        }\n        return simpleStatistics;\n    }\n}\nexports.PerformanceStatistics = PerformanceStatistics;\nPerformanceStatistics.m_instance = undefined;\n//# sourceMappingURL=Statistics.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/Statistics.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/TextureLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/TextureLoader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextureLoader = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * A texture loader that supports request headers(e.g. for Authorization)\n */\nclass TextureLoader {\n    constructor() {\n        this.m_textureLoader = new THREE.TextureLoader();\n    }\n    /**\n     * Load an image from url and create a texture\n     * @param url - URL to the image\n     * @param requestHeaders - Optional request headers to load image(e.g. Authorization)\n     * @param abortSignal - Optional AbortSignal to cancel the load.\n     * @param crossOrigin - Enable/disable CORS\n     */\n    async load(url, requestHeaders, abortSignal, crossOrigin = true) {\n        // Use THREE.js texture loader directly if no request header is set\n        if (requestHeaders === undefined) {\n            return await this.loadWithThreeLoader(url);\n        }\n        // Load image with fetch API if request header is set\n        const response = await fetch(url, {\n            headers: requestHeaders,\n            signal: abortSignal,\n            mode: crossOrigin ? \"cors\" : \"no-cors\"\n        });\n        const blob = await response.blob();\n        // Load image from blob using THREE.js loader\n        const texture = await this.loadWithThreeLoader(URL.createObjectURL(blob));\n        // Set correct image format from original URL or blob mime type\n        // (object URL does not contain file format)\n        const isJPEG = blob.type === \"image/jpeg/\" ||\n            url.search(/\\.jpe?g($|\\?)/i) > 0 ||\n            url.search(/^data\\:image\\/jpeg/) === 0;\n        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;\n        return texture;\n    }\n    loadWithThreeLoader(url) {\n        return new Promise((resolve, reject) => {\n            this.m_textureLoader.setCrossOrigin(\"\");\n            this.m_textureLoader.load(url, texture => resolve(texture), undefined, () => reject(new Error(\"failed to load texture\")));\n        });\n    }\n}\nexports.TextureLoader = TextureLoader;\n//# sourceMappingURL=TextureLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/TextureLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeHelpers.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLight = exports.toTextureFilter = exports.toWrappingMode = exports.toTextureDataType = exports.toPixelFormat = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.\n */\nfunction toPixelFormat(format) {\n    switch (format) {\n        case \"Alpha\":\n            return THREE.AlphaFormat;\n        case \"RGB\":\n            return THREE.RGBFormat;\n        case \"RGBA\":\n            return THREE.RGBAFormat;\n        case \"Luminance\":\n            return THREE.LuminanceFormat;\n        case \"LuminanceAlpha\":\n            return THREE.LuminanceAlphaFormat;\n        case \"RGBE\":\n            return THREE.RGBEFormat;\n        case \"Depth\":\n            return THREE.DepthFormat;\n        case \"DepthStencil\":\n            return THREE.DepthStencilFormat;\n        case \"Red\":\n            return THREE.RedFormat;\n        default:\n            throw new Error(`invalid pixel format: ${format}`);\n    }\n}\nexports.toPixelFormat = toPixelFormat;\n/**\n * Returns `three.js` texture data types based on a [[TextureDataType]] specified.\n */\nfunction toTextureDataType(dataType) {\n    switch (dataType) {\n        case \"UnsignedByte\":\n            return THREE.UnsignedByteType;\n        case \"Byte\":\n            return THREE.ByteType;\n        case \"Short\":\n            return THREE.ShortType;\n        case \"UnsignedShort\":\n            return THREE.UnsignedShortType;\n        case \"Int\":\n            return THREE.IntType;\n        case \"UnsignedInt\":\n            return THREE.UnsignedIntType;\n        case \"Float\":\n            return THREE.FloatType;\n        case \"HalfFloat\":\n            return THREE.HalfFloatType;\n        default:\n            throw new Error(`invalid texture data type: ${dataType}`);\n    }\n}\nexports.toTextureDataType = toTextureDataType;\n/**\n * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.\n */\nfunction toWrappingMode(mode) {\n    switch (mode) {\n        case \"clamp\":\n            return THREE.ClampToEdgeWrapping;\n        case \"repeat\":\n            return THREE.RepeatWrapping;\n        case \"mirror\":\n            return THREE.MirroredRepeatWrapping;\n        default:\n            throw new Error(`invalid wrapping mode: ${mode}`);\n    }\n}\nexports.toWrappingMode = toWrappingMode;\n/**\n * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.\n */\nfunction toTextureFilter(filter) {\n    switch (filter) {\n        case \"nearest\":\n            return THREE.NearestFilter;\n        case \"nearestMipMapNearest\":\n            return THREE.NearestMipMapNearestFilter;\n        case \"nearestMipMapLinear\":\n            return THREE.NearestMipMapLinearFilter;\n        case \"linear\":\n            return THREE.LinearFilter;\n        case \"linearMipMapNearest\":\n            return THREE.LinearMipMapNearestFilter;\n        case \"linearMipMapLinear\":\n            return THREE.LinearMipMapLinearFilter;\n        default:\n            throw new Error(`invalid texture filter: ${filter}`);\n    }\n}\nexports.toTextureFilter = toTextureFilter;\n/**\n * Create a specific light for lighting the map.\n */\nfunction createLight(lightDescription) {\n    switch (lightDescription.type) {\n        case \"ambient\": {\n            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);\n            light.name = lightDescription.name;\n            return light;\n        }\n        case \"directional\": {\n            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);\n            light.name = lightDescription.name;\n            if (lightDescription.castShadow !== undefined) {\n                light.castShadow = lightDescription.castShadow;\n            }\n            if (light.castShadow) {\n                light.shadow.bias = 0.00001;\n                light.shadow.mapSize.width = 1024;\n                light.shadow.mapSize.height = 1024;\n            }\n            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);\n            light.position.normalize();\n            return light;\n        }\n    }\n}\nexports.createLight = createLight;\n//# sourceMappingURL=ThemeHelpers.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ThemeHelpers.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeLoader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThemeLoader = exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = void 0;\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst Theme_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ \"./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js\");\n/**\n * @internal\n */\nexports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;\n/**\n * Loads and validates a theme from URL objects.\n */\nclass ThemeLoader {\n    /**\n     * Loads a {@link @here/harp-datasource-protocol#Theme} from a\n     * remote resource, provided as a URL that points to a\n     * JSON-encoded theme.\n     *\n     * By default, resolves following features of theme:\n     *\n     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])\n     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section\n     *     of theme (see [[resolveThemeReferences]])\n     *\n     * Relative URIs of reference resources are resolved to full URL using the document's base URL\n     * (see [[resolveUrls]]).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by\n     * providing {@link @here/harp-utils#UriResolver} using {@link ThemeLoadOptions.uriResolver}\n     * option.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme} instance or theme URL\n     *                to the theme.\n     * @param options - Optional, a {@link ThemeLoadOptions} objects\n     *                  containing any custom settings for\n     *                  this load request.\n     */\n    static async load(theme, options) {\n        var _a;\n        options = options !== null && options !== void 0 ? options : {};\n        if (typeof theme === \"string\") {\n            const uriResolver = options.uriResolver;\n            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;\n            const response = await fetch(themeUrl, { signal: options.signal });\n            if (!response.ok) {\n                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);\n            }\n            theme = (await response.json());\n            theme.url = harp_utils_1.resolveReferenceUri(harp_utils_1.getAppBaseUrl(), themeUrl);\n            theme = this.resolveUrls(theme, options);\n        }\n        else if (theme.url === undefined) {\n            // assume that theme url is same as baseUrl\n            theme.url = harp_utils_1.getAppBaseUrl();\n            theme = this.resolveUrls(theme, options);\n        }\n        else {\n            theme = this.convertFlatTheme(theme);\n        }\n        if (theme === null || theme === undefined) {\n            throw new Error(\"ThemeLoader#load: loaded resource is not valid JSON\");\n        }\n        ThemeLoader.checkTechniqueSupport(theme);\n        const resolveDefinitions = harp_utils_1.getOptionValue(options.resolveDefinitions, false);\n        theme = await ThemeLoader.resolveBaseThemes(theme, options);\n        if (resolveDefinitions) {\n            const contextLoader = new harp_utils_1.ContextLogger((_a = options.logger) !== null && _a !== void 0 ? _a : console, `when processing Theme ${theme.url}:`);\n            ThemeLoader.resolveThemeReferences(theme, contextLoader);\n        }\n        return theme;\n    }\n    /**\n     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.\n     *\n     * @param theme -\n     */\n    static isThemeLoaded(theme) {\n        // TODO: Remove array check, when FlatTheme is fully supported\n        return theme.extends === undefined && !Array.isArray(theme.styles);\n    }\n    /**\n     * @deprecated Please use `ThemeLoader.load`\n     *\n     * Loads a {@link @here/harp-datasource-protocol#Theme} from a remote resource,\n     * provided as a URL that points to a JSON-encoded\n     * theme.\n     *\n     * @param themeUrl - The URL to the theme.\n     *\n     */\n    static async loadAsync(themeUrl) {\n        return await ThemeLoader.load(themeUrl);\n    }\n    /**\n     * Resolves all {@link @here/harp-datasource-protocol#Theme}'s relatives URLs\n     * to full URL using the {@link @here/harp-datasource-protocol#Theme}'s URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * This method mutates original `theme` instance.\n     *\n     * @param theme - The {@link @here/harp-datasource-protocol#Theme} to resolve.\n     */\n    static resolveUrls(theme, options) {\n        // Ensure that all resources referenced in theme by relative URIs are in fact relative to\n        // theme.\n        theme = ThemeLoader.convertFlatTheme(theme);\n        if (theme.url === undefined) {\n            return theme;\n        }\n        const childUrlResolver = harp_utils_1.composeUriResolvers(options === null || options === void 0 ? void 0 : options.uriResolver, new harp_utils_1.RelativeUriResolver(theme.url));\n        const resolveIncludes = options === undefined || !(options.resolveIncludeUris === false);\n        if (theme.extends && resolveIncludes) {\n            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(baseTheme => {\n                if (typeof baseTheme === \"string\") {\n                    return childUrlResolver.resolveUri(baseTheme);\n                }\n                else {\n                    if (baseTheme.url !== undefined) {\n                        return baseTheme;\n                    }\n                    else {\n                        baseTheme.url = theme.url;\n                        return this.resolveUrls(baseTheme, options);\n                    }\n                }\n            });\n        }\n        if (!ThemeLoader.convertFlatTheme(theme)) {\n            return theme;\n        }\n        const resolveResources = options === undefined || !(options.resolveResourceUris === false);\n        if (resolveResources) {\n            ThemeLoader.resolveResources(theme, childUrlResolver);\n        }\n        return theme;\n    }\n    static checkTechniqueSupport(theme) {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                for (const style of theme.styles[styleSetName]) {\n                    switch (style.technique) {\n                        // TODO: Re-enable this once \"dashed-line\" is deprecated.\n                        /* case \"dashed-line\":\n                            console.warn(\n                                `Using deprecated \"dashed-line\" technique.\n                                Use \"solid-line\" technique instead`\n                            ); */\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Expand all `ref` expressions in {@link @here/harp-datasource-protocol#Theme}\n     * basing on `definitions`.\n     *\n     * @remarks\n     * This method mutates original `theme` instance.\n     */\n    static resolveThemeReferences(theme, contextLogger) {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                contextLogger.pushAttr(\"styles\");\n                contextLogger.pushAttr(styleSetName);\n                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(theme.styles[styleSetName], theme.definitions, contextLogger);\n                contextLogger.pop();\n                contextLogger.pop();\n            }\n        }\n        return theme;\n    }\n    /**\n     * Expand all `ref` in [[StyleSet]] basing on `definitions`.\n     */\n    static resolveStyleSet(styleSet, definitions, contextLogger) {\n        const result = [];\n        for (let index = 0; index < styleSet.length; ++index) {\n            const currentStyle = styleSet[index];\n            contextLogger.pushIndex(index);\n            const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);\n            if (resolvedStyle !== undefined) {\n                result.push(resolvedStyle);\n            }\n            else {\n                contextLogger.warn(\"invalid style, ignored\");\n            }\n            contextLogger.pop();\n        }\n        return result;\n    }\n    /**\n     * Expand all `ref` in [[Style]] instance basing on `definitions`.\n     */\n    static resolveStyle(style, definitions, contextLogger) {\n        if (Array.isArray(style.when)) {\n            contextLogger.pushAttr(\"when\");\n            const resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);\n            contextLogger.pop();\n            if (resolvedWhen === undefined) {\n                return undefined;\n            }\n            style.when = resolvedWhen;\n        }\n        if (style.attr !== undefined) {\n            const attr = style.attr;\n            contextLogger.pushAttr(\"attr\");\n            for (const prop in attr) {\n                if (!attr.hasOwnProperty(prop)) {\n                    continue;\n                }\n                const value = attr[prop];\n                if (!Array.isArray(value)) {\n                    continue; // nothing to do\n                }\n                contextLogger.pushAttr(prop);\n                const resolvedValue = this.resolveExpressionReferences(value, definitions, contextLogger);\n                contextLogger.pop();\n                if (resolvedValue !== undefined) {\n                    attr[prop] = resolvedValue;\n                }\n                else {\n                    delete attr[prop];\n                }\n            }\n            contextLogger.pop();\n        }\n        return style;\n    }\n    /**\n     * Resolve `[ref, ...]` in expressions.\n     *\n     * Returns `undefined` some reference was invalid (missing or wrong type).\n     */\n    static resolveExpressionReferences(value, definitions, contextLogger) {\n        let failed = false;\n        function resolveInternal(node) {\n            if (Theme_1.isJsonExprReference(node)) {\n                const defName = node[1];\n                const def = definitions && definitions[defName];\n                if (def === undefined) {\n                    contextLogger.warn(`invalid reference '${defName}' - not found`);\n                    failed = true;\n                    return undefined;\n                }\n                if (harp_datasource_protocol_1.isJsonExpr(def)) {\n                    return def;\n                }\n                return def.value;\n            }\n            else if (Array.isArray(node)) {\n                const result = [...node];\n                for (let i = 1; i < result.length; ++i) {\n                    result[i] = resolveInternal(result[i]);\n                }\n                return result;\n            }\n            else {\n                return node;\n            }\n        }\n        const r = resolveInternal(value);\n        if (failed) {\n            return undefined;\n        }\n        return r;\n    }\n    /**\n     * Realize `extends` clause by merging `theme` with\n     * its base {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme} object\n     * @param options - Optional, a {@link ThemeLoadOptions} objects\n     *                  containing any custom settings for\n     *                  this load request.\n     */\n    static async resolveBaseThemes(theme, options) {\n        options = options !== null && options !== void 0 ? options : {};\n        if (theme.extends === undefined) {\n            return theme;\n        }\n        const maxInheritanceDepth = harp_utils_1.getOptionValue(options.maxInheritanceDepth, exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);\n        if (maxInheritanceDepth <= 0) {\n            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);\n        }\n        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;\n        delete theme.extends;\n        let baseThemesMerged = {};\n        for (const baseTheme of baseThemes) {\n            const actualBaseTheme = await ThemeLoader.load(baseTheme, Object.assign(Object.assign({}, options), { resolveDefinitions: false, maxInheritanceDepth: maxInheritanceDepth - 1 }));\n            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);\n        }\n        return ThemeLoader.mergeThemes(theme, baseThemesMerged);\n    }\n    static mergeThemes(theme, baseTheme) {\n        const definitions = Object.assign(Object.assign({}, baseTheme.definitions), theme.definitions);\n        let styles;\n        if (baseTheme.styles && theme.styles) {\n            const currentStyleSets = Object.keys(baseTheme.styles);\n            const incomingStyleSets = Object.keys(theme.styles);\n            styles = {};\n            currentStyleSets.forEach(styleSetName => {\n                const index = incomingStyleSets.indexOf(styleSetName);\n                if (index !== -1) {\n                    // merge the current and incoming styleset\n                    // and add the result to `styles`.\n                    const baseStyleSet = baseTheme.styles[styleSetName];\n                    const newStyleSet = [];\n                    const styleIdMap = new Map();\n                    baseStyleSet.forEach(style => {\n                        if (typeof style.id === \"string\") {\n                            styleIdMap.set(style.id, newStyleSet.length);\n                        }\n                        newStyleSet.push(style);\n                    });\n                    const incomingStyleSet = theme.styles[styleSetName];\n                    incomingStyleSet.forEach(style => {\n                        if (typeof style.extends === \"string\" && styleIdMap.has(style.extends)) {\n                            // extends the existing style referenced by `style.extends`.\n                            const baseStyleIndex = styleIdMap.get(style.extends);\n                            const baseStyle = newStyleSet[baseStyleIndex];\n                            newStyleSet[baseStyleIndex] = Object.assign(Object.assign({}, baseStyle), style);\n                            newStyleSet[baseStyleIndex].extends = undefined;\n                            return;\n                        }\n                        if (typeof style.id === \"string\" && styleIdMap.has(style.id)) {\n                            // overrides the existing style with `id` equals to `style.id`.\n                            const styleIndex = styleIdMap.get(style.id);\n                            newStyleSet[styleIndex] = style;\n                            return;\n                        }\n                        newStyleSet.push(style);\n                    });\n                    styles[styleSetName] = newStyleSet;\n                    // remove the styleset from the incoming list\n                    incomingStyleSets.splice(index, 1);\n                }\n                else {\n                    // copy the existing style set to `styles`.\n                    styles[styleSetName] = baseTheme.styles[styleSetName];\n                }\n            });\n            // add the remaining stylesets to styles.\n            incomingStyleSets.forEach(p => {\n                styles[p] = theme.styles[p];\n            });\n        }\n        else if (baseTheme.styles) {\n            styles = Object.assign({}, baseTheme.styles);\n        }\n        else if (theme.styles) {\n            styles = Object.assign({}, theme.styles);\n        }\n        return Object.assign(Object.assign(Object.assign({}, baseTheme), theme), { definitions, styles });\n    }\n    static convertFlatTheme(theme) {\n        if (Array.isArray(theme.styles)) {\n            // Convert the flat theme to a standard theme.\n            const styles = {};\n            theme.styles.forEach(style => {\n                if (harp_datasource_protocol_1.isJsonExpr(style)) {\n                    throw new Error(\"invalid usage of theme reference\");\n                }\n                const styleSetName = style.styleSet;\n                if (styleSetName === undefined) {\n                    throw new Error(\"missing reference to style set\");\n                }\n                if (!styles[styleSetName]) {\n                    styles[styleSetName] = [];\n                }\n                styles[styleSetName].push(style);\n            });\n            theme.styles = styles;\n        }\n        return theme;\n    }\n    static resolveResources(theme, childUrlResolver) {\n        if (theme.sky && theme.sky.type === \"cubemap\") {\n            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {\n                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];\n                if (faceUrl !== undefined) {\n                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);\n                }\n            }\n        }\n        if (theme.images) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                image.url = childUrlResolver.resolveUri(image.url);\n                if (image.atlas !== undefined) {\n                    image.atlas = childUrlResolver.resolveUri(image.atlas);\n                }\n            }\n        }\n        if (theme.fontCatalogs) {\n            for (const font of theme.fontCatalogs) {\n                font.url = childUrlResolver.resolveUri(font.url);\n            }\n        }\n        if (theme.poiTables) {\n            for (const poiTable of theme.poiTables) {\n                poiTable.url = childUrlResolver.resolveUri(poiTable.url);\n            }\n        }\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                const styleSet = theme.styles[styleSetName];\n                for (const style of styleSet) {\n                    if (!style.attr) {\n                        continue;\n                    }\n                    [\"map\", \"normalMap\", \"displacementMap\", \"roughnessMap\"].forEach(texturePropertyName => {\n                        const textureProperty = style.attr[texturePropertyName];\n                        if (textureProperty && typeof textureProperty === \"string\") {\n                            style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);\n                        }\n                    });\n                }\n            }\n        }\n    }\n}\nexports.ThemeLoader = ThemeLoader;\n//# sourceMappingURL=ThemeLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ThemeLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Tile.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Tile.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tile = exports.getFeatureDataSize = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst LodMesh_1 = __webpack_require__(/*! ./geometry/LodMesh */ \"./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js\");\nconst TileGeometryLoader_1 = __webpack_require__(/*! ./geometry/TileGeometryLoader */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js\");\nconst ITileLoader_1 = __webpack_require__(/*! ./ITileLoader */ \"./node_modules/@here/harp-mapview/lib/ITileLoader.js\");\nconst Statistics_1 = __webpack_require__(/*! ./Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst TextElement_1 = __webpack_require__(/*! ./text/TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementGroup_1 = __webpack_require__(/*! ./text/TextElementGroup */ \"./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js\");\nconst TextElementGroupPriorityList_1 = __webpack_require__(/*! ./text/TextElementGroupPriorityList */ \"./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js\");\nconst TileTextStyleCache_1 = __webpack_require__(/*! ./text/TileTextStyleCache */ \"./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"Tile\");\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n/**\n * Compute the memory footprint of `TileFeatureData`.\n *\n * @internal\n */\nfunction getFeatureDataSize(featureData) {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n    if (featureData.starts !== undefined) {\n        numBytes += featureData.starts.length * 8;\n    }\n    if (featureData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n    return numBytes;\n}\nexports.getFeatureDataSize = getFeatureDataSize;\n/**\n * The class that holds the tiled data for a {@link DataSource}.\n */\nclass Tile {\n    /**\n     * Creates a new {@link Tile}.\n     *\n     * @param dataSource - The {@link DataSource} that created this {@link Tile}.\n     * @param tileKey - The unique identifier for this {@link Tile}.\n     *                  Currently only up to level 24 is\n     *                  supported, because of the use of the upper bits for the offset.\n     * @param offset - The optional offset, this is an integer which represents what multiple of 360\n     *                 degrees to shift, only useful for flat projections, hence optional.\n     * @param localTangentSpace - Whether the tile geometry is in local tangent space or not.\n     */\n    constructor(dataSource, tileKey, offset = 0, localTangentSpace) {\n        this.dataSource = dataSource;\n        this.tileKey = tileKey;\n        /**\n         * A list of the THREE.js objects stored in this `Tile`.\n         */\n        this.objects = [];\n        /**\n         * The optional list of HERE TileKeys of tiles with geometries that cross the boundaries of this\n         * `Tile`.\n         */\n        this.dependencies = [];\n        /**\n         * Keeping some stats for the individual {@link Tile}s to analyze caching behavior.\n         *\n         * The frame the {@link Tile} was last requested. This is\n         * required to know when the given {@link Tile}\n         * can be removed from the cache.\n         */\n        this.frameNumLastRequested = -1;\n        /**\n         * The frame the `Tile` was first visible.\n         */\n        this.frameNumVisible = -1;\n        /**\n         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine\n         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is\n         * visible.\n         */\n        this.frameNumLastVisible = -1;\n        /**\n         * After removing from cache, this is the number of frames the `Tile` was visible.\n         */\n        this.numFramesVisible = 0;\n        /**\n         * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the\n         * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of\n         * computing visibility.\n         */\n        this.visibilityCounter = -1;\n        /**\n         * @hidden\n         *\n         * Used to tell if the Tile is used temporarily as a fallback tile.\n         *\n         * levelOffset is in in the range [-quadTreeSearchDistanceUp,\n         * quadTreeSearchDistanceDown], where these values come from the\n         * {@link VisibleTileSetOptions}\n         */\n        this.levelOffset = 0;\n        /**\n         * If the tile should not be rendered, this is used typically when the tile in question\n         * is completely covered by another tile and therefore can be skipped without any visual\n         * impact. Setting this value directly affects the [[willRender]] method, unless\n         * overriden by deriving classes.\n         */\n        this.skipRendering = false;\n        /**\n         * If the tile should not yet be rendered, this is used typically when the tile in question\n         * does not fit into the gpu upload limit of the current frame.\n         * Setting this value directly affects the [[willRender]] method, unless\n         * overriden by deriving classes.\n         */\n        this.delayRendering = false;\n        /**\n         * The bounding box of this `Tile` in world coordinates.\n         */\n        this.m_boundingBox = new harp_geoutils_1.OrientedBox3();\n        this.m_disposed = false;\n        this.m_forceHasGeometry = undefined;\n        // Used for {@link TextElement}s that are stored in the data, and that are placed explicitly,\n        // fading in and out.\n        this.m_textElementGroups = new TextElementGroupPriorityList_1.TextElementGroupPriorityList();\n        // Blocks other labels from showing.\n        this.m_pathBlockingElements = [];\n        // Center of the tile's un-elevated bounding box world coordinates.\n        this.m_worldCenter = new THREE.Vector3();\n        this.m_visibleArea = 0;\n        // Tile elevation range in meters\n        this.m_elevationRange = { minElevation: 0, maxElevation: 0 };\n        // List of owned textures for disposal\n        this.m_ownedTextures = new WeakSet();\n        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);\n        this.updateBoundingBox();\n        this.m_worldCenter.copy(this.boundingBox.position);\n        this.m_localTangentSpace = localTangentSpace !== null && localTangentSpace !== void 0 ? localTangentSpace : false;\n        this.m_textStyleCache = new TileTextStyleCache_1.TileTextStyleCache(this);\n        this.m_offset = offset;\n        this.m_uniqueKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);\n        if (dataSource.useGeometryLoader) {\n            this.m_tileGeometryLoader = new TileGeometryLoader_1.TileGeometryLoader(this, this.mapView.taskQueue);\n            this.attachGeometryLoadedCallback();\n        }\n    }\n    /**\n     * The visibility status of the {@link Tile}. It is actually\n     * visible or planned to become visible.\n     */\n    get isVisible() {\n        // Tiles are not evaluated as invisible until the second frame they aren't requested.\n        // This happens in order to prevent that, during VisibleTileSet visibility evaluation,\n        // visible tiles that haven't yet been evaluated for the current frame are preemptively\n        // removed from [[DataSourceCache]].\n        // There is cases when a tile was already removed from the MapView, i.e. the PolaCaps\n        // Datasource might get remove on a change of projection, in this case\n        // this.dataSource.mapView will throw an error\n        try {\n            return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;\n        }\n        catch (error) {\n            logger.debug(error);\n            return false;\n        }\n    }\n    /**\n     * Sets the tile visibility status.\n     * @param visible - `True` to mark the tile as visible, `False` otherwise.\n     */\n    set isVisible(visible) {\n        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;\n        if (!visible && this.m_tileGeometryLoader && !this.m_tileGeometryLoader.isSettled) {\n            this.m_tileGeometryLoader.cancel();\n        }\n    }\n    /**\n     * The {@link @here/harp-geoutils#Projection} currently used by the {@link MapView}.\n     */\n    get projection() {\n        return this.dataSource.projection;\n    }\n    /**\n     * The {@link MapView} this `Tile` belongs to.\n     */\n    get mapView() {\n        return this.dataSource.mapView;\n    }\n    /**\n     * Whether the data of this tile is in local tangent space or not.\n     *\n     * @remarks\n     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then\n     * {@link MapView} will rotate the objects before rendering using the rotation matrix of the\n     * oriented [[boundingBox]].\n     */\n    get localTangentSpace() {\n        return this.m_localTangentSpace;\n    }\n    /*\n     * The size of this Tile in system memory.\n     */\n    get memoryUsage() {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo.heapSize;\n    }\n    /**\n     * The center of this `Tile` in world coordinates.\n     */\n    get center() {\n        return this.m_worldCenter;\n    }\n    /**\n     * Gets the key to uniquely represent this tile (based on\n     * the {@link tileKey} and {@link offset}).\n     *\n     * @remarks\n     * This key is only unique within the given {@link DataSource},\n     * to get a key which is unique across\n     * {@link DataSource}s see [[DataSourceCache.getKeyForTile]].\n     */\n    get uniqueKey() {\n        return this.m_uniqueKey;\n    }\n    /**\n     * The optional offset, this is an integer which represents what multiple of 360 degrees to\n     * shift, only useful for flat projections, hence optional.\n     */\n    get offset() {\n        return this.m_offset;\n    }\n    /**\n     * The optional offset, this is an integer which represents what multiple of 360 degrees to\n     * shift, only useful for flat projections, hence optional.\n     * @param offset - Which multiple of 360 degrees to apply to the {@link Tile}.\n     */\n    set offset(offset) {\n        if (this.m_offset !== offset) {\n            this.m_uniqueKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);\n        }\n        this.m_offset = offset;\n    }\n    /**\n     * Compute {@link TileResourceInfo} of this `Tile`.\n     *\n     * @remarks\n     * May be using a cached value. The method\n     * `invalidateResourceInfo` can be called beforehand to force a recalculation.\n     *\n     * @returns `TileResourceInfo` for this `Tile`.\n     */\n    getResourceInfo() {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo;\n    }\n    /**\n     * Force invalidation of the cached {@link TileResourceInfo}.\n     *\n     * @remarks\n     * Useful after the `Tile` has been\n     * modified.\n     */\n    invalidateResourceInfo() {\n        this.m_resourceInfo = undefined;\n    }\n    /**\n     * Add ownership of a texture to this tile.\n     *\n     * @remarks\n     * The texture will be disposed if the `Tile` is disposed.\n     * @param texture - Texture to be owned by the `Tile`\n     */\n    addOwnedTexture(texture) {\n        this.m_ownedTextures.add(texture);\n    }\n    /**\n     * @internal\n     * @deprecated User text elements are deprecated.\n     *\n     * Gets the list of developer-defined {@link TextElement} in this `Tile`.\n     *\n     * @remarks\n     * This list is always rendered first.\n     */\n    get userTextElements() {\n        let group = this.m_textElementGroups.groups.get(TextElement_1.TextElement.HIGHEST_PRIORITY);\n        if (group === undefined) {\n            group = new TextElementGroup_1.TextElementGroup(TextElement_1.TextElement.HIGHEST_PRIORITY);\n            this.m_textElementGroups.groups.set(group.priority, group);\n        }\n        return group;\n    }\n    /**\n     * Adds a developer-defined {@link TextElement} to this `Tile`.\n     *\n     * @remarks\n     * The {@link TextElement} is always\n     * visible, if it's in the map's currently visible area.\n     *\n     * @deprecated use [[addTextElement]].\n     *\n     * @param textElement - The Text element to add.\n     */\n    addUserTextElement(textElement) {\n        textElement.priority = TextElement_1.TextElement.HIGHEST_PRIORITY;\n        this.addTextElement(textElement);\n    }\n    /**\n     * Removes a developer-defined {@link TextElement} from this `Tile`.\n     *\n     * @deprecated use `removeTextElement`.\n     *\n     * @param textElement - A developer-defined TextElement to remove.\n     * @returns `true` if the element has been removed successfully; `false` otherwise.\n     */\n    removeUserTextElement(textElement) {\n        textElement.priority = TextElement_1.TextElement.HIGHEST_PRIORITY;\n        return this.removeTextElement(textElement);\n    }\n    /**\n     * Adds a {@link TextElement} to this `Tile`, which is added to the visible set of\n     * {@link TextElement}s based on the capacity and visibility.\n     *\n     * @remarks\n     * The {@link TextElement}'s priority controls if or when it becomes visible.\n     *\n     * To ensure that a TextElement is visible, use a high value for its priority, such as\n     * `TextElement.HIGHEST_PRIORITY`. Since the number of visible TextElements is limited by the\n     * screen space, not all TextElements are visible at all times.\n     *\n     * @param textElement - The TextElement to add.\n     */\n    addTextElement(textElement) {\n        this.textElementGroups.add(textElement);\n        if (this.m_textElementsChanged === false) {\n            // HARP-8733: Clone all groups so that they are handled as new element groups\n            // by TextElementsRenderer and it doesn't try to reuse the same state stored\n            // for the old groups.\n            this.m_textElementGroups = this.textElementGroups.clone();\n        }\n        this.textElementsChanged = true;\n    }\n    /**\n     * Adds a `PathBlockingElement` to this `Tile`.\n     *\n     * @remarks\n     * This path has the highest priority and blocks\n     * all other labels. There maybe in future a use case to give it a priority, but as that isn't\n     * yet required, it is left to be implemented later if required.\n     * @param blockingElement - Element which should block all other labels.\n     */\n    addBlockingElement(blockingElement) {\n        this.m_pathBlockingElements.push(blockingElement);\n    }\n    /**\n     * Removes a {@link TextElement} from this `Tile`.\n     *\n     * @remarks\n     * For the element to be removed successfully, the\n     * priority of the {@link TextElement} has to be equal to its priority when it was added.\n     *\n     * @param textElement - The TextElement to remove.\n     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.\n     */\n    removeTextElement(textElement) {\n        const groups = this.textElementGroups;\n        if (!groups.remove(textElement)) {\n            return false;\n        }\n        if (this.m_textElementsChanged === false) {\n            // HARP-8733: Clone all groups so that they are handled as new element groups\n            // by TextElementsRenderer and it doesn't try to reuse the same state stored\n            // for the old groups.\n            this.m_textElementGroups = groups.clone();\n        }\n        this.textElementsChanged = true;\n        return true;\n    }\n    /**\n     * @internal\n     *\n     * Gets the current `GroupedPriorityList` which\n     * contains a list of all {@link TextElement}s to be\n     * selected and placed for rendering.\n     */\n    get textElementGroups() {\n        return this.m_textElementGroups;\n    }\n    /**\n     * Gets the current modification state for the list\n     * of {@link TextElement}s in the `Tile`.\n     *\n     * @remarks\n     * If the value is `true` the `TextElement` is placed for\n     * rendering during the next frame.\n     */\n    get textElementsChanged() {\n        var _a;\n        return (_a = this.m_textElementsChanged) !== null && _a !== void 0 ? _a : false;\n    }\n    set textElementsChanged(changed) {\n        this.m_textElementsChanged = changed;\n    }\n    /**\n     * Returns true if the `Tile` has any text elements to render.\n     */\n    hasTextElements() {\n        return this.m_textElementGroups.count() > 0;\n    }\n    /**\n     * Get the current blocking elements.\n     */\n    get blockingElements() {\n        return this.m_pathBlockingElements;\n    }\n    /**\n     * Called before {@link MapView} starts rendering this `Tile`.\n     *\n     * @remarks\n     * @param zoomLevel - The current zoom level.\n     * @returns Returns `true` if this `Tile` should be rendered. Influenced directly by the\n     *      `skipRendering` property unless specifically overriden in deriving classes.\n     */\n    willRender(_zoomLevel) {\n        return !this.skipRendering && !this.delayRendering;\n    }\n    /**\n     * Called after {@link MapView} has rendered this `Tile`.\n     */\n    didRender() {\n        // to be overridden by subclasses\n    }\n    /**\n     * Estimated visible area of tile used for sorting the priorities during loading.\n     */\n    get visibleArea() {\n        return this.m_visibleArea;\n    }\n    set visibleArea(area) {\n        this.m_visibleArea = area;\n        if (this.tileLoader !== undefined) {\n            this.tileLoader.priority = area;\n        }\n    }\n    /**\n     * @internal\n     * Gets the tile's ground elevation range in meters.\n     */\n    get elevationRange() {\n        return this.m_elevationRange;\n    }\n    /**\n     * @internal\n     * Sets the tile's ground elevation range in meters.\n     *\n     * @param elevationRange - The elevation range.\n     */\n    set elevationRange(elevationRange) {\n        var _a;\n        if (elevationRange.minElevation === this.m_elevationRange.minElevation &&\n            elevationRange.maxElevation === this.m_elevationRange.maxElevation &&\n            elevationRange.calculationStatus === this.m_elevationRange.calculationStatus) {\n            return;\n        }\n        this.m_elevationRange.minElevation = elevationRange.minElevation;\n        this.m_elevationRange.maxElevation = elevationRange.maxElevation;\n        this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;\n        this.elevateGeoBox();\n        // Only update bounding box if tile has already been decoded and a maximum/minimum geometry\n        // height is provided by the data source.\n        if (this.m_maxGeometryHeight !== undefined || this.m_minGeometryHeight !== undefined) {\n            harp_utils_1.assert(((_a = this.decodedTile) === null || _a === void 0 ? void 0 : _a.boundingBox) === undefined);\n            this.updateBoundingBox();\n        }\n    }\n    /**\n     * Gets the decoded tile; it is removed after geometry handling.\n     */\n    get decodedTile() {\n        return this.m_decodedTile;\n    }\n    /**\n     * Applies the decoded tile to the tile.\n     *\n     * @remarks\n     * If the geometry is empty, then the tile's forceHasGeometry flag is set.\n     * Map is updated.\n     * @param decodedTile - The decoded tile to set.\n     */\n    set decodedTile(decodedTile) {\n        var _a, _b;\n        this.m_decodedTile = decodedTile;\n        this.invalidateResourceInfo();\n        if (decodedTile === undefined) {\n            return;\n        }\n        if (decodedTile.geometries.length === 0) {\n            this.forceHasGeometry(true);\n        }\n        // If the decoder provides a more accurate bounding box than the one we computed from\n        // the flat geo box we take it instead. Otherwise, if an elevation range was set, elevate\n        // bounding box to match the elevated geometry.\n        this.m_maxGeometryHeight = decodedTile.boundingBox\n            ? undefined\n            : (_a = decodedTile.maxGeometryHeight) !== null && _a !== void 0 ? _a : 0;\n        this.m_minGeometryHeight = decodedTile.boundingBox\n            ? undefined\n            : (_b = decodedTile.minGeometryHeight) !== null && _b !== void 0 ? _b : 0;\n        this.elevateGeoBox();\n        this.updateBoundingBox(decodedTile.boundingBox);\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        if (stats.enabled && decodedTile.decodeTime !== undefined) {\n            stats.currentFrame.addValue(\"decode.decodingTime\", decodedTile.decodeTime);\n            stats.currentFrame.addValue(\"decode.decodedTiles\", 1);\n        }\n        if (decodedTile.copyrightHolderIds !== undefined) {\n            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));\n        }\n        this.dataSource.requestUpdate();\n    }\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free the geometry of a `Tile` object.\n     *\n     * @param object - The object that references the geometry.\n     * @returns `true` if the geometry can be disposed.\n     */\n    shouldDisposeObjectGeometry(object) {\n        return true;\n    }\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a `Tile` object's material.\n     *\n     * @param object - The object referencing the geometry.\n     * @returns `true` if the material can be disposed.\n     */\n    shouldDisposeObjectMaterial(object) {\n        return true;\n    }\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a Texture that is part of a `Tile` object's material.\n     *\n     * @param texture - The texture about to be disposed.\n     * @returns `true` if the texture can be disposed.\n     */\n    shouldDisposeTexture(texture) {\n        return this.m_ownedTextures.has(texture);\n    }\n    /**\n     * Returns `true` if this `Tile` has been disposed.\n     */\n    get disposed() {\n        return this.m_disposed;\n    }\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    get allGeometryLoaded() {\n        var _a, _b;\n        return (_b = (_a = this.m_tileGeometryLoader) === null || _a === void 0 ? void 0 : _a.isFinished) !== null && _b !== void 0 ? _b : this.hasGeometry;\n    }\n    /**\n     * MapView checks if this `Tile` is ready to be rendered while culling.\n     *\n     * By default, MapView checks if the [[objects]] list is not empty. However, you can override\n     * this check by manually setting this property.\n     */\n    get hasGeometry() {\n        if (this.m_forceHasGeometry === undefined) {\n            return this.objects.length !== 0;\n        }\n        else {\n            return this.m_forceHasGeometry;\n        }\n    }\n    /**\n     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.\n     *\n     * @param value - A new value for the [[hasGeometry]] flag.\n     */\n    forceHasGeometry(value) {\n        this.m_forceHasGeometry = value;\n    }\n    /**\n     * Reset the visibility counter. This will force the visibility check to be rerun on all objects\n     * in this `Tile`.\n     */\n    resetVisibilityCounter() {\n        this.visibilityCounter = -1;\n    }\n    /**\n     * Gets the {@link ITileLoader} that manages this tile.\n     */\n    get tileLoader() {\n        return this.m_tileLoader;\n    }\n    /**\n     * Sets the {@link ITileLoader} to manage this tile.\n     *\n     * @param tileLoader - A {@link ITileLoader} instance to manage\n     *                     the loading process for this tile.\n     */\n    set tileLoader(tileLoader) {\n        this.m_tileLoader = tileLoader;\n    }\n    /**\n     * Loads this `Tile` geometry.\n     *\n     * @returns Promise which can be used to wait for the loading to be finished.\n     */\n    async load() {\n        const tileLoader = this.tileLoader;\n        if (tileLoader === undefined) {\n            return await Promise.resolve();\n        }\n        if (this.m_tileGeometryLoader) {\n            const wasSettled = this.m_tileGeometryLoader.isSettled;\n            this.m_tileGeometryLoader.reset();\n            if (wasSettled) {\n                this.attachGeometryLoadedCallback();\n            }\n        }\n        return await tileLoader\n            .loadAndDecode()\n            .then(tileLoaderState => {\n            var _a;\n            harp_utils_1.assert(tileLoaderState === ITileLoader_1.TileLoaderState.Ready);\n            const decodedTile = tileLoader.decodedTile;\n            this.decodedTile = decodedTile;\n            (_a = decodedTile === null || decodedTile === void 0 ? void 0 : decodedTile.dependencies) === null || _a === void 0 ? void 0 : _a.forEach(mortonCode => {\n                this.dependencies.push(harp_geoutils_1.TileKey.fromMortonCode(mortonCode));\n            });\n        })\n            .catch(tileLoaderState => {\n            if (tileLoaderState === ITileLoader_1.TileLoaderState.Failed) {\n                this.dispose();\n            }\n            else if (tileLoaderState !== ITileLoader_1.TileLoaderState.Canceled) {\n                logger.error(\"Unknown error\" + tileLoaderState);\n            }\n        });\n    }\n    /**\n     * Text style cache for this tile.\n     * @hidden\n     */\n    get textStyleCache() {\n        return this.m_textStyleCache;\n    }\n    /**\n     * Frees the rendering resources allocated by this `Tile`.\n     *\n     * @remarks\n     * The default implementation of this method frees the geometries and the materials for all the\n     * reachable objects.\n     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this\n     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).\n     */\n    clear() {\n        const disposeMaterial = (material) => {\n            Object.getOwnPropertyNames(material).forEach((property) => {\n                const materialProperty = material[property];\n                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {\n                    const texture = materialProperty;\n                    if (this.shouldDisposeTexture(texture)) {\n                        texture.dispose();\n                    }\n                }\n            });\n            material.dispose();\n        };\n        const disposeObject = (object) => {\n            if (this.shouldDisposeObjectGeometry(object)) {\n                if (object.geometry !== undefined) {\n                    object.geometry.dispose();\n                }\n                if (object.geometries !== undefined) {\n                    for (const geometry of object.geometries) {\n                        geometry.dispose();\n                    }\n                }\n            }\n            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {\n                if (object.material instanceof Array) {\n                    object.material.forEach((material) => {\n                        if (material !== undefined) {\n                            disposeMaterial(material);\n                        }\n                    });\n                }\n                else {\n                    disposeMaterial(object.material);\n                }\n            }\n        };\n        this.objects.forEach((rootObject) => {\n            rootObject.traverse((object) => {\n                disposeObject(object);\n            });\n            disposeObject(rootObject);\n        });\n        this.objects.length = 0;\n        if (this.preparedTextPaths) {\n            this.preparedTextPaths = [];\n        }\n        this.m_textStyleCache.clear();\n        this.clearTextElements();\n        this.invalidateResourceInfo();\n    }\n    /**\n     * Removes all {@link TextElement} from the tile.\n     */\n    clearTextElements() {\n        if (!this.hasTextElements()) {\n            return;\n        }\n        this.textElementsChanged = true;\n        this.m_pathBlockingElements.splice(0);\n        this.textElementGroups.forEach((element) => {\n            element.dispose();\n        });\n        this.textElementGroups.clear();\n    }\n    /**\n     * Adds a callback that will be called whenever the tile is disposed.\n     *\n     * @remarks\n     * Multiple callbacks may be added.\n     * @internal\n     * @param callback - The callback to be called when the tile is disposed.\n     */\n    addDisposeCallback(callback) {\n        this.m_disposeCallback = harp_utils_1.chainCallbacks(this.m_disposeCallback, callback);\n    }\n    /**\n     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.\n     */\n    dispose() {\n        var _a;\n        if (this.m_disposed) {\n            return;\n        }\n        if (this.m_tileLoader) {\n            this.m_tileLoader.cancel();\n            this.m_tileLoader = undefined;\n        }\n        this.clear();\n        // Ensure that tile is removable from tile cache.\n        this.frameNumLastRequested = 0;\n        this.m_disposed = true;\n        (_a = this.m_tileGeometryLoader) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (this.m_disposeCallback) {\n            this.m_disposeCallback(this);\n        }\n    }\n    /**\n     * Computes the offset in the x world coordinates corresponding to this tile, based on\n     * its {@link offset}.\n     *\n     * @returns The x offset.\n     */\n    computeWorldOffsetX() {\n        return this.projection.worldExtent(0, 0).max.x * this.offset;\n    }\n    /**\n     * Update tile for current map view zoom level\n     * @param zoomLevel - Zoom level of the map view\n     * @internal\n     */\n    update(zoomLevel) {\n        for (const object of this.objects) {\n            if (object instanceof LodMesh_1.LodMesh) {\n                object.setLevelOfDetail(zoomLevel - this.tileKey.level);\n            }\n        }\n    }\n    /**\n     * Gets the tile's bounding box.\n     */\n    get boundingBox() {\n        return this.m_boundingBox;\n    }\n    /**\n     * Start with or continue with loading geometry for tiles requiring this step. Called\n     * repeatedly until loading is finished.\n     * @param priority - Priority assigned to asynchronous tasks doing the geometry update.\n     * @param enabledKinds - {@link GeometryKind}s that will be created.\n     * @param disabledKinds - {@link GeometryKind}s that will not be created.\n     * @return `true` if tile uses a geometry loader, `false` otherwise.\n     * @internal\n     */\n    updateGeometry(priority, enabledKinds, disabledKinds) {\n        if (!this.m_tileGeometryLoader) {\n            return false;\n        }\n        if (this.m_tileGeometryLoader.isSettled) {\n            return true;\n        }\n        if (this.dataSource.isDetached()) {\n            this.m_tileGeometryLoader.cancel();\n            return true;\n        }\n        if (this.tileLoader) {\n            if (!this.tileLoader.isFinished) {\n                return true;\n            }\n            else if (!this.decodedTile) {\n                // Finish loading if tile has no data.\n                this.m_tileGeometryLoader.finish();\n                return true;\n            }\n        }\n        if (priority !== undefined) {\n            this.m_tileGeometryLoader.priority = priority;\n        }\n        this.m_tileGeometryLoader.update(enabledKinds, disabledKinds);\n        return true;\n    }\n    /**\n     * Gets a set of the {@link GeometryKind}s that were loaded (if any).\n     * @internal\n     */\n    get loadedGeometryKinds() {\n        var _a;\n        return (_a = this.m_tileGeometryLoader) === null || _a === void 0 ? void 0 : _a.availableGeometryKinds;\n    }\n    /**\n     * Called when {@link TileGeometryLoader} is finished.\n     *\n     * @remarks\n     * It may be used to add content to the `Tile`.\n     * The {@link @here/harp-datasource-protocol#DecodedTile} is still available.\n     */\n    loadingFinished() {\n        // To be used in subclasses.\n    }\n    attachGeometryLoadedCallback() {\n        harp_utils_1.assert(this.m_tileGeometryLoader !== undefined);\n        this.m_tileGeometryLoader.waitFinished()\n            .then(() => {\n            this.loadingFinished();\n            this.removeDecodedTile();\n        })\n            .catch(() => {\n            if (this.disposed) {\n                return;\n            }\n            // Loader was canceled, dispose tile.\n            if (!this.dataSource.isDetached()) {\n                this.mapView.visibleTileSet.disposeTile(this);\n            }\n        });\n    }\n    /**\n     * Remove the decodedTile when no longer needed.\n     */\n    removeDecodedTile() {\n        this.m_decodedTile = undefined;\n        this.invalidateResourceInfo();\n    }\n    /**\n     * Updates the tile's world bounding box.\n     * @param newBoundingBox - The new bounding box to set. If undefined, the bounding box will be\n     *                         computed by projecting the tile's geoBox.\n     */\n    updateBoundingBox(newBoundingBox) {\n        if (newBoundingBox) {\n            this.m_boundingBox.copy(newBoundingBox);\n            this.m_worldCenter.copy(this.boundingBox.position);\n        }\n        else {\n            this.projection.projectBox(this.geoBox, this.boundingBox);\n        }\n    }\n    /**\n     * Elevates the tile's geo box using the elevation range and maximum geometry height.\n     */\n    elevateGeoBox() {\n        var _a, _b;\n        this.geoBox.southWest.altitude =\n            this.m_elevationRange.minElevation + ((_a = this.m_minGeometryHeight) !== null && _a !== void 0 ? _a : 0);\n        this.geoBox.northEast.altitude =\n            this.m_elevationRange.maxElevation + ((_b = this.m_maxGeometryHeight) !== null && _b !== void 0 ? _b : 0);\n    }\n    computeResourceInfo() {\n        let heapSize = 0;\n        let num3dObjects = 0;\n        let numTextElements = 0;\n        const aggregatedObjSize = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.\n        // They should be counted only once even if they are shared.\n        const visitedObjects = new Map();\n        for (const object of this.objects) {\n            if (object.visible) {\n                num3dObjects++;\n            }\n            Utils_1.MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);\n        }\n        for (const group of this.textElementGroups.groups) {\n            numTextElements += group[1].elements.length;\n        }\n        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes\n        // was the minimum retained size of a TextElement that was not being rendered. If a\n        // TextElement is actually rendered, the size may be _much_ bigger.\n        heapSize += numTextElements * 312;\n        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {\n            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;\n        }\n        this.m_resourceInfo = {\n            heapSize: aggregatedObjSize.heapSize + heapSize,\n            gpuSize: aggregatedObjSize.gpuSize,\n            num3dObjects,\n            numTextElements,\n            numUserTextElements: 0\n        };\n    }\n}\nexports.Tile = Tile;\n//# sourceMappingURL=Tile.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/Tile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/TileObjectsRenderer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/TileObjectsRenderer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileObjectRenderer = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ \"./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js\");\nconst SolidLineMesh_1 = __webpack_require__(/*! ./geometry/SolidLineMesh */ \"./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js\");\nconst MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ \"./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js\");\nconst DEFAULT_STENCIL_VALUE = 1;\nclass TileObjectRenderer {\n    constructor(m_env, m_renderer) {\n        this.m_env = m_env;\n        this.m_renderer = m_renderer;\n        this.m_renderOrderStencilValues = new Map();\n        // Valid values start at 1, because the screen is cleared to zero\n        this.m_stencilValue = DEFAULT_STENCIL_VALUE;\n    }\n    render(tile, storageLevel, zoomLevel, cameraPosition, rootNode) {\n        const worldOffsetX = tile.computeWorldOffsetX();\n        if (tile.willRender(storageLevel)) {\n            for (const object of tile.objects) {\n                const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);\n                if (!this.processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter)) {\n                    continue;\n                }\n                this.updateStencilRef(object);\n                object.position.copy(tile.center);\n                if (object.displacement !== undefined) {\n                    object.position.add(object.displacement);\n                }\n                object.position.x += worldOffsetX;\n                object.position.sub(cameraPosition);\n                if (tile.localTangentSpace) {\n                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());\n                }\n                object.frustumCulled = false;\n                rootNode.add(object);\n            }\n            tile.didRender();\n        }\n    }\n    prepareRender() {\n        this.m_stencilValue = DEFAULT_STENCIL_VALUE;\n        this.m_renderOrderStencilValues.clear();\n    }\n    /**\n     * Prepares the sorting of tile objects.\n     */\n    setupRenderer() {\n        /**\n         * Custom sorting function to avoid non-deterministic IBCT testcases. It's basically a copy\n         * of the three.js internal sorting, see:\n         * https://github.com/mrdoob/three.js/blob/r118/src/renderers/webgl/WebGLRenderLists.js#L5\n         * but additionally checking tile-id before checking object.id, material.id and program.id\n         * b/c these ids are generated by incrementing a counter. This means if for two test\n         * executions the tiles are processed in a different order the ids hence draw call order\n         * will also be different.\n         */\n        const stableSort = (a, b) => {\n            if (a.groupOrder !== b.groupOrder) {\n                return a.groupOrder - b.groupOrder;\n            }\n            else if (a.renderOrder !== b.renderOrder) {\n                return a.renderOrder - b.renderOrder;\n            }\n            else if (a.object.userData.tileKey &&\n                b.object.userData.tileKey &&\n                a.object.userData.tileKey.mortonCode() !== b.object.userData.tileKey.mortonCode()) {\n                return (a.object.userData.tileKey.mortonCode() - b.object.userData.tileKey.mortonCode());\n            }\n            else if (a.program !== b.program) {\n                return a.program.id - b.program.id;\n            }\n            else if (a.material.id !== b.material.id) {\n                return a.material.id - b.material.id;\n            }\n            else if (a.z !== b.z) {\n                return a.z - b.z;\n            }\n            else {\n                return a.id - b.id;\n            }\n        };\n        // Custom sorting function which first sorts by the data source order, then by the level,\n        // then by the function `stableSort` above.\n        const painterSortStable = (a, b) => {\n            var _a, _b, _c, _d;\n            const mapObjectAdapterA = MapObjectAdapter_1.MapObjectAdapter.get(a.object);\n            const mapObjectAdapterB = MapObjectAdapter_1.MapObjectAdapter.get(b.object);\n            const dataSourceOrder = (_a = mapObjectAdapterA === null || mapObjectAdapterA === void 0 ? void 0 : mapObjectAdapterA.dataSource) === null || _a === void 0 ? void 0 : _a.dataSourceOrder;\n            const otherDataSourceOrder = (_b = mapObjectAdapterB === null || mapObjectAdapterB === void 0 ? void 0 : mapObjectAdapterB.dataSource) === null || _b === void 0 ? void 0 : _b.dataSourceOrder;\n            if (\n            // We need to check against undefined because if either is 0, it will evaluate false\n            dataSourceOrder !== undefined &&\n                otherDataSourceOrder !== undefined &&\n                dataSourceOrder !== otherDataSourceOrder) {\n                return dataSourceOrder - otherDataSourceOrder;\n            }\n            // Background data source must be sorted by rendorOrder and not level, otherwise\n            // fallback tiles are useless, because they will be covered by this datasource\n            if (a.renderOrder === BackgroundDataSource_1.BackgroundDataSource.GROUND_RENDER_ORDER ||\n                b.renderOrder === BackgroundDataSource_1.BackgroundDataSource.GROUND_RENDER_ORDER) {\n                return stableSort(a, b);\n            }\n            if ((mapObjectAdapterA === null || mapObjectAdapterA === void 0 ? void 0 : mapObjectAdapterA.level) !== undefined && (mapObjectAdapterB === null || mapObjectAdapterB === void 0 ? void 0 : mapObjectAdapterB.level) !== undefined) {\n                // Extruded buildings may interfere with landmarks, so we need to sort by\n                // renderOrder, see LandmarkDataSource.computeRenderOrder\n                const eitherIsBuilding = ((_c = mapObjectAdapterA.kind) === null || _c === void 0 ? void 0 : _c.find(s => s === \"building\")) !== undefined ||\n                    ((_d = mapObjectAdapterB.kind) === null || _d === void 0 ? void 0 : _d.find(s => s === \"building\")) !== undefined;\n                const sameLevel = mapObjectAdapterA.level === mapObjectAdapterB.level;\n                if (sameLevel || eitherIsBuilding) {\n                    return stableSort(a, b);\n                }\n                return mapObjectAdapterA.level - mapObjectAdapterB.level;\n            }\n            return stableSort(a, b);\n        };\n        this.m_renderer.setOpaqueSort(painterSortStable);\n    }\n    updateStencilRef(object) {\n        // TODO: acquire a new style value of if transparent\n        if (object.renderOrder !== undefined && object instanceof SolidLineMesh_1.SolidLineMesh) {\n            const material = object.material;\n            if (Array.isArray(material)) {\n                material.forEach(mat => (mat.stencilRef = this.getStencilValue(object.renderOrder)));\n            }\n            else {\n                material.stencilRef = this.getStencilValue(object.renderOrder);\n            }\n        }\n    }\n    allocateStencilValue(renderOrder) {\n        const stencilValue = this.m_stencilValue++;\n        this.m_renderOrderStencilValues.set(renderOrder, stencilValue);\n        return stencilValue;\n    }\n    getStencilValue(renderOrder) {\n        var _a;\n        return ((_a = this.m_renderOrderStencilValues.get(renderOrder)) !== null && _a !== void 0 ? _a : this.allocateStencilValue(renderOrder));\n    }\n    /**\n     * Process dynamic updates of [[TileObject]]'s style.\n     *\n     * @returns `true` if object shall be used in scene, `false` otherwise\n     */\n    processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter) {\n        if (!object.visible) {\n            return false;\n        }\n        if (!this.processTileObjectFeatures(tile, storageLevel, zoomLevel, object)) {\n            return false;\n        }\n        if (mapObjectAdapter) {\n            mapObjectAdapter.ensureUpdated(tile.mapView);\n            if (!mapObjectAdapter.isVisible()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Process the features owned by the given `TileObject`.\n     *\n     * @param tile - The {@link Tile} owning the `TileObject`'s features.\n     * @param storageLevel - The storage level of the `Tile` containing the object,\n     * @param zoomLevel - The current zoom level of `MapView`.\n     * @param object - The `TileObject` to process.\n     * @returns `false` if the given `TileObject` should not be added to the scene.\n     */\n    processTileObjectFeatures(tile, storageLevel, zoomLevel, object) {\n        var _a, _b;\n        const technique = object.userData.technique;\n        const minZoomLevel = harp_datasource_protocol_1.getPropertyValue(technique === null || technique === void 0 ? void 0 : technique.minZoomLevel, this.m_env);\n        const maxZoomLevel = harp_datasource_protocol_1.getPropertyValue(technique === null || technique === void 0 ? void 0 : technique.maxZoomLevel, this.m_env);\n        if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n            return false;\n        }\n        if (typeof maxZoomLevel === \"number\" && zoomLevel >= maxZoomLevel) {\n            return false;\n        }\n        if ((technique === null || technique === void 0 ? void 0 : technique.enabled) === undefined) {\n            // Nothing to do, there's no technique.\n            return true;\n        }\n        const feature = object.userData.feature;\n        if (!feature || !harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {\n            return Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, this.m_env));\n        }\n        const { starts, objInfos } = feature;\n        if (!Array.isArray(objInfos) || !Array.isArray(starts)) {\n            // Nothing to do, the object is missing feature ids and their position\n            // in the index buffer.\n            return true;\n        }\n        const geometry = object.geometry;\n        if (!geometry || !geometry.isBufferGeometry) {\n            // Nothing to do, the geometry is not a [[THREE.BufferGeometry]]\n            // and we can't generate groups.\n            return true;\n        }\n        // ExtrudeBufferGeometry for example doesn't have an index, hence we get the final index\n        // from the number of vertices.\n        const finalIndex = (_b = (_a = geometry.getIndex()) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : geometry.attributes.position.count;\n        // clear the groups.\n        geometry.clearGroups();\n        // The offset in the index buffer of the end of the last\n        // pushed group.\n        let endOfLastGroup;\n        objInfos.forEach((properties, featureIndex) => {\n            var _a, _b;\n            // the id of the current feature.\n            const featureId = harp_datasource_protocol_1.getFeatureId(properties);\n            let enabled = true;\n            if (harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {\n                // the state of current feature.\n                const featureState = tile.dataSource.getFeatureState(featureId);\n                // create a new {@link @here/harp-datasource-protocol#Env} that can be used\n                // to evaluate expressions that access the feature state.\n                const $state = featureState ? new harp_datasource_protocol_1.MapEnv(featureState) : null;\n                const parentEnv = typeof properties === \"object\"\n                    ? new harp_datasource_protocol_1.MapEnv(properties, this.m_env)\n                    : this.m_env;\n                const env = new harp_datasource_protocol_1.MapEnv({ $state }, parentEnv);\n                enabled = Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, env));\n            }\n            if (!enabled) {\n                // skip this feature, it was disabled.\n                return;\n            }\n            // HARP-12247, geometry with no featureStarts would set start to `undefined`, in this\n            // case, `endOfLastGroup` is also undefined (first execution in this loop), so it would\n            // try to change the count of a group which hasn't yet been added, `addGroup` wasn't yet\n            // called, hence we use the `??` operator and fall back to 0. Because featureStarts are\n            // optional, we need to have a fallback.\n            const start = (_a = starts[featureIndex]) !== null && _a !== void 0 ? _a : 0;\n            const end = (_b = starts[featureIndex + 1]) !== null && _b !== void 0 ? _b : finalIndex;\n            const count = end - start;\n            if (start === endOfLastGroup) {\n                // extend the last group\n                geometry.groups[geometry.groups.length - 1].count += count;\n            }\n            else {\n                geometry.addGroup(start, count);\n            }\n            endOfLastGroup = start + count;\n        });\n        return geometry.groups.length > 0;\n    }\n}\nexports.TileObjectRenderer = TileObjectRenderer;\n//# sourceMappingURL=TileObjectsRenderer.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/TileObjectsRenderer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileOffsetUtils = exports.MapViewUtils = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Tile_1 = __webpack_require__(/*! ./Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"MapViewUtils\");\n// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.\n// There may be cases where it is possible to construct Object3Ds with considerable less memory\n// consumption, but this value is used to simplify the estimation.\nconst MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;\nconst MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;\n/**\n * Zoom level to request terrain tiles for getting the height of the camera above terrain.\n */\nconst TERRAIN_ZOOM_LEVEL = 4;\n// Caching those for performance reasons.\nconst groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);\nconst groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());\nconst groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);\nconst rayCaster = new THREE.Raycaster();\nconst epsilon = 1e-5;\n/**\n * Cached ThreeJS instances for realtime maths.\n */\nconst space = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst tangentSpace = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst cache = {\n    box3: [new THREE.Box3()],\n    obox3: [new harp_geoutils_1.OrientedBox3()],\n    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],\n    vector2: [new THREE.Vector2()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transforms: [\n        {\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3(),\n            position: new THREE.Vector3()\n        }\n    ]\n};\n/**\n * Rounds a given zoom level up to the nearest integer value if it's close enough.\n *\n * The zoom level set in {@link MapView} after a zoom level\n * target is given to {@link (MapView.lookAt:WITH_PARAMS)} or\n * {@link @here/harp-map-controls#MapControls} never matches\n * exactly the target due to the precision loss caused by the\n * conversion from zoom level to camera distance (done in\n * {@link (MapView.lookAt:WITH_PARAMS)} and {@link @here/harp-map-controls#MapControls})\n * and from distance back to zoom level (done at every frame on camera update).\n * As a result, given a fixed integer zoom level input, the final zoom level computed at every frame\n * may fall sometimes below the integer value and others above. This causes flickering since each\n * frame will use different tile levels and different style evaluations for object visibility.\n * See HARP-9673 and HARP-8523.\n * @param zoomLevel - Input zoom level\n * @return The ceiling zoom level if input zoom level is close enough, otherwise the unmodified\n * input zoom level.\n */\nfunction snapToCeilingZoomLevel(zoomLevel) {\n    const eps = 1e-6;\n    const ceiling = Math.ceil(zoomLevel);\n    return ceiling - zoomLevel < eps ? ceiling : zoomLevel;\n}\nvar MapViewUtils;\n(function (MapViewUtils) {\n    MapViewUtils.MAX_TILT_DEG = 89;\n    MapViewUtils.MAX_TILT_RAD = MapViewUtils.MAX_TILT_DEG * THREE.MathUtils.DEG2RAD;\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param mapView - Instance of MapView.\n     * @param targetNDCx - Target x position in NDC space.\n     * @param targetNDCy - Target y position in NDC space.\n     * @param zoomLevel - The desired zoom level.\n     * @param maxTiltAngle - The maximum tilt angle to comply by, in globe projection, in radian.\n     * @returns `false` if requested zoom cannot be achieved due to the map view's maximum bounds\n     * {@link MapView.geoMaxBounds},`true` otherwise.\n     */\n    function zoomOnTargetPosition(mapView, targetNDCx, targetNDCy, zoomLevel, maxTiltAngle = MapViewUtils.MAX_TILT_RAD) {\n        const { elevationProvider, camera, projection } = mapView;\n        // Use for now elevation at camera position. See getTargetAndDistance.\n        const elevation = elevationProvider\n            ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL)\n            : undefined;\n        // Get current target position in world space before we zoom.\n        const zoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);\n        // Compute current camera target, it may not be the one set in MapView, e.g. when this\n        // function is called multiple times between frames.\n        const cameraTarget = MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider).target;\n        const newCameraDistance = calculateDistanceFromZoomLevel(mapView, zoomLevel);\n        if (mapView.geoMaxBounds) {\n            // If map view has maximum bounds set, constrain camera target and distance to ensure\n            // they remain within bounds.\n            const constrained = constrainTargetAndDistanceToViewBounds(cameraTarget, newCameraDistance, mapView);\n            if (constrained.distance !== newCameraDistance) {\n                // Only indicate failure when zooming out. This avoids zoom in cancellations when\n                // camera is already at the maximum distance allowed by the view bounds.\n                return zoomLevel >= mapView.zoomLevel;\n            }\n        }\n        // Set the camera distance according to the given zoom level.\n        camera\n            .getWorldDirection(camera.position)\n            .multiplyScalar(-newCameraDistance)\n            .add(cameraTarget);\n        // In sphere, we may have to also orbit the camera around the position located at the\n        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change\n        // this tilt by changing the camera's height above.\n        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // FIXME: We cannot use mapView.tilt here b/c it does not reflect the latest camera\n            // changes.\n            const tilt = extractCameraTilt(camera, projection);\n            const deltaTilt = tilt - maxTiltAngle;\n            if (deltaTilt > 0) {\n                orbitAroundScreenPoint(mapView, 0, 0, 0, deltaTilt, maxTiltAngle);\n            }\n        }\n        // Get new target position after the zoom\n        const newZoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);\n        if (!zoomTarget || !newZoomTarget) {\n            return true;\n        }\n        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            // Calculate the difference and pan the map to maintain the map relative to the target\n            // position.\n            zoomTarget.sub(newZoomTarget);\n            panCameraAboveFlatMap(mapView, zoomTarget.x, zoomTarget.y);\n        }\n        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            panCameraAroundGlobe(mapView, zoomTarget, newZoomTarget);\n        }\n        return true;\n    }\n    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;\n    /**\n     * Orbits the camera around a given point on the screen.\n     *\n     * @param mapView - The {@link MapView} instance to manipulate.\n     * @param offsetX - Orbit point in NDC space.\n     * @param offsetY - Orbit point in NDC space.\n     * @param deltaAzimuth - Delta azimuth in radians.\n     * @param deltaTil - Delta tilt in radians.\n     * @param maxTiltAngle - The maximum tilt between the camera and its target in radian.\n     */\n    function orbitAroundScreenPoint(mapView, offsetX, offsetY, deltaAzimuth, deltaTilt, maxTiltAngle) {\n        const rotationTargetWorld = MapViewUtils.rayCastWorldCoordinates(mapView, offsetX, offsetY);\n        if (rotationTargetWorld === null) {\n            return;\n        }\n        const mapTargetWorld = offsetX === 0 && offsetY === 0\n            ? rotationTargetWorld\n            : MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0);\n        if (mapTargetWorld === null) {\n            return;\n        }\n        applyAzimuthAroundTarget(mapView, rotationTargetWorld, -deltaAzimuth);\n        const tiltAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(mapView.camera.quaternion);\n        const clampedDeltaTilt = computeClampedDeltaTilt(mapView, offsetY, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis);\n        applyTiltAroundTarget(mapView, rotationTargetWorld, clampedDeltaTilt, tiltAxis);\n    }\n    MapViewUtils.orbitAroundScreenPoint = orbitAroundScreenPoint;\n    /**\n     * @hidden\n     * @internal\n     *\n     * Applies the given Azimith to the camera around the supplied target.\n     */\n    function applyAzimuthAroundTarget(mapView, rotationTargetWorld, deltaAzimuth) {\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        const headingAxis = projection.surfaceNormal(rotationTargetWorld, cache.vector3[0]);\n        const headingQuat = cache.quaternions[0].setFromAxisAngle(headingAxis, deltaAzimuth);\n        camera.quaternion.premultiply(headingQuat);\n        camera.position.sub(rotationTargetWorld);\n        camera.position.applyQuaternion(headingQuat);\n        camera.position.add(rotationTargetWorld);\n    }\n    /**\n     * @hidden\n     * @internal\n     *\n     * Clamps the supplied `deltaTilt` to the `maxTiltAngle` supplied. Note, when a non-zero offset\n     * is applied, we apply another max angle of 89 degrees to the rotation center to prevent some\n     * corner cases where the angle at the rotation center is 90 degrees and therefore intersects\n     * the geometry with the near plane.\n     */\n    function computeClampedDeltaTilt(mapView, offsetY, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis) {\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        const tilt = extractTiltAngleFromLocation(projection, camera, mapTargetWorld, tiltAxis);\n        if (tilt + deltaTilt < 0) {\n            // Clamp the final tilt to 0\n            return -tilt;\n        }\n        else if (deltaTilt <= 0) {\n            // Reducing the tilt isn't clamped (apart from above).\n            return deltaTilt;\n        }\n        else if (mapTargetWorld.equals(rotationTargetWorld) || offsetY < 0) {\n            // When the rotation target is the center, or the offsetY is < 0, i.e. the angle at the\n            // `mapTargetWorld` is always bigger, then we have a simple formula\n            return harp_geoutils_1.MathUtils.clamp(deltaTilt + tilt, 0, maxTiltAngle) - tilt;\n        }\n        const rotationCenterTilt = extractTiltAngleFromLocation(projection, camera, rotationTargetWorld, tiltAxis);\n        const maxRotationTiltAngle = THREE.MathUtils.degToRad(89);\n        // The rotationCenterTilt may exceed 89 degrees when for example the user has tilted to 89\n        // at the mapTargetWorld, then choose a rotation center target above the mapTargetWorld,\n        // i.e. offsetY > 0. In such case, we just return 0, i.e. we don't let the user increase\n        // the tilt (but it can decrease, see check above for \"deltaTilt <= 0\").\n        if (rotationCenterTilt > maxRotationTiltAngle) {\n            return 0;\n        }\n        // This is used to find the max tilt angle, because the difference in normals is needed\n        // to correct the triangle used to find the max tilt angle at the rotation center.\n        let angleBetweenNormals = 0;\n        if (projection === harp_geoutils_1.sphereProjection) {\n            const projectedRotationTargetNormal = projection\n                .surfaceNormal(rotationTargetWorld, cache.vector3[0])\n                .projectOnPlane(tiltAxis)\n                .normalize();\n            const mapTargetNormal = projection.surfaceNormal(mapTargetWorld, cache.vector3[1]);\n            angleBetweenNormals = projectedRotationTargetNormal.angleTo(mapTargetNormal);\n        }\n        const ninetyRad = THREE.MathUtils.degToRad(90);\n        // The following terminology will be used:\n        // Ta = Tilt axis, tilting is achieved by rotating the camera around this direction.\n        // R = rotation target, i.e. the point about which we are rotating: `rotationTargetWorld`\n        // Rp = rotation target projected on to Ta\n        // C = camera position\n        // M = map target, i.e. the point which the camera is looking at at the NDC coordinates 0,0\n        // Note, the points Rp, C, and M create a plane that is perpendicular to the earths surface,\n        // because the tilt axis is perpendicular to the up vector. The following variable `RpCM` is\n        // the angle between the two rays C->Rp and C->M. This angle remains constant when tilting\n        // with a fixed `offsetX` and `offsetY`. It is calculated by using the intersection of the\n        // two rays with the earth.\n        // Note the use of `angleBetweenNormals` to ensure this works for spherical projections.\n        // Note, this calculation only works when the tilt at M is less than the tilt\n        // at Rp, otherwise the above formula won't work. We however don't need to worry about this\n        // case because this happens only when offsetY is less than zero, and this is handled above.\n        const MRpC = ninetyRad + angleBetweenNormals - rotationCenterTilt;\n        const CMRp = ninetyRad + tilt;\n        const RpCM = ninetyRad * 2 - (MRpC + CMRp);\n        // We want to find the greatest angle at the rotation target that gives us the max\n        // angle at the map center target.\n        const CMRpMaxTilt = ninetyRad * 2 - RpCM - ninetyRad - maxTiltAngle;\n        // Converting the `MRpC` back to a tilt is as easy as subtracting it from 90 and the\n        // `angleBetweenNormals`, i.e. this gives us the maximum allowed tilt at R that satisfies\n        // the `maxTiltAngle` constraint. Note, for globe projection, this is just an approximation,\n        // because once we move the camera by delta, the map target changes, and therefore the\n        // normal also changes, this would need to be applied iteratively until the difference in\n        // normals is reduced to some epsilon. I don't apply this because it is computationally\n        // expensive and the user would never notice this in practice.\n        const maxTilt = ninetyRad + angleBetweenNormals - CMRpMaxTilt;\n        // Here we clamp to the min of `maxTilt` and 89 degrees. The check for 89 is to prevent it\n        // intersecting with the world at 90. This is possible for example when the R position is\n        // near the horizon. If the angle RCM is say 5 degrees, then an angle of say 89 degrees at\n        // R, plus 5 degrees means the tilt at M would be 84 degrees, so the camera can reach 90\n        // from the point R whilst the tilt to M never reaches the `maxTiltAngle`\n        const clampedDeltaTilt = harp_geoutils_1.MathUtils.clamp(deltaTilt + rotationCenterTilt, 0, Math.min(maxTilt, maxRotationTiltAngle)) - rotationCenterTilt;\n        return clampedDeltaTilt;\n    }\n    /**\n     * @hidden\n     * @internal\n     *\n     * Applies the given tilt to the camera around the supplied target.\n     */\n    function applyTiltAroundTarget(mapView, rotationTargetWorld, deltaTilt, tiltAxis) {\n        const camera = mapView.camera;\n        // Consider to use the cache if necessary, but beware, because the `rayCastWorldCoordinates`\n        // also uses this cache.\n        const posBackup = camera.position.clone();\n        const quatBackup = camera.quaternion.clone();\n        const tiltQuat = cache.quaternions[0].setFromAxisAngle(tiltAxis, deltaTilt);\n        camera.quaternion.premultiply(tiltQuat);\n        camera.position.sub(rotationTargetWorld);\n        camera.position.applyQuaternion(tiltQuat);\n        camera.position.add(rotationTargetWorld);\n        if (MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0) === null) {\n            logger.warn(\"Target got invalidated during rotation.\");\n            camera.position.copy(posBackup);\n            camera.quaternion.copy(quatBackup);\n        }\n    }\n    /**\n     * Calculate target (focus) point geo-coordinates for given camera.\n     * @see getTargetPositionFromCamera\n     *\n     * @param camera - The camera looking on target point.\n     * @param projection - The geo-projection used.\n     * @param elevation - Optional elevation above (or below) sea level measured in world units.\n     *\n     * @deprecated This function is for internal use only and will be removed in the future. Use\n     * MapView.worldTarget instead.\n     */\n    function getGeoTargetFromCamera(camera, projection, elevation) {\n        // This function does almost the same as:\n        // rayCastGeoCoordinates(mapView, 0, 0)\n        // but in more gentle and performance wise manner\n        const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);\n        if (targetWorldPos !== null) {\n            return projection.unprojectPoint(targetWorldPos);\n        }\n        return null;\n    }\n    MapViewUtils.getGeoTargetFromCamera = getGeoTargetFromCamera;\n    /**\n     * Calculate target (focus) point world coordinates for given camera position and orientation.\n     * @param camera - The camera looking on target point.\n     * @param projection - The geo-projection used.\n     * @param elevation - Optional elevation above (or below) sea level in world units.\n     *\n     * @deprecated This function is for internal use only and will be removed in the future.\n     */\n    function getWorldTargetFromCamera(camera, projection, elevation) {\n        const cameraPos = cache.vector3[0].copy(camera.position);\n        const cameraLookAt = camera.getWorldDirection(cache.vector3[1]);\n        rayCaster.set(cameraPos, cameraLookAt);\n        if (elevation !== undefined) {\n            groundPlane.constant -= elevation;\n            groundSphere.radius += elevation;\n        }\n        const targetWorldPos = new THREE.Vector3();\n        const result = projection.type === harp_geoutils_1.ProjectionType.Planar\n            ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos)\n            : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);\n        if (elevation !== undefined) {\n            groundPlane.constant = 0;\n            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;\n        }\n        return result;\n    }\n    MapViewUtils.getWorldTargetFromCamera = getWorldTargetFromCamera;\n    /**\n     * Constrains given camera target and distance to {@link MapView.maxBounds}.\n     *\n     * @remarks\n     * The resulting\n     * target and distance will keep the view within the maximum bounds for a camera with tilt and\n     * yaw set to 0.\n     * @param target - The camera target.\n     * @param distance - The camera distance.\n     * @param mapView - The map view whose maximum bounds will be used as constraints.\n     * @returns constrained target and distance, or the unchanged input arguments if the view\n     * does not have maximum bounds set.\n     */\n    function constrainTargetAndDistanceToViewBounds(target, distance, mapView) {\n        const unconstrained = { target, distance };\n        const worldMaxBounds = mapView.worldMaxBounds;\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        if (!worldMaxBounds) {\n            return unconstrained;\n        }\n        /**\n         * Constraints are checked similarly for planar and sphere. The extents of a top down view\n         * (even if camera isn't top down) using the given camera distance are compared with those\n         * of the maximum bounds to compute a scale. There are two options:\n         * a) scale > 1. The view covers a larger area than the maximum bounds. The distance is\n         * is reduced to match the bounds extents and the target is set at the bounds center.\n         * b) scale <= 1. The view may fit within the bounds without changing the distance, only the\n         * target is moved to fit the whole view within the bounds.\n         **/\n        const boundsSize = worldMaxBounds.getSize(cache.vector3[1]);\n        const screenSize = mapView.renderer.getSize(cache.vector2[0]);\n        const viewHeight = calculateWorldSizeByFocalLength(mapView.focalLength, unconstrained.distance, screenSize.height);\n        const viewWidth = viewHeight * camera.aspect;\n        const scale = Math.max(viewWidth / boundsSize.x, viewHeight / boundsSize.y);\n        const viewHalfSize = new THREE.Vector3(viewWidth / 2, viewHeight / 2, 0);\n        const constrained = {\n            target: unconstrained.target.clone(),\n            distance: unconstrained.distance\n        };\n        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            if (scale > 1) {\n                constrained.distance /= scale;\n                camera\n                    .getWorldDirection(camera.position)\n                    .multiplyScalar(-constrained.distance)\n                    .add(worldMaxBounds.getCenter(constrained.target));\n            }\n            else {\n                const targetBounds = cache.box3[0]\n                    .copy(worldMaxBounds)\n                    .expandByVector(viewHalfSize.multiplyScalar(-1));\n                targetBounds\n                    .clampPoint(unconstrained.target, constrained.target)\n                    .setZ(unconstrained.target.z);\n                if (constrained.target.equals(unconstrained.target)) {\n                    return unconstrained;\n                }\n                camera.position.x += constrained.target.x - unconstrained.target.x;\n                camera.position.y += constrained.target.y - unconstrained.target.y;\n            }\n            return constrained;\n        }\n        // Spherical projection\n        if (scale > 1) {\n            // Set target to center of max bounds but keeping same height as unconstrained target.\n            worldMaxBounds.getCenter(constrained.target);\n            constrained.target.setLength(unconstrained.target.length());\n            constrained.distance /= scale;\n        }\n        else {\n            // Compute the bounds where the target must be to ensure a top down view remains within\n            // the maximum bounds.\n            const targetMaxBounds = cache.obox3[0];\n            targetMaxBounds.copy(worldMaxBounds);\n            targetMaxBounds.position.setLength(unconstrained.target.length());\n            targetMaxBounds.extents.sub(viewHalfSize);\n            // Project unconstrained target to local tangent plane at the max bounds center.\n            const rotMatrix = targetMaxBounds.getRotationMatrix(cache.matrix4[0]);\n            const localTarget = cache.vector3[1]\n                .copy(constrained.target)\n                .sub(targetMaxBounds.position)\n                .applyMatrix4(cache.matrix4[1].copy(rotMatrix).transpose())\n                .setZ(0);\n            // Clamp the projected target with the target bounds and check if it changes.\n            const constrainedLocalTarget = cache.vector3[2]\n                .copy(localTarget)\n                .clamp(cache.vector3[3].copy(targetMaxBounds.extents).multiplyScalar(-1), targetMaxBounds.extents);\n            if (constrainedLocalTarget.equals(localTarget)) {\n                return unconstrained;\n            }\n            // Project the local constrained target back into the sphere.\n            constrained.target\n                .copy(constrainedLocalTarget)\n                .applyMatrix4(rotMatrix)\n                .add(targetMaxBounds.position);\n            const targetHeightSq = targetMaxBounds.position.lengthSq();\n            const constTargetDistSq = constrained.target.distanceToSquared(targetMaxBounds.position);\n            const constTargetDistToGround = Math.sqrt(targetHeightSq) - Math.sqrt(targetHeightSq - constTargetDistSq);\n            constrained.target.addScaledVector(targetMaxBounds.zAxis, -constTargetDistToGround);\n            // Set the constrained target to the same height as the unconstrained one.\n            constrained.target.setLength(unconstrained.target.length());\n        }\n        // Pan camera to constrained target and set constrained distance.\n        MapViewUtils.panCameraAroundGlobe(mapView, cache.vector3[1].copy(constrained.target), cache.vector3[2].copy(unconstrained.target));\n        camera\n            .getWorldDirection(camera.position)\n            .multiplyScalar(-constrained.distance)\n            .add(constrained.target);\n        return constrained;\n    }\n    MapViewUtils.constrainTargetAndDistanceToViewBounds = constrainTargetAndDistanceToViewBounds;\n    /**\n     * @internal\n     * Computes the target for a given camera and the distance between them.\n     * @param projection - The world space projection.\n     * @param camera - The camera whose target will be computed.\n     * @param elevationProvider - If provided, elevation at the camera position will be used.\n     * @returns The target, the distance to it and a boolean flag set to false in case an elevation\n     * provider was passed but the elevation was not available yet.\n     */\n    function getTargetAndDistance(projection, camera, elevationProvider) {\n        const cameraPitch = extractAttitude({ projection }, camera).pitch;\n        //FIXME: For now we keep the old behaviour when terrain is enabled (i.e. use the camera\n        //       height above terrain to deduce the target distance).\n        //       This leads to zoomlevel changes while panning. We have to find a proper solution\n        //       for terrain (e.g. raycast with the ground surfcae that is elevated by the average\n        //       elevation in the scene)\n        const elevation = elevationProvider\n            ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL)\n            : undefined;\n        const final = !elevationProvider || elevation !== undefined;\n        // Even for a tilt of 90 raycastTargetFromCamera is returning some point almost at\n        // infinity.\n        const target = cameraPitch < MapViewUtils.MAX_TILT_RAD\n            ? getWorldTargetFromCamera(camera, projection, elevation)\n            : null;\n        if (target !== null) {\n            const distance = camera.position.distanceTo(target);\n            return { target, distance, final };\n        }\n        else {\n            // We either reached the [[PITCH_LIMIT]] or we did not hit the ground surface.\n            // In this case we do the reverse, i.e. compute some fallback distance and\n            // use it to compute the tagret point by using the camera direction.\n            const groundDistance = projection.groundDistance(camera.position);\n            const heightAboveTerrain = Math.max(groundDistance - (elevation !== null && elevation !== void 0 ? elevation : 0), 0);\n            //For flat projection we fallback to the target distance at 89 degree pitch.\n            //For spherical projection we fallback to the tangent line distance\n            const distance = projection.type === harp_geoutils_1.ProjectionType.Planar\n                ? heightAboveTerrain / Math.cos(Math.min(cameraPitch, MapViewUtils.MAX_TILT_RAD))\n                : Math.sqrt(Math.pow(heightAboveTerrain + EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS, 2) -\n                    Math.pow(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS, 2));\n            const cameraDir = camera.getWorldDirection(cache.vector3[0]);\n            cameraDir.multiplyScalar(distance);\n            const fallbackTarget = cache.vector3[1];\n            fallbackTarget.copy(camera.position).add(cameraDir);\n            return { target: fallbackTarget, distance, final };\n        }\n    }\n    MapViewUtils.getTargetAndDistance = getTargetAndDistance;\n    /**\n     * Returns the {@link @here/harp-geoutils#GeoCoordinates} of the camera,\n     * given its target coordinates on the map and its\n     * zoom, yaw and pitch.\n     *\n     * @param targetCoordinates - Coordinates of the center of the view.\n     * @param distance - Distance to the target in meters.\n     * @param yawDeg - Camera yaw in degrees.\n     * @param pitchDeg - Camera pitch in degrees.\n     * @param projection - Active MapView, needed to get the camera fov and map projection.\n     * @param result - Optional output vector.\n     * @returns Camera position in world space.\n     */\n    function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection, result = new THREE.Vector3()) {\n        const pitchRad = THREE.MathUtils.degToRad(pitchDeg);\n        const altitude = Math.cos(pitchRad) * distance;\n        const yawRad = THREE.MathUtils.degToRad(yawDeg);\n        projection.projectPoint(targetCoordinates, result);\n        const groundDistance = distance * Math.sin(pitchRad);\n        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            result.x = result.x + Math.sin(yawRad) * groundDistance;\n            result.y = result.y - Math.cos(yawRad) * groundDistance;\n            result.z = result.z + altitude;\n        }\n        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // In globe yaw and pitch are understood to be in tangent space. The approach below is\n            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and\n            // set its new length (groundDistance). Finally the up vector's length is set to the\n            // camera height and added to the transformed Y above.\n            // Get the Z axis in tangent space: it is the normalized position vector of the target.\n            tangentSpace.z.copy(result).normalize();\n            // Get the Y axis (north axis in tangent space):\n            tangentSpace.y.set(0, 0, 1).projectOnPlane(tangentSpace.z).normalize();\n            // Rotate this north axis by the given yaw, giving the camera direction relative to\n            // the target.\n            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);\n            tangentSpace.y.applyQuaternion(cache.quaternions[0]);\n            // Push the camera to the specified distance.\n            tangentSpace.y.setLength(groundDistance);\n            // Now get the actual camera position vector: from the target position, add the\n            // previous computation to get the projection of the camera on the ground, then add\n            // the height of the camera in the tangent space.\n            const height = distance * Math.cos(pitchRad);\n            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));\n            const a = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + altitude;\n            const b = Math.sin(pitchRad) * distance;\n            const cameraHeight = Math.sqrt(a * a + b * b);\n            result.setLength(cameraHeight);\n        }\n        return result;\n    }\n    MapViewUtils.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;\n    /**\n     * @hidden\n     * @internal\n     *\n     * Add offset to geo points for minimal view box in flat projection with tile wrapping.\n     *\n     * @remarks\n     * In flat projection, with wrap around enabled, we should detect clusters of points around that\n     * wrap antimeridian.\n     *\n     * Here, we fit points into minimal geo box taking world wrapping into account.\n     */\n    function wrapGeoPointsToScreen(points, startPosition) {\n        let startIndex = 0;\n        if (startPosition === undefined) {\n            startPosition = harp_geoutils_1.GeoCoordinates.fromObject(points[0]);\n            startIndex = 1;\n        }\n        let north = startPosition.latitude;\n        let south = startPosition.latitude;\n        let lonCenter = harp_geoutils_1.MathUtils.normalizeLongitudeDeg(startPosition.longitude);\n        let lonSpan = 0;\n        let east = startPosition.longitude;\n        let west = startPosition.longitude;\n        const result = [];\n        result.push(new harp_geoutils_1.GeoCoordinates(north, lonCenter));\n        for (let i = startIndex; i < points.length; i++) {\n            const p = harp_geoutils_1.GeoCoordinates.fromObject(points[i]);\n            if (p.latitude > north) {\n                north = p.latitude;\n            }\n            else if (p.latitude < south) {\n                south = p.latitude;\n            }\n            let longitude = harp_geoutils_1.MathUtils.normalizeLongitudeDeg(p.longitude);\n            const relToCenter = harp_geoutils_1.MathUtils.angleDistanceDeg(lonCenter, longitude);\n            longitude = lonCenter - relToCenter;\n            if (relToCenter < 0 && -relToCenter > lonSpan / 2) {\n                east = Math.max(east, lonCenter - relToCenter);\n                lonSpan = east - west;\n                lonCenter = (east + west) / 2;\n            }\n            else if (relToCenter > 0 && relToCenter > lonSpan / 2) {\n                west = Math.min(west, longitude);\n                lonSpan = east - west;\n                lonCenter = (east + west) / 2;\n            }\n            result.push(new harp_geoutils_1.GeoCoordinates(p.latitude, longitude));\n        }\n        return result;\n    }\n    MapViewUtils.wrapGeoPointsToScreen = wrapGeoPointsToScreen;\n    /**\n     * @hidden\n     * @internal\n     *\n     * Given `cameraPos`, force all points that lie on non-visible sphere half to be \"near\" max\n     * possible viewable circle from given camera position.\n     *\n     * @remarks\n     * Assumes that shpere projection with world center is in `(0, 0, 0)`.\n     */\n    function wrapWorldPointsToView(points, cameraPos) {\n        const cameraPosNormalized = cameraPos.clone().normalize();\n        for (const point of points) {\n            if (point.angleTo(cameraPos) > Math.PI / 2) {\n                // Point is on other side of sphere, we \"clamp it to\" max possible viewable circle\n                // from given camera position\n                const pointLen = point.length();\n                point.projectOnPlane(cameraPosNormalized).setLength(pointLen);\n            }\n        }\n    }\n    MapViewUtils.wrapWorldPointsToView = wrapWorldPointsToView;\n    /**\n     * @hidden\n     * @internal\n     *\n     * Return `GeoPoints` bounding {@link @here/harp-geoutils#GeoBox}\n     * applicable for {@link getFitBoundsDistance}.\n     *\n     * @returns {@link @here/harp-geoutils#GeoCoordinates} set that covers `box`\n     */\n    function geoBoxToGeoPoints(box) {\n        const center = box.center;\n        return [\n            new harp_geoutils_1.GeoCoordinates(box.north, box.west),\n            new harp_geoutils_1.GeoCoordinates(box.north, box.east),\n            new harp_geoutils_1.GeoCoordinates(center.latitude, box.west),\n            new harp_geoutils_1.GeoCoordinates(center.latitude, box.east),\n            new harp_geoutils_1.GeoCoordinates(box.south, box.west),\n            new harp_geoutils_1.GeoCoordinates(box.south, box.east),\n            new harp_geoutils_1.GeoCoordinates(box.north, center.longitude),\n            new harp_geoutils_1.GeoCoordinates(box.south, center.longitude)\n        ];\n    }\n    MapViewUtils.geoBoxToGeoPoints = geoBoxToGeoPoints;\n    /**\n     * @hidden\n     * @internal\n     *\n     * Get minimal distance required for `camera` looking at `worldTarget` to cover `points`.\n     *\n     * All dimensions belong to world space.\n     *\n     * @param points - points which shall are to be covered by view\n     *\n     * @param worldTarget - readonly, world target of {@link MapView}\n     * @param camera - readonly, camera with proper `position` and rotation set\n     * @returns new distance to camera to be used with {@link (MapView.lookAt:WITH_PARAMS)}\n     */\n    function getFitBoundsDistance(points, worldTarget, camera) {\n        const cameraRotationMatrix = new THREE.Matrix4();\n        cameraRotationMatrix.extractRotation(camera.matrixWorld);\n        const screenUpVector = new THREE.Vector3(0, 1, 0).applyMatrix4(cameraRotationMatrix);\n        const screenSideVector = new THREE.Vector3(1, 0, 0).applyMatrix4(cameraRotationMatrix);\n        const screenVertMidPlane = new THREE.Plane().setFromCoplanarPoints(camera.position, worldTarget, worldTarget.clone().add(screenUpVector));\n        const screenHorzMidPlane = new THREE.Plane().setFromCoplanarPoints(camera.position, worldTarget, worldTarget.clone().add(screenSideVector));\n        const cameraPos = cache.vector3[0];\n        cameraPos.copy(camera.position);\n        const halfVertFov = THREE.MathUtils.degToRad(camera.fov / 2);\n        const halfHorzFov = MapViewUtils.calculateHorizontalFovByVerticalFov(2 * halfVertFov, camera.aspect) / 2;\n        // tan(fov/2)\n        const halfVertFovTan = 1 / Math.tan(halfVertFov);\n        const halfHorzFovTan = 1 / Math.tan(halfHorzFov);\n        const cameraToTarget = cache.vector3[1];\n        cameraToTarget.copy(cameraPos).sub(worldTarget).negate();\n        const cameraToTargetNormalized = new THREE.Vector3().copy(cameraToTarget).normalize();\n        const offsetVector = new THREE.Vector3();\n        const cameraToPointOnRefPlane = new THREE.Vector3();\n        const pointOnRefPlane = new THREE.Vector3();\n        function checkAngle(point, referencePlane, maxAngle, fovFactor) {\n            referencePlane.projectPoint(point, pointOnRefPlane);\n            cameraToPointOnRefPlane.copy(cameraPos).sub(pointOnRefPlane).negate();\n            const viewAngle = cameraToTarget.angleTo(cameraToPointOnRefPlane);\n            if (viewAngle <= maxAngle) {\n                return;\n            }\n            const cameraToPointLen = cameraToPointOnRefPlane.length();\n            const cameraToTargetLen = cameraToTarget.length();\n            const newCameraDistance = cameraToPointLen * (Math.sin(viewAngle) * fovFactor - Math.cos(viewAngle)) +\n                cameraToTargetLen;\n            offsetVector\n                .copy(cameraToTargetNormalized)\n                .multiplyScalar(cameraToTargetLen - newCameraDistance);\n            cameraPos.add(offsetVector);\n            cameraToTarget.sub(offsetVector);\n        }\n        for (const point of points) {\n            checkAngle(point, screenVertMidPlane, halfVertFov, halfVertFovTan);\n            checkAngle(point, screenHorzMidPlane, halfHorzFov, halfHorzFovTan);\n        }\n        return cameraToTarget.length();\n    }\n    MapViewUtils.getFitBoundsDistance = getFitBoundsDistance;\n    /**\n     * @hidden\n     * @internal\n     *\n     * Get {@link LookAtParams} that fit all `worldPoints`\n     * giving that {@link MapView} will target at\n     * `geoTarget`.\n     *\n     * @param geoTarget - desired target (see {@link MapView.target}) as geo point\n     * @param worldTarget - same as `geoTarget` but in world space\n     * @param worldPoints - points we want to see\n     * @param params - other params derived from {@link MapView}.\n     */\n    function getFitBoundsLookAtParams(geoTarget, worldTarget, worldPoints, params) {\n        const { tilt, heading, projection } = params;\n        const startDistance = params.minDistance;\n        const tmpCamera = params.camera.clone();\n        getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera.quaternion);\n        getCameraPositionFromTargetCoordinates(geoTarget, startDistance, -heading, tilt, projection, tmpCamera.position);\n        tmpCamera.updateMatrixWorld(true);\n        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            wrapWorldPointsToView(worldPoints, tmpCamera.position);\n        }\n        const distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera);\n        return {\n            target: geoTarget,\n            distance,\n            heading,\n            tilt\n        };\n    }\n    MapViewUtils.getFitBoundsLookAtParams = getFitBoundsLookAtParams;\n    /**\n     * @deprecated use getCameraPositionFromTargetCoordinates instead\n     */\n    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {\n        return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache.vector3[1]));\n    }\n    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;\n    /**\n     * Casts a ray in NDC space from the current map view and returns the intersection point of that\n     * ray wih the map in world space.\n     *\n     * @param mapView - Instance of MapView.\n     * @param pointOnScreenXinNDC - X coordinate in NDC space.\n     * @param pointOnScreenYinNDC - Y coordinate in NDC space.\n     * @param elevation - Optional param used to offset the ground plane. Used when wanting to pan\n     * based on a plane at some altitude. Necessary for example when panning with terrain.\n     *\n     * @returns Intersection coordinates, or `null` if raycast failed.\n     */\n    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {\n        const pointInNDCPosition = cache.vector3[0].set(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);\n        mapView.camera.updateMatrixWorld();\n        const cameraPos = cache.vector3[1].copy(mapView.camera.position);\n        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);\n        // Prepare the unprojection matrix which projects from NDC space to camera space\n        // and takes the current rotation of the camera into account.\n        cache.matrix4[1].multiplyMatrices(cache.matrix4[0], cache.matrix4[1].copy(mapView.camera.projectionMatrix).invert());\n        // Unproject the point via the unprojection matrix.\n        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);\n        // Use the point in camera space as the vector towards this point.\n        rayCaster.set(cameraPos, pointInCameraSpace.normalize());\n        if (elevation !== undefined) {\n            groundPlane.constant -= elevation;\n            groundSphere.radius += elevation;\n        }\n        const worldPosition = new THREE.Vector3();\n        const result = mapView.projection.type === harp_geoutils_1.ProjectionType.Planar\n            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)\n            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);\n        if (elevation !== undefined) {\n            groundPlane.constant = 0;\n            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;\n        }\n        return result;\n    }\n    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;\n    /**\n     * Pans the camera according to the projection.\n     *\n     * @param mapView - Instance of MapView.\n     * @param xOffset - In world space. Value > 0 will pan the map to the right, value < 0 will pan\n     *                  the map to the left in default camera orientation.\n     * @param yOffset - In world space. Value > 0 will pan the map upwards, value < 0 will pan the\n     *                  map downwards in default camera orientation.\n     */\n    function panCameraAboveFlatMap(mapView, offsetX, offsetY) {\n        mapView.camera.position.x += offsetX;\n        mapView.camera.position.y += offsetY;\n    }\n    MapViewUtils.panCameraAboveFlatMap = panCameraAboveFlatMap;\n    /**\n     * The function doing a pan in the spherical space\n     * when {@link MapView}'s active [[ProjectionType]]\n     * is spherical. In other words, the function that rotates the camera around the globe.\n     *\n     * @param mapView - MapView instance.\n     * @param fromWorld - Start vector representing the scene position of a geolocation.\n     * @param toWorld - End vector representing the scene position of a geolocation.\n     */\n    function panCameraAroundGlobe(mapView, fromWorld, toWorld) {\n        cache.quaternions[0]\n            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())\n            .invert();\n        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);\n        mapView.camera.applyMatrix4(cache.matrix4[0]);\n        mapView.camera.updateMatrixWorld();\n    }\n    MapViewUtils.panCameraAroundGlobe = panCameraAroundGlobe;\n    /**\n     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the\n     * maximum possible tilt to the new target, and under the horizon in sphere projection.\n     *\n     * @param mapView - The {@link MapView} instance in use.\n     * @param deltaYawDeg - Delta yaw in degrees.\n     * @param deltaPitchDeg - Delta pitch in degrees.\n     * @param maxTiltAngleRad - Max tilt angle in radians.\n     */\n    function rotate(mapView, deltaYawDeg, deltaPitchDeg = 0, maxTiltAngleRad = Math.PI / 4) {\n        // 1. Apply yaw: rotate around the vertical axis.\n        mapView.camera.rotateOnWorldAxis(mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical\n            ? cache.vector3[0].copy(mapView.camera.position).normalize()\n            : cache.vector3[0].set(0, 0, 1), THREE.MathUtils.degToRad(-deltaYawDeg));\n        mapView.camera.updateMatrixWorld();\n        // 2. Apply pitch: rotate around the camera's local X axis.\n        if (deltaPitchDeg === 0) {\n            return;\n        }\n        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;\n        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.\n        let newPitch = THREE.MathUtils.clamp(pitch + THREE.MathUtils.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);\n        // In sphere projection, the value of a maximum pitch is smaller than the value of the\n        // maximum tilt, as the curvature of the surface adds up to it.\n        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.\n            const maxPitch = Math.asin((EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /\n                mapView.camera.position.length());\n            newPitch = Math.min(newPitch, maxPitch);\n        }\n        mapView.camera.rotateX(newPitch - pitch);\n    }\n    MapViewUtils.rotate = rotate;\n    /**\n     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations\n     * hinge on the current `projection` and `target`, because yaw and pitch are defined in\n     * tangent space of the target point.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param projection - Current projection.\n     * @param target - The camera target.\n     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg - Pitch in degrees.\n     */\n    function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg, result = new THREE.Quaternion()) {\n        const transform = cache.transforms[0];\n        projection.localTangentSpace(target, transform);\n        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n        result.setFromRotationMatrix(cache.matrix4[0]);\n        cache.quaternions[0].setFromAxisAngle(cache.vector3[1].set(0, 0, 1), THREE.MathUtils.degToRad(yawDeg));\n        cache.quaternions[1].setFromAxisAngle(cache.vector3[1].set(1, 0, 0), THREE.MathUtils.degToRad(pitchDeg));\n        result.multiply(cache.quaternions[0]);\n        result.multiply(cache.quaternions[1]);\n        return result;\n    }\n    MapViewUtils.getCameraRotationAtTarget = getCameraRotationAtTarget;\n    /**\n     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge\n     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent\n     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param mapView - Instance of MapView.\n     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg - Pitch in degrees.\n     */\n    function setRotation(mapView, yawDeg, pitchDeg) {\n        getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);\n    }\n    MapViewUtils.setRotation = setRotation;\n    /**\n     * Extracts current camera tilt angle in radians.\n     *\n     * @param camera - The [[Camera]] in use.\n     * @param projection - The {@link @here/harp-geoutils#Projection} used to\n     *                     convert between geo and world coordinates.\n     *\n     * @deprecated Use MapView.tilt\n     */\n    function extractCameraTilt(camera, projection) {\n        // For planar projections the camera target point local tangent is the same\n        // at every point on the ground (ignoring terrain fluctuations), so we may\n        // simply use inverted ground normal for tilt calculation. This simplifies\n        // the more generic calculus used for spherical projections.\n        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            const lookAt = camera.getWorldDirection(cache.vector3[0]).normalize();\n            const normal = projection\n                .surfaceNormal(camera.position, cache.vector3[1])\n                .negate();\n            const cosTheta = lookAt.dot(normal);\n            return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));\n        }\n        else {\n            // Sanity check if new projection type is introduced.\n            harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);\n            const targetGeoCoords = MapViewUtils.getGeoTargetFromCamera(camera, projection);\n            // If focus point is lost we then expose maximum allowable tilt value.\n            if (targetGeoCoords !== null) {\n                return MapViewUtils.extractTiltAngleFromLocation(projection, camera, targetGeoCoords);\n            }\n            else {\n                logger.warn(\"MapView camera is pointing in the void, using maxTilt: \", MapViewUtils.MAX_TILT_RAD);\n                return MapViewUtils.MAX_TILT_RAD;\n            }\n        }\n    }\n    MapViewUtils.extractCameraTilt = extractCameraTilt;\n    /**\n     * Extracts yaw, pitch, and roll rotation in radians.\n     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),\n     * starting north.\n     * - Pitch :Rotation around the horizontal axis.\n     * - Roll : Rotation around the view axis.\n     *\n     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\n     *\n     * @param options - Subset of necessary {@link MapView} properties.\n     * @param object - The [[THREE.Object3D]] instance to extract the rotations from.\n     */\n    function extractAttitude(mapView, object) {\n        // 1. Build the matrix of the tangent space of the object.\n        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.\n        mapView.projection.localTangentSpace(cache.vector3[1], {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].copy(cache.matrix4[1]).invert().multiply(object.matrixWorld);\n        space.x.setFromMatrixColumn(cache.matrix4[0], 0);\n        space.y.setFromMatrixColumn(cache.matrix4[0], 1);\n        space.z.setFromMatrixColumn(cache.matrix4[0], 2);\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));\n        if (d < 1.0 - Number.EPSILON) {\n            if (d > -1.0 + Number.EPSILON) {\n                yaw = Math.atan2(space.z.x, -space.z.y);\n                pitch = Math.acos(space.z.z);\n                roll = Math.atan2(space.x.z, space.y.z);\n            }\n            else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-space.y.x, space.x.x);\n                pitch = 180;\n                roll = 0;\n            }\n        }\n        else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-space.y.x, space.x.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n    MapViewUtils.extractAttitude = extractAttitude;\n    /**\n     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical\n     * coordinates of `object` in the tangent space of `location`.\n     *\n     * @param mapView - The {@link MapView} instance to consider.\n     * @param object - The object to get the coordinates from.\n     * @param location - The reference point.\n     */\n    function extractSphericalCoordinatesFromLocation(mapView, object, location) {\n        // if (projection instanceof MapView) {\n        //     logger.warn(\"Passing MapView to extractSphericalCoordinatesFromLocation is deprecated\");\n        //     projection = projection.projection;\n        // }\n        mapView.projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        let tilt = 0;\n        let azimuth = 0;\n        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with\n        // tangent Z.\n        cache.vector3[1].copy(object.position).sub(cache.vector3[0]).normalize();\n        if (cache.vector3[1].dot(tangentSpace.z) > 1 - Number.EPSILON) {\n            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.\n            azimuth = Math.PI - extractAttitude(mapView, object).yaw;\n            // Wrap between -PI and PI.\n            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));\n            tilt = 0;\n            return { tilt, azimuth };\n        }\n        tilt = cache.vector3[1].angleTo(tangentSpace.z);\n        // Tilted view: the azimuth is the direction of the object from the origin.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .projectOnPlane(tangentSpace.z)\n            .normalize();\n        azimuth = cache.vector3[1].angleTo(tangentSpace.y);\n        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {\n            azimuth = -azimuth;\n        }\n        return { tilt, azimuth };\n    }\n    MapViewUtils.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;\n    /**\n     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle\n     * (in radians) of `object` in the tangent space of `location`.\n     *\n     * @param projection - The {@link @here/harp-geoutils#Projection} used when\n     *                     converting from geo to world coordinates.\n     * @param object - The object to get the coordinates from.\n     * @param location - The reference point.\n     * @param tiltAxis - Optional axis used to define the rotation about which the object's tilt\n     * occurs, the direction vector to the location from the camera is projected on the plane with\n     * the given angle.\n     */\n    function extractTiltAngleFromLocation(projection, object, location, tiltAxis) {\n        projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        // Get point to object vector (dirVec) and compute the `tilt` as the angle with tangent Z.\n        const dirVec = cache.vector3[2].copy(object.position).sub(cache.vector3[0]);\n        if (tiltAxis) {\n            dirVec.projectOnPlane(tiltAxis);\n            tangentSpace.z.projectOnPlane(tiltAxis).normalize();\n        }\n        const dirLen = dirVec.length();\n        if (dirLen < epsilon) {\n            logger.error(\"Can not calculate tilt for the zero length vector!\");\n            return 0;\n        }\n        dirVec.divideScalar(dirLen);\n        const cosTheta = dirVec.dot(tangentSpace.z);\n        if (cosTheta >= 1 - Number.EPSILON) {\n            // Top down view.\n            return 0;\n        }\n        return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));\n    }\n    MapViewUtils.extractTiltAngleFromLocation = extractTiltAngleFromLocation;\n    /**\n     * Get perspective camera frustum planes distances.\n     * @return all plane distances in helper object.\n     */\n    function getCameraFrustumPlanes(camera) {\n        const near = camera.near;\n        const far = camera.far;\n        let top = (near * Math.tan(THREE.MathUtils.degToRad(0.5 * camera.fov))) / camera.zoom;\n        let height = 2 * top;\n        let width = camera.aspect * height;\n        let left = -0.5 * width;\n        const view = camera.view;\n        if (view !== null && view.enabled) {\n            const fullWidth = view.fullWidth;\n            const fullHeight = view.fullHeight;\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n        // Correct by skew factor\n        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;\n        return {\n            left,\n            right: left + width,\n            top,\n            bottom: top - height,\n            near,\n            far\n        };\n    }\n    MapViewUtils.getCameraFrustumPlanes = getCameraFrustumPlanes;\n    /**\n     * Casts a ray in NDC space from the current view of the camera and returns the intersection\n     * point of that ray against the map in geo coordinates. The return value can be `null` when\n     * the raycast is above the horizon.\n     *\n     * @param mapView - Instance of MapView.\n     * @param pointOnScreenXNDC -  Abscissa in NDC space.\n     * @param pointOnScreenYNDC -  Ordinate in NDC space.\n     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.\n     */\n    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {\n        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);\n        if (!worldCoordinates) {\n            return null;\n        }\n        return mapView.projection.unprojectPoint(worldCoordinates);\n    }\n    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;\n    /**\n     * Calculates and returns the distance from the ground, which is needed to put the camera to\n     * this height, to see the size of the area that would be covered by one tile for the given zoom\n     * level.\n     *\n     * @param mapView - Instance of MapView.\n     * @param options - Subset of necessary {@link MapView} properties.\n     */\n    function calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel) {\n        const cameraPitch = extractAttitude(mapView, mapView.camera).pitch;\n        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return ((mapView.focalLength * tileSize) / 256) * Math.cos(cameraPitch);\n    }\n    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;\n    /**\n     * Calculates and returns the distance to the target point.\n     *\n     * @param options - Necessary subset of MapView properties to compute the distance.\n     * @param zoomLevel - The zoom level to get the equivalent height to.\n     */\n    function calculateDistanceFromZoomLevel(options, zoomLevel) {\n        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return (options.focalLength * tileSize) / 256;\n    }\n    MapViewUtils.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;\n    /**\n     * Calculates the zoom level, which corresponds to the current distance from\n     * camera to lookAt point.\n     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in\n     * between zoom levels. By setting the zoom level, you change the height position of the camera\n     * in away that the field of view of the camera should be able to cover one tile for the given\n     * zoom level.\n     *\n     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you\n     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of\n     * you.\n     *\n     * @param options - Subset of necessary {@link MapView} properties.\n     * @param distance - The distance in meters, which are scene units in {@link MapView}.\n     */\n    function calculateZoomLevelFromDistance(options, distance) {\n        const tileSize = (256 * distance) / options.focalLength;\n        const zoomLevel = THREE.MathUtils.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);\n        return snapToCeilingZoomLevel(zoomLevel);\n    }\n    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;\n    /**\n     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.\n     * This is useful as the depth values are not stored in the depth buffer linearly, and this can\n     * lead into confusing behavior when not taken into account.\n     *\n     * @param clipDistance - Distance from the camera in clip space (range: [0, 1]).\n     * @param camera - Camera applying the perspective projection.\n     */\n    function calculateDepthFromClipDistance(clipDistance, camera) {\n        const perspCam = camera;\n        const cameraRange = perspCam.far - perspCam.near;\n        const viewSpaceDistance = clipDistance * perspCam.far;\n        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);\n    }\n    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;\n    /**\n     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n     * [0..cameraFar].\n     *\n     * @param distance - Distance from the camera (range: [0, 1]).\n     * @param camera - Camera applying the perspective projection.\n     */\n    function cameraToWorldDistance(distance, camera) {\n        const perspCam = camera;\n        return distance * perspCam.far;\n    }\n    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;\n    /**\n     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.\n     *\n     * @param hFov - Horizontal field of view in rad.\n     * @param aspect - Aspect ratio.\n     */\n    function calculateVerticalFovByHorizontalFov(hFov, aspect) {\n        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);\n    }\n    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;\n    /**\n     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.\n     *\n     * @param hFov - Vertical field of view in rad.\n     * @param aspect - Aspect ratio.\n     */\n    function calculateHorizontalFovByVerticalFov(vFov, aspect) {\n        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);\n    }\n    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;\n    /**\n     * Calculates the focal length based on the vertical FOV and height.\n     *\n     * @param vFov - Vertical field of view in rad.\n     * @param height - Height of canvas in pixels.\n     */\n    function calculateFocalLengthByVerticalFov(vFov, height) {\n        return height / 2 / Math.tan(vFov / 2);\n    }\n    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;\n    /**\n     * Calculates the vertical field of view based on the focal length and the height.\n     *\n     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param height - Height of canvas in pixels.\n     */\n    function calculateFovByFocalLength(focalLength, height) {\n        return THREE.MathUtils.radToDeg(2 * Math.atan(height / 2 / focalLength));\n    }\n    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;\n    /**\n     * Calculates object's screen size based on the focal length and it's camera distance.\n     *\n     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance - Object distance in world space.\n     * @param worldSize - Object size in world space.\n     * @return object size in screen space.\n     */\n    function calculateScreenSizeByFocalLength(focalLength, distance, worldSize) {\n        return (focalLength * worldSize) / distance;\n    }\n    MapViewUtils.calculateScreenSizeByFocalLength = calculateScreenSizeByFocalLength;\n    /**\n     * Calculates object's world size based on the focal length and it's camera distance.\n     *\n     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance - Object distance in world space.\n     * @param screenSize - Object size in screen space.\n     * @return object size in world space.\n     */\n    function calculateWorldSizeByFocalLength(focalLength, distance, screenSize) {\n        return (distance * screenSize) / focalLength;\n    }\n    MapViewUtils.calculateWorldSizeByFocalLength = calculateWorldSizeByFocalLength;\n    /**\n     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials\n     * and/or attributes will be counted multiple times.\n     *\n     * @param object - The mesh object to evaluate\n     * @param size - The {@link MemoryUsage} to update.\n     * @param visitedObjects - Optional map to store large objects that could be shared.\n     *\n     * @returns Estimate of object size in bytes for heap and GPU.\n     */\n    function estimateObject3dSize(object, parentSize, visitedObjects) {\n        const size = parentSize !== undefined\n            ? parentSize\n            : {\n                heapSize: 0,\n                gpuSize: 0\n            };\n        if (visitedObjects === undefined) {\n            visitedObjects = new Map();\n        }\n        estimateMeshSize(object, size, visitedObjects);\n        if (object.children.length > 0) {\n            for (const child of object.children) {\n                estimateObject3dSize(child, size, visitedObjects);\n            }\n        }\n        return size;\n    }\n    MapViewUtils.estimateObject3dSize = estimateObject3dSize;\n    /**\n     * Check if tiles or other content is currently being loaded.\n     *\n     * This method can be removed once HARP-7932 is implemented.\n     *\n     * @returns `true` if MapView has visible tiles or other content that is being loaded.\n     */\n    function mapViewIsLoading(mapView) {\n        let numTilesLoading = 0;\n        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {\n            numTilesLoading += tileList.numTilesLoading;\n            for (const tile of tileList.visibleTiles) {\n                if (!tile.allGeometryLoaded) {\n                    numTilesLoading++;\n                }\n            }\n        }\n        let isLoading = numTilesLoading > 0;\n        if (mapView.textElementsRenderer !== undefined) {\n            isLoading = isLoading || mapView.textElementsRenderer.loading;\n        }\n        isLoading =\n            isLoading ||\n                !mapView.poiTableManager.finishedLoading ||\n                !mapView.visibleTileSet.allVisibleTilesLoaded;\n        return isLoading;\n    }\n    MapViewUtils.mapViewIsLoading = mapViewIsLoading;\n    function closeToFrustum(point, camera, eps = 1e-13) {\n        const ndcPoint = new THREE.Vector3().copy(point).project(camera);\n        if (Math.abs(ndcPoint.x) - eps < 1 &&\n            Math.abs(ndcPoint.y) - eps < 1 &&\n            Math.abs(ndcPoint.z) - eps < 1) {\n            return true;\n        }\n        return false;\n    }\n    MapViewUtils.closeToFrustum = closeToFrustum;\n    function estimateTextureSize(texture, objectSize, visitedObjects) {\n        if (texture === null ||\n            texture === undefined ||\n            texture.image === undefined ||\n            texture.image === null) {\n            return;\n        }\n        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(texture.uuid, true);\n        // May be HTMLImage or ImageData\n        const image = texture.image;\n        // Assuming RGBA\n        const imageBytes = 4 * image.width * image.height;\n        objectSize.heapSize += imageBytes;\n        objectSize.gpuSize += imageBytes;\n    }\n    function estimateMaterialSize(material, objectSize, visitedObjects) {\n        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(material.uuid, true);\n        if (material instanceof THREE.RawShaderMaterial ||\n            material instanceof THREE.ShaderMaterial) {\n            const rawMaterial = material;\n            for (const name in rawMaterial.uniforms) {\n                if (rawMaterial.uniforms[name] !== undefined) {\n                    const uniform = rawMaterial.uniforms[name];\n                    if (uniform instanceof THREE.Texture) {\n                        estimateTextureSize(uniform, objectSize, visitedObjects);\n                    }\n                }\n            }\n        }\n        else if (material instanceof THREE.MeshBasicMaterial ||\n            material instanceof harp_materials_1.MapMeshBasicMaterial) {\n            const meshMaterial = material;\n            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);\n        }\n        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {\n            const standardMaterial = material;\n            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);\n        }\n        else if (material instanceof THREE.LineBasicMaterial ||\n            material instanceof THREE.LineDashedMaterial ||\n            material instanceof THREE.PointsMaterial) {\n            // Nothing to be done here\n        }\n        else {\n            logger.warn(\"estimateMeshSize: unidentified material: \", material);\n        }\n    }\n    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {\n        // Attributes (apparently) do not have their uuid set up.\n        if (attribute.uuid === undefined) {\n            attribute.uuid = THREE.MathUtils.generateUUID();\n        }\n        if (visitedObjects.get(attribute.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(attribute.uuid, true);\n        let attrBytes = 0;\n        let bytesPerElement = 4;\n        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {\n            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;\n        }\n        if (attribute instanceof THREE.InterleavedBufferAttribute ||\n            attribute instanceof THREE.BufferAttribute) {\n            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;\n        }\n        else {\n            logger.warn(\"estimateMeshSize: unidentified attribute: \", attrName);\n        }\n        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;\n        objectSize.gpuSize += attrBytes;\n    }\n    function estimateGeometrySize(geometry, objectSize, visitedObjects) {\n        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;\n        if (!isNewObject) {\n            return;\n        }\n        visitedObjects.set(geometry.uuid, true);\n        let bufferGeometry;\n        if (geometry instanceof THREE.Geometry) {\n            // Each vertex is represented as 3 floats vector (24 bytes).\n            objectSize.heapSize += geometry.vertices.length * 24;\n            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and\n            // colors are not counted here.\n            objectSize.heapSize += geometry.faces.length * (24 + 24);\n            // Additionally, the internal _bufferGeometry is also counted:\n            bufferGeometry = geometry._bufferGeometry;\n        }\n        else if (geometry instanceof THREE.BufferGeometry) {\n            bufferGeometry = geometry;\n        }\n        if (bufferGeometry === undefined) {\n            // Nothing more to calculate.\n            return;\n        }\n        const attributes = bufferGeometry.attributes;\n        if (attributes === undefined) {\n            logger.warn(\"estimateGeometrySize: unidentified geometry: \", geometry);\n            return;\n        }\n        for (const property in attributes) {\n            if (attributes[property] !== undefined) {\n                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);\n            }\n        }\n        if (bufferGeometry.index !== null) {\n            estimateAttributeSize(bufferGeometry.index, \"index\", objectSize, visitedObjects);\n        }\n    }\n    function estimateMeshSize(object, objectSize, visitedObjects) {\n        if (!object.isObject3D || object instanceof THREE.Scene) {\n            return;\n        }\n        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(object.uuid, true);\n        if (object.isMesh || object.isLine || object.isPoints) {\n            // Estimated minimum impact on heap.\n            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;\n            const gpuSize = 0;\n            // Cast to LodMesh class which contains the minimal required properties sub-set.\n            const mesh = object;\n            // Calculate material(s) impact.\n            if (mesh.material !== undefined) {\n                if (Array.isArray(mesh.material)) {\n                    const materials = mesh.material;\n                    for (const material of materials) {\n                        estimateMaterialSize(material, objectSize, visitedObjects);\n                    }\n                }\n                else {\n                    const material = mesh.material;\n                    estimateMaterialSize(material, objectSize, visitedObjects);\n                }\n            }\n            // Calculate cost of geometry.\n            if (mesh.geometries !== undefined) {\n                for (const geometry of mesh.geometries) {\n                    estimateGeometrySize(geometry, objectSize, visitedObjects);\n                }\n            }\n            else if (mesh.geometry !== undefined) {\n                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);\n            }\n            // Add info that is required for picking (parts of) objects and match them to\n            // the featureID in the map data.\n            const featureData = object.userData !== undefined\n                ? object.userData.feature\n                : undefined;\n            if (featureData !== undefined) {\n                heapSize += Tile_1.getFeatureDataSize(featureData);\n            }\n            objectSize.heapSize += heapSize;\n            objectSize.gpuSize += gpuSize;\n        }\n        else {\n            logger.warn(\"estimateMeshSize: unidentified object\", object);\n        }\n    }\n    /**\n     * Gets language list used by the browser\n     *\n     * @returns Array of iso language codes\n     */\n    function getBrowserLanguages() {\n        if (navigator.languages !== undefined && navigator.languages.length > 0) {\n            const languageList = [];\n            for (const lang of navigator.languages) {\n                languageList.push(getIsoLanguageCode(lang));\n            }\n            return languageList;\n        }\n        if (navigator.language !== undefined) {\n            return [getIsoLanguageCode(navigator.language)];\n        }\n        return undefined;\n    }\n    MapViewUtils.getBrowserLanguages = getBrowserLanguages;\n    /**\n     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)\n     */\n    function getIsoLanguageCode(language) {\n        return language.substring(0, 2);\n    }\n})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000\n];\nvar TileOffsetUtils;\n(function (TileOffsetUtils) {\n    /**\n     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the\n     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because\n     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the\n     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24\n     * levels. Given the current support up to level 19 this should be fine.\n     *\n     * @param tileKey - The unique {@link @here/harp-geoutils#TileKey}\n     *                  from which to compute the unique key.\n     * @param offset - How much the given {@link @here/harp-geoutils#TileKey} is offset\n     * @param bitshift - How much space we have to store the offset. The default of 4 means we have\n     *      enough space to store 16 unique tiles in a single view.\n     */\n    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {\n        const shiftedOffset = getShiftedOffset(offset, bitshift);\n        return tileKey.mortonCode() + shiftedOffset;\n    }\n    TileOffsetUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;\n    /**\n     * Extracts the offset and morton key from the given key (must be created by:\n     * [[getKeyForTileKeyAndOffset]])\n     *\n     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and\n     * would truncate the numbers, hence using powers of two.\n     *\n     * @param key - Key to extract offset and morton key.\n     * @param bitshift - How many bits to shift by, must be the same as was used when creating the\n     * key.\n     */\n    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {\n        let offset = 0;\n        let mortonCode = key;\n        let i = 0;\n        // Compute the offset\n        for (; i < bitshift; i++) {\n            // Note, we use 52, because 2^53-1 is the biggest value, the highest value\n            // that can be set is the bit in the 52th position.\n            const num = powerOfTwo[52 - i];\n            if (mortonCode >= num) {\n                mortonCode -= num;\n                offset += powerOfTwo[bitshift - 1 - i];\n            }\n        }\n        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset\n        offset -= powerOfTwo[bitshift - 1];\n        return { offset, mortonCode };\n    }\n    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;\n    /**\n     * Returns the key of the parent. Key must have been computed using the function\n     * [[getKeyForTileKeyAndOffset]].\n     *\n     * @param calculatedKey - Key to decompose\n     * @param bitshift - Bit shift used to create the key\n     */\n    function getParentKeyFromKey(calculatedKey, bitshift = 4) {\n        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);\n        const parentTileKey = harp_geoutils_1.TileKey.fromMortonCode(harp_geoutils_1.TileKey.parentMortonCode(mortonCode));\n        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);\n    }\n    TileOffsetUtils.getParentKeyFromKey = getParentKeyFromKey;\n    /**\n     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and\n     * 2^(52-bitshift).\n     *\n     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really\n     * matter, this is primarily used to find a unique id, if there is an offset 10, which is\n     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.\n     * What can be a problem though is that the cache gets filled up and isn't emptied.\n     *\n     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set\n     * the high bits instead.\n     *\n     * @param offset - Offset to pack into the high bits.\n     * @param offsetBits - How many bits to use to pack the offset.\n     */\n    function getShiftedOffset(offset, offsetBits = 4) {\n        let result = 0;\n        const totalOffsetsToStore = powerOfTwo[offsetBits];\n        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,\n        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -\n        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be\n        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).\n        offset += totalOffsetsToStore / 2;\n        while (offset < 0) {\n            offset += totalOffsetsToStore;\n        }\n        while (offset >= totalOffsetsToStore) {\n            offset -= totalOffsetsToStore;\n        }\n        // Offset is now a number between >= 0 and < totalOffsetsToStore\n        for (let i = 0; i < offsetBits && offset > 0; i++) {\n            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an\n            // integer safely.\n            if (offset & 0x1) {\n                result += powerOfTwo[53 - offsetBits + i];\n            }\n            offset >>>= 1;\n        }\n        harp_utils_1.assert(offset === 0);\n        return result;\n    }\n})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));\n//# sourceMappingURL=Utils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/VisibleTileSet.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VisibleTileSet = exports.ResourceComputationType = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ \"./node_modules/@here/harp-lrucache/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ \"./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js\");\nconst FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ \"./node_modules/@here/harp-mapview/lib/FrustumIntersection.js\");\nconst MapView_1 = __webpack_require__(/*! ./MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\n/**\n * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If\n * it is in MB, an estimation is used.\n */\nvar ResourceComputationType;\n(function (ResourceComputationType) {\n    ResourceComputationType[ResourceComputationType[\"EstimationInMb\"] = 0] = \"EstimationInMb\";\n    ResourceComputationType[ResourceComputationType[\"NumberOfTiles\"] = 1] = \"NumberOfTiles\";\n})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));\n// Direction in quad tree to search: up -> shallower levels, down -> deeper levels.\nvar SearchDirection;\n(function (SearchDirection) {\n    SearchDirection[SearchDirection[\"NONE\"] = 0] = \"NONE\";\n    SearchDirection[SearchDirection[\"UP\"] = 1] = \"UP\";\n    SearchDirection[SearchDirection[\"DOWN\"] = 2] = \"DOWN\";\n    SearchDirection[SearchDirection[\"BOTH\"] = 3] = \"BOTH\";\n})(SearchDirection || (SearchDirection = {}));\nconst MB_FACTOR = 1.0 / (1024.0 * 1024.0);\n/**\n * Wrapper for LRU cache that encapsulates tiles caching for any {@link DataSource} used.\n *\n * Provides LRU based caching mechanism where each tile is identified by its tile key\n * (morton code) and data source name.\n * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted\n * only when cache reaches full saturation and tile is no longer visible.\n * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and\n * data source name, thus it is required that each {@link DataSource} used should have unique\n * name, but implementation could be improved to omit this limitation.\n */\nclass DataSourceCache {\n    constructor(cacheSize, rct = ResourceComputationType.EstimationInMb) {\n        this.m_disposedTiles = [];\n        this.m_resourceComputationType = rct;\n        this.m_tileCache = new harp_lrucache_1.LRUCache(cacheSize, (tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            }\n            else {\n                return 1;\n            }\n        });\n        this.m_tileCache.evictionCallback = (_, tile) => {\n            if (tile.tileLoader !== undefined) {\n                // Cancel downloads as early as possible.\n                tile.tileLoader.cancel();\n            }\n            this.m_disposedTiles.push(tile);\n        };\n        this.m_tileCache.canEvict = (_, tile) => {\n            // Tiles can be evicted that weren't requested in the last frame.\n            return !tile.isVisible;\n        };\n    }\n    /**\n     * Creates unique tile key for caching based on morton code, tile offset and its data source.\n     *\n     * @param mortonCode - The tile morton code.\n     * @param offset - The tile offset.\n     * @param dataSource - The {@link DataSource} from which tile was loaded.\n     */\n    static getKey(mortonCode, offset, dataSource) {\n        return `${dataSource.name}_${mortonCode}_${offset}`;\n    }\n    /**\n     * Create unique tile identifier for caching, based on tile object passed in.\n     *\n     * @param tile - The tile for which key is generated.\n     */\n    static getKeyForTile(tile) {\n        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);\n    }\n    /**\n     * Get information how cached tiles affects cache space available.\n     *\n     * The way how cache evaluates the __resources size__ have a big influence on entire\n     * caching mechanism, if [[resourceComputationType]] is set to:\n     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size\n     * differently depending on the memory consumed, on other side\n     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,\n     * so its real memory consumed does not matter affect caching behavior. Of course in\n     * the second scenario cache may grow significantly in terms of memory usage and thus it\n     * is out of control.\n     *\n     * @return [[ResourceComputationType]] enum that describes if resources are counted by\n     * space occupied in memory or just by number of them.\n     */\n    get resourceComputationType() {\n        return this.m_resourceComputationType;\n    }\n    /**\n     * Get the cache capacity measured as number if megabytes or number of entries.\n     *\n     * The total cached tiles size determines cache saturation, if it reaches the capacity value\n     * then the resources becomes evicted (released) starting from the oldest (the latest used).\n     *\n     * @see size.\n     * @see resourceComputationType.\n     */\n    get capacity() {\n        return this.m_tileCache.capacity;\n    }\n    /**\n     * Get total cache size described as number of megabytes consumed or number of tiles stored.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     */\n    get size() {\n        return this.m_tileCache.size;\n    }\n    /**\n     * Set cache capacity and the algorithm used for cache size calculation.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     * @param size - The new capacity declared in megabytes or number of entires.\n     * @param rct - The enum value that determines how size and capacity are evaluated.\n     */\n    setCapacity(size, rct) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache.setCapacityAndMeasure(size, (tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            }\n            else {\n                return 1;\n            }\n        });\n    }\n    /**\n     * Get tile cached or __undefined__ if tile is not yet in cache.\n     *\n     * @param mortonCode - An unique tile morton code.\n     * @param offset - Tile offset.\n     * @param dataSource - A {@link DataSource} the tile comes from.\n     */\n    get(mortonCode, offset, dataSource) {\n        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));\n    }\n    /**\n     * Add new tile to the cache.\n     *\n     * @param mortonCode - En unique tile code (morton code).\n     * @param offset - The tile offset.\n     * @param dataSource - A {@link DataSource} the tile comes from.\n     * @param tile - The tile reference.\n     */\n    set(mortonCode, offset, dataSource, tile) {\n        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);\n    }\n    /**\n     * Delete tile from cache.\n     *\n     * @note This method will not call eviction callback.\n     * @param tile - The tile reference to be removed from cache.\n     */\n    delete(tile) {\n        const tileKey = DataSourceCache.getKeyForTile(tile);\n        this.deleteByKey(tileKey);\n    }\n    /**\n     * Delete tile using its unique identifier.\n     *\n     * @note Tile identifier its constructed using information about tile code (morton code) and its\n     * {@link DataSource}.\n     * @note This is explicit removal thus eviction callback will not be processed.\n     * @see DataSourceCache.getKey.\n     * @param tileKey - The unique tile identifier.\n     */\n    deleteByKey(tileKey) {\n        this.m_tileCache.delete(tileKey);\n    }\n    /**\n     * Dispose all tiles releasing their internal data.\n     */\n    disposeTiles() {\n        this.m_disposedTiles.forEach(tile => {\n            tile.dispose();\n        });\n        this.m_disposedTiles.length = 0;\n    }\n    /**\n     * Shrink cache to its allowed capacity.\n     *\n     * This method should be called each time after operations are performed on the cache entries,\n     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory\n     * consumed by its entries and check if cache is overgrown, is such case some tiles will be\n     * evicted.\n     */\n    shrinkToCapacity() {\n        this.m_tileCache.shrinkToCapacity();\n    }\n    /**\n     * Evict all cached tiles implicitly even without checking if still in use.\n     */\n    evictAll() {\n        this.m_tileCache.evictAll();\n    }\n    /**\n     * Evict selected tiles implicitly.\n     *\n     * @param selector - The callback used to determine if tile should be evicted.\n     */\n    evictSelected(selector) {\n        this.m_tileCache.evictSelected(selector);\n    }\n    /**\n     * Call functor (callback) on each tile store in cache.\n     *\n     * Optionally you may specify from which {@link DataSource} tiles should be processed.\n     * This limits the tiles visited to a sub-set originating from single {@link DataSource}.\n     * @param callback - The function to be called for each visited tile.\n     * @param inDataSource - The optional {@link DataSource} to which tiles should belong.\n     */\n    forEach(callback, inDataSource) {\n        this.m_tileCache.forEach((entry, key) => {\n            if (inDataSource === undefined || entry.dataSource === inDataSource) {\n                callback(entry, key);\n            }\n        });\n    }\n}\n// Sort by distance to camera, now the tiles that are further away are at the end\n// of the list.\n//\n// Sort is unstable if distance is equal, which happens a lot when looking top-down.\n// Unstable sorting makes label placement unstable at tile borders, leading to\n// flickering.\nconst compareDistances = (a, b) => {\n    const distanceDiff = a.distance - b.distance;\n    // Take care or numerical precision issues\n    const minDiff = (a.distance + b.distance) * 0.000001;\n    return Math.abs(distanceDiff) < minDiff\n        ? a.tileKey.mortonCode() - b.tileKey.mortonCode()\n        : distanceDiff;\n};\n/**\n * Manages visible {@link Tile}s for {@link MapView}.\n *\n * Responsible for election of rendered tiles:\n *  - quad-tree traversal\n *  - frustum culling\n *  - sorting tiles by relevance (visible area) to prioritize load\n *  - limiting number of visible tiles\n *  - caching tiles\n *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby\n *    zoom levels\n */\nclass VisibleTileSet {\n    constructor(m_frustumIntersection, m_tileGeometryManager, options, m_taskQueue) {\n        var _a;\n        this.m_frustumIntersection = m_frustumIntersection;\n        this.m_tileGeometryManager = m_tileGeometryManager;\n        this.options = options;\n        this.m_taskQueue = m_taskQueue;\n        this.dataSourceTileList = [];\n        this.allVisibleTilesLoaded = false;\n        this.m_cameraOverride = new THREE.PerspectiveCamera();\n        this.m_viewRange = {\n            near: 0.1,\n            far: Infinity,\n            minimum: 0.1,\n            maximum: Infinity\n        };\n        // Maps morton codes to a given Tile, used to find overlapping Tiles. We only need to have this\n        // for a single TilingScheme, i.e. that of the BackgroundDataSource.\n        this.m_coveringMap = new Map();\n        this.m_resourceComputationType = ResourceComputationType.EstimationInMb;\n        this.options = options;\n        this.options.maxTilesPerFrame = Math.floor((_a = this.options.maxTilesPerFrame) !== null && _a !== void 0 ? _a : 0);\n        this.m_resourceComputationType =\n            options.resourceComputationType === undefined\n                ? ResourceComputationType.EstimationInMb\n                : options.resourceComputationType;\n        this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);\n    }\n    /**\n     * Returns cache size.\n     */\n    getDataSourceCacheSize() {\n        return this.options.tileCacheSize;\n    }\n    /**\n     * Sets cache size.\n     *\n     * @param size - cache size\n     * @param computationType - Optional value specifying the way a {@link Tile}s cache usage is\n     *      computed, either based on size in MB (mega bytes) or in number of tiles. Defaults to\n     *      `ResourceComputationType.EstimationInMb`.\n     */\n    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {\n        this.options.tileCacheSize = size;\n        // This effectively invalidates DataSourceCache\n        this.resourceComputationType = computationType;\n    }\n    /**\n     * Retrieves maximum number of visible tiles.\n     */\n    getNumberOfVisibleTiles() {\n        return this.options.maxVisibleDataSourceTiles;\n    }\n    /**\n     * Sets maximum number of visible tiles.\n     *\n     * @param size - size of visible tiles array\n     */\n    setNumberOfVisibleTiles(size) {\n        this.options.maxVisibleDataSourceTiles = size;\n    }\n    /**\n     * Gets the maximum number of tiles that can be added to the scene per frame\n     * @beta\n     * @internal\n     */\n    get maxTilesPerFrame() {\n        return this.options.maxTilesPerFrame;\n    }\n    /**\n     * Gets the maximum number of tiles that can be added to the scene per frame\n     * @beta\n     * @internal\n     * @param value\n     */\n    set maxTilesPerFrame(value) {\n        if (value < 0) {\n            throw new Error(\"Invalid value, this will result in no tiles ever showing\");\n        }\n        this.options.maxTilesPerFrame = Math.floor(value);\n    }\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType() {\n        return this.m_resourceComputationType;\n    }\n    /**\n     * Sets the way tile cache is managing its elements.\n     *\n     * Cache may be either keeping number of elements stored or the memory consumed by them.\n     *\n     * @param computationType - Type of algorith used in cache for checking full saturation,\n     * may be counting number of elements or memory consumed by them.\n     */\n    set resourceComputationType(computationType) {\n        this.m_resourceComputationType = computationType;\n        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);\n    }\n    /**\n     * Evaluate frustum near/far clip planes and visibility ranges.\n     */\n    updateClipPlanes(maxElevation, minElevation) {\n        if (maxElevation !== undefined) {\n            this.options.clipPlanesEvaluator.maxElevation = maxElevation;\n        }\n        if (minElevation !== undefined) {\n            this.options.clipPlanesEvaluator.minElevation = minElevation;\n        }\n        const { camera, projection, elevationProvider } = this.m_frustumIntersection.mapView;\n        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(camera, projection, elevationProvider);\n        return this.m_viewRange;\n    }\n    /**\n     * Calculates a new set of visible tiles.\n     * @param storageLevel - The camera storage level, see {@link MapView.storageLevel}.\n     * @param zoomLevel - The camera zoom level.\n     * @param dataSources - The data sources for which the visible tiles will be calculated.\n     * @param elevationRangeSource - Source of elevation range data if any.\n     * @returns view ranges and their status since last update (changed or not).\n     */\n    updateRenderList(storageLevel, zoomLevel, dataSources, frameNumber, elevationRangeSource) {\n        let allVisibleTilesLoaded = true;\n        // This isn't really const, because we pass by ref to the methods below.\n        const newTilesPerFrame = 0;\n        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);\n        this.dataSourceTileList = [];\n        this.m_coveringMap.clear();\n        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {\n            visibleTileKeys.sort(compareDistances);\n            // Create actual tiles only for the allowed number of visible tiles\n            const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);\n            const visibleResult = this.processVisibleTiles(visibleTileKeys, dataSource, frameNumber, {\n                newTilesPerFrame\n            }, true);\n            const dependentResult = this.processVisibleTiles(visibleResult.dependentTiles, dataSource, frameNumber, {\n                newTilesPerFrame\n            }, false);\n            // creates geometry if not yet available\n            this.m_tileGeometryManager.updateTiles(visibleResult.visibleTiles);\n            this.m_tileGeometryManager.updateTiles(dependentResult.visibleTiles);\n            // used to actually render the tiles or find alternatives for incomplete tiles\n            this.dataSourceTileList.push({\n                dataSource,\n                storageLevel,\n                zoomLevel: dataZoomLevel,\n                allVisibleTileLoaded: visibleResult.allDataSourceTilesLoaded &&\n                    dependentResult.allDataSourceTilesLoaded,\n                numTilesLoading: visibleResult.numTilesLoading + dependentResult.numTilesLoading,\n                visibleTiles: [...visibleResult.visibleTiles, ...dependentResult.visibleTiles],\n                renderedTiles: new Map()\n            });\n            allVisibleTilesLoaded = allVisibleTilesLoaded && visibleResult.allDataSourceTilesLoaded;\n        }\n        this.allVisibleTilesLoaded =\n            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;\n        this.populateRenderedTiles();\n        this.forEachCachedTile(tile => {\n            // Remove all tiles that are still being loaded, but are no longer visible. They have to\n            // be reloaded when they become visible again. Hopefully, they are still in the browser\n            // cache by then.\n            if (!tile.isVisible && !tile.allGeometryLoaded) {\n                // The internal TileLoader is cancelled automatically when the Tile is disposed.\n                this.disposeTile(tile);\n            }\n        });\n        this.m_dataSourceCache.shrinkToCapacity();\n        let minElevation;\n        let maxElevation;\n        this.dataSourceTileList.forEach(renderListEntry => {\n            // Calculate min/max elevation from every data source tiles,\n            // data sources without elevationRangeSource will contribute to\n            // values with zero levels for both elevations.\n            const tiles = renderListEntry.renderedTiles;\n            tiles.forEach(tile => {\n                tile.update(renderListEntry.zoomLevel);\n                minElevation = harp_utils_1.MathUtils.min2(minElevation, tile.geoBox.minAltitude);\n                maxElevation = harp_utils_1.MathUtils.max2(maxElevation, tile.geoBox.maxAltitude);\n            });\n        });\n        if (minElevation === undefined) {\n            minElevation = 0;\n        }\n        if (maxElevation === undefined) {\n            maxElevation = 0;\n        }\n        // If clip planes evaluator depends on the tiles elevation re-calculate\n        // frustum planes and update the camera near/far plane distances.\n        let viewRangesChanged = false;\n        const oldViewRanges = this.m_viewRange;\n        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);\n        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;\n        return {\n            viewRanges: newViewRanges,\n            viewRangesChanged\n        };\n    }\n    /**\n     * Gets the tile corresponding to the given data source, key and offset, creating it if\n     * necessary.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @param frameNumber - Frame in which the tile was requested\n     * @return The tile if it was found or created, undefined otherwise.\n     */\n    getTile(dataSource, tileKey, offset, frameNumber) {\n        const cacheOnly = false;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);\n    }\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the cache.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @param frameNumber - Frame in which the tile was requested\n     * @return The tile if found in cache, undefined otherwise.\n     */\n    getCachedTile(dataSource, tileKey, offset, frameNumber) {\n        harp_utils_1.assert(dataSource.cacheable);\n        const cacheOnly = true;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);\n    }\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTile(dataSource, tileKey, offset = 0) {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n        return dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset));\n    }\n    /**\n     * Gets the tile corresponding to the given data source and location from the rendered tiles.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param geoPoint - The geolocation included within the tile.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTileAtLocation(dataSource, geoPoint, offset = 0) {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n        const tilingScheme = dataSource.getTilingScheme();\n        const visibleLevel = dataSourceVisibleTileList.zoomLevel;\n        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);\n        if (!visibleTileKey) {\n            return undefined;\n        }\n        let tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));\n        if (tile !== undefined) {\n            return tile;\n        }\n        const { searchLevelsUp, searchLevelsDown } = this.getSearchDirection(dataSource, visibleLevel);\n        let parentTileKey = visibleTileKey;\n        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {\n            parentTileKey = parentTileKey.parent();\n            tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));\n            if (tile !== undefined) {\n                return tile;\n            }\n        }\n        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);\n        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {\n            const childLevel = visibleLevel + levelOffset;\n            const childTileKey = harp_geoutils_1.TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);\n            if (childTileKey) {\n                tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset));\n                if (tile !== undefined) {\n                    return tile;\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Removes all internal bookkeeping entries and cache related to specified datasource.\n     *\n     * Called by {@link MapView} when {@link DataSource} has been removed from {@link MapView}.\n     */\n    removeDataSource(dataSource) {\n        this.clearTileCache(dataSource);\n        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource !== dataSource);\n    }\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the {@link Tile} objects created by cacheable {@link DataSource}.\n     * If a {@link DataSource} name is\n     * provided, this method restricts the eviction\n     * the {@link DataSource} with the given name.\n     *\n     * @param dataSourceName - The name of the {@link DataSource}.\n     * @param filter Optional tile filter\n     */\n    clearTileCache(dataSource, filter) {\n        if (dataSource !== undefined) {\n            this.m_dataSourceCache.evictSelected((tile, _) => {\n                return (tile.dataSource === dataSource && (filter !== undefined ? filter(tile) : true));\n            });\n        }\n        else if (filter !== undefined) {\n            this.m_dataSourceCache.evictSelected(filter);\n        }\n        else {\n            this.m_dataSourceCache.evictAll();\n        }\n    }\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance\n     *      are processed. If `undefined`, tiles from all {@link DataSource}s are processed.\n     * @param filter Optional tile filter\n     */\n    markTilesDirty(dataSource, filter) {\n        if (dataSource === undefined) {\n            this.dataSourceTileList.forEach(renderListEntry => {\n                this.markDataSourceTilesDirty(renderListEntry, filter);\n            });\n        }\n        else {\n            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);\n            if (renderListEntry === undefined) {\n                return;\n            }\n            this.markDataSourceTilesDirty(renderListEntry, filter);\n        }\n    }\n    /**\n     * Dispose tiles that are marked for removal by {@link @here/harp-lrucache#LRUCache} algorithm.\n     */\n    disposePendingTiles() {\n        this.m_dataSourceCache.disposeTiles();\n    }\n    /**\n     * Process callback function [[fun]] with each visible tile in set.\n     *\n     * @param fun - The callback function to be called.\n     */\n    forEachVisibleTile(fun) {\n        for (const listEntry of this.dataSourceTileList) {\n            listEntry.renderedTiles.forEach(fun);\n        }\n    }\n    /**\n     * Process callback function [[fun]] with each tile in the cache.\n     *\n     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to\n     * DataSource passed in.\n     *\n     * @param fun - The callback function to be called.\n     * @param dataSource - The optional DataSource reference for tiles selection.\n     */\n    forEachCachedTile(fun, dataSource) {\n        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);\n    }\n    /**\n     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.\n     */\n    disposeTile(tile) {\n        // TODO: Consider using evict here!\n        this.m_dataSourceCache.delete(tile);\n        tile.dispose();\n    }\n    // Requests the tiles using the tilekeys from the DataSource and returns them, including whether\n    // all tiles were loaded and how many are loading.\n    processVisibleTiles(visibleTileKeys, dataSource, frameNumber, \n    // Must be passed by reference\n    refs, processDependentTiles) {\n        var _a;\n        let allDataSourceTilesLoaded = true;\n        let numTilesLoading = 0;\n        const visibleTiles = [];\n        const dependentTiles = [];\n        for (let i = 0; i < visibleTileKeys.length &&\n            visibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {\n            const tileEntry = visibleTileKeys[i];\n            const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset, frameNumber);\n            if (tile === undefined) {\n                continue;\n            }\n            visibleTiles.push(tile);\n            allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;\n            if (!tile.allGeometryLoaded) {\n                numTilesLoading++;\n            }\n            else {\n                // If this tile's data source is \"covering\" then other tiles beneath it have\n                // their rendering skipped, see [[Tile.willRender]].\n                this.skipOverlappedTiles(dataSource, tile);\n                if (this.processDelayTileRendering(tile, refs.newTilesPerFrame, frameNumber)) {\n                    refs.newTilesPerFrame++;\n                }\n            }\n            // Update the visible area of the tile. This is used for those tiles that are\n            // currently loaded and are waiting to be decoded to sort the jobs by area.\n            tile.visibleArea = tileEntry.area;\n            tile.elevationRange = (_a = tileEntry.elevationRange) !== null && _a !== void 0 ? _a : { minElevation: 0, maxElevation: 0 };\n            if (processDependentTiles) {\n                // Add any dependent tileKeys if not already visible. Consider to optimize with a\n                // Set if this proves to be a bottleneck (because of O(n^2) search). Given the fact\n                // that dependencies are rare and used for non tiled data, this shouldn't be a\n                // problem.\n                for (const tileKey of tile.dependencies) {\n                    if (visibleTileKeys.find(tileKeyEntry => tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()) === undefined) {\n                        dependentTiles.push(new FrustumIntersection_1.TileKeyEntry(tileKey, 0));\n                    }\n                }\n            }\n        }\n        return {\n            allDataSourceTilesLoaded,\n            numTilesLoading,\n            visibleTiles,\n            dependentTiles\n        };\n    }\n    // Processes if the tile should delay its rendering, returns if the tile is new, which is needed\n    // to count how many tiles are generated per frame.\n    processDelayTileRendering(tile, newTilesPerFrame, frameNumber) {\n        let isNewTile = false;\n        if (\n        // if set to 0, it will ignore the limit and upload all available\n        this.options.maxTilesPerFrame !== 0 &&\n            newTilesPerFrame > this.options.maxTilesPerFrame &&\n            //if the tile was already visible last frame dont delay it\n            !(tile.frameNumLastVisible === frameNumber - 1)) {\n            tile.delayRendering = true;\n            tile.mapView.update();\n        }\n        else {\n            if (tile.frameNumVisible < 0) {\n                // Store the fist frame the tile became visible.\n                tile.frameNumVisible = frameNumber;\n                isNewTile = true;\n            }\n            tile.numFramesVisible++;\n            tile.delayRendering = false;\n        }\n        return isNewTile;\n    }\n    /**\n     * Skips rendering of tiles that are overlapped. The overlapping {@link Tile} comes from a\n     * {@link DataSource} which is fully covering, i.e. there it is fully opaque.\n     **/\n    skipOverlappedTiles(dataSource, tile) {\n        if (this.options.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // HARP-7899, currently the globe has no background planes in the tiles (it relies on\n            // the BackgroundDataSource), because the LOD mismatches, hence disabling for globe.\n            return;\n        }\n        if (dataSource.isFullyCovering()) {\n            const key = tile.uniqueKey;\n            const entry = this.m_coveringMap.get(key);\n            if (entry === undefined) {\n                // We need to reset the flag so that if the covering datasource is disabled, that\n                // the tiles beneath then start to render.\n                tile.skipRendering = false;\n                this.m_coveringMap.set(key, tile);\n            }\n            else {\n                // Skip the Tile if either the stored entry or the tile to consider is from the\n                // [[BackgroundDataSource]]\n                if (entry.dataSource instanceof BackgroundDataSource_1.BackgroundDataSource) {\n                    entry.skipRendering = true;\n                }\n                else if (dataSource instanceof BackgroundDataSource_1.BackgroundDataSource) {\n                    tile.skipRendering = true;\n                }\n            }\n        }\n    }\n    // Returns the search direction and the number of levels up / down that can be searched.\n    getSearchDirection(dataSource, visibleLevel) {\n        const searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minDataLevel));\n        const searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxDataLevel - visibleLevel));\n        const searchDirection = searchLevelsDown > 0 && searchLevelsUp > 0\n            ? SearchDirection.BOTH\n            : searchLevelsDown > 0\n                ? SearchDirection.DOWN\n                : searchLevelsUp > 0\n                    ? SearchDirection.UP\n                    : SearchDirection.NONE;\n        return { searchDirection, searchLevelsUp, searchLevelsDown };\n    }\n    /**\n     * Populates the list of tiles to render, see \"renderedTiles\". Tiles that are loaded and which\n     * are an exact match are added straight to the list, tiles that are still loading are replaced\n     * with tiles in the cache that are either a parent or child of the requested tile. This helps\n     * to prevent flickering when zooming in / out. The distance to search is based on the options\n     * [[quadTreeSearchDistanceDown]] and [[quadTreeSearchDistanceUp]].\n     *\n     * Each {@link DataSource} can also switch this behaviour on / off using the\n     * [[allowOverlappingTiles]] flag.\n     *\n     */\n    populateRenderedTiles() {\n        this.dataSourceTileList.forEach(renderListEntry => {\n            const renderedTiles = renderListEntry.renderedTiles;\n            // Tiles for which we need to fall(back/forward) to.\n            const incompleteTiles = [];\n            // Populate the list of tiles which can be shown (\"renderedTiles\"), and the list of\n            // tiles that are incomplete, and for which we search for an alternative\n            // (\"incompleteTiles\").\n            renderListEntry.visibleTiles.forEach(tile => {\n                tile.levelOffset = 0;\n                if (tile.hasGeometry && !tile.delayRendering) {\n                    renderedTiles.set(tile.uniqueKey, tile);\n                }\n                else {\n                    // if dataSource supports cache and it was existing before this render\n                    // then enable searching for loaded tiles in cache\n                    incompleteTiles.push(tile.uniqueKey);\n                }\n            });\n            const dataSource = renderListEntry.dataSource;\n            if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {\n                // Either all tiles are loaded or the datasource doesn't support using cached tiles\n                // from other levels.\n                return;\n            }\n            const dataZoomLevel = renderListEntry.zoomLevel;\n            const { searchDirection } = this.getSearchDirection(dataSource, dataZoomLevel);\n            // Minor optimization for the fallback search, only check parent tiles once, otherwise\n            // the recursive algorithm checks all parent tiles multiple times, the key is the code\n            // of the tile that is checked and the value is whether a parent was found or not.\n            const checkedTiles = new Map();\n            // Iterate over incomplete (not loaded tiles) and find their parents or children that\n            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour\n            // falling back to parent tiles rather than children.\n            for (const tileKeyCode of incompleteTiles) {\n                if (searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.UP) {\n                    if (this.findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource)) {\n                        // Continue to next entry so we don't search down.\n                        continue;\n                    }\n                }\n                if (searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.DOWN) {\n                    this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);\n                }\n            }\n        });\n    }\n    findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource) {\n        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);\n        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);\n        const tilingScheme = dataSource.getTilingScheme();\n        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n            const childTileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);\n            const childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);\n            const nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);\n            if (childTile !== undefined && childTile.hasGeometry && !childTile.delayRendering) {\n                //childTile has geometry and was/can be uploaded to the GPU,\n                //so we can use it as fallback\n                renderedTiles.set(childTileCode, childTile);\n                childTile.levelOffset = nextLevelDiff;\n                continue;\n            }\n            // Recurse down until the max distance is reached.\n            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {\n                this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);\n            }\n        }\n    }\n    /**\n     * Returns true if a tile was found in the cache which is a parent\n     * @param tileKeyCode - Morton code of the current tile that should be searched for.\n     * @param dataZoomLevel - The current data zoom level of tiles that are to be displayed.\n     * @param renderedTiles - The list of tiles that are shown to the user.\n     * @param checkedTiles - Used to map a given code to a boolean which tells us if an ancestor is\n     * displayed or not.\n     * @param dataSource - The provider of tiles.\n     * @returns Whether a parent tile exists.\n     */\n    findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource) {\n        const parentCode = Utils_1.TileOffsetUtils.getParentKeyFromKey(tileKeyCode);\n        // Check if another sibling has already added the parent.\n        if (renderedTiles.get(parentCode) !== undefined) {\n            return true;\n        }\n        const exists = checkedTiles.get(parentCode);\n        if (exists !== undefined) {\n            return exists;\n        }\n        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);\n        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);\n        const parentTileKey = parentTile ? parentTile.tileKey : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);\n        const nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);\n        if (parentTile !== undefined && parentTile.hasGeometry && !parentTile.delayRendering) {\n            checkedTiles.set(parentCode, true);\n            // parentTile has geometry, so can be reused as fallback\n            renderedTiles.set(parentCode, parentTile);\n            // We want to have parent tiles as -ve, hence the minus.\n            parentTile.levelOffset = -nextLevelDiff;\n            return true;\n        }\n        else {\n            checkedTiles.set(parentCode, false);\n        }\n        // Recurse up until the max distance is reached or we go to the parent of all parents.\n        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {\n            const foundUp = this.findUp(parentCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource);\n            // If there was a tile upstream found, then add it to the list, so we can\n            // early skip checkedTiles.\n            checkedTiles.set(parentCode, foundUp);\n            if (foundUp) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber) {\n        function touchTile(tileToUpdate) {\n            // Keep the tile from being removed from the cache.\n            tileToUpdate.frameNumLastRequested = frameNumber;\n        }\n        if (!dataSource.cacheable && !cacheOnly) {\n            const resultTile = dataSource.getTile(tileKey, true);\n            if (resultTile !== undefined) {\n                this.addToTaskQueue(resultTile);\n                touchTile(resultTile);\n            }\n            return resultTile;\n        }\n        const tileCache = this.m_dataSourceCache;\n        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);\n        if (tile !== undefined && tile.offset === offset) {\n            touchTile(tile);\n            return tile;\n        }\n        if (cacheOnly) {\n            return undefined;\n        }\n        tile = dataSource.getTile(tileKey, true);\n        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry\n        if (tile !== undefined) {\n            this.addToTaskQueue(tile);\n            tile.offset = offset;\n            touchTile(tile);\n            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);\n        }\n        return tile;\n    }\n    addToTaskQueue(tile) {\n        this.m_taskQueue.add({\n            execute: tile.load.bind(tile),\n            group: MapView_1.TileTaskGroups.FETCH_AND_DECODE,\n            getPriority: () => {\n                var _a, _b;\n                return (_b = (_a = tile === null || tile === void 0 ? void 0 : tile.tileLoader) === null || _a === void 0 ? void 0 : _a.priority) !== null && _b !== void 0 ? _b : 0;\n            },\n            isExpired: () => {\n                return !(tile === null || tile === void 0 ? void 0 : tile.isVisible);\n            },\n            estimatedProcessTime: () => {\n                return 1;\n            }\n        });\n    }\n    markDataSourceTilesDirty(renderListEntry, filter) {\n        const dataSourceCache = this.m_dataSourceCache;\n        const retainedTiles = new Set();\n        const markTileDirty = (tile) => {\n            const tileKey = DataSourceCache.getKeyForTile(tile);\n            if (!retainedTiles.has(tileKey)) {\n                retainedTiles.add(tileKey);\n                this.addToTaskQueue(tile);\n            }\n        };\n        renderListEntry.visibleTiles.forEach(tile => {\n            if (filter === undefined || filter(tile)) {\n                markTileDirty(tile);\n            }\n        });\n        renderListEntry.renderedTiles.forEach(tile => {\n            if (filter === undefined || filter(tile)) {\n                markTileDirty(tile);\n            }\n        });\n        dataSourceCache.forEach((tile, key) => {\n            if ((filter === undefined || filter(tile)) && !retainedTiles.has(key)) {\n                dataSourceCache.deleteByKey(key);\n                tile.dispose();\n            }\n        }, renderListEntry.dataSource);\n    }\n    // Computes the visible tile keys for each supplied data source.\n    getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {\n        const tileKeys = Array();\n        let allBoundingBoxesFinal = true;\n        if (dataSources.length === 0) {\n            return { tileKeys, allBoundingBoxesFinal };\n        }\n        const dataSourceBuckets = new Map();\n        dataSources.forEach(dataSource => {\n            const tilingScheme = dataSource.getTilingScheme();\n            const bucket = dataSourceBuckets.get(tilingScheme);\n            if (bucket === undefined) {\n                dataSourceBuckets.set(tilingScheme, [dataSource]);\n            }\n            else {\n                bucket.push(dataSource);\n            }\n        });\n        // If elevation is to be taken into account extend view frustum:\n        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that\n        // are far below ground plane and high enough to intersect the frustum.\n        if (elevationRangeSource !== undefined) {\n            this.m_cameraOverride.copy(this.m_frustumIntersection.camera);\n            this.m_cameraOverride.near = Math.min(this.m_cameraOverride.near, this.m_viewRange.minimum);\n            this.m_cameraOverride.far = Math.max(this.m_cameraOverride.far, this.m_viewRange.maximum);\n            this.m_cameraOverride.updateProjectionMatrix();\n            this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);\n        }\n        else {\n            this.m_frustumIntersection.updateFrustum();\n        }\n        // For each bucket of data sources with same tiling scheme, calculate frustum intersection\n        // once using the maximum display level.\n        for (const [tilingScheme, bucket] of dataSourceBuckets) {\n            const zoomLevels = bucket.map(dataSource => dataSource.getDataZoomLevel(zoomLevel));\n            const result = this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);\n            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;\n            for (const dataSource of bucket) {\n                // For each data source check what tiles from the intersection should be rendered\n                // at this zoom level.\n                const visibleTileKeys = [];\n                const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);\n                for (const tileKeyEntry of result.tileKeyEntries.get(dataZoomLevel).values()) {\n                    if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {\n                        visibleTileKeys.push(tileKeyEntry);\n                    }\n                }\n                tileKeys.push({ dataSource, visibleTileKeys });\n            }\n        }\n        return { tileKeys, allBoundingBoxesFinal };\n    }\n}\nexports.VisibleTileSet = VisibleTileSet;\nfunction viewRangesEqual(a, b) {\n    return (a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near);\n}\n//# sourceMappingURL=VisibleTileSet.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/VisibleTileSet.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerBasedDecoder = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\n/**\n * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n/**\n * Decoder based on [[ConcurrentWorkerSet]].\n *\n * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends decode requests,\n * - configuration.\n */\nclass WorkerBasedDecoder {\n    /**\n     * Creates a new `WorkerBasedDecoder`.\n     *\n     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param decoderServiceType - Service type identifier.\n     */\n    constructor(workerSet, decoderServiceType) {\n        this.workerSet = workerSet;\n        this.decoderServiceType = decoderServiceType;\n        this.m_serviceCreated = false;\n        this.workerSet.addReference();\n        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;\n    }\n    /**\n     * Dispose of dedicated tile decoder services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,\n                targetServiceId: this.serviceId\n            })\n                .catch(() => {\n                /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n            });\n        }\n        this.workerSet.removeReference();\n    }\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.\n     */\n    async connect() {\n        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,\n                targetServiceType: this.decoderServiceType,\n                targetServiceId: this.serviceId\n            });\n            this.m_serviceCreated = true;\n        }\n    }\n    /**\n     * Get {@link Tile} from tile decoder service in worker.\n     *\n     * @remarks\n     * Invokes {@link @here/harp-datasource-protocol#DecodeTileRequest} on\n     * [[TileDecoderService]] running in worker pool.\n     */\n    decodeTile(data, tileKey, projection, requestController) {\n        const tileKeyCode = tileKey.mortonCode();\n        const message = {\n            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: harp_datasource_protocol_1.getProjectionName(projection)\n        };\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);\n    }\n    /**\n     * Get {@link @here/harp-datasource-protocol#TileInfo} from tile decoder service in worker.\n     *\n     * @remarks\n     * Invokes {@link @here/harp-datasource-protocol#TileInfoRequest}\n     * on [[TileDecoderService]] running in worker pool.\n     */\n    getTileInfo(data, tileKey, projection, requestController) {\n        const tileKeyCode = tileKey.mortonCode();\n        const message = {\n            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: harp_datasource_protocol_1.getProjectionName(projection)\n        };\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);\n    }\n    /**\n     * Configure tile decoder service in workers.\n     *\n     * @remarks\n     * Broadcasts {@link @here/harp-datasource-protocol#ConfigurationMessage}\n     * to all [[TileDecoderService]]s running in worker pool.\n     *\n     * @param options - Options that will be applied to the styles\n     * @param customOptions -   new options, undefined options are not changed\n     */\n    configure(options, customOptions) {\n        const message = Object.assign(Object.assign({ service: this.serviceId, type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration }, options), { options: customOptions });\n        this.workerSet.broadcastMessage(message);\n    }\n    /**\n     * The number of workers started for this decoder. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount() {\n        return this.workerSet.workerCount;\n    }\n}\nexports.WorkerBasedDecoder = WorkerBasedDecoder;\n//# sourceMappingURL=WorkerBasedDecoder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerBasedTiler = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\n/**\n * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n/**\n * Tiler based on [[ConcurrentWorkerSet]].\n *\n * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends tile requests,\n * - configuration.\n */\nclass WorkerBasedTiler {\n    /**\n     * Creates a new `WorkerBasedTiler`.\n     *\n     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param tilerServiceType - Service type identifier.\n     */\n    constructor(workerSet, tilerServiceType) {\n        this.workerSet = workerSet;\n        this.tilerServiceType = tilerServiceType;\n        this.m_serviceCreated = false;\n        this.workerSet.addReference();\n        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;\n    }\n    /**\n     * Dispose of dedicated tiler services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,\n                targetServiceId: this.serviceId\n            })\n                .catch(() => {\n                /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n            });\n        }\n        this.workerSet.removeReference();\n    }\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TilerService]]s in all workers to serve tiling requests.\n     */\n    async connect() {\n        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,\n                targetServiceType: this.tilerServiceType,\n                targetServiceId: this.serviceId\n            });\n            this.m_serviceCreated = true;\n        }\n    }\n    /**\n     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId - Index identifier.\n     * @param input - Url to the index payload, or direct GeoJSON.\n     */\n    registerIndex(indexId, input) {\n        const message = {\n            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : input\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n    /**\n     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId - Index identifier.\n     * @param input - Url to the index payload, or direct GeoJSON.\n     */\n    updateIndex(indexId, input) {\n        const message = {\n            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : input\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n    /**\n     * Retrieves a tile for a previously registered index.\n     *\n     * @param indexId - Index identifier.\n     * @param tileKey - The {@link @here/harp-geoutils#TileKey} that identifies the tile.\n     */\n    getTile(indexId, tileKey) {\n        const tileKeyCode = tileKey.mortonCode();\n        const message = {\n            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,\n            index: indexId,\n            tileKey: tileKeyCode\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n}\nexports.WorkerBasedTiler = WorkerBasedTiler;\n//# sourceMappingURL=WorkerBasedTiler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LowResRenderPass = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\n/**\n * The `LowResRenderPass` renders the scene at a lower resolution into an internal\n * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal\n * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.\n *\n * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be\n * visible.\n */\nclass LowResRenderPass extends Pass_1.Pass {\n    /**\n     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at\n     * a quad.\n     *\n     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     */\n    constructor(lowResPixelRatio) {\n        super();\n        this.lowResPixelRatio = lowResPixelRatio;\n        this.m_renderTarget = null;\n        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        this.m_quadScene = new THREE.Scene();\n        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;\n        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);\n        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);\n        this.m_savedWidth = 0;\n        this.m_savedHeight = 0;\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n        this.m_pixelRatio = lowResPixelRatio;\n    }\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        this.m_quadMaterial.dispose();\n        this.m_quad.geometry.dispose();\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n    /**\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     *\n     * @default `undefined`\n     */\n    set pixelRatio(ratio) {\n        this.m_pixelRatio = ratio;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));\n        }\n    }\n    get pixelRatio() {\n        return this.m_pixelRatio;\n    }\n    /**\n     * The render function of `LowResRenderPass`. It renders the whole scene into an internal\n     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.\n     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it\n     * is the screen.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene - The ThreeJS Scene instance to render the scene with.\n     * @param camera - The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        if (!this.enabled || this.pixelRatio === undefined) {\n            return;\n        }\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_savedWidth = readBuffer.width;\n            this.m_savedHeight = readBuffer.height;\n            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat,\n                depthBuffer: true,\n                stencilBuffer: true\n            });\n            this.m_renderTarget.texture.name = \"LowResRenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        this.m_quadUniforms.opacity.value = 1.0;\n        const oldRenderTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.m_renderTarget);\n        renderer.clear();\n        // Render into the low resolution internal render target.\n        renderer.render(scene, camera);\n        // Render the low resolution target into the screen.\n        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.clear();\n        renderer.render(this.m_quadScene, this.m_localCamera);\n        renderer.setRenderTarget(oldRenderTarget);\n    }\n    /**\n     * Resize the internal render target to match the new size specified. The size of internal\n     * buffer depends on the `pixelRatio`.\n     *\n     * @param width - New width to apply to the render target.\n     * @param height - New height to apply to the render target.\n     * @override\n     */\n    setSize(width, height) {\n        this.m_savedWidth = width;\n        this.m_savedHeight = height;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));\n        }\n    }\n}\nexports.LowResRenderPass = LowResRenderPass;\n//# sourceMappingURL=LowResRenderPass.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MSAARenderPass = exports.MSAASampling = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\n/**\n * This enum represents the sampling level to apply to\n * a {@link MSAARenderPass} instance. At level 0,\n * only one sample is performed, which is like\n * disabling the MSAA pass.\n */\nvar MSAASampling;\n(function (MSAASampling) {\n    MSAASampling[MSAASampling[\"Level_0\"] = 0] = \"Level_0\";\n    MSAASampling[MSAASampling[\"Level_1\"] = 1] = \"Level_1\";\n    MSAASampling[MSAASampling[\"Level_2\"] = 2] = \"Level_2\";\n    MSAASampling[MSAASampling[\"Level_3\"] = 3] = \"Level_3\";\n    MSAASampling[MSAASampling[\"Level_4\"] = 4] = \"Level_4\";\n    MSAASampling[MSAASampling[\"Level_5\"] = 5] = \"Level_5\";\n})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));\n/**\n * {@link MapView}'s MSAA implementation.\n *\n * @remarks\n * MSAA stands for Multi Sampling Anti-Aliasing, and its concept\n * is to provide a rendering engine with additional color values for each pixel, so they can include\n * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation\n * with four samples. Because of its native nature, it is more efficient and one may not want to use\n * MapView's MSAA implementation when these four samples are satisfying. However in some situations\n * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the\n * number of samples at runtime. On the other hand, when the interaction stops, the engine also\n * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then\n * turn very noticeable. In such static renders, the number of samples could be dramatically\n * increased on a last frame to render.\n */\nclass MSAARenderPass extends Pass_1.Pass {\n    /**\n     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a\n     * quad.\n     *\n     * @param m_scene - The scene to render.\n     * @param m_camera - The camera to render the scene through.\n     */\n    constructor() {\n        super();\n        /**\n         * The sampling level determines the number of samples that will be performed per frame.\n         * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.\n         * Therefore there can be between 1 and 32 samples.\n         *\n         * @default `SamplingLevel.Level_1`\n         */\n        this.samplingLevel = MSAASampling.Level_1;\n        this.m_renderTarget = null;\n        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        this.m_quadScene = new THREE.Scene();\n        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;\n        this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);\n        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);\n        this.m_tmpColor = new THREE.Color();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n    }\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n    /**\n     * The render function of `MSAARenderPass`.\n     *\n     * @remarks\n     * At each call of this method, and for each sample the {@link MapView}\n     * camera provided in the `render method is offset within the dimension of a\n     * pixel on screen. It then renders the whole scene with this offset to a local\n     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera\n     * created in the constructor shoots the quad and renders to the write buffer or to the frame\n     * buffer. The quad material's opacity is modified so the renders can accumulate in the\n     * targetted buffer.\n     *\n     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].\n     *\n     * If there is no further pass, the {@link Pass.renderToScreen} flag can be set to `true` to\n     * output directly to the framebuffer.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene - The ThreeJS Scene instance to render the scene with.\n     * @param camera - The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        if (!this.enabled) {\n            return;\n        }\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat\n            });\n            this.m_renderTarget.texture.name = \"MSAARenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];\n        const rendererClearColor = renderer.getClearColor(this.m_tmpColor);\n        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain\n        // its usability externally (like for the triple view in mosaic demo) we must cache the\n        // previous values stored in `camera.view` and re-assign them at the end of the pass.\n        // 1. Create a default cache object, with default dimensions the size of our read buffer.\n        const oldView = {\n            enabled: camera.view !== null && camera.view.enabled,\n            fullWidth: readBuffer.width,\n            fullHeight: readBuffer.height,\n            x: 0,\n            y: 0,\n            width: readBuffer.width,\n            height: readBuffer.height\n        };\n        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called\n        // externally: copy the existing `camera.view` values in the cache. Override the cache\n        // object with the values provided externally.\n        if (oldView.enabled && camera.view !== null) {\n            oldView.fullWidth = camera.view.fullWidth;\n            oldView.fullHeight = camera.view.fullHeight;\n            oldView.x = camera.view.offsetX;\n            oldView.y = camera.view.offsetY;\n            oldView.width = camera.view.width;\n            oldView.height = camera.view.height;\n        }\n        const oldRenderTarget = renderer.getRenderTarget();\n        for (let i = 0; i < offsets.length; i++) {\n            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the\n            // `camera.view` object in Three.js.\n            const offset = offsets[i];\n            camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);\n            // 5. Divide the opacity of the quad by the number of samples to accumulate on the\n            // target buffer, and reduce the impact of the offset on color to reduce banding. Then\n            // render.\n            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;\n            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;\n            this.m_quadUniforms.opacity.value = sampleWeight;\n            renderer.setRenderTarget(this.m_renderTarget);\n            renderer.clear();\n            renderer.render(scene, camera);\n            // 6. Render the quad on top of the previous renders.\n            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n            if (i === 0) {\n                renderer.setClearColor(0x000000);\n                renderer.clear();\n            }\n            renderer.render(this.m_quadScene, this.m_localCamera);\n            if (i === 0 && rendererClearColor !== undefined) {\n                renderer.setClearColor(oldClearColor);\n            }\n        }\n        renderer.setRenderTarget(oldRenderTarget);\n        // 7. Restore `camera.view` as set externally (or not).\n        if (camera.view !== null) {\n            camera.view.enabled = oldView.enabled;\n            camera.view.offsetX = oldView.x;\n            camera.view.offsetY = oldView.y;\n        }\n    }\n    /**\n     * Resize the internal render target to match the new size specified.\n     *\n     * @param width - New width to apply to the render target.\n     * @param height - New height to apply to the render target.\n     * @override\n     */\n    setSize(width, height) {\n        if (this.m_renderTarget) {\n            this.m_renderTarget.setSize(width, height);\n        }\n    }\n}\nexports.MSAARenderPass = MSAARenderPass;\n/**\n * The list of offsets to apply to the camera, per sampling level, adapted from :\n *\n * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n */\nMSAARenderPass.OffsetVectors = [\n    [[0, 0]],\n    [\n        [4, 4],\n        [-4, -4]\n    ],\n    [\n        [-2, -6],\n        [6, -2],\n        [-6, 2],\n        [2, 6]\n    ],\n    [\n        [1, -3],\n        [-1, 3],\n        [5, 1],\n        [-3, -5],\n        [-5, 5],\n        [-7, -1],\n        [3, 7],\n        [7, -7]\n    ],\n    [\n        [1, 1],\n        [-1, -3],\n        [-3, 2],\n        [4, -1],\n        [-5, -2],\n        [2, 5],\n        [5, 3],\n        [3, -5],\n        [-2, 6],\n        [0, -7],\n        [-4, -6],\n        [-6, 4],\n        [-8, 0],\n        [7, -4],\n        [6, 7],\n        [-7, -8]\n    ],\n    [\n        [-4, -7],\n        [-7, -5],\n        [-3, -5],\n        [-5, -4],\n        [-1, -4],\n        [-2, -2],\n        [-6, -1],\n        [-4, 0],\n        [-7, 1],\n        [-1, 2],\n        [-6, 3],\n        [-3, 3],\n        [-7, 6],\n        [-3, 6],\n        [-5, 7],\n        [-1, 7],\n        [5, -7],\n        [1, -6],\n        [6, -5],\n        [4, -4],\n        [2, -3],\n        [7, -2],\n        [1, -1],\n        [4, -1],\n        [2, 1],\n        [6, 2],\n        [0, 4],\n        [4, 4],\n        [2, 5],\n        [7, 5],\n        [5, 6],\n        [3, 7]\n    ]\n];\n//# sourceMappingURL=MSAARenderPass.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapRenderingManager = void 0;\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ \"./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js\");\nconst MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ \"./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js\");\nconst Outline_1 = __webpack_require__(/*! ./Outline */ \"./node_modules/@here/harp-mapview/lib/composing/Outline.js\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\nconst UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ \"./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js\");\nconst DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;\nconst DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;\n/**\n * The implementation of {@link IMapRenderingManager} to\n * instantiate in {@link MapView} and manage the map\n * rendering.\n */\nclass MapRenderingManager {\n    /**\n     * The constructor of `MapRenderingManager`.\n     *\n     * @param width - Width of the frame buffer.\n     * @param height - Height of the frame buffer.\n     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     * @param antialiasSetting - The object defining the demeanor of MSAA.\n     */\n    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {\n        this.bloom = {\n            enabled: false,\n            strength: 1.5,\n            radius: 0.4,\n            threshold: 0.85\n        };\n        this.outline = {\n            enabled: false,\n            thickness: 0.005,\n            color: \"#000000\",\n            ghostExtrudedPolygons: false,\n            needsUpdate: false\n        };\n        this.vignette = {\n            enabled: false,\n            offset: 1.0,\n            darkness: 1.0\n        };\n        this.sepia = {\n            enabled: false,\n            amount: 0.5\n        };\n        this.m_width = 1;\n        this.m_height = 1;\n        this.m_renderPass = new Pass_1.RenderPass();\n        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);\n        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);\n        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);\n        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);\n        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);\n        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();\n        this.m_msaaPass.enabled =\n            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;\n        this.m_dynamicMsaaSamplingLevel =\n            antialiasSettings.dynamicMsaaSamplingLevel === undefined\n                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.dynamicMsaaSamplingLevel;\n        this.m_staticMsaaSamplingLevel =\n            antialiasSettings.staticMsaaSamplingLevel === undefined\n                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.staticMsaaSamplingLevel;\n        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);\n        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;\n    }\n    updateOutline(options) {\n        this.outline.color = options.color;\n        this.outline.thickness = options.thickness;\n        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;\n        this.outline.needsUpdate = true;\n    }\n    /**\n     * The method to call to render the map with the `MapRenderingManager` instance. It contains the\n     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering\n     * conditions as disabling AA when a high DPI device is in use.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.\n     * @param scene - The ThreeJS Scene instance containing the map objects to render.\n     * @param camera - The ThreeJS Camera instance to render the scene through.\n     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     */\n    render(renderer, scene, camera, isStaticFrame) {\n        const target = null;\n        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {\n            // Not designed to be combined with our own MSAA\n            this.m_lowResPass.renderToScreen = true;\n            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);\n            return;\n        }\n        const usePostEffects = this.bloom.enabled ||\n            this.outline.enabled ||\n            this.vignette.enabled ||\n            this.sepia.enabled;\n        let activeTarget = null;\n        // 1. If the bloom is enabled, clear the depth.\n        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n            renderer.setRenderTarget(this.m_target1);\n            renderer.clearDepth();\n        }\n        // 2. Render the map.\n        if (this.m_msaaPass.enabled) {\n            // Use a higher MSAA sampling level for static rendering.\n            this.m_msaaPass.samplingLevel = isStaticFrame\n                ? this.m_staticMsaaSamplingLevel\n                : this.m_dynamicMsaaSamplingLevel;\n            // MSAA is the only effect for the moment.\n            this.m_msaaPass.renderToScreen = !usePostEffects;\n            // Render to the specified target with the MSAA pass.\n            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);\n        }\n        else {\n            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n                activeTarget = this.m_target1;\n                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);\n            }\n            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {\n                renderer.render(scene, camera);\n            }\n        }\n        // 3. Apply effects\n        if (this.outline.enabled) {\n            if (this.m_outlineEffect === undefined) {\n                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);\n            }\n            if (this.outline.needsUpdate) {\n                this.m_outlineEffect.color = this.outline.color;\n                this.m_outlineEffect.thickness = this.outline.thickness;\n                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;\n                this.outline.needsUpdate = false;\n            }\n            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;\n            if (nextEffectEnabled) {\n                activeTarget = this.m_target1;\n            }\n            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);\n            this.m_outlineEffect.render(scene, camera);\n        }\n        if (this.bloom.enabled) {\n            if (this.m_bloomPass === undefined) {\n                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);\n            }\n            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;\n            this.m_bloomPass.renderToScreen = !nextEffectEnabled;\n            this.m_bloomPass.radius = this.bloom.radius;\n            this.m_bloomPass.strength = this.bloom.strength;\n            this.m_bloomPass.threshold = this.bloom.threshold;\n            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);\n        }\n        else if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.dispose();\n            this.m_bloomPass = undefined;\n        }\n        if (this.vignette.enabled) {\n            const oldTarget = activeTarget;\n            const nextEffectEnabled = this.sepia.enabled;\n            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;\n            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;\n            this.m_vignettePass.renderToScreen = !nextEffectEnabled;\n            if (nextEffectEnabled) {\n                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;\n            }\n            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);\n        }\n        if (this.sepia.enabled) {\n            this.m_sepiaPass.renderToScreen = true;\n            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;\n            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);\n        }\n    }\n    /**\n     * The resize function to call on resize events to resize the render targets. It shall include\n     * the resize methods of all the sub-passes used in `MapRenderingManager`.\n     *\n     * @param width - New width to use.\n     * @param height - New height to use.\n     */\n    setSize(width, height) {\n        this.m_readBuffer.setSize(width, height);\n        this.m_msaaPass.setSize(width, height);\n        if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.setSize(width, height);\n        }\n        this.m_lowResPass.setSize(width, height);\n        this.m_target1.setSize(width, height);\n        this.m_target2.setSize(width, height);\n        this.m_width = width;\n        this.m_height = height;\n    }\n    /**\n     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values\n     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of\n     * `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     */\n    get lowResPixelRatio() {\n        return this.m_lowResPass.pixelRatio;\n    }\n    set lowResPixelRatio(pixelRatio) {\n        this.m_lowResPass.pixelRatio = pixelRatio;\n        this.m_lowResPass.enabled = pixelRatio !== undefined;\n    }\n    /**\n     * Set the level of sampling while the user interacts.\n     *\n     * @param samplingLevel - The sampling level.\n     */\n    set dynamicMsaaSamplingLevel(samplingLevel) {\n        this.m_dynamicMsaaSamplingLevel = samplingLevel;\n    }\n    /**\n     * Return the sampling level defined during continuous rendering.\n     */\n    get dynamicMsaaSamplingLevel() {\n        return this.m_dynamicMsaaSamplingLevel;\n    }\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the {@link MapRenderingManager.render} method to render the scene.\n     *\n     * @param value - If `true`, MSAA is enabled, disabled otherwise.\n     */\n    set msaaEnabled(value) {\n        this.m_msaaPass.enabled = value;\n    }\n    /**\n     * Return whether the MSAA is enabled.\n     */\n    get msaaEnabled() {\n        return this.m_msaaPass.enabled;\n    }\n    /**\n     * Set the sampling level for rendering static frames.\n     *\n     * @param samplingLevel - The sampling level.\n     */\n    set staticMsaaSamplingLevel(samplingLevel) {\n        this.m_staticMsaaSamplingLevel = samplingLevel;\n    }\n    /**\n     * Return the sampling level defined for rendering static frames.\n     */\n    get staticMsaaSamplingLevel() {\n        return this.m_staticMsaaSamplingLevel;\n    }\n}\nexports.MapRenderingManager = MapRenderingManager;\n//# sourceMappingURL=MapRenderingManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Outline.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Outline.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OutlineEffect = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst vertexShaderChunk = `\n#ifdef USE_EXTRUSION\n  #ifndef HAS_EXTRUSION_PARS_VERTEX\n    #include <extrusion_pars_vertex>\n  #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_vertex>\n#endif\n\nuniform float outlineThickness;\n\nvec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\n    float thickness = outlineThickness;\n    const float ratio = 1.0;\n    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\n    vec4 norm = normalize( pos - pos2 );\n    return pos + norm * thickness * pos.w * ratio;\n}`;\nconst vertexShaderChunk2 = `\n#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )\n    #ifndef USE_ENVMAP\n        vec3 objectNormal = normalize( normal );\n    #endif\n#endif\n\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n\n#ifdef DECLARE_TRANSFORMED\n    vec3 transformed = vec3( position );\n#endif\n\n#ifdef USE_EXTRUSION\n #ifndef HAS_EXTRUSION_VERTEX\n  #include <extrusion_vertex>\n #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_vertex>\n#endif\n\n#ifdef USE_EXTRUSION\n  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),\n      objectNormal, vec4( transformed, 1.0 ) );\n#else\n  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\n#endif\n\n#include <fog_vertex>`;\nconst fragmentShader = `\n#include <common>\n#include <fog_pars_fragment>\n\n#ifdef USE_EXTRUSION\n  #include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_fragment>\n#endif\n\nuniform vec3 outlineColor;\nuniform float outlineAlpha;\n\nvoid main() {\n\n    gl_FragColor = vec4( outlineColor, outlineAlpha );\n\n    #include <fog_fragment>\n\n    #ifdef USE_EXTRUSION\n      #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n      #include <fading_fragment>\n    #endif\n}`;\n/**\n * Effect to render bold lines around extruded polygons.\n *\n * Implemented by rendering the mesh geometries with an outline material before rendering them\n * again with their original.\n */\nclass OutlineEffect {\n    constructor(m_renderer) {\n        this.m_renderer = m_renderer;\n        this.enabled = true;\n        this.m_defaultThickness = 0.02;\n        this.m_defaultColor = new THREE.Color(0, 0, 0);\n        this.m_defaultAlpha = 1;\n        this.m_defaultKeepAlive = false;\n        this.m_ghostExtrudedPolygons = false;\n        this.m_cache = {};\n        this.m_removeThresholdCount = 60;\n        this.m_originalMaterials = {};\n        this.m_originalOnBeforeRenders = {};\n        this.m_shaderIDs = {\n            MeshBasicMaterial: \"basic\",\n            MeshLambertMaterial: \"lambert\",\n            MeshPhongMaterial: \"phong\",\n            MeshToonMaterial: \"phong\",\n            MeshStandardMaterial: \"physical\",\n            MeshPhysicalMaterial: \"physical\"\n        };\n        this.m_uniformsChunk = {\n            outlineThickness: { value: this.m_defaultThickness },\n            outlineColor: { value: this.m_defaultColor },\n            outlineAlpha: { value: this.m_defaultAlpha }\n        };\n        this.autoClear = m_renderer.autoClear;\n        this.domElement = m_renderer.domElement;\n        this.shadowMap = m_renderer.shadowMap;\n    }\n    set thickness(thickness) {\n        this.m_defaultThickness = thickness;\n        this.m_uniformsChunk.outlineThickness.value = thickness;\n        this.m_cache = {};\n    }\n    set color(color) {\n        this.m_defaultColor.set(color);\n        this.m_cache = {};\n    }\n    set ghostExtrudedPolygons(ghost) {\n        this.m_ghostExtrudedPolygons = ghost;\n    }\n    clear(color, depth, stencil) {\n        this.m_renderer.clear(color, depth, stencil);\n    }\n    getPixelRatio() {\n        return this.m_renderer.getPixelRatio();\n    }\n    setPixelRatio(value) {\n        this.m_renderer.setPixelRatio(value);\n    }\n    getSize(target) {\n        return this.m_renderer.getSize(target);\n    }\n    setSize(width, height, updateStyle) {\n        this.m_renderer.setSize(width, height, updateStyle);\n    }\n    setViewport(x, y, width, height) {\n        this.m_renderer.setViewport(x, y, width, height);\n    }\n    setScissor(x, y, width, height) {\n        this.m_renderer.setScissor(x, y, width, height);\n    }\n    setScissorTest(boolean) {\n        this.m_renderer.setScissorTest(boolean);\n    }\n    setRenderTarget(renderTarget) {\n        this.m_renderer.setRenderTarget(renderTarget);\n    }\n    render(scene, camera) {\n        // Re-rendering the scene with the outline effect enables to hide the\n        // extruded polygons and show only the outlines (it is a hack and should be\n        // implemented another way!).\n        if (this.m_ghostExtrudedPolygons) {\n            if (!this.enabled) {\n                this.m_renderer.render(scene, camera);\n                return;\n            }\n            const currentAutoClear = this.m_renderer.autoClear;\n            this.m_renderer.autoClear = this.autoClear;\n            this.m_renderer.render(scene, camera);\n            this.m_renderer.autoClear = currentAutoClear;\n        }\n        this.renderOutline(scene, camera);\n    }\n    renderOutline(scene, camera) {\n        const currentAutoClear = this.m_renderer.autoClear;\n        const currentSceneAutoUpdate = scene.autoUpdate;\n        const currentSceneBackground = scene.background;\n        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;\n        scene.autoUpdate = false;\n        scene.background = null;\n        this.m_renderer.autoClear = false;\n        this.m_renderer.shadowMap.enabled = false;\n        scene.traverse(this.setOutlineMaterial.bind(this));\n        this.m_renderer.render(scene, camera);\n        scene.traverse(this.restoreOriginalMaterial.bind(this));\n        this.cleanupCache();\n        scene.autoUpdate = currentSceneAutoUpdate;\n        scene.background = currentSceneBackground;\n        this.m_renderer.autoClear = currentAutoClear;\n        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;\n    }\n    createInvisibleMaterial() {\n        return new THREE.ShaderMaterial({ name: \"invisible\", visible: false });\n    }\n    createMaterial(originalMaterial) {\n        // EdgeMaterial or depth prepass material should not be used for outlines.\n        if (originalMaterial instanceof harp_materials_1.EdgeMaterial ||\n            originalMaterial.isDepthPrepassMaterial === true) {\n            return this.createInvisibleMaterial();\n        }\n        const shaderID = this.m_shaderIDs[originalMaterial.type];\n        let originalVertexShader;\n        let originalUniforms = originalMaterial.shaderUniforms !== undefined\n            ? originalMaterial.shaderUniforms\n            : originalMaterial.uniforms;\n        if (shaderID !== undefined) {\n            const shader = THREE.ShaderLib[shaderID];\n            originalUniforms = shader.uniforms;\n            originalVertexShader = shader.vertexShader;\n        }\n        else if (originalMaterial.isRawShaderMaterial === true) {\n            originalVertexShader = originalMaterial.vertexShader;\n            if (!/attribute\\s+vec3\\s+position\\s*;/.test(originalVertexShader) ||\n                !/attribute\\s+vec3\\s+normal\\s*;/.test(originalVertexShader)) {\n                return this.createInvisibleMaterial();\n            }\n        }\n        else if (originalMaterial.isShaderMaterial === true) {\n            originalVertexShader = originalMaterial.vertexShader;\n        }\n        else {\n            return this.createInvisibleMaterial();\n        }\n        const isExtrusionMaterial = originalMaterial.shaderUniforms !== undefined &&\n            originalMaterial.shaderUniforms.extrusionRatio !== undefined;\n        const isFadingMaterial = harp_materials_1.FadingFeature.isDefined(originalMaterial);\n        const uniforms = Object.assign(Object.assign({}, originalUniforms), this.m_uniformsChunk);\n        const vertexShader = originalVertexShader\n            // put vertexShaderChunk right before \"void main() {...}\"\n            .replace(/void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + \"\\nvoid main()\")\n            // put vertexShaderChunk2 the end of \"void main() {...}\"\n            // Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n            .replace(/\\}\\s*$/, vertexShaderChunk2 + \"\\n}\")\n            // remove any light related lines\n            // Note: here is very sensitive to originalVertexShader\n            // TODO: consider safer way\n            .replace(/#include\\s+<[\\w_]*light[\\w_]*>/g, \"\");\n        const defines = {};\n        if (!/vec3\\s+transformed\\s*=/.test(originalVertexShader) &&\n            !/#include\\s+<begin_vertex>/.test(originalVertexShader)) {\n            defines.DECLARE_TRANSFORMED = true;\n        }\n        if (isExtrusionMaterial) {\n            // If the original material is setup for animated extrusion (like buildings), add the\n            // uniform describing the extrusion to the outline material.\n            uniforms.extrusionRatio = { value: harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN };\n            defines.USE_EXTRUSION = 1;\n        }\n        if (isFadingMaterial) {\n            uniforms.fadeNear = {\n                value: originalUniforms.fadeNear !== undefined\n                    ? originalUniforms.fadeNear.value\n                    : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR\n            };\n            uniforms.fadeFar = {\n                value: originalUniforms.fadeFar !== undefined\n                    ? originalUniforms.fadeFar.value\n                    : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR\n            };\n            defines.USE_FADING = 1;\n        }\n        const outlineMaterial = new THREE.ShaderMaterial({\n            defines,\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.BackSide,\n            //wireframe: true,\n            skinning: false,\n            morphTargets: false,\n            morphNormals: false,\n            fog: false,\n            blending: THREE.CustomBlending,\n            blendSrc: THREE.SrcAlphaFactor,\n            blendDst: THREE.OneMinusSrcAlphaFactor,\n            blendSrcAlpha: THREE.OneFactor,\n            blendDstAlpha: THREE.OneMinusSrcAlphaFactor,\n            transparent: true,\n            polygonOffset: true,\n            // Extreme values used here to reduce artifacts, especially at tile borders.\n            polygonOffsetFactor: 10.0,\n            polygonOffsetUnits: 30.0\n        });\n        return outlineMaterial;\n    }\n    getOutlineMaterialFromCache(originalMaterial) {\n        let data = this.m_cache[originalMaterial.uuid];\n        if (data === undefined) {\n            data = {\n                material: this.createMaterial(originalMaterial),\n                used: true,\n                keepAlive: this.m_defaultKeepAlive,\n                count: 0\n            };\n            this.m_cache[originalMaterial.uuid] = data;\n        }\n        data.used = true;\n        return data.material;\n    }\n    getOutlineMaterial(originalMaterial) {\n        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);\n        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;\n        this.updateOutlineMaterial(outlineMaterial, originalMaterial);\n        return outlineMaterial;\n    }\n    setOutlineMaterial(object) {\n        if (object.material === undefined) {\n            return;\n        }\n        if (Array.isArray(object.material)) {\n            for (let i = 0, il = object.material.length; i < il; i++) {\n                object.material[i] = this.getOutlineMaterial(object.material[i]);\n            }\n        }\n        else {\n            object.material = this.getOutlineMaterial(object.material);\n        }\n        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));\n    }\n    restoreOriginalMaterial(object) {\n        if (object.material === undefined) {\n            return;\n        }\n        if (Array.isArray(object.material)) {\n            for (let i = 0, il = object.material.length; i < il; i++) {\n                object.material[i] = this.m_originalMaterials[object.material[i].uuid];\n            }\n        }\n        else {\n            object.material = this.m_originalMaterials[object.material.uuid];\n        }\n        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];\n    }\n    onBeforeRender(renderer, scene, camera, geometry, material, group) {\n        const originalMaterial = this.m_originalMaterials[material.uuid];\n        // just in case\n        if (originalMaterial === undefined) {\n            return;\n        }\n        this.updateUniforms(material, originalMaterial);\n    }\n    updateUniforms(material, originalMaterial) {\n        var _a;\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n        const outlineUniforms = material.uniforms;\n        outlineUniforms.outlineAlpha.value = originalMaterial.opacity;\n        const originalUniforms = originalMaterial.shaderUniforms !== undefined\n            ? originalMaterial.shaderUniforms\n            : originalMaterial.uniforms;\n        if (outlineParameters !== undefined) {\n            if (outlineParameters.thickness !== undefined) {\n                outlineUniforms.outlineThickness.value = outlineParameters.thickness;\n            }\n            if (outlineParameters.color !== undefined) {\n                outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);\n            }\n            if (outlineParameters.alpha !== undefined) {\n                outlineUniforms.outlineAlpha.value = outlineParameters.alpha;\n            }\n        }\n        // If the original material is setup for animated extrusion (like buildings), update the\n        // uniforms in the outline material.\n        if (originalUniforms !== undefined && originalUniforms.extrusionRatio !== undefined) {\n            const value = originalMaterial.shaderUniforms.extrusionRatio.value;\n            material.extrusionRatio = value;\n            material.uniforms.extrusionRatio.value =\n                value !== undefined ? value : harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        }\n        // Copy available fading params to the outline material.\n        if (((_a = material.defines) === null || _a === void 0 ? void 0 : _a.USE_FADING) !== undefined &&\n            originalUniforms.fadeNear !== undefined &&\n            originalUniforms.fadeFar !== undefined &&\n            originalUniforms.fadeFar.value >= 0.0) {\n            outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;\n            outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;\n        }\n    }\n    updateOutlineMaterial(material, originalMaterial) {\n        if (material.name === \"invisible\") {\n            return;\n        }\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n        material.skinning = originalMaterial.skinning;\n        material.morphTargets = originalMaterial.morphTargets;\n        material.morphNormals = originalMaterial.morphNormals;\n        material.fog = originalMaterial.fog;\n        if (outlineParameters !== undefined) {\n            material.visible =\n                originalMaterial.visible === false\n                    ? false\n                    : outlineParameters.visible !== undefined\n                        ? outlineParameters.visible\n                        : true;\n            if (outlineParameters.keepAlive !== undefined) {\n                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n            }\n        }\n        else {\n            material.visible = originalMaterial.visible;\n        }\n        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {\n            material.visible = false;\n        }\n    }\n    cleanupCache() {\n        let keys;\n        // clear originialMaterials\n        keys = Object.keys(this.m_originalMaterials);\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalMaterials[keys[i]] = undefined;\n        }\n        // clear originalOnBeforeRenders\n        keys = Object.keys(this.m_originalOnBeforeRenders);\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalOnBeforeRenders[keys[i]] = undefined;\n        }\n        // remove unused outlineMaterial from cache\n        keys = Object.keys(this.m_cache);\n        for (const key of keys) {\n            if (this.m_cache[key].used === false) {\n                this.m_cache[key].count++;\n                if (this.m_cache[key].keepAlive === false &&\n                    this.m_cache[key].count > this.m_removeThresholdCount) {\n                    delete this.m_cache[key];\n                }\n            }\n            else {\n                this.m_cache[key].used = false;\n                this.m_cache[key].count = 0;\n            }\n        }\n    }\n}\nexports.OutlineEffect = OutlineEffect;\n//# sourceMappingURL=Outline.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/Outline.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Pass.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Pass.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShaderPass = exports.RenderPass = exports.Pass = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * The base class to extend for further passes in {@link MapView},\n * like the {@link MSAARenderPass},\n *\n * @remarks\n * `Pass` provides the core logic for both :\n * - render passes (proper scene renders),\n * - and shader passes (quad renders, i.e. effects added on top of the render output as a\n * postprocess).\n *\n * Even some shader passes still actually fall within the render pass category as they need to\n * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the\n * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.\n * These only are proper shader passes.\n */\nclass Pass {\n    constructor() {\n        this.enabled = false;\n        this.renderToScreen = false;\n    }\n    setSize(width, height) {\n        // Implemented in sub-classes.\n    }\n    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {\n        // Implemented in sub-classes.\n    }\n}\nexports.Pass = Pass;\n/**\n * The pass that does a default normal scene rendering for further post-effects.\n */\nclass RenderPass extends Pass {\n    constructor() {\n        super();\n    }\n    /** @override */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.render(scene, camera);\n    }\n}\nexports.RenderPass = RenderPass;\n/**\n * The base class to extend for post-effects on the final render (like Vignette, Sepia, color\n * correction...)\n */\nclass ShaderPass extends Pass {\n    constructor(shader, textureID = \"tDiffuse\") {\n        super();\n        this.textureID = textureID;\n        if (shader instanceof THREE.ShaderMaterial) {\n            this.uniforms = shader.uniforms;\n            this.material = shader;\n        }\n        else {\n            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            this.material = new THREE.ShaderMaterial({\n                defines: Object.assign({}, shader.defines),\n                uniforms: this.uniforms,\n                vertexShader: shader.vertexShader,\n                fragmentShader: shader.fragmentShader\n            });\n        }\n        this.fsQuad = new FullScreenQuad(this.material);\n    }\n    /** @override */\n    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {\n        if (this.uniforms[this.textureID]) {\n            this.uniforms[this.textureID].value = readBuffer.texture;\n        }\n        this.fsQuad.material = this.material;\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        this.fsQuad.render(renderer);\n    }\n}\nexports.ShaderPass = ShaderPass;\nclass FullScreenQuad {\n    constructor(material) {\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const geometry = new THREE.PlaneBufferGeometry(2, 2);\n        this.m_mesh = new THREE.Mesh(geometry, material);\n    }\n    get material() {\n        return this.m_mesh.material;\n    }\n    set material(value) {\n        this.m_mesh.material = value;\n    }\n    render(renderer) {\n        renderer.render(this.m_mesh, this.m_camera);\n    }\n}\n//# sourceMappingURL=Pass.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/Pass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BloomPass = void 0;\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\nconst BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nconst BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n/**\n * The TS version of ThreeJS's UnrealBloomPass.\n */\nclass BloomPass extends Pass_1.Pass {\n    constructor(resolution, strength, radius, threshold) {\n        super();\n        this.resolution = new THREE.Vector2(256, 256);\n        this.m_renderTargetsHorizontal = [];\n        this.m_renderTargetsVertical = [];\n        this.m_nMips = 5;\n        this.m_separableBlurMaterials = [];\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        this.m_scene = new THREE.Scene();\n        this.m_basic = new THREE.MeshBasicMaterial();\n        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));\n        this.m_bloomTintColors = [\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1)\n        ];\n        this.strength = strength;\n        this.radius = radius;\n        this.threshold = threshold;\n        this.resolution = resolution;\n        this.m_quad.frustumCulled = false;\n        this.m_scene.add(this.m_quad);\n        const pars = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBAFormat\n        };\n        let resx = Math.round(this.resolution.x / 2);\n        let resy = Math.round(this.resolution.y / 2);\n        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.m_renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n        this.m_renderTargetBright.texture.generateMipmaps = false;\n        for (let i = 0; i < this.m_nMips; i++) {\n            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n            renderTargetHorizonal.texture.generateMipmaps = false;\n            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);\n            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n            renderTargetVertical.texture.generateMipmaps = false;\n            this.m_renderTargetsVertical.push(renderTargetVertical);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = threshold;\n        this.m_highPassUniforms[\"smoothWidth\"].value = 0.01;\n        this.m_materialHighPassFilter = new THREE.ShaderMaterial({\n            uniforms: this.m_highPassUniforms,\n            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,\n            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,\n            defines: {}\n        });\n        // Gaussian Blur Materials\n        const kernelSizeArray = [3, 5, 7, 9, 11];\n        resx = Math.round(this.resolution.x / 2);\n        resy = Math.round(this.resolution.y / 2);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n        // Composite material\n        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);\n        this.m_compositeMaterial.uniforms[\"blurTexture1\"].value = this.m_renderTargetsVertical[0].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture2\"].value = this.m_renderTargetsVertical[1].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture3\"].value = this.m_renderTargetsVertical[2].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture4\"].value = this.m_renderTargetsVertical[3].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture5\"].value = this.m_renderTargetsVertical[4].texture;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n        this.m_compositeMaterial.needsUpdate = true;\n        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n        this.m_compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);\n        this.m_copyUniforms[\"opacity\"].value = 1.0;\n        this.m_materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.m_copyUniforms,\n            vertexShader: harp_materials_1.CopyShader.vertexShader,\n            fragmentShader: harp_materials_1.CopyShader.fragmentShader,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n    }\n    dispose() {\n        for (const rt of this.m_renderTargetsHorizontal) {\n            rt.dispose();\n        }\n        for (const rt of this.m_renderTargetsVertical) {\n            rt.dispose();\n        }\n        this.m_renderTargetBright.dispose();\n    }\n    /** @override */\n    setSize(width, height) {\n        let resx = Math.round(width / 2);\n        let resy = Math.round(height / 2);\n        this.m_renderTargetBright.setSize(resx, resy);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_renderTargetsHorizontal[i].setSize(resx, resy);\n            this.m_renderTargetsVertical[i].setSize(resx, resy);\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n    }\n    /** @override */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        // Render input to screen\n        if (this.renderToScreen) {\n            this.m_quad.material = this.m_basic;\n            this.m_basic.map = readBuffer.texture;\n            renderer.setRenderTarget(null);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        // 1. Extract bright areas\n        this.m_highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n        this.m_quad.material = this.m_materialHighPassFilter;\n        renderer.setRenderTarget(this.m_renderTargetBright);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n        // 2. Blur all the mips progressively\n        let inputRenderTarget = this.m_renderTargetBright;\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_quad.material = this.m_separableBlurMaterials[i];\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value =\n                inputRenderTarget.texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionX;\n            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.m_renderTargetsHorizontal[i].texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionY;\n            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n            inputRenderTarget = this.m_renderTargetsVertical[i];\n        }\n        // Composite all the mips\n        this.m_quad.material = this.m_compositeMaterial;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n        // Blend it additively over the input texture\n        this.m_quad.material = this.m_materialCopy;\n        this.m_copyUniforms[\"tDiffuse\"].value = this.m_renderTargetsHorizontal[0].texture;\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        else {\n            renderer.setRenderTarget(readBuffer);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n    }\n    getSeperableBlurMaterial(kernelRadius) {\n        return new THREE.ShaderMaterial({\n            defines: {\n                KERNEL_RADIUS: kernelRadius,\n                SIGMA: kernelRadius\n            },\n            uniforms: {\n                colorTexture: { value: null },\n                texSize: { value: new THREE.Vector2(0.5, 0.5) },\n                direction: { value: new THREE.Vector2(0.5, 0.5) }\n            },\n            vertexShader: `varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }`,\n            fragmentShader: `#include <common>\n            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;\n            uniform vec2 direction;\n\n            float gaussianPdf(in float x, in float sigma) {\n                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n            }\n            void main() {\\n\\\n                vec2 invSize = 1.0 / texSize;\n                float fSigma = float(SIGMA);\n                float weightSum = gaussianPdf(0.0, fSigma);\n                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n                    float x = float(i);\n                    float w = gaussianPdf(x, fSigma);\n                    vec2 uvOffset = direction * invSize * x;\n                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n                    diffuseSum += (sample1 + sample2) * w;\n                    weightSum += 2.0 * w;\n                }\n                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n            }`\n        });\n    }\n    getCompositeMaterial(nMips) {\n        return new THREE.ShaderMaterial({\n            defines: {\n                NUM_MIPS: nMips\n            },\n            uniforms: {\n                blurTexture1: { value: null },\n                blurTexture2: { value: null },\n                blurTexture3: { value: null },\n                blurTexture4: { value: null },\n                blurTexture5: { value: null },\n                dirtTexture: { value: null },\n                bloomStrength: { value: 1.0 },\n                bloomFactors: { value: null },\n                bloomTintColors: { value: null },\n                bloomRadius: { value: 0.0 }\n            },\n            vertexShader: `varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }`,\n            fragmentShader: `varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    gl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }`\n        });\n    }\n}\nexports.BloomPass = BloomPass;\n//# sourceMappingURL=UnrealBloomPass.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MSAASampling = exports.MSAARenderPass = exports.Pass = exports.MapRenderingManager = void 0;\nvar MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ \"./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js\");\nObject.defineProperty(exports, \"MapRenderingManager\", { enumerable: true, get: function () { return MapRenderingManager_1.MapRenderingManager; } });\nvar Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\nObject.defineProperty(exports, \"Pass\", { enumerable: true, get: function () { return Pass_1.Pass; } });\nvar MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ \"./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js\");\nObject.defineProperty(exports, \"MSAARenderPass\", { enumerable: true, get: function () { return MSAARenderPass_1.MSAARenderPass; } });\nObject.defineProperty(exports, \"MSAASampling\", { enumerable: true, get: function () { return MSAARenderPass_1.MSAASampling; } });\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CopyrightCoverageProvider = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst RBush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/rbush.min.js\");\n/**\n * Base class to provide copyrights based on copyright coverage information, defined by geographical\n * bounding boxes and relevant zoom level ranges.\n */\nclass CopyrightCoverageProvider {\n    constructor() {\n        /** Logger instance. */\n        this.logger = harp_utils_1.LoggerManager.instance.create(\"CopyrightCoverageProvider\");\n    }\n    /** @inheritdoc */\n    getTree() {\n        if (this.m_cachedTreePromise !== undefined) {\n            return this.m_cachedTreePromise;\n        }\n        this.m_cachedTreePromise = this.getCopyrightCoverageData()\n            .then(coverageInfo => this.initRBush(coverageInfo))\n            .catch(error => {\n            this.logger.error(error);\n            return new RBush();\n        });\n        return this.m_cachedTreePromise;\n    }\n    /** @inheritdoc */\n    async getCopyrights(geoBox, level) {\n        const tree = await this.getTree();\n        const result = [];\n        const matchingEntries = tree.search({\n            minX: geoBox.west,\n            minY: geoBox.south,\n            maxX: geoBox.east,\n            maxY: geoBox.north\n        });\n        for (const entry of matchingEntries) {\n            const minLevel = harp_utils_1.getOptionValue(entry.minLevel, 0);\n            const maxLevel = harp_utils_1.getOptionValue(entry.maxLevel, Infinity);\n            if (level >= minLevel && level <= maxLevel) {\n                if (result.find(item => item.id === entry.label) === undefined) {\n                    result.push({ id: entry.label });\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Initializes RBush.\n     *\n     * @param entries - Entries for tree.\n     * @returns RBush instance.\n     */\n    initRBush(entries) {\n        const tree = new RBush();\n        if (!entries) {\n            this.logger.warn(\"No copyright coverage data provided\");\n            return tree;\n        }\n        for (const entry of entries) {\n            const { minLevel, maxLevel, label, alt } = entry;\n            if (!entry.boxes) {\n                tree.insert({\n                    minX: -180,\n                    minY: -90,\n                    maxX: 180,\n                    maxY: 180,\n                    minLevel,\n                    maxLevel,\n                    label,\n                    alt\n                });\n            }\n            else {\n                for (const box of entry.boxes) {\n                    const [minY, minX, maxY, maxX] = box;\n                    tree.insert({\n                        minX,\n                        minY,\n                        maxX,\n                        maxY,\n                        minLevel,\n                        maxLevel,\n                        label,\n                        alt\n                    });\n                }\n            }\n        }\n        return tree;\n    }\n}\nexports.CopyrightCoverageProvider = CopyrightCoverageProvider;\n//# sourceMappingURL=CopyrightCoverageProvider.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CopyrightElementHandler = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst MapView_1 = __webpack_require__(/*! ../MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\nconst CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js\");\n/**\n * Helper class that maintains up-to-date {@link MapView} copyright information in DOM element.\n *\n * @example\n *\n *     // HTML snippet\n *     <div id=\"copyrightNotice\" style=\"position:absolute; right:0; bottom:0; z-index:100\"></div>\n *\n *     // JavaScript\n *     const mapView = new MapView({ ... });\n *     CopyrightElementHandler.install(\"copyrightNotice\", mapView);\n */\nclass CopyrightElementHandler {\n    /**\n     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info\n     * of the given `mapView`.\n     *\n     * Note: Generally, the static [[install]] method can be used to create and attach a new\n     * `CopyrightElementHandler` to a {@link MapView}\n     *\n     * @param element - HTML DOM element or a HTML DOM element id\n     * @param mapView - optional, [[attach]] to this {@link MapView} instance\n     */\n    constructor(element, mapView) {\n        this.m_defaults = new Map();\n        this.m_mapViews = [];\n        /**\n         * Update copyright info text in controlled HTML element.\n         */\n        this.update = () => {\n            var _a;\n            const mergedCopyrightInfo = this.m_mapViews\n                .map(mapView => mapView.copyrightInfo)\n                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, (_a = this.staticInfo) !== null && _a !== void 0 ? _a : []);\n            // Conditionally hiding of element with copyright information.\n            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.\n            if (mergedCopyrightInfo.length === 0) {\n                this.m_element.style.display = \"none\";\n                return;\n            }\n            else {\n                this.m_element.style.display = \"block\";\n            }\n            if (this.m_defaults.size !== 0) {\n                for (const sourceInfo of mergedCopyrightInfo) {\n                    const defaults = this.m_defaults.get(sourceInfo.id);\n                    if (defaults !== undefined) {\n                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);\n                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);\n                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);\n                    }\n                }\n            }\n            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);\n            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);\n        };\n        if (typeof element === \"string\") {\n            const htmlElement = document.getElementById(element);\n            if (!htmlElement) {\n                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);\n            }\n            this.m_element = htmlElement;\n        }\n        else {\n            this.m_element = element;\n        }\n        if (mapView !== undefined) {\n            this.attach(mapView);\n        }\n    }\n    /**\n     * Install {@link CopyrightElementHandler} on DOM element and - optionally -\n     * attach to a {@link MapView} instance.\n     *\n     * @param element - HTML DOM element or a HTML DOM element id\n     * @param mapView -, optional, [[attach]] to this {@link MapView}\n     */\n    static install(element, mapView) {\n        return new CopyrightElementHandler(element, mapView);\n    }\n    /**\n     * Destroys this object by removing all event listeners from the attached {@link MapView}s.\n     */\n    destroy() {\n        for (const mapView of this.m_mapViews) {\n            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);\n        }\n    }\n    /**\n     * Attaches this {@link CopyrightInfo} updates from {@link MapView} instance.\n     */\n    attach(mapView) {\n        this.m_mapViews.push(mapView);\n        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);\n        this.update();\n        return this;\n    }\n    /**\n     * Stop following {@link CopyrightInfo} updates from {@link MapView} instance.\n     */\n    detach(mapView) {\n        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);\n        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);\n        this.update();\n        return this;\n    }\n    /**\n     * Set {@link CopyrightInfo} defaults to be used in case\n     * {@link DataSource} does not provide deatailed\n     * copyright information.\n     *\n     * @remarks\n     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright\n     * information retrieved from {@link MapView}.\n     */\n    setDefaults(defaults) {\n        this.m_defaults.clear();\n        if (defaults !== undefined) {\n            for (const item of defaults) {\n                this.m_defaults.set(item.id, item);\n            }\n        }\n        return this;\n    }\n    /**\n     * Sets the [[staticInfo]] property.\n     *\n     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and\n     * copyright information obtained from attached {@link MapView}s.\n     *\n     * This information is used when {@link DataSource}\n     * instances of given {@link MapView} do not provide\n     * copyright information.\n     */\n    setStaticCopyightInfo(staticInfo) {\n        this.staticInfo = staticInfo;\n        return this;\n    }\n}\nexports.CopyrightElementHandler = CopyrightElementHandler;\n//# sourceMappingURL=CopyrightElementHandler.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CopyrightInfo = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nvar CopyrightInfo;\n(function (CopyrightInfo) {\n    /**\n     * Merge {@link CopyrightInfo} arrays, removing duplicates.\n     *\n     * `id` and `label` are considered keys in deduplication algorithm.\n     *\n     * @param sources - non-duplicate elements from this array are added to `target`\n     * @returns merge of all copyright infos in `sources`\n     */\n    function mergeArrays(a, b) {\n        const result = [];\n        for (const source of [a, b]) {\n            if (source === undefined) {\n                continue;\n            }\n            for (const sourceInfo of source) {\n                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||\n                    (findItem.label !== undefined && findItem.label === sourceInfo.label));\n                if (existingInfo === undefined) {\n                    result.push(Object.assign({}, sourceInfo));\n                }\n                else {\n                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);\n                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);\n                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);\n                }\n            }\n        }\n        return result;\n    }\n    CopyrightInfo.mergeArrays = mergeArrays;\n    /**\n     * Format copyright information to a HTML string that can be displayed in the UI.\n     *\n     * * Empty list returns empty string.\n     * * Entries with empty (but defined) labels are skipped.\n     *\n     * @param copyrightInfo - Array of copyrights to format.\n     */\n    function formatAsHtml(copyrightInfo) {\n        if (copyrightInfo.length === 0) {\n            return \"\";\n        }\n        const filtered = copyrightInfo.filter(entry => entry.label !== \"\");\n        if (filtered.length === 0) {\n            return \"\";\n        }\n        return (\" \" +\n            filtered\n                .map(entry => {\n                var _a;\n                const label = (_a = entry.label) !== null && _a !== void 0 ? _a : entry.id;\n                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;\n                const link = entry.link;\n                return link\n                    ? `<a href=\"${link}\" target=\"_blank\" rel=\"noreferrer noopener\">${text}</a>`\n                    : `${text}`;\n            })\n                .join(\", \"));\n    }\n    CopyrightInfo.formatAsHtml = formatAsHtml;\n})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));\n//# sourceMappingURL=CopyrightInfo.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=CopyrightProvider.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UrlCopyrightProvider = void 0;\nconst harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ \"./node_modules/@here/harp-transfer-manager/index.js\");\nconst CopyrightCoverageProvider_1 = __webpack_require__(/*! ./CopyrightCoverageProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js\");\n/**\n * Copyright provider which retrieves copyright coverage information from provided URL.\n */\nclass UrlCopyrightProvider extends CopyrightCoverageProvider_1.CopyrightCoverageProvider {\n    /**\n     * Default constructor.\n     *\n     * @param m_fetchURL - URL to fetch copyrights data from.\n     * @param m_baseScheme - Scheme to get copyrights from.\n     * @param m_requestHeaders - Optional request headers for requests(e.g. Authorization)\n     */\n    constructor(m_fetchURL, m_baseScheme, m_requestHeaders, m_transferManager = harp_transfer_manager_1.TransferManager.instance()) {\n        super();\n        this.m_fetchURL = m_fetchURL;\n        this.m_baseScheme = m_baseScheme;\n        this.m_requestHeaders = m_requestHeaders;\n        this.m_transferManager = m_transferManager;\n    }\n    /**\n     * Sets request headers.\n     * @param headers -\n     */\n    setRequestHeaders(headers) {\n        this.m_requestHeaders = headers;\n    }\n    /**\n     * @inheritdoc\n     * @override\n     */\n    getCopyrightCoverageData(abortSignal) {\n        if (this.m_cachedCopyrightResponse !== undefined) {\n            return this.m_cachedCopyrightResponse;\n        }\n        this.m_cachedCopyrightResponse = this.m_transferManager\n            .downloadJson(this.m_fetchURL, {\n            headers: this.m_requestHeaders,\n            signal: abortSignal\n        })\n            .then(json => json[this.m_baseScheme])\n            .catch(error => {\n            this.logger.error(error);\n            return [];\n        });\n        return this.m_cachedCopyrightResponse;\n    }\n}\nexports.UrlCopyrightProvider = UrlCopyrightProvider;\n//# sourceMappingURL=UrlCopyrightProvider.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/AddGroundPlane.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/AddGroundPlane.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addGroundPlane = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst EdgeLengthGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js\");\nconst SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst LodMesh_1 = __webpack_require__(/*! ./LodMesh */ \"./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js\");\nconst ProjectTilePlaneCorners_1 = __webpack_require__(/*! ./ProjectTilePlaneCorners */ \"./node_modules/@here/harp-mapview/lib/geometry/ProjectTilePlaneCorners.js\");\nconst RegisterTileObject_1 = __webpack_require__(/*! ./RegisterTileObject */ \"./node_modules/@here/harp-mapview/lib/geometry/RegisterTileObject.js\");\nconst tmpV = new THREE.Vector3();\n/**\n * Creates and adds a background plane mesh for the tile.\n * @param tile - The tile to which the ground plane belongs.\n * @param renderOrder - The plane render order.\n * @param materialOrColor - The plane material or a color for a default material.\n * @param createTexCoords - Whether to create texture coordinates.\n * @param receiveShadow - Whether the plane should receive shadows.\n * @param createMultiLod - Whether to generate multiple LODs for sphere projection.\n * @internal\n */\nfunction addGroundPlane(tile, renderOrder, materialOrColor = tile.mapView.clearColor, createTexCoords = false, receiveShadow = tile.mapView.shadowsEnabled, createMultiLod = tile.mapView.enableMixedLod !== false) {\n    const mesh = createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod);\n    mesh.receiveShadow = receiveShadow;\n    mesh.renderOrder = renderOrder;\n    RegisterTileObject_1.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background, { pickable: false });\n    tile.objects.push(mesh);\n}\nexports.addGroundPlane = addGroundPlane;\nfunction createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod) {\n    const { dataSource, projection } = tile;\n    const sourceProjection = dataSource.getTilingScheme().projection;\n    const shouldSubdivide = projection.type === harp_geoutils_1.ProjectionType.Spherical;\n    const useLocalTargetCoords = !shouldSubdivide;\n    const material = typeof materialOrColor === \"number\"\n        ? createGroundPlaneMaterial(new THREE.Color(materialOrColor), receiveShadow, projection.type === harp_geoutils_1.ProjectionType.Spherical)\n        : materialOrColor;\n    const geometry = createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow);\n    if (!shouldSubdivide) {\n        return new THREE.Mesh(geometry, material);\n    }\n    const geometries = [];\n    const sphericalModifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.MathUtils.degToRad(10), sourceProjection);\n    if (!createMultiLod) {\n        sphericalModifier.modify(geometry);\n        toLocalTargetCoords(geometry, sourceProjection, tile);\n        return new THREE.Mesh(geometry, material);\n    }\n    // Use a [[LodMesh]] to adapt tesselation of tile depending on zoom level\n    for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {\n        const subdivision = Math.pow(2, zoomLevelOffset);\n        const zoomLevelGeometry = geometry.clone();\n        if (subdivision > 1) {\n            const edgeModifier = new EdgeLengthGeometrySubdivisionModifier_1.EdgeLengthGeometrySubdivisionModifier(subdivision, tile.geoBox, EdgeLengthGeometrySubdivisionModifier_1.SubdivisionMode.All, sourceProjection);\n            edgeModifier.modify(zoomLevelGeometry);\n        }\n        sphericalModifier.modify(zoomLevelGeometry);\n        toLocalTargetCoords(zoomLevelGeometry, sourceProjection, tile);\n        geometries.push(zoomLevelGeometry);\n    }\n    return new LodMesh_1.LodMesh(geometries, material);\n}\nfunction toLocalTargetCoords(geom, srcProjection, tile) {\n    const attr = geom.getAttribute(\"position\");\n    const oldArray = attr.array;\n    // Convert to single precision before rendering (WebGL does not support double\n    // precision).\n    const newArray = new Float32Array(oldArray.length);\n    for (let i = 0; i < attr.array.length; i += 1) {\n        tmpV.fromBufferAttribute(attr, i);\n        tile.projection.reprojectPoint(srcProjection, tmpV, tmpV).sub(tile.center);\n        tmpV.toArray(newArray, i * 3);\n    }\n    attr.array = newArray;\n    attr.needsUpdate = true;\n}\nfunction createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow) {\n    const { dataSource, projection } = tile;\n    const sourceProjection = dataSource.getTilingScheme().projection;\n    const tmpV = new THREE.Vector3();\n    const geometry = new THREE.BufferGeometry();\n    const tileCorners = ProjectTilePlaneCorners_1.projectTilePlaneCorners(tile, sourceProjection);\n    const cornersArray = [tileCorners.sw, tileCorners.se, tileCorners.nw, tileCorners.ne];\n    if (useLocalTargetCoords) {\n        for (const corner of cornersArray) {\n            projection.reprojectPoint(sourceProjection, corner, corner).sub(tile.center);\n        }\n    }\n    // Use 64bits floats for world coordinates to avoid precision issues on coordinate\n    // tranformations. The array must be converted to single precision before rendering.\n    const bufferArray = useLocalTargetCoords ? new Float32Array(12) : new Float64Array(12);\n    const posAttr = new THREE.BufferAttribute(bufferArray, 3).copyVector3sArray(cornersArray);\n    geometry.setAttribute(\"position\", posAttr);\n    if (receiveShadow) {\n        // Webmercator needs to have it negated to work correctly.\n        sourceProjection.surfaceNormal(tileCorners.sw, tmpV).negate();\n        const normAttr = new THREE.BufferAttribute(new Float32Array(12), 3).copyVector3sArray(Array(4).fill(tmpV));\n        geometry.setAttribute(\"normal\", normAttr);\n    }\n    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));\n    if (createTexCoords) {\n        const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);\n        geometry.setAttribute(\"uv\", uvAttr);\n    }\n    return geometry;\n}\nfunction createGroundPlaneMaterial(color, receiveShadow, depthWrite) {\n    if (receiveShadow) {\n        return new harp_materials_1.MapMeshStandardMaterial({\n            color,\n            visible: true,\n            depthWrite,\n            removeDiffuseLight: true\n        });\n    }\n    else {\n        return new harp_materials_1.MapMeshBasicMaterial({\n            color,\n            visible: true,\n            depthWrite\n        });\n    }\n}\n//# sourceMappingURL=AddGroundPlane.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/AddGroundPlane.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisplacedBufferAttribute = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst VertexCache_1 = __webpack_require__(/*! ./VertexCache */ \"./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js\");\n/**\n * @internal\n * BufferAttribute decorator that displaces on the fly the coordinates in a given attribute using a\n * specified displacement map.\n */\nclass DisplacedBufferAttribute extends THREE.BufferAttribute {\n    /**\n     * Creates an instance of displaced buffer attribute.\n     * @param originalAttribute - The buffer attribute to be displaced\n     *                            (e.g. the position attribute).\n     * @param m_normals - The normals along which the coordinates will be displaced.\n     * @param m_uvs - The uv coordinates to be used to sample the displacement map.\n     * @param displacementMap - A texture with the displacement values in 32bit floats.\n     */\n    constructor(originalAttribute, m_normals, m_uvs, displacementMap) {\n        super(originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);\n        this.originalAttribute = originalAttribute;\n        this.m_normals = m_normals;\n        this.m_uvs = m_uvs;\n        this.m_textureWidth = 0;\n        this.m_textureHeight = 0;\n        this.m_cache = new VertexCache_1.VertexCache(DisplacedBufferAttribute.MAX_CACHE_SIZE);\n        this.m_lastPos = new THREE.Vector3();\n        this.m_tmpNormal = new THREE.Vector3();\n        this.resetTexture(displacementMap);\n    }\n    /**\n     * Resets the displaced buffer attribute to use new buffer attributes or displacement map.\n     * @param originalAttribute - The buffer attribute to be displaced\n     *                            (e.g. the position attribute).\n     * @param normals - The normals along which the coordinates will be displaced.\n     * @param uvs -  The uv coordinates to be used to sample the displacement map.\n     * @param displacementMap - A texture with the displacement values in 32bit floats.\n     */\n    reset(originalAttribute, normals, uvs, displacementMap) {\n        this.array = originalAttribute.array;\n        this.itemSize = originalAttribute.itemSize;\n        this.count = this.array.length / this.itemSize;\n        this.normalized = originalAttribute.normalized;\n        this.originalAttribute = originalAttribute;\n        this.m_normals = normals;\n        this.m_uvs = uvs;\n        this.m_cache.clear();\n        this.m_lastBufferIndex = undefined;\n        this.resetTexture(displacementMap);\n    }\n    // HARP-9585: These getters are overrides of the base class ones, however tslint doesn't\n    // recognize them as such.\n    getX(index) {\n        return this.getDisplacedCoordinate(index).x;\n    }\n    getY(index) {\n        return this.getDisplacedCoordinate(index).y;\n    }\n    getZ(index) {\n        return this.getDisplacedCoordinate(index).z;\n    }\n    resetTexture(displacementMap) {\n        this.m_texture = new Float32Array(displacementMap.image.data.buffer);\n        this.m_textureWidth = displacementMap.image.width;\n        this.m_textureHeight = displacementMap.image.height;\n    }\n    getDisplacedCoordinate(bufferIndex) {\n        if (bufferIndex === this.m_lastBufferIndex) {\n            return this.m_lastPos;\n        }\n        this.m_lastBufferIndex = bufferIndex;\n        if (this.m_cache.get(bufferIndex, this.m_lastPos)) {\n            return this.m_lastPos;\n        }\n        this.displacePosition(bufferIndex);\n        this.m_cache.set(bufferIndex, this.m_lastPos);\n        return this.m_lastPos;\n    }\n    displacePosition(bufferIndex) {\n        this.m_lastPos.fromBufferAttribute(this.originalAttribute, bufferIndex);\n        const normals = this.m_normals;\n        this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);\n        const uvs = this.m_uvs;\n        const u = THREE.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);\n        const v = THREE.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);\n        const displacement = harp_utils_1.sampleBilinear(this.m_texture, this.m_textureWidth, this.m_textureHeight, u, v);\n        this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));\n    }\n}\nexports.DisplacedBufferAttribute = DisplacedBufferAttribute;\nDisplacedBufferAttribute.MAX_CACHE_SIZE = 6;\n//# sourceMappingURL=DisplacedBufferAttribute.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisplacedBufferGeometry = exports.displaceBox = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DisplacedBufferAttribute_1 = __webpack_require__(/*! ./DisplacedBufferAttribute */ \"./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js\");\nconst tmpV1 = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector3();\nconst tmpBox = new THREE.Box3();\n/**\n * @internal\n * Displace a box in a given direction by a specified range. The original box min and max vertices\n * are translated as a result by displacementRange.min and displacementRange.max respectively.\n * @param box - The original box to displace.\n * @param displacementRange - The minimum and maximum displacement values.\n * @param displacementDir - Direction in which the displacement will be applied.\n * @return The displaced box.\n */\nfunction displaceBox(box, displacementRange, displacementDir) {\n    tmpBox.copy(box);\n    const tmpNormalMin = tmpV1.copy(displacementDir);\n    const tmpNormalMax = tmpV2.copy(tmpNormalMin);\n    box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max)));\n    return box;\n}\nexports.displaceBox = displaceBox;\n/**\n * @internal\n * BufferGeometry decorator that displaces on the fly the position attribute using a specified\n * displacement map.\n */\nclass DisplacedBufferGeometry extends THREE.BufferGeometry {\n    /**\n     * Creates an instance of displaced buffer geometry.\n     * @param originalGeometry - The goeometry to be displaced.\n     * @param displacementMap - A texture with the displacement values.\n     * @param displacementRange - The displacement value range found in the displacement map.\n     * @param displacedPositions - Buffer attribute that will be used for displaced positions if\n     * provided, otherwise a new buffer attribute will be created.\n     */\n    constructor(originalGeometry, displacementMap, displacementRange, displacedPositions) {\n        super();\n        this.originalGeometry = originalGeometry;\n        this.displacementRange = displacementRange;\n        this.m_originalBoundingBox = new THREE.Box3();\n        if (!displacedPositions) {\n            this.m_displacedPositions = new DisplacedBufferAttribute_1.DisplacedBufferAttribute(originalGeometry.attributes.position, originalGeometry.attributes.normal, originalGeometry.attributes.uv, displacementMap);\n        }\n        else {\n            this.m_displacedPositions = displacedPositions;\n        }\n        this.resetAttributes();\n    }\n    /**\n     * Resets the displaced buffer geometry to use new geometry or displacement map.\n     * @param geometry - The goeometry to be displaced.\n     * @param displacementMap - A texture with the displacement values.\n     * @param displacementRange - The displacement value range found in the displacement map.\n     */\n    reset(geometry, displacementMap, displacementRange) {\n        this.originalGeometry = geometry;\n        const positions = geometry.attributes.position;\n        const normals = geometry.attributes.normal;\n        const uvs = geometry.attributes.uv;\n        this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);\n        const displacementRangeChanged = this.displacementRange.min !== displacementRange.min ||\n            this.displacementRange.max !== displacementRange.max;\n        this.displacementRange = displacementRange;\n        this.resetAttributes();\n        this.resetBoundingVolumes(displacementRangeChanged);\n    }\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    computeBoundingBox() {\n        // Calculate a coarse approximation of the displaced geometry bbox by displacing the\n        // original bbox and enlarging it to cover the whole displacement range.\n        // This approximation is used to avoid having to displace the whole geometry, which will\n        // be done only if the bbox test passes.\n        if (this.originalGeometry.boundingBox === null) {\n            this.originalGeometry.computeBoundingBox();\n        }\n        const origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox);\n        if (this.boundingBox === null) {\n            this.boundingBox = origBBox.clone();\n        }\n        else {\n            this.boundingBox.copy(origBBox);\n        }\n        displaceBox(this.boundingBox, this.displacementRange, tmpV1.fromBufferAttribute(this.attributes.normal, 0));\n    }\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    computeBoundingSphere() {\n        // Use as coarse approximation the sphere bounding the bbox.\n        if (this.boundingBox === null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere === null) {\n            this.boundingSphere = new THREE.Sphere();\n        }\n        this.boundingBox.getBoundingSphere(this.boundingSphere);\n    }\n    needsBoundingBoxUpdate(displacementRangeChanged) {\n        return (displacementRangeChanged ||\n            (this.boundingBox !== null &&\n                (!this.originalGeometry.boundingBox ||\n                    !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox))));\n    }\n    resetBoundingVolumes(displacementRangeChanged) {\n        if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {\n            this.computeBoundingBox();\n            if (this.boundingSphere) {\n                this.computeBoundingSphere();\n            }\n        }\n    }\n    resetAttributes() {\n        this.index = this.originalGeometry.index;\n        this.groups = this.originalGeometry.groups;\n        this.drawRange = this.originalGeometry.drawRange;\n        this.attributes = Object.assign({}, this.originalGeometry.attributes);\n        this.attributes.position = this.m_displacedPositions;\n    }\n}\nexports.DisplacedBufferGeometry = DisplacedBufferGeometry;\n//# sourceMappingURL=DisplacedBufferGeometry.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisplacedMesh = void 0;\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DisplacedBufferAttribute_1 = __webpack_require__(/*! ./DisplacedBufferAttribute */ \"./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js\");\nconst DisplacedBufferGeometry_1 = __webpack_require__(/*! ./DisplacedBufferGeometry */ \"./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js\");\nfunction isDisplacementMaterial(material) {\n    const isDisplacementFeature = harp_materials_1.hasDisplacementFeature(material);\n    harp_utils_1.assert(isDisplacementFeature, \"Material does not support displacement maps.\");\n    return isDisplacementFeature;\n}\nfunction isDataTextureMap(map) {\n    if (!map) {\n        return false;\n    }\n    const isDataTexture = map instanceof THREE.DataTexture;\n    harp_utils_1.assert(isDataTexture, \"Material does not support displacement maps.\");\n    return isDataTexture;\n}\n/**\n * Mesh with geometry modified by a displacement map. Overrides raycasting behaviour to apply\n * displacement map before intersection test.\n * @internal\n */\nclass DisplacedMesh extends THREE.Mesh {\n    /**\n     * Creates an instance of displaced mesh.\n     * @param geometry - Original geometry to displace.\n     * @param material - Material(s) to be used by the mesh. All must have the same\n     *                   displacement map.\n     * @param m_getDisplacementRange - Displacement values range getter.\n     * @param [m_raycastStrategy] Function that will be used to find ray intersections. If not\n     * provided, THREE.Mesh's raycast will be used.\n     */\n    constructor(geometry, material, m_getDisplacementRange, m_raycastStrategy) {\n        super(geometry, material);\n        this.m_getDisplacementRange = m_getDisplacementRange;\n        this.m_raycastStrategy = m_raycastStrategy;\n    }\n    static getDisplacedPositionAttribute(geometry, displacementMap) {\n        // Reuse same buffer attribute for all meshes since it's only needed during the\n        // intersection test.\n        if (!DisplacedMesh.displacedPositions) {\n            DisplacedMesh.displacedPositions = new DisplacedBufferAttribute_1.DisplacedBufferAttribute(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);\n        }\n        else {\n            DisplacedMesh.displacedPositions.reset(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);\n        }\n        return DisplacedMesh.displacedPositions;\n    }\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    raycast(raycaster, intersects) {\n        // All materials in the object are expected to have the same displacement map.\n        const firstMaterial = this.firstMaterial;\n        // Use default raycasting implementation if there's no displacement material or if there's\n        // no displacement map or its type is not supported.\n        if (!isDisplacementMaterial(firstMaterial) ||\n            !isDataTextureMap(firstMaterial.displacementMap)) {\n            super.raycast(raycaster, intersects);\n            return;\n        }\n        const displacementMap = firstMaterial.displacementMap;\n        const displacementRange = Object.assign({}, this.m_getDisplacementRange());\n        harp_utils_1.assert(this.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type.\");\n        const geometry = this.geometry;\n        if (this.displacedGeometry) {\n            this.displacedGeometry.reset(geometry, displacementMap, displacementRange);\n        }\n        else {\n            this.displacedGeometry = new DisplacedBufferGeometry_1.DisplacedBufferGeometry(geometry, displacementMap, displacementRange, DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap));\n        }\n        // Replace the original geometry by the displaced one only during the intersection test.\n        this.geometry = this.displacedGeometry;\n        if (this.m_raycastStrategy) {\n            this.m_raycastStrategy(this, raycaster, intersects);\n        }\n        else {\n            super.raycast(raycaster, intersects);\n        }\n        super.geometry = this.displacedGeometry.originalGeometry;\n    }\n    get firstMaterial() {\n        return Array.isArray(this.material) ? this.material[0] : this.material;\n    }\n}\nexports.DisplacedMesh = DisplacedMesh;\n//# sourceMappingURL=DisplacedMesh.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LodMesh = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * A mesh that can store multiple versions of a geometry with differents level of detail.\n * The rendered level of detail can be adapted during runtime.\n * @internal\n * @hidden\n */\nclass LodMesh extends THREE.Mesh {\n    /**\n     * Creates a [[LodMesh]] with given geometries and materials\n     * @param geometries - A list of geometries with different levels of detail\n     * @param material - Material for the mesh\n     */\n    constructor(geometries, material) {\n        super(undefined, material);\n        this.geometries = geometries;\n    }\n    /**\n     * Update geometries of mesh\n     */\n    set geometries(geometries) {\n        // dispose previous geometries\n        if (this.m_geometries !== geometries) {\n            this.disposeGeometries();\n        }\n        this.m_geometries = geometries;\n        if (this.geometries && this.m_geometries.length > 0) {\n            this.geometry = this.m_geometries[0];\n        }\n    }\n    /**\n     * Get geometries of mesh\n     */\n    get geometries() {\n        return this.m_geometries;\n    }\n    /**\n     * Change the rendered level of detail of the mesh\n     * @param level - The level of detail (index of the geometry in the list).\n     */\n    setLevelOfDetail(level) {\n        if (!this.m_geometries || this.m_geometries.length === 0) {\n            return;\n        }\n        level = THREE.MathUtils.clamp(level, 0, this.m_geometries.length - 1);\n        this.geometry = this.m_geometries[level];\n    }\n    /**\n     * Dispose all geometries of mesh\n     */\n    disposeGeometries() {\n        if (this.m_geometries) {\n            for (const geometry of this.m_geometries) {\n                geometry.dispose();\n            }\n        }\n        this.geometry.dispose();\n    }\n}\nexports.LodMesh = LodMesh;\n//# sourceMappingURL=LodMesh.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/ProjectTilePlaneCorners.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/ProjectTilePlaneCorners.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.projectTilePlaneCorners = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Returns the corners of the tile's geo bounding box projected using a given projection.\n * @param tile - The tile whose corners will be projected.\n * @param projection - The projection to be used.\n * @returns The projected tile corners.\n * @internal\n * @hidden\n */\nfunction projectTilePlaneCorners(tile, projection) {\n    const { east, west, north, south } = tile.geoBox;\n    const sw = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), new THREE.Vector3());\n    const se = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), new THREE.Vector3());\n    const nw = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), new THREE.Vector3());\n    const ne = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), new THREE.Vector3());\n    return { sw, se, nw, ne };\n}\nexports.projectTilePlaneCorners = projectTilePlaneCorners;\n//# sourceMappingURL=ProjectTilePlaneCorners.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/ProjectTilePlaneCorners.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/RegisterTileObject.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/RegisterTileObject.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerTileObject = void 0;\nconst MapObjectAdapter_1 = __webpack_require__(/*! ../MapObjectAdapter */ \"./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js\");\n/**\n * Adds a THREE object to the root of the tile and register [[MapObjectAdapter]].\n *\n * Sets the owning tiles datasource.name and the `tileKey` in the `userData` property of the\n * object, such that the tile it belongs to can be identified during picking.\n *\n * @param tile - The {@link Tile} to add the object to.\n * @param object - The object to add to the root of the tile.\n * @param geometryKind - The kind of object. Can be used for filtering.\n * @param mapAdapterParams - additional parameters for [[MapObjectAdapter]]\n */\nfunction registerTileObject(tile, object, geometryKind, mapAdapterParams) {\n    const kind = geometryKind instanceof Set\n        ? Array.from(geometryKind.values())\n        : Array.isArray(geometryKind)\n            ? geometryKind\n            : [geometryKind];\n    MapObjectAdapter_1.MapObjectAdapter.create(object, Object.assign({ dataSource: tile.dataSource, kind, level: tile.tileKey.level }, mapAdapterParams));\n    // TODO legacy fields, encoded directly in `userData to be removed\n    if (object.userData === undefined) {\n        object.userData = {};\n    }\n    const userData = object.userData;\n    userData.tileKey = tile.tileKey;\n    userData.dataSource = tile.dataSource.name;\n    userData.kind = kind;\n    // Force a visibility check of all objects.\n    tile.resetVisibilityCounter();\n}\nexports.registerTileObject = registerTileObject;\n//# sourceMappingURL=RegisterTileObject.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/RegisterTileObject.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SolidLineMesh = void 0;\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DisplacedBufferGeometry_1 = __webpack_require__(/*! ./DisplacedBufferGeometry */ \"./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js\");\nconst tmpSphere = new THREE.Sphere();\nconst tmpInverseMatrix = new THREE.Matrix4();\nconst tmpRay = new THREE.Ray();\nconst tmpLine1 = new THREE.Line3();\nconst tmpBox = new THREE.Box3();\nconst tmpOBB = new harp_geoutils_1.OrientedBox3();\nconst tmpPlane = new THREE.Plane();\nconst tmpV1 = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector3();\nconst tmpV3 = new THREE.Vector3();\nconst tmpV4 = new THREE.Vector3();\n// Strides to access the index buffer. See [[createLineGeometry]].\n// Stride between the start vertex indices of consecutive segments, each one made of 2 triangles.\nconst SEGMENT_STRIDE = 6;\n// Stride between the start and end vertex indices of a segment. Vertices are duplicated so that\n// each copy is extruded in opposite directions in the vertex shader.\nconst VERTEX_STRIDE = 2;\nfunction isSolidLineMaterial(material) {\n    return Array.isArray(material)\n        ? material.every(mat => mat instanceof harp_materials_1.SolidLineMaterial)\n        : material instanceof harp_materials_1.SolidLineMaterial;\n}\n/**\n * Create an [[AttributeInfo]] for the specified attribute.\n * @param attribute The attribute to retrieve version info from.\n * @returns The [[AttributeInfo]] containing a reference and version of the attribute's data.\n */\nfunction getAttributeInfo(attribute) {\n    const isBufferAttribute = attribute.isBufferAttribute === true;\n    const data = isBufferAttribute\n        ? attribute\n        : attribute.data;\n    return {\n        data,\n        version: data.version\n    };\n}\n/**\n * Check if an attribute has changed compared to the version info.\n * @param attribute Attribute to check.\n * @param attrInfo Attribute version info.\n * @returns `true` if the attribute is the same, `false` otherwise.\n */\nfunction attributeChanged(attribute, attrInfo) {\n    const isBufferAttribute = attribute.isBufferAttribute === true;\n    const data = isBufferAttribute\n        ? attribute\n        : attribute.data;\n    return (attrInfo === undefined ||\n        attrInfo.data !== data ||\n        (attribute.isBufferAttribute &&\n            attrInfo.version !== data.version));\n}\n/**\n * Computes the bounding sphere of the part of a given geometry corresponding to a feature.\n * @param geometry - The geometry containing the feature.\n * @param featureBeginIndex - The index where the feature starts in the geometry's\n *                            indices attribute.\n * @param featureEndIndex - The index where the feature end in the geometry's indices attribute.\n * @returns The feature bounding sphere.\n */\nfunction computeFeatureBoundingSphere(geometry, featureBeginIndex, featureEndIndex) {\n    let displacementRange;\n    if (geometry instanceof DisplacedBufferGeometry_1.DisplacedBufferGeometry) {\n        displacementRange = geometry.displacementRange;\n        geometry = geometry.originalGeometry;\n    }\n    const attributes = geometry.attributes;\n    const pos = attributes.position;\n    const indices = geometry.index.array;\n    const sphere = new THREE.Sphere();\n    const bbox = tmpBox.makeEmpty();\n    const vertex = tmpV1;\n    // First compute the bounding box for all line segments.\n    for (let i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE) {\n        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));\n        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));\n    }\n    if (displacementRange) {\n        // If geometry is displaced, expand the bounding box to cover the whole displacement range,\n        // and return the sphere bounding the box. This is a coarse estimation, but avoids having\n        // to displace all vertices.\n        // All normals in the geometry are assumed to be the same or close enough so that any of\n        // them can be used as displacement direction. For sphere projection, the surface normals\n        // within a tile are approximately the same from level 4 onwards. Here are some examples of\n        // the minimum dot product between normals in a tile (normals at tile's opposite corners):\n        // TILE: (6,9,4): 0.9806892129880023\n        // TILE: (12,17,5): 0.9946739445457075\n        // TILE: (25,34,6): 0.9986326302953471\n        // TILE: (50,68,7): 0.9996583822992287\n        // TILE: (1620,2199,12): 0.9999996706085572\n        const normal = tmpV2;\n        normal.fromBufferAttribute(geometry.attributes.normal, 0);\n        return DisplacedBufferGeometry_1.displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);\n    }\n    return bbox.getBoundingSphere(sphere);\n}\n/**\n * Finds the intersection of a ray with a extruded line.\n * @param ray - Intersection ray in object's local space.\n * @param line - The centerline.\n * @param vExtrusion - Line extrusion vector.\n * @param normal - Extrusion plane normal.\n * @param hWidth - Extrusion half width.\n * @returns Distance of the extruded line intersection to the ray origin.\n */\nfunction intersectExtrudedLine(ray, line, vExtrusion, normal, hWidth) {\n    var _a;\n    const obb = tmpOBB;\n    line.getCenter(obb.position);\n    line.delta(obb.xAxis).normalize();\n    obb.yAxis.copy(vExtrusion);\n    obb.zAxis.copy(normal);\n    obb.extents.set(line.distance() / 2, hWidth, hWidth);\n    if (obb.contains(ray.origin)) {\n        return 0;\n    }\n    return (_a = obb.intersectsRay(ray)) !== null && _a !== void 0 ? _a : Infinity;\n}\n/**\n * Finds the intersection of a ray with the closest end cap of a extruded line.\n * @param ray - Intersection ray in object's local space.\n * @param line - The centerline.\n * @param hWidth - Extrusion half width.\n * @returns Distance of the end cap intersection to the ray origin.\n */\nfunction intersectClosestEndCap(ray, line, hWidth) {\n    const sphere = new THREE.Sphere(line.start, hWidth);\n    const startCapT = sphere.containsPoint(ray.origin)\n        ? 0\n        : ray.intersectSphere(sphere, tmpV4)\n            ? tmpV4.sub(ray.origin).length()\n            : Infinity;\n    sphere.center.copy(line.end);\n    const endCapT = sphere.containsPoint(ray.origin)\n        ? 0\n        : ray.intersectSphere(sphere, tmpV4)\n            ? tmpV4.sub(ray.origin).length()\n            : Infinity;\n    return Math.min(startCapT, endCapT);\n}\n/**\n * Intersects line\n * @param ray - Intersection ray in object's local space.\n * @param line - The line to intersect.\n * @param vExtrusion - Line extrusion vector.\n * @param hWidth - The line's extrusion half width.\n * @param hWidthSq - The line's extrusion half width squared.\n * @param plane - The extrusion plane.\n * @param interPlane - The intersection of the ray with the extrusion plane.\n * @param outInterLine - The ray intersection with the extruded line.\n * @returns true if ray intersects the extruded line, false otherwise.\n */\nfunction intersectLine(ray, line, vExtrusion, hWidth, hWidthSq, plane, interPlane, outInterLine) {\n    if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {\n        // Corner case: ray is coplanar to extruded line, find distance to extruded line sides\n        // and end caps.\n        const extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);\n        const endCapT = intersectClosestEndCap(ray, line, hWidth);\n        const minT = Math.min(extrLineT, endCapT);\n        if (minT === Infinity) {\n            return false;\n        }\n        ray.at(minT, outInterLine);\n        return true;\n    }\n    // The plain intersection is also a line intersection only if it's closer to the line\n    // than the extrusion half width.\n    const distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));\n    if (distSq > hWidthSq) {\n        return false;\n    }\n    outInterLine.copy(interPlane);\n    return true;\n}\n/**\n * Finds the intersections of a ray with a partition of a solid line mesh representing a feature.\n * @param mesh - The mesh whose intersections will be found.\n * @param raycaster - Contains the intersection ray.\n * @param localRay - Same ray as raycaster.ray but in object's local space.\n * @param halfWidth - The line's extrusion half width.\n * @param lHalfWidth - The line's extrusion half width in mesh local space.\n * @param lHalfWidthSq - The line's extrusion half width squared in mesh local space.\n * @param beginIdx - The index where the feature starts in the mesh geometry's indices attribute.\n * @param endIdx - The index where the feature end in the mesh geometry's indices attribute.\n * @param bSphere - The feature bounding sphere.\n * @param intersections - Array where all intersections found between ray and feature will\n *                        be pushed.\n */\nfunction intersectFeature(mesh, raycaster, localRay, halfWidth, lHalfWidth, lHalfWidthSq, beginIdx, endIdx, bSphere, intersections) {\n    const vExt = tmpV1;\n    const plane = tmpPlane;\n    const interPlane = tmpV2;\n    const line = tmpLine1;\n    const geometry = mesh.geometry;\n    const attributes = geometry.attributes;\n    const position = attributes.position;\n    const bitangent = attributes.bitangent;\n    const indices = geometry.index.array;\n    tmpSphere.copy(bSphere);\n    tmpSphere.applyMatrix4(mesh.matrixWorld);\n    tmpSphere.radius += halfWidth;\n    if (!raycaster.ray.intersectsSphere(tmpSphere)) {\n        return;\n    }\n    for (let i = beginIdx; i < endIdx; i += SEGMENT_STRIDE) {\n        const a = indices[i];\n        const b = indices[i + VERTEX_STRIDE];\n        // Find the plane containing the line segment, using the segment start, end and extrusion\n        // vector.\n        line.start.fromBufferAttribute(position, a);\n        line.end.fromBufferAttribute(position, b);\n        vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();\n        plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);\n        if (plane.normal.manhattanLength() === 0) {\n            // Invalid plane, coplanar points are actually collinear because:\n            // a) The line segment has length 0.\n            // b) The extrusion vector has length 0.\n            // c) The extrusion and segment directions are the same.\n            // In any case it's a degenerate segment, skip it.\n            continue;\n        }\n        // The ray intersection if any, will be on the extrusion plane.\n        if (!localRay.intersectPlane(plane, interPlane)) {\n            continue;\n        }\n        const interLine = tmpV3;\n        if (!intersectLine(localRay, line, vExt, lHalfWidth, lHalfWidthSq, plane, interPlane, interLine)) {\n            continue;\n        }\n        // Move back to world space for distance calculation\n        const interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);\n        const distance = raycaster.ray.origin.distanceTo(interLineWorld);\n        if (distance < raycaster.near || distance > raycaster.far) {\n            continue;\n        }\n        intersections.push({\n            distance,\n            point: interLineWorld.clone(),\n            index: i,\n            object: mesh\n        });\n    }\n}\nconst singleFeatureStart = [0];\nconst MAX_SCALE_RATIO_DIFF = 1e-2;\n/**\n * Finds the intersections of a ray with a group within a solid line mesh.\n * @param mesh - The mesh whose intersections will be found.\n * @param material - The material used by the group inside the mesh.\n * @param raycaster -  Contains the intersection ray.\n * @param localRay - Same ray as raycaster.ray but in object's local space.\n * @param firstFeatureIdx - Index of the first feature in the group.\n * @param groupEndIdx - Index of the last vertex in the group.\n * @param intersections -  Array where all intersections found between ray and group will be pushed.\n * @returns The next feature index after the group.\n */\nfunction intersectGroup(mesh, material, raycaster, localRay, firstFeatureIdx, groupEndIdx, intersections) {\n    var _a;\n    const bVolumes = mesh.userData.feature.boundingVolumes;\n    harp_utils_1.assert(mesh.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type.\");\n    const geometry = mesh.geometry;\n    harp_utils_1.assert(isSolidLineMaterial(material), \"Unsupported material type\");\n    const solidLineMaterial = material;\n    const halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;\n    // Assumption: scaling is uniform or close enough to use a local width independent of direction.\n    harp_utils_1.assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);\n    harp_utils_1.assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);\n    harp_utils_1.assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);\n    const localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);\n    const localHalfWidthSq = localHalfWidth * localHalfWidth;\n    const featureStarts = (_a = mesh.userData.feature.starts) !== null && _a !== void 0 ? _a : singleFeatureStart;\n    let featureIdx = firstFeatureIdx;\n    let beginIdx = featureStarts[featureIdx];\n    const lastFeatureIdx = featureStarts.length - 1;\n    while (beginIdx < groupEndIdx) {\n        const bVolumeIdx = featureIdx;\n        const endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;\n        if (bVolumeIdx >= bVolumes.length) {\n            // Geometry might be extruded on any direction. To avoid extruding all vertices, the\n            // centerline geometry is used to compute a bounding sphere whose radius is later\n            // expanded by the extrusion half width to ensure it contains the extruded geometry.\n            bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));\n        }\n        intersectFeature(mesh, raycaster, localRay, halfWidth, localHalfWidth, localHalfWidthSq, beginIdx, endIdx, bVolumes[bVolumeIdx], intersections);\n        beginIdx = endIdx;\n    }\n    return featureIdx;\n}\n/**\n * Mesh formed by extruding a polyline in the shaders. Overrides raycasting behaviour to account for\n * extrusion, see [[SolidLineMaterial]].\n * @internal\n */\nclass SolidLineMesh extends THREE.Mesh {\n    /**\n     * Finds the intersections of a ray with a mesh, assuming the mesh is a polyline extruded in\n     * the shaders (see [[SolidLineMaterial]]).\n     * @param mesh - The mesh whose intersections will be found.\n     * @param raycaster - Contains the intersection ray.\n     * @param intersections - Array where all intersections found between ray and mesh will\n     *                        be pushed.\n     */\n    static raycast(mesh, raycaster, intersections) {\n        harp_utils_1.assert(mesh.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type\");\n        const geometry = mesh.geometry;\n        harp_utils_1.assert(geometry.index !== null, \"Geometry does not have indices\");\n        const matrixWorld = mesh.matrixWorld;\n        tmpInverseMatrix.copy(matrixWorld).invert();\n        const localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n        // Test intersection of ray with each of the features within the mesh.\n        if (mesh.userData.feature === undefined) {\n            mesh.userData.feature = {};\n        }\n        const positionAttribute = geometry.attributes[\"position\"];\n        const attributeInfo = mesh.userData.feature\n            .attributeInfo;\n        // Rebuild bounding volumes if geometry has been modified.\n        if (attributeInfo === undefined ||\n            mesh.userData.feature.boundingVolumes === undefined ||\n            attributeChanged(positionAttribute, attributeInfo)) {\n            mesh.userData.feature.boundingVolumes = [];\n            mesh.userData.feature.attributeInfo = getAttributeInfo(positionAttribute);\n        }\n        const indices = geometry.index.array;\n        if (Array.isArray(mesh.material)) {\n            let nextFeatureIdx = 0;\n            for (const group of geometry.groups) {\n                const material = mesh.material[group.materialIndex];\n                const groupEndIdx = group.start + group.count;\n                nextFeatureIdx = intersectGroup(mesh, material, raycaster, localRay, nextFeatureIdx, groupEndIdx, intersections);\n            }\n        }\n        else {\n            intersectGroup(mesh, mesh.material, raycaster, localRay, 0, indices.length, intersections);\n        }\n    }\n    /**\n     * Creates an instance of SolidLineMesh.\n     * @param geometry - Mesh geometry.\n     * @param material - Material(s) to be used by the mesh. They must be instances of\n     * [[SolidLineMaterial]].\n     */\n    constructor(geometry, material) {\n        super(geometry, material);\n    }\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    raycast(raycaster, intersects) {\n        SolidLineMesh.raycast(this, raycaster, intersects);\n    }\n}\nexports.SolidLineMesh = SolidLineMesh;\n//# sourceMappingURL=SolidLineMesh.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileDataAccessor = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileDataAccessor\");\n/**\n * An accessor for all geometries in a tile.\n *\n * @remarks\n * This class uses a client-provided {@link ITileDataVisitor}\n * to visit all objects, based on filtering options specified\n * by both, the `TileDataAccessor` and\n * the visitor itself.\n */\nclass TileDataAccessor {\n    /**\n     * Constructs a `TileDataAccessor` instance.\n     *\n     * @param tile - The tile to access.\n     * @param visitor - The visitor.\n     * @param options - Options for the tile.\n     */\n    constructor(tile, visitor, options) {\n        this.tile = tile;\n        this.visitor = visitor;\n        const wantsAll = options.wantsAll === true;\n        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);\n        this.m_wantsLines = wantsAll || !(options.wantsLines === false);\n        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);\n        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);\n    }\n    /**\n     * Calls the visitor on all objects in the tile.\n     */\n    visitAll() {\n        const objects = this.tile.objects;\n        for (const object of objects) {\n            this.visitObject(object);\n        }\n    }\n    /**\n     * Visits a single object. This function should normally be called during visiting.\n     *\n     * @param object - The object to visit.\n     */\n    visitObject(object) {\n        const featureData = object.userData !== undefined\n            ? object.userData.feature\n            : undefined;\n        // early opt out if there is no feature data, or if the feature data has only a single id\n        // and the visitor wants to ignore that featureId\n        if (featureData === undefined ||\n            (featureData.objInfos !== undefined &&\n                featureData.objInfos.length === 1 &&\n                !this.visitor.wantsFeature(harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])))) {\n            return;\n        }\n        const geometryType = featureData.geometryType;\n        if (geometryType === undefined) {\n            logger.warn(\"#visitObject: visiting object failed, no geometryType\", object);\n            return;\n        }\n        harp_utils_1.assert(featureData.objInfos !== undefined, \"featureData.ids missing\");\n        harp_utils_1.assert(featureData.starts !== undefined, \"featureData.starts missing\");\n        harp_utils_1.assert(Array.isArray(featureData.starts), \"featureData.starts is not an array\");\n        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {\n            harp_utils_1.assert(featureData.objInfos.length === featureData.starts.length, \"featureData.ids and featureData.starts have unequal length\");\n        }\n        switch (geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                if (!this.m_wantsPoints) {\n                    return;\n                }\n                break;\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                if (!this.m_wantsLines) {\n                    return;\n                }\n                break;\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                if (!this.m_wantsAreas) {\n                    return;\n                }\n                break;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                if (!this.m_wantsObject3D) {\n                    return;\n                }\n                break;\n            default:\n                logger.warn(\"#visitObject: invalid geometryType\");\n        }\n        if (object.type !== \"Mesh\") {\n            logger.warn(\"#visitObject: visiting object failed, not of type 'Mesh'\", object);\n            return;\n        }\n        const mesh = object;\n        this.visitMesh(mesh, featureData);\n    }\n    /**\n     * Gets the `BufferGeometry` from the specified object. This function requires the\n     * attribute `position` in `BufferGeometry` to be set.\n     *\n     * @param object - The object from which to get the geometry.\n     * @returns the geometry of the object, or `undefined`.\n     */\n    getBufferGeometry(object) {\n        const geometry = object.geometry;\n        if (geometry.type !== \"BufferGeometry\") {\n            logger.warn(\"#visitObject: object does not have BufferGeometry\");\n            return undefined;\n        }\n        const bufferGeometry = geometry;\n        // we know its a BufferAttribute because it is a BufferGeometry\n        const position = bufferGeometry.getAttribute(\"position\");\n        if (!position) {\n            logger.warn(\"#visitLines: BufferGeometry has no position attribute\");\n            return undefined;\n        }\n        return bufferGeometry;\n    }\n    /**\n     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType - The type of geometry.\n     * @param object - The object for which to access the attributes and geometry.\n     * @param bufferGeometry - The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    getGeometryAccessor(geometryType, object, bufferGeometry) {\n        switch (geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);\n            default:\n                logger.warn(\"#getGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n    /**\n     * Obtains an accessor for the indexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType - The type of geometry.\n     * @param object - The object for which to access the attributes and geometry.\n     * @param bufferGeometry - The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {\n        switch (geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            default:\n                logger.warn(\"#getIndexedGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n    /**\n     * Visit the object.\n     *\n     * @param meshObject - Object of type `Mesh`.\n     * @param featureData - Dataset stored along with the object.\n     */\n    visitMesh(meshObject, featureData) {\n        const { objInfos, starts } = featureData;\n        const geometryType = featureData.geometryType;\n        // make linter happy: we already know that these both are valid\n        if (objInfos === undefined || starts === undefined || geometryType === undefined) {\n            return;\n        }\n        let geometryAccessor;\n        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {\n            const featureId = harp_datasource_protocol_1.getFeatureId(objInfos[featureIndex]);\n            if (!this.visitor.wantsFeature(featureId)) {\n                continue;\n            }\n            const featureStart = starts[featureIndex];\n            let featureEnd = -1;\n            // lazy creation of accessor, in case featureId was not wanted...\n            if (geometryAccessor === undefined) {\n                const bufferGeometry = this.getBufferGeometry(meshObject);\n                if (bufferGeometry === undefined) {\n                    continue;\n                }\n                if (bufferGeometry.index !== null) {\n                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);\n                }\n                else {\n                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);\n                }\n                if (geometryAccessor === undefined) {\n                    logger.warn(\"#visitObject: no accessor geometryType\", geometryType);\n                    continue;\n                }\n            }\n            featureEnd =\n                featureIndex < starts.length - 1\n                    ? starts[featureIndex + 1]\n                    : geometryAccessor.getCount();\n            // setup/update the accessor for the new range of the object\n            geometryAccessor.setRange(featureStart, featureEnd);\n            switch (geometryType) {\n                case harp_datasource_protocol_1.GeometryType.Point:\n                case harp_datasource_protocol_1.GeometryType.Text:\n                    this.visitor.visitPoint(featureId);\n                    break;\n                case harp_datasource_protocol_1.GeometryType.SolidLine:\n                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n                case harp_datasource_protocol_1.GeometryType.TextPath:\n                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));\n                    this.visitor.visitLine(featureId, geometryAccessor);\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Polygon:\n                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                    this.visitor.visitArea(featureId);\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Object3D:\n                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));\n                    this.visitor.visitObject3D(featureId, geometryAccessor);\n                    break;\n                default:\n                    logger.warn(\"#visitObject: invalid geometryType\");\n            }\n        }\n    }\n}\nexports.TileDataAccessor = TileDataAccessor;\n//# sourceMappingURL=TileDataAccessor.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexedBufferedGeometryLineAccessor = exports.IndexedBufferedGeometryAccessor = exports.BufferedGeometryObject3dAccessor = exports.BufferedGeometryLineAccessor = exports.BufferedGeometryAccessor = exports.BufferedGeometryAccessorBase = exports.isObject3dAccessor = exports.isLineAccessor = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ \"./node_modules/@here/harp-lines/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileGeometry\");\n/**\n * Helper function to check if an accessor is of type `ILineAccessor`.\n *\n * @param arg - `true` if `arg` is `ILineAccessor`.\n * @internal\n */\nfunction isLineAccessor(arg) {\n    /**\n     * Get vertices from the object.\n     *\n     * @param mode - Specifies which part of the vertices should be returned.\n     */\n    return typeof arg.isLineAccessor === \"function\" && arg.isLineAccessor() === true;\n}\nexports.isLineAccessor = isLineAccessor;\n/**\n * Helper function to check if an accessor is of type `IObject3dAccessor`.\n *\n * @param arg - `true` if `arg` is `IObject3dAccessor`.\n * @internal\n */\nfunction isObject3dAccessor(arg) {\n    return typeof arg.isObject3dAccessor === \"function\" && arg.isObject3dAccessor() === true;\n}\nexports.isObject3dAccessor = isObject3dAccessor;\n/**\n * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.\n */\nclass BufferedGeometryAccessorBase {\n    constructor(object, geometryType, bufferGeometry) {\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n        this.start = -1;\n        this.end = -1;\n        this.startCapSize = 0;\n        this.endCapSize = 0;\n        harp_utils_1.assert(!!object);\n        if (bufferGeometry.type !== \"BufferGeometry\") {\n            logger.error(\"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong \" + \"type\");\n        }\n        harp_utils_1.assert(bufferGeometry.type === \"BufferGeometry\", \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type\");\n        // we know its a BufferAttribute because it is a BufferGeometry\n        this.position = this.bufferGeometry.getAttribute(\"position\");\n        this.itemSize = this.position.itemSize;\n        if (!this.position) {\n            logger.warn(\"BufferedGeometryAccessor#constructor: BufferGeometry has no position \" +\n                \"attribute\");\n        }\n        if (this.position.array.constructor !== Float32Array) {\n            logger.warn(\"BufferedGeometryAccessor#constructor: BufferGeometry.position: \" +\n                \"unsupported ArrayBuffer\");\n        }\n    }\n    /**\n     * Get the number of accessible geometries in this buffer.\n     *\n     * @returns Number of primitives in this geometry.\n     */\n    getCount() {\n        return this.position.count;\n    }\n    /**\n     * Get `renderOrder` of object.\n     *\n     * @returns `renderOrder` of the object.\n     */\n    get renderOrder() {\n        return this.object.renderOrder;\n    }\n    setRange(start, end, startCapSize = 0, endCapSize = 0) {\n        harp_utils_1.assert(start >= 0);\n        harp_utils_1.assert(end >= 0);\n        harp_utils_1.assert(start <= end);\n        this.start = start;\n        this.end = end;\n        this.startCapSize = startCapSize;\n        this.endCapSize = endCapSize;\n    }\n    /**\n     * Get one or more colors from materials.\n     */\n    get color() {\n        /**\n         * TODO: Get color(s) from vertex colors\n         */\n        const getColor = (material) => {\n            const meshMaterial = material;\n            if (meshMaterial.type === \"MeshBasicMaterial\" ||\n                meshMaterial.type === \"MeshStandardMaterial\") {\n                return meshMaterial.color;\n            }\n            else if (meshMaterial.type === \"RawShaderMaterial\") {\n                const rawShaderMaterial = material;\n                if (rawShaderMaterial.name === \"SolidLineMaterial\") {\n                    return rawShaderMaterial.uniforms.diffuse.value;\n                }\n                logger.warn(\"BufferedGeometryAccessor#color: unknown shader material name\", rawShaderMaterial.name);\n            }\n            else {\n                logger.warn(\"BufferedGeometryAccessor#color: unknown material type\", meshMaterial.type);\n            }\n            return undefined;\n        };\n        if (Array.isArray(this.object.material)) {\n            const results = new Array();\n            const materials = this.object.material;\n            for (const material of materials) {\n                results.push(getColor(material));\n            }\n            return results;\n        }\n        else {\n            return getColor(this.object.material);\n        }\n    }\n}\nexports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;\n/**\n * Abstract base class of an accessor for nonindexed geometry.\n */\nclass BufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Create an object of type `BufferedGeometryAccessor`\n     *\n     * @param object - mesh object\n     * @param geometryType - type of geometry to be used\n     * @param bufferGeometry - which buffer geometry to use\n     * @param stride - geometry stride length\n     */\n    constructor(object, geometryType, bufferGeometry, stride) {\n        super(object, geometryType, bufferGeometry);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n        this.stride = stride;\n    }\n    clear() {\n        harp_utils_1.assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n        const positionsArray = this.position.array;\n        const start = this.start * this.itemSize;\n        const end = this.end * this.itemSize;\n        for (let i = start; i < end; i++) {\n            positionsArray[i] = 0;\n        }\n        this.position.needsUpdate = true;\n    }\n    getVertices() {\n        harp_utils_1.assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n        const start = this.start;\n        const end = this.end;\n        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);\n    }\n    checkSetUp() {\n        return (this.position !== undefined &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.position.count &&\n            this.start <= this.end);\n    }\n}\nexports.BufferedGeometryAccessor = BufferedGeometryAccessor;\n/**\n * Accessor for nonindexed line geometry.\n */\nclass BufferedGeometryLineAccessor extends BufferedGeometryAccessor {\n    constructor(object, geometryType, bufferGeometry) {\n        super(object, geometryType, bufferGeometry, 3);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n    }\n    isLineAccessor() {\n        return true;\n    }\n    get width() {\n        //TODO: There is no implementation of such a line, yet...\n        harp_utils_1.assert(this.checkSetUp(), \"RoBufferedGeometryLineAccessor not setup\");\n        return undefined;\n    }\n}\nexports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;\n/**\n * Accessor for nonindexed unspecified (`Object3D`) geometry.\n */\nclass BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {\n    constructor(object, geometryType, bufferGeometry) {\n        super(object, geometryType, bufferGeometry, 1);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n    }\n    isObject3dAccessor() {\n        return true;\n    }\n    /** @override */\n    getVertices() {\n        return super.getVertices();\n    }\n}\nexports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;\n/**\n * Abstract base class of indexed geometry.\n */\nclass IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Creates an abstract class `IndexedBufferedGeometryAccessor`.\n     *\n     * @param object - mesh to be used\n     * @param geometryType - type of geometry\n     * @param bufferGeometry - geometry used\n     * @param start -\n     * @param end -\n     */\n    constructor(object, geometryType, bufferGeometry, start, end) {\n        super(object, geometryType, bufferGeometry);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n        this.indices =\n            this.bufferGeometry.index !== null\n                ? this.bufferGeometry.index.array\n                : undefined;\n        if (!this.indices) {\n            logger.warn(\"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no \" + \"index\");\n            harp_utils_1.assert(!!this.indices);\n        }\n        else {\n            if (!(this.indices instanceof Uint32Array)) {\n                logger.warn(\"IndexedBufferedGeometryAccessor#constructor: BufferGeometry index \" +\n                    \"has wrong type\");\n                harp_utils_1.assert(this.indices instanceof Uint32Array);\n            }\n        }\n    }\n    /**\n     * Returns number of primitives, which is not known in this base class, so we return the number\n     * of indices.\n     *\n     * @returns The number of indices in the geometry.\n     * @override\n     */\n    getCount() {\n        return this.indices.length;\n    }\n    checkSetUp() {\n        return (!!this.indices &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.indices.length &&\n            this.start <= this.end);\n    }\n}\nexports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;\n/**\n * Accessor for lines in an indexed geometry.\n */\nclass IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {\n    constructor(object, geometryType, bufferGeometry) {\n        super(object, geometryType, bufferGeometry, 3);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n    }\n    isLineAccessor() {\n        return true;\n    }\n    /**\n     * Reconstructs line width from triangulated geometry.\n     *\n     * @returns Line width.\n     */\n    get width() {\n        harp_utils_1.assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {\n            const start = this.start + this.startCapSize;\n            const positionArray = this.position.array;\n            return harp_lines_1.reconstructLineWidth(positionArray, start);\n        }\n        return undefined;\n    }\n    clear() {\n        harp_utils_1.assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n        const start = this.start;\n        const end = this.end;\n        for (let i = start; i < end; i++) {\n            this.indices[i] = 0;\n        }\n        if (this.bufferGeometry.index !== null) {\n            this.bufferGeometry.index.needsUpdate = true;\n        }\n    }\n    getVertices() {\n        harp_utils_1.assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n        const itemSize = this.itemSize;\n        const start = this.start;\n        const end = this.end;\n        const result = new Float32Array((end - start) * itemSize);\n        const positionArray = this.position.array;\n        if (itemSize === 2) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n            }\n        }\n        if (itemSize === 3) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n                result[j + 2] = positionArray[index * itemSize + 2];\n            }\n        }\n        else {\n            for (let i = start, j = 0; i < end; i++, j++) {\n                const index = this.indices[i];\n                for (let k = 0; k < itemSize; k++) {\n                    result[j * itemSize + k] = positionArray[index * itemSize + k];\n                }\n            }\n        }\n        return result;\n    }\n}\nexports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;\n//# sourceMappingURL=TileGeometry.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileGeometryCreator = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\nconst DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ \"./node_modules/@here/harp-mapview/lib/DepthPrePass.js\");\nconst MapMaterialAdapter_1 = __webpack_require__(/*! ../MapMaterialAdapter */ \"./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js\");\nconst PathBlockingElement_1 = __webpack_require__(/*! ../PathBlockingElement */ \"./node_modules/@here/harp-mapview/lib/PathBlockingElement.js\");\nconst TextElementBuilder_1 = __webpack_require__(/*! ../text/TextElementBuilder */ \"./node_modules/@here/harp-mapview/lib/text/TextElementBuilder.js\");\nconst AddGroundPlane_1 = __webpack_require__(/*! ./AddGroundPlane */ \"./node_modules/@here/harp-mapview/lib/geometry/AddGroundPlane.js\");\nconst RegisterTileObject_1 = __webpack_require__(/*! ./RegisterTileObject */ \"./node_modules/@here/harp-mapview/lib/geometry/RegisterTileObject.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileGeometryCreator\");\nconst tmpVector3 = new THREE.Vector3();\nconst tmpVector2 = new THREE.Vector2();\nclass AttachmentCache {\n    constructor() {\n        this.bufferAttributes = new Map();\n        this.interleavedAttributes = new Map();\n    }\n}\nclass MemoCallExpr extends harp_datasource_protocol_1.CallExpr {\n    constructor(expr) {\n        super(\"memo\", [expr]);\n        this.m_cachedProperties = [];\n        this.m_deps = Array.from(expr.dependencies().properties);\n        this.descriptor = this;\n    }\n    call(context) {\n        let changed = false;\n        this.m_deps.forEach((d, i) => {\n            const newValue = context.env.lookup(d);\n            if (!changed && newValue !== this.m_cachedProperties[i]) {\n                changed = true;\n            }\n            if (changed) {\n                this.m_cachedProperties[i] = newValue;\n            }\n        });\n        if (changed || this.m_cachedValue === undefined) {\n            this.m_cachedValue = context.evaluate(this.args[0]);\n        }\n        return this.m_cachedValue;\n    }\n}\nclass AttachmentInfo {\n    constructor(geometry, info, cache) {\n        this.geometry = geometry;\n        this.info = info;\n        this.cache = cache;\n    }\n    getBufferAttribute(description) {\n        if (this.cache.bufferAttributes.has(description)) {\n            return this.cache.bufferAttributes.get(description);\n        }\n        const attribute = DecodedTileHelpers_1.getBufferAttribute(description);\n        this.cache.bufferAttributes.set(description, attribute);\n        return attribute;\n    }\n    getInterleavedBufferAttributes(description) {\n        const interleavedAttributes = this.cache.interleavedAttributes.get(description);\n        if (interleavedAttributes) {\n            return interleavedAttributes;\n        }\n        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(description.type);\n        const buffer = new ArrayCtor(description.buffer);\n        const interleavedBuffer = new THREE.InterleavedBuffer(buffer, description.stride);\n        const attrs = description.attributes.map(interleavedAttr => {\n            const attribute = new THREE.InterleavedBufferAttribute(interleavedBuffer, interleavedAttr.itemSize, interleavedAttr.offset, false);\n            const name = interleavedAttr.name;\n            return { name, attribute };\n        });\n        this.cache.interleavedAttributes.set(description, attrs);\n        return attrs;\n    }\n}\nfunction addToExtrudedMaterials(material, extrudedMaterials) {\n    if (Array.isArray(material)) {\n        const materials = material;\n        extrudedMaterials.push(...materials);\n    }\n    else {\n        extrudedMaterials.push(material);\n    }\n}\n/**\n * Support class to create geometry for a {@link Tile} from a {@link @here/harp-datasource-protocol#DecodedTile}.\n */\nclass TileGeometryCreator {\n    /**\n     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.\n     */\n    constructor() {\n        //\n    }\n    /**\n     * The `instance` of the `TileGeometryCreator`.\n     *\n     * @returns TileGeometryCreator\n     */\n    static get instance() {\n        return this.m_instance || (this.m_instance = new TileGeometryCreator());\n    }\n    /**\n     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a\n     * technique is identified as disabled, its property `enabled` is set to `false`.\n     *\n     * @param decodedTile - The decodedTile containing the actual tile map data.\n     * @param enabledKinds - Optional [[GeometryKindSet]] used to specify which object kinds should be\n     *      created.\n     * @param disabledKinds - Optional [[GeometryKindSet]] used to filter objects that should not be\n     *      created.\n     */\n    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {\n        for (const technique of decodedTile.techniques) {\n            const kind = technique.kind;\n            // No info about kind, no way to filter it.\n            if (kind === undefined || (kind instanceof Set && kind.size === 0)) {\n                technique._kindState = true;\n                continue;\n            }\n            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or\n            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.\n            technique._kindState =\n                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(kind)) ||\n                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(kind));\n        }\n        for (const srcGeometry of decodedTile.geometries) {\n            for (const group of srcGeometry.groups) {\n                group.createdOffsets = [];\n            }\n        }\n    }\n    /**\n     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before\n     * calling this method.\n     *\n     * @see [[TileGeometryCreator#initDecodedTile]]\n     *\n     * @param tile - The {@link Tile} to process.\n     * @param decodedTile - The decodedTile containing the actual tile map data.\n     */\n    createAllGeometries(tile, decodedTile) {\n        const filter = (technique) => {\n            return technique._kindState !== false;\n        };\n        this.createObjects(tile, decodedTile, filter);\n        this.preparePois(tile, decodedTile);\n        // TextElements do not get their geometry created by Tile, but are managed on a\n        // higher level.\n        const textFilter = (technique) => {\n            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&\n                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&\n                !harp_datasource_protocol_1.isTextTechnique(technique)) {\n                return false;\n            }\n            return filter(technique);\n        };\n        this.createTextElements(tile, decodedTile, textFilter);\n        this.createLabelRejectionElements(tile, decodedTile);\n        // HARP-7899, disable ground plane for globe\n        if (tile.dataSource.addGroundPlane && tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            // The ground plane is required for when we zoom in and we fall back to the parent\n            // (whilst the new tiles are loading), in that case the ground plane ensures that the\n            // parent's geometry doesn't show through.\n            AddGroundPlane_1.addGroundPlane(tile, -1);\n        }\n    }\n    createLabelRejectionElements(tile, decodedTile) {\n        if (decodedTile.pathGeometries === undefined) {\n            return;\n        }\n        for (const path of decodedTile.pathGeometries) {\n            tile.addBlockingElement(new PathBlockingElement_1.PathBlockingElement(path.path));\n        }\n    }\n    /**\n     * Processes the given tile and assign default values for geometry kinds,\n     * render orders and label priorities.\n     *\n     * @param {Tile} tile\n     * @param {(GeometryKindSet | undefined)} enabledKinds\n     * @param {(GeometryKindSet | undefined)} disabledKinds\n     */\n    processTechniques(tile, enabledKinds, disabledKinds) {\n        const decodedTile = tile.decodedTile;\n        if (decodedTile === undefined) {\n            return;\n        }\n        // Speedup and simplify following code: Test all techniques if they intersect with\n        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be\n        // ignored hereafter.\n        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n        // compile the dynamic expressions.\n        const exprPool = tile.dataSource.exprPool;\n        decodedTile.techniques.forEach((technique) => {\n            for (const propertyName in technique) {\n                if (!technique.hasOwnProperty(propertyName)) {\n                    continue;\n                }\n                const value = technique[propertyName];\n                if (harp_datasource_protocol_1.isJsonExpr(value) && propertyName !== \"kind\") {\n                    // \"kind\" is reserved.\n                    try {\n                        let expr = harp_datasource_protocol_1.Expr.fromJSON(value);\n                        if (expr.dependencies().volatile !== true) {\n                            expr = new MemoCallExpr(harp_datasource_protocol_1.Expr.fromJSON(value));\n                        }\n                        technique[propertyName] = expr.intern(exprPool);\n                    }\n                    catch (error) {\n                        logger.error(\"Failed to compile expression:\", error);\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Splits the text paths that contain sharp corners.\n     *\n     * @param tile - The {@link Tile} to process paths on.\n     * @param textPathGeometries - The original path geometries that may have defects.\n     * @param textFilter -: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {\n        const processedPaths = new Array();\n        const newPaths = textPathGeometries.slice();\n        while (newPaths.length > 0) {\n            const textPath = newPaths.pop();\n            if (textPath === undefined) {\n                break;\n            }\n            const technique = decodedTile.techniques[textPath.technique];\n            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||\n                (textFilter !== undefined && !textFilter(technique))) {\n                continue;\n            }\n            processedPaths.push(textPath);\n        }\n        return processedPaths;\n    }\n    /**\n     * Creates {@link TextElement} objects from the decoded tile and list of materials specified. The\n     * priorities of the {@link TextElement}s are updated to simplify label placement.\n     *\n     * @param tile - The {@link Tile} to create the testElements on.\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     * @param textFilter -: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    createTextElements(tile, decodedTile, textFilter) {\n        var _a;\n        const mapView = tile.mapView;\n        const worldOffsetX = tile.computeWorldOffsetX();\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const textElementBuilder = new TextElementBuilder_1.TextElementBuilder(discreteZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);\n        if (decodedTile.textPathGeometries !== undefined) {\n            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);\n            for (const textPath of textPathGeometries) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (technique._kindState === false ||\n                    !harp_datasource_protocol_1.isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))) {\n                    continue;\n                }\n                const path = [];\n                for (let i = 0; i < textPath.path.length; i += 3) {\n                    path.push(new THREE.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));\n                }\n                const textElement = textElementBuilder\n                    .withTechnique(technique)\n                    .build(textPath.text, path, tile.offset, textPath.objInfos, textPath.pathLengthSqr);\n                tile.addTextElement(textElement);\n            }\n        }\n        if (decodedTile.textGeometries !== undefined) {\n            for (const text of decodedTile.textGeometries) {\n                if (text.technique === undefined || text.stringCatalog === undefined) {\n                    continue;\n                }\n                const technique = decodedTile.techniques[text.technique];\n                if (technique._kindState === false ||\n                    !harp_datasource_protocol_1.isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))) {\n                    continue;\n                }\n                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);\n                const numPositions = positions.count;\n                if (numPositions < 1) {\n                    continue;\n                }\n                textElementBuilder.withTechnique(technique);\n                for (let i = 0; i < numPositions; ++i) {\n                    const x = positions.getX(i) + worldOffsetX;\n                    const y = positions.getY(i);\n                    const z = positions.getZ(i);\n                    const label = text.stringCatalog[text.texts[i]];\n                    if (label === undefined) {\n                        // skip missing labels\n                        continue;\n                    }\n                    const attributes = (_a = text.objInfos) === null || _a === void 0 ? void 0 : _a[i];\n                    const point = new THREE.Vector3(x, y, z);\n                    const textElement = textElementBuilder.build(label, point, tile.offset, attributes);\n                    tile.addTextElement(textElement);\n                }\n            }\n        }\n    }\n    /**\n     * Creates `Tile` objects from the decoded tile and list of materials specified.\n     *\n     * @param tile - The {@link Tile} to create the geometry on.\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     * @param techniqueFilter -: Optional filter. Should return true for any technique that is\n     *      applicable.\n     */\n    createObjects(tile, decodedTile, techniqueFilter) {\n        var _a, _b, _c, _d, _e, _f;\n        const mapView = tile.mapView;\n        const materials = [];\n        const extrudedMaterials = [];\n        const animatedExtrusionHandler = mapView.animatedExtrusionHandler;\n        const dataSource = tile.dataSource;\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const objects = tile.objects;\n        const viewRanges = mapView.viewRanges;\n        const elevationEnabled = mapView.elevationProvider !== undefined;\n        for (const attachment of this.getAttachments(decodedTile)) {\n            const srcGeometry = attachment.geometry;\n            const groups = attachment.info.groups;\n            const groupCount = groups.length;\n            for (let groupIndex = 0; groupIndex < groupCount;) {\n                const group = groups[groupIndex++];\n                const start = group.start;\n                const techniqueIndex = group.technique;\n                const technique = decodedTile.techniques[techniqueIndex];\n                if (group.createdOffsets === undefined) {\n                    group.createdOffsets = [];\n                }\n                if (group.createdOffsets.includes(tile.offset) ||\n                    technique._kindState === false ||\n                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {\n                    continue;\n                }\n                let count = group.count;\n                group.createdOffsets.push(tile.offset);\n                // compress consecutive groups\n                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {\n                    if (start + count !== groups[groupIndex].start) {\n                        break;\n                    }\n                    count += groups[groupIndex].count;\n                    // Mark this group as created, so it does not get processed again.\n                    groups[groupIndex].createdOffsets.push(tile.offset);\n                }\n                if (!DecodedTileHelpers_1.usesObject3D(technique)) {\n                    continue;\n                }\n                const extrusionAnimationEnabled = (_a = animatedExtrusionHandler === null || animatedExtrusionHandler === void 0 ? void 0 : animatedExtrusionHandler.setAnimationProperties(technique, discreteZoomEnv)) !== null && _a !== void 0 ? _a : false;\n                let material = materials[techniqueIndex];\n                if (material === undefined) {\n                    const onMaterialUpdated = (texture) => {\n                        dataSource.requestUpdate();\n                        if (texture !== undefined) {\n                            tile.addOwnedTexture(texture);\n                        }\n                    };\n                    material = DecodedTileHelpers_1.createMaterial(mapView.renderer.capabilities, {\n                        technique,\n                        env: mapView.env,\n                        fog: mapView.scene.fog !== null,\n                        shadowsEnabled: mapView.shadowsEnabled\n                    }, onMaterialUpdated);\n                    if (material === undefined) {\n                        continue;\n                    }\n                    if (extrusionAnimationEnabled && harp_materials_1.hasExtrusionFeature(material)) {\n                        addToExtrudedMaterials(material, extrudedMaterials);\n                    }\n                    materials[techniqueIndex] = material;\n                }\n                const techniqueKind = technique.kind;\n                // Modify the standard textured shader to support height-based coloring.\n                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {\n                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);\n                }\n                const bufferGeometry = new THREE.BufferGeometry();\n                (_b = srcGeometry.vertexAttributes) === null || _b === void 0 ? void 0 : _b.forEach(vertexAttribute => {\n                    const buffer = attachment.getBufferAttribute(vertexAttribute);\n                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);\n                });\n                (_c = srcGeometry.interleavedVertexAttributes) === null || _c === void 0 ? void 0 : _c.forEach(attr => {\n                    attachment\n                        .getInterleavedBufferAttributes(attr)\n                        .forEach(({ name, attribute }) => bufferGeometry.setAttribute(name, attribute));\n                });\n                const index = (_d = attachment.info.index) !== null && _d !== void 0 ? _d : srcGeometry.index;\n                if (index) {\n                    bufferGeometry.setIndex(attachment.getBufferAttribute(index));\n                }\n                if (!bufferGeometry.getAttribute(\"normal\") && harp_datasource_protocol_1.needsVertexNormals(technique)) {\n                    bufferGeometry.computeVertexNormals();\n                }\n                bufferGeometry.addGroup(start, count);\n                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {\n                    // TODO: Unify access to shader defines via SolidLineMaterial setters\n                    harp_utils_1.assert(!harp_materials_1.isHighPrecisionLineMaterial(material));\n                    const lineMaterial = material;\n                    if (technique.clipping === true &&\n                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n                        tile.boundingBox.getSize(tmpVector3);\n                        tmpVector2.set(tmpVector3.x, tmpVector3.y);\n                        lineMaterial.clipTileSize = tmpVector2;\n                    }\n                    if (bufferGeometry.getAttribute(\"color\")) {\n                        harp_materials_1.setShaderMaterialDefine(lineMaterial, \"USE_COLOR\", true);\n                    }\n                }\n                // Add the solid line outlines as a separate object.\n                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;\n                // When the source geometry is split in groups, we\n                // should create objects with an array of materials.\n                const hasFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&\n                    srcGeometry.featureStarts &&\n                    srcGeometry.featureStarts.length > 0;\n                const object = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, hasFeatureGroups ? [material] : material, tile, elevationEnabled);\n                object.renderOrder = harp_datasource_protocol_1.getPropertyValue(technique.renderOrder, mapView.env);\n                if (attachment.info.uuid !== undefined) {\n                    object.uuid = attachment.info.uuid;\n                    object.userData.geometryId = attachment.info.uuid;\n                }\n                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&\n                    technique.enablePicking !== undefined) {\n                    object.enableRayTesting = technique.enablePicking;\n                }\n                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);\n                }\n                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);\n                }\n                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                    // extruded lines are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    if (technique.fadeFar !== undefined) {\n                        const fadingParams = this.getFadingParams(mapView.env, technique);\n                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);\n                    }\n                }\n                this.addUserData(tile, srcGeometry, technique, object);\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n                    object.castShadow = mapView.shadowsEnabled;\n                    object.receiveShadow = mapView.shadowsEnabled;\n                }\n                else if (harp_datasource_protocol_1.isStandardTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {\n                    object.receiveShadow = mapView.shadowsEnabled;\n                }\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) ||\n                    harp_datasource_protocol_1.isStandardTechnique(technique) ||\n                    harp_datasource_protocol_1.isFillTechnique(technique)) {\n                    // filled polygons are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    if (technique.fadeFar !== undefined) {\n                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);\n                    }\n                }\n                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&\n                    DepthPrePass_1.isRenderDepthPrePassEnabled(technique, discreteZoomEnv);\n                if (renderDepthPrePass) {\n                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);\n                    this.addUserData(tile, srcGeometry, technique, depthPassMesh);\n                    // Set geometry kind for depth pass mesh so that it gets the displacement map\n                    // for elevation overlay.\n                    RegisterTileObject_1.registerTileObject(tile, depthPassMesh, techniqueKind, {\n                        technique,\n                        pickable: false\n                    });\n                    objects.push(depthPassMesh);\n                    if (extrusionAnimationEnabled) {\n                        addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);\n                    }\n                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);\n                }\n                // register all objects as pickable except solid lines with outlines, in that case\n                // it's enough to make outlines pickable.\n                RegisterTileObject_1.registerTileObject(tile, object, techniqueKind, {\n                    technique,\n                    pickable: !hasSolidLinesOutlines\n                });\n                objects.push(object);\n                // Add the extruded polygon edges as a separate geometry.\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&\n                    attachment.info.edgeIndex !== undefined) {\n                    // When the source geometry is split in groups, we\n                    // should create objects with an array of materials.\n                    const hasEdgeFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&\n                        srcGeometry.edgeFeatureStarts &&\n                        srcGeometry.edgeFeatureStarts.length > 0;\n                    const buildingTechnique = technique;\n                    const edgeGeometry = new THREE.BufferGeometry();\n                    edgeGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n                    const colorAttribute = bufferGeometry.getAttribute(\"color\");\n                    if (colorAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"color\", colorAttribute);\n                    }\n                    const extrusionAttribute = bufferGeometry.getAttribute(\"extrusionAxis\");\n                    if (extrusionAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"extrusionAxis\", extrusionAttribute);\n                    }\n                    const normalAttribute = bufferGeometry.getAttribute(\"normal\");\n                    if (normalAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"normal\", normalAttribute);\n                    }\n                    const uvAttribute = bufferGeometry.getAttribute(\"uv\");\n                    if (uvAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"uv\", uvAttribute);\n                    }\n                    edgeGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));\n                    // Read the uniforms from the technique values (and apply the default values).\n                    const extrudedPolygonTechnique = technique;\n                    const fadingParams = this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);\n                    // Configure the edge material based on the theme values.\n                    const materialParams = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar,\n                        extrusionRatio: extrusionAnimationEnabled ? 0 : undefined,\n                        vertexColors: bufferGeometry.getAttribute(\"color\") ? true : false,\n                        rendererCapabilities: mapView.renderer.capabilities\n                    };\n                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);\n                    const edgeObj = new THREE.LineSegments(edgeGeometry, hasEdgeFeatureGroups ? [edgeMaterial] : edgeMaterial);\n                    this.addUserData(tile, srcGeometry, technique, edgeObj);\n                    // Set the correct render order.\n                    edgeObj.renderOrder = object.renderOrder + 0.1;\n                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);\n                    if (extrusionAnimationEnabled) {\n                        addToExtrudedMaterials(edgeObj.material, extrudedMaterials);\n                    }\n                    RegisterTileObject_1.registerTileObject(tile, edgeObj, techniqueKind, {\n                        technique,\n                        pickable: false\n                    });\n                    MapMaterialAdapter_1.MapMaterialAdapter.create(edgeMaterial, {\n                        color: buildingTechnique.lineColor,\n                        objectColor: buildingTechnique.color,\n                        opacity: buildingTechnique.opacity,\n                        lineWidth: (frameMapView) => {\n                            // lineWidth for ExtrudedPolygonEdges only supports 0 or 1\n                            const value = harp_datasource_protocol_1.getPropertyValue(buildingTechnique.lineWidth, frameMapView.env);\n                            if (typeof value === \"number\") {\n                                return THREE.MathUtils.clamp(value, 0, 1);\n                            }\n                            else {\n                                return 0;\n                            }\n                        }\n                    });\n                    objects.push(edgeObj);\n                }\n                // animate the extrusion of buildings\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {\n                    object.customDepthMaterial = new harp_materials_1.MapMeshDepthMaterial({\n                        depthPacking: THREE.RGBADepthPacking\n                    });\n                    addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);\n                }\n                // Add the fill area edges as a separate geometry.\n                if (harp_datasource_protocol_1.isFillTechnique(technique) && attachment.info.edgeIndex) {\n                    const hasEdgeFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&\n                        srcGeometry.edgeFeatureStarts &&\n                        srcGeometry.edgeFeatureStarts.length > 0;\n                    const outlineGeometry = new THREE.BufferGeometry();\n                    outlineGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n                    outlineGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));\n                    const fillTechnique = technique;\n                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);\n                    // Configure the edge material based on the theme values.\n                    const materialParams = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar,\n                        vertexColors: bufferGeometry.getAttribute(\"color\") ? true : false,\n                        rendererCapabilities: mapView.renderer.capabilities\n                    };\n                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);\n                    const outlineObj = new THREE.LineSegments(outlineGeometry, hasEdgeFeatureGroups ? [outlineMaterial] : outlineMaterial);\n                    outlineObj.renderOrder = object.renderOrder + 0.1;\n                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);\n                    this.addUserData(tile, srcGeometry, technique, outlineObj);\n                    RegisterTileObject_1.registerTileObject(tile, outlineObj, techniqueKind, {\n                        technique,\n                        pickable: false\n                    });\n                    MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {\n                        color: fillTechnique.lineColor,\n                        objectColor: fillTechnique.color,\n                        opacity: fillTechnique.opacity\n                    });\n                    objects.push(outlineObj);\n                }\n                // Add the fill area edges as a separate geometry.\n                if (hasSolidLinesOutlines) {\n                    const outlineTechnique = technique;\n                    const outlineMaterial = material.clone();\n                    DecodedTileHelpers_1.applyBaseColorToMaterial(outlineMaterial, outlineMaterial.color, outlineTechnique, (_e = outlineTechnique.secondaryColor) !== null && _e !== void 0 ? _e : 0x000000, discreteZoomEnv);\n                    if (outlineTechnique.secondaryCaps !== undefined) {\n                        outlineMaterial.caps = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryCaps, mapView.env);\n                    }\n                    const outlineObj = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, outlineMaterial, tile, elevationEnabled);\n                    outlineObj.renderOrder =\n                        ((_f = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env)) !== null && _f !== void 0 ? _f : 0) - 0.0000001;\n                    this.addUserData(tile, srcGeometry, technique, outlineObj);\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);\n                    const secondaryWidth = DecodedTileHelpers_1.buildMetricValueEvaluator(outlineTechnique.secondaryWidth, outlineTechnique.metricUnit);\n                    RegisterTileObject_1.registerTileObject(tile, outlineObj, techniqueKind, { technique });\n                    const mainMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.get(material);\n                    const outlineMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {\n                        color: outlineTechnique.secondaryColor,\n                        opacity: outlineTechnique.opacity,\n                        caps: outlineTechnique.secondaryCaps,\n                        // Still handled above\n                        lineWidth: (frameMapView) => {\n                            if (!mainMaterialAdapter) {\n                                return;\n                            }\n                            mainMaterialAdapter.ensureUpdated(frameMapView);\n                            const mainLineWidth = mainMaterialAdapter.currentStyledProperties.lineWidth;\n                            const secondaryLineWidth = harp_datasource_protocol_1.getPropertyValue(secondaryWidth, mapView.env);\n                            const opacity = outlineMaterialAdapter.currentStyledProperties\n                                .opacity;\n                            if (typeof mainLineWidth === \"number\" &&\n                                typeof secondaryLineWidth === \"number\") {\n                                if (secondaryLineWidth <= mainLineWidth &&\n                                    (opacity === null || opacity === undefined || opacity === 1)) {\n                                    // We could mark object as invisible somehow, not sure how\n                                    // objectAdapter.markInvisible();\n                                    return 0;\n                                }\n                                else {\n                                    return secondaryLineWidth;\n                                }\n                            }\n                            else {\n                                return 0;\n                            }\n                        }\n                    });\n                    objects.push(outlineObj);\n                }\n            }\n        }\n        if (extrudedMaterials.length > 0) {\n            mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);\n        }\n    }\n    /**\n     * Prepare the {@link Tile}s pois. Uses the {@link PoiManager} in {@link MapView}.\n     */\n    preparePois(tile, decodedTile) {\n        if (decodedTile.poiGeometries !== undefined) {\n            tile.mapView.poiManager.addPois(tile, decodedTile);\n        }\n    }\n    /**\n     * Gets the attachments of the given {@link @here/harp-datasource-protocol#DecodedTile}.\n     *\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     */\n    *getAttachments(decodedTile) {\n        const cache = new AttachmentCache();\n        for (const geometry of decodedTile.geometries) {\n            // the main attachment\n            const mainAttachment = {\n                index: geometry.index,\n                edgeIndex: geometry.edgeIndex,\n                uuid: geometry.uuid,\n                groups: geometry.groups\n            };\n            yield new AttachmentInfo(geometry, mainAttachment, cache);\n            if (geometry.attachments) {\n                // the additional attachments\n                for (const info of geometry.attachments) {\n                    yield new AttachmentInfo(geometry, info, cache);\n                }\n            }\n        }\n    }\n    setupTerrainMaterial(technique, material, terrainColor) {\n        if (!technique.map || !technique.displacementMap) {\n            // Render terrain using the given color.\n            const stdMaterial = material;\n            stdMaterial.color.set(terrainColor);\n            // Remove displacement map, otherwise it would elevate terrain geometry and make it\n            // twice as high as it should be.\n            harp_materials_1.setDisplacementMapToMaterial(null, stdMaterial);\n            return;\n        }\n        // Render terrain using height-based colors.\n        material.onBeforeCompile = (shader) => {\n            shader.fragmentShader = shader.fragmentShader.replace(\"#include <map_pars_fragment>\", `#include <map_pars_fragment>\n    uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;`);\n            shader.fragmentShader = shader.fragmentShader.replace(\"#include <map_fragment>\", `#ifdef USE_MAP\n    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};\n    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};\n    float elevationRange = maxElevation - minElevation;\n\n    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;\n    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n#endif`);\n            // We remove the displacement map from manipulating the vertices, it is\n            // however still required for the pixel shader, so it can't be directly\n            // removed.\n            shader.vertexShader = shader.vertexShader.replace(\"#include <displacementmap_vertex>\", \"\");\n        };\n        material.displacementMap.needsUpdate = true;\n    }\n    addUserData(tile, srcGeometry, technique, object) {\n        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {\n            harp_utils_1.assert(Object.keys(object.userData).length === 0, \"Unexpected user data in terrain object\");\n            harp_utils_1.assert(typeof srcGeometry.objInfos[0] === \"object\", \"Wrong attribute map type for terrain geometry\");\n            const displacementMap = srcGeometry.objInfos[0];\n            const tileDisplacementMap = {\n                tileKey: tile.tileKey,\n                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),\n                displacementMap,\n                geoBox: tile.geoBox\n            };\n            object.userData = tileDisplacementMap;\n        }\n        else {\n            // Set the feature data for picking with `MapView.intersectMapObjects()` except for\n            // solid-line which uses tile-based picking.\n            const isOutline = object.type === \"LineSegments\" &&\n                (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique));\n            const featureData = {\n                geometryType: srcGeometry.type,\n                starts: isOutline ? srcGeometry.edgeFeatureStarts : srcGeometry.featureStarts,\n                objInfos: srcGeometry.objInfos\n            };\n            object.userData.feature = featureData;\n            object.userData.technique = technique;\n        }\n    }\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    getFadingParams(env, technique) {\n        const fadeNear = technique.fadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar = technique.fadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;\n        return {\n            fadeNear,\n            fadeFar\n        };\n    }\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    getPolygonFadingParams(env, technique) {\n        let color;\n        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;\n        if (technique.lineColor !== undefined) {\n            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, env);\n            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n                const extrudedPolygonTechnique = technique;\n                colorMix =\n                    extrudedPolygonTechnique.lineColorMix !== undefined\n                        ? extrudedPolygonTechnique.lineColorMix\n                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;\n            }\n        }\n        const fadeNear = technique.fadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar = technique.fadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;\n        const lineFadeNear = technique.lineFadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, env)\n            : fadeNear;\n        const lineFadeFar = technique.lineFadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, env)\n            : fadeFar;\n        if (color === undefined) {\n            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;\n        }\n        return {\n            color,\n            colorMix,\n            fadeNear,\n            fadeFar,\n            lineFadeNear,\n            lineFadeFar\n        };\n    }\n}\nexports.TileGeometryCreator = TileGeometryCreator;\n//# sourceMappingURL=TileGeometryCreator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileGeometryLoader = exports.TileGeometryLoaderState = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst MapView_1 = __webpack_require__(/*! ../MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\nconst Statistics_1 = __webpack_require__(/*! ../Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js\");\nfunction addDiscardedTileToStats(tile) {\n    const stats = Statistics_1.PerformanceStatistics.instance;\n    if (stats.enabled) {\n        const name = tile.dataSource.name;\n        const level = tile.tileKey.level;\n        const col = tile.tileKey.column;\n        const row = tile.tileKey.row;\n        const reason = tile.disposed ? `disposed` : `invisible`;\n        stats.currentFrame.addMessage(`Decoded tile: ${name} # lvl=${level} col=${col} row=${row} DISCARDED - ${reason}`);\n    }\n}\n/**\n * The state the {@link TileGeometryLoader}.\n */\nvar TileGeometryLoaderState;\n(function (TileGeometryLoaderState) {\n    TileGeometryLoaderState[TileGeometryLoaderState[\"Initialized\"] = 0] = \"Initialized\";\n    TileGeometryLoaderState[TileGeometryLoaderState[\"CreationQueued\"] = 1] = \"CreationQueued\";\n    TileGeometryLoaderState[TileGeometryLoaderState[\"CreatingGeometry\"] = 2] = \"CreatingGeometry\";\n    TileGeometryLoaderState[TileGeometryLoaderState[\"Finished\"] = 3] = \"Finished\";\n    TileGeometryLoaderState[TileGeometryLoaderState[\"Canceled\"] = 4] = \"Canceled\";\n    TileGeometryLoaderState[TileGeometryLoaderState[\"Disposed\"] = 5] = \"Disposed\";\n})(TileGeometryLoaderState = exports.TileGeometryLoaderState || (exports.TileGeometryLoaderState = {}));\n/**\n * Loads the geometry for its {@link Tile}. Loads all geometry in a single step.\n * @internal\n */\nclass TileGeometryLoader {\n    constructor(m_tile, m_taskQueue) {\n        this.m_tile = m_tile;\n        this.m_taskQueue = m_taskQueue;\n        this.m_priority = 0;\n        this.m_state = TileGeometryLoaderState.Initialized;\n        this.m_finishedPromise = new Promise((resolve, reject) => {\n            this.m_resolveFinishedPromise = resolve;\n            this.m_rejectFinishedPromise = reject;\n        });\n    }\n    /**\n     * Make sure that all technique have their geometryKind set, either from the theme or their\n     * default value.\n     *\n     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.\n     *\n     * @param {DecodedTile} decodedTile\n     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.\n     */\n    static prepareAvailableGeometryKinds(decodedTile) {\n        const foundSet = new harp_datasource_protocol_1.GeometryKindSet();\n        for (const technique of decodedTile.techniques) {\n            const geometryKind = TileGeometryLoader.compileGeometryKind(technique);\n            if (geometryKind instanceof Set) {\n                for (const kind of geometryKind) {\n                    foundSet.add(kind);\n                }\n            }\n            else {\n                foundSet.add(geometryKind);\n            }\n        }\n        return foundSet;\n    }\n    /**\n     * Make sure that the technique has its geometryKind set, either from the theme or their default\n     * value.\n     *\n     * @param {Technique} technique\n     */\n    static compileGeometryKind(technique) {\n        let geometryKind = technique.kind;\n        // Set default kind based on technique.\n        if (geometryKind === undefined) {\n            if (harp_datasource_protocol_1.isFillTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Area;\n            }\n            else if (harp_datasource_protocol_1.isLineTechnique(technique) ||\n                harp_datasource_protocol_1.isSolidLineTechnique(technique) ||\n                harp_datasource_protocol_1.isSegmentsTechnique(technique) ||\n                harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Line;\n            }\n            else if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Building;\n            }\n            else if (harp_datasource_protocol_1.isPoiTechnique(technique) ||\n                harp_datasource_protocol_1.isLineMarkerTechnique(technique) ||\n                harp_datasource_protocol_1.isTextTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Label;\n            }\n            else {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.All;\n            }\n            technique.kind = geometryKind;\n        }\n        else if (Array.isArray(geometryKind)) {\n            geometryKind = technique.kind = new harp_datasource_protocol_1.GeometryKindSet(geometryKind);\n        }\n        return geometryKind;\n    }\n    set priority(value) {\n        this.m_priority = value;\n    }\n    //This is not a getter as it need to be bound to this for the taskqueue\n    getPriority() {\n        return this.m_priority;\n    }\n    /**\n     * The {@link Tile} this `TileGeometryLoader` is managing.\n     */\n    get tile() {\n        return this.m_tile;\n    }\n    /**\n     * `True` if a decoded Tile is set\n     */\n    get hasDecodedTile() {\n        return this.m_decodedTile !== undefined;\n    }\n    /**\n     * `True` if all geometry of the `Tile` has been loaded and the loading process is finished.\n     */\n    get isFinished() {\n        return this.m_state === TileGeometryLoaderState.Finished;\n    }\n    /**\n     * `True` if loader is finished, canceled or disposed.\n     */\n    get isSettled() {\n        return this.isFinished || this.isCanceled || this.isDisposed;\n    }\n    /**\n     * Returns a promise resolved when this `TileGeometryLoader` is in\n     * `TileGeometryLoaderState.Finished` state, or rejected when it's in\n     * `TileGeometryLoaderState.Cancelled` or `TileGeometryLoaderState.Disposed` states.\n     */\n    waitFinished() {\n        return this.m_finishedPromise;\n    }\n    /**\n     * Set the {@link @here/harp-datasource-protocol#DecodedTile} of the tile.\n     *\n     * @remarks\n     * Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile) {\n        this.m_decodedTile = decodedTile;\n        if (this.hasDecodedTile) {\n            this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(this.m_decodedTile);\n        }\n        return this.m_decodedTile;\n    }\n    /**\n     * The kinds of geometry stored in this {@link Tile}.\n     */\n    get availableGeometryKinds() {\n        return this.m_availableGeometryKinds;\n    }\n    /**\n     * Start with or continue with loading geometry. Called repeatedly until `isFinished` is `true`.\n     */\n    update(enabledKinds, disabledKinds) {\n        const tile = this.tile;\n        // Geometry kinds have changed but some is already created, so reset\n        if (this.tile.hasGeometry && !this.compareGeometryKinds(enabledKinds, disabledKinds)) {\n            this.reset();\n        }\n        // First time this tile is handled, or reset has been requested.\n        if ((this.m_state === TileGeometryLoaderState.Initialized ||\n            this.m_state === TileGeometryLoaderState.Canceled) &&\n            tile.decodedTile !== undefined) {\n            if (this.m_state === TileGeometryLoaderState.Initialized) {\n                TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);\n                this.setGeometryKinds(enabledKinds, disabledKinds);\n                this.setDecodedTile(tile.decodedTile);\n            }\n            this.queueGeometryCreation(enabledKinds, disabledKinds);\n        }\n    }\n    /**\n     * Cancel geometry loading.\n     */\n    cancel() {\n        var _a;\n        addDiscardedTileToStats(this.tile);\n        this.m_state = TileGeometryLoaderState.Canceled;\n        (_a = this.m_rejectFinishedPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * Dispose of any resources.\n     */\n    dispose() {\n        var _a;\n        addDiscardedTileToStats(this.tile);\n        this.clear();\n        this.m_state = TileGeometryLoaderState.Disposed;\n        (_a = this.m_rejectFinishedPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * Reset the loader to its initial state and cancels any asynchronous work.\n     * @remarks\n     * This method prepares the loader to reload new geometry. Since the loader does not transition\n     * to a final state, the promise returned by {@link TileGeometryLoader.waitFinished} is not\n     * settled.\n     */\n    reset() {\n        this.clear();\n        if (this.isSettled) {\n            this.m_finishedPromise = new Promise((resolve, reject) => {\n                this.m_resolveFinishedPromise = resolve;\n                this.m_rejectFinishedPromise = reject;\n            });\n        }\n        this.m_state = TileGeometryLoaderState.Initialized;\n    }\n    /**\n     * Finish geometry loading.\n     */\n    finish() {\n        var _a;\n        this.m_decodedTile = undefined;\n        this.m_state = TileGeometryLoaderState.Finished;\n        (_a = this.m_resolveFinishedPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    clear() {\n        var _a, _b, _c;\n        (_a = this.m_availableGeometryKinds) === null || _a === void 0 ? void 0 : _a.clear();\n        (_b = this.m_enabledKinds) === null || _b === void 0 ? void 0 : _b.clear();\n        (_c = this.m_disabledKinds) === null || _c === void 0 ? void 0 : _c.clear();\n        this.m_decodedTile = undefined;\n    }\n    queueGeometryCreation(enabledKinds, disabledKinds) {\n        if (this.m_state === TileGeometryLoaderState.CreationQueued) {\n            return;\n        }\n        this.m_taskQueue.add({\n            execute: this.createGeometry.bind(this, enabledKinds, disabledKinds),\n            group: MapView_1.TileTaskGroups.CREATE,\n            getPriority: this.getPriority.bind(this),\n            isExpired: () => {\n                return this.m_state !== TileGeometryLoaderState.CreationQueued;\n            },\n            estimatedProcessTime: () => {\n                var _a, _b;\n                //TODO: this seems to be close in many cases, but take some measures to confirm\n                return ((_b = (_a = this.tile.decodedTile) === null || _a === void 0 ? void 0 : _a.decodeTime) !== null && _b !== void 0 ? _b : 30) / 6;\n            }\n        });\n        this.m_state = TileGeometryLoaderState.CreationQueued;\n    }\n    createGeometry(enabledKinds, disabledKinds) {\n        if (this.m_state === TileGeometryLoaderState.CreatingGeometry) {\n            return;\n        }\n        this.m_state = TileGeometryLoaderState.CreatingGeometry;\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        // Just a sanity check that satisfies compiler check below.\n        if (decodedTile === undefined) {\n            this.finish();\n            return;\n        }\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        let now = 0;\n        if (stats.enabled) {\n            now = harp_utils_1.PerformanceTimer.now();\n        }\n        const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;\n        tile.clear();\n        // Set up techniques which should be processed.\n        geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n        geometryCreator.createAllGeometries(tile, decodedTile);\n        if (stats.enabled) {\n            this.addStats(stats, now);\n        }\n        this.finish();\n        tile.dataSource.requestUpdate();\n    }\n    addStats(stats, now) {\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        if (decodedTile === undefined) {\n            return;\n        }\n        const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;\n        const currentFrame = stats.currentFrame;\n        // Account for the geometry creation in the current frame.\n        currentFrame.addValue(\"render.fullFrameTime\", geometryCreationTime);\n        currentFrame.addValue(\"render.geometryCreationTime\", geometryCreationTime);\n        currentFrame.addValue(\"geometry.geometryCreationTime\", geometryCreationTime);\n        currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n        currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n        currentFrame.addValue(\"geometryCount.numPoiGeometries\", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);\n        currentFrame.addValue(\"geometryCount.numTextGeometries\", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);\n        currentFrame.addValue(\"geometryCount.numTextPathGeometries\", decodedTile.textPathGeometries !== undefined ? decodedTile.textPathGeometries.length : 0);\n        currentFrame.addValue(\"geometryCount.numPathGeometries\", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);\n        currentFrame.addMessage(\n        // tslint:disable-next-line: max-line-length\n        `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);\n    }\n    /**\n     * Stores geometry kinds used to load decoded tile geometry.\n     *\n     * This values are stored to detect geometry kind changes during loading.\n     *\n     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.\n     * @param disabledKinds - Set of geometry kinds that won't be rendered.\n     */\n    setGeometryKinds(enabledKinds, disabledKinds) {\n        var _a, _b;\n        if (enabledKinds !== undefined) {\n            this.m_enabledKinds = Object.assign((_a = this.m_enabledKinds) !== null && _a !== void 0 ? _a : new harp_datasource_protocol_1.GeometryKindSet(), enabledKinds);\n        }\n        if (disabledKinds !== undefined) {\n            this.m_disabledKinds = Object.assign((_b = this.m_disabledKinds) !== null && _b !== void 0 ? _b : new harp_datasource_protocol_1.GeometryKindSet(), disabledKinds);\n        }\n    }\n    /**\n     * Compare enabled and disabled geometry kinds with currently set.\n     *\n     * Method compares input sets with recently used geometry kinds in performance wise\n     * manner, taking special care of undefined and zero size sets.\n     *\n     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.\n     * @param disabledKinds - Set of geometry kinds that won't be rendered.\n     * @return `true` only if sets are logically equal, meaning that undefined and empty sets\n     * may result in same geometry (techniques kind) beeing rendered.\n     */\n    compareGeometryKinds(enabledKinds, disabledKinds) {\n        const enabledSame = this.m_enabledKinds === enabledKinds;\n        const disabledSame = this.m_disabledKinds === disabledKinds;\n        // Same references, no need to compare.\n        if (enabledSame && disabledSame) {\n            return true;\n        }\n        const enabledEmpty = (this.m_enabledKinds === undefined || this.m_enabledKinds.size === 0) &&\n            (enabledKinds === undefined || enabledKinds.size === 0);\n        const disabledEmpty = (this.m_disabledKinds === undefined || this.m_disabledKinds.size === 0) &&\n            (disabledKinds === undefined || disabledKinds.size === 0);\n        // We deal only with empty, the same or undefined sets - fast return, no need to compare.\n        if ((enabledEmpty && disabledEmpty) ||\n            (enabledSame && disabledEmpty) ||\n            (disabledSame && enabledEmpty)) {\n            return true;\n        }\n        // It is enough that one the the sets are different, try to spot difference otherwise\n        // return true. Compare only non-empty sets.\n        if (!enabledEmpty) {\n            // If one set undefined then other must be non-empty, for sure different.\n            if (enabledKinds === undefined || this.m_enabledKinds === undefined) {\n                return false;\n            }\n            // Both defined and non-empty, compare the sets.\n            else if (!enabledKinds.has(this.m_enabledKinds)) {\n                return false;\n            }\n        }\n        if (!disabledEmpty) {\n            // One set defined and non-empty other undefined, for sure different.\n            if (disabledKinds === undefined || this.m_disabledKinds === undefined) {\n                return false;\n            }\n            // Both defined and non-empty, compare the sets.\n            else if (!disabledKinds.has(this.m_disabledKinds)) {\n                return false;\n            }\n        }\n        // No difference found.\n        return true;\n    }\n    /**\n     * `True` if TileGeometryLoader was canceled\n     */\n    get isCanceled() {\n        return this.m_state === TileGeometryLoaderState.Canceled;\n    }\n    /**\n     * `True` if TileGeometryLoader was disposed\n     */\n    get isDisposed() {\n        return this.m_state === TileGeometryLoaderState.Disposed;\n    }\n}\nexports.TileGeometryLoader = TileGeometryLoader;\n//# sourceMappingURL=TileGeometryLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileGeometryManager = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst MapObjectAdapter_1 = __webpack_require__(/*! ../MapObjectAdapter */ \"./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js\");\n/**\n * Manages the content (the geometries) of a tile.\n */\nclass TileGeometryManager {\n    /**\n     * Creates an instance of `TileGeometryManager` with a reference to the {@link MapView}.\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        /**\n         * If set to `true`, the filters of enabled/disabledGeometryKinds are applied, otherwise they\n         * are ignored.\n         */\n        this.enableFilterByKind = true;\n        this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        this.hiddenKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        /**\n         * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the\n         * visibility of the kinds is applied to their geometries.\n         */\n        this.m_visibilityCounter = 1;\n    }\n    /**\n     * The set of geometry kinds that is enabled. Their geometry will be created after decoding.\n     */\n    get enabledGeometryKinds() {\n        return this.enabledKinds;\n    }\n    set enabledGeometryKinds(kinds) {\n        this.enabledKinds = kinds;\n    }\n    /**\n     * The set of geometry kinds that is disabled. Their geometry will not be created after\n     * decoding.\n     */\n    get disabledGeometryKinds() {\n        return this.disabledKinds;\n    }\n    set disabledGeometryKinds(kinds) {\n        this.disabledKinds = kinds;\n    }\n    /**\n     * The set of geometry kinds that is hidden. Their geometry may be created, but it is hidden\n     * until the method `hideKind` with an argument of `addOrRemoveToHiddenSet:false` is called.\n     */\n    get hiddenGeometryKinds() {\n        return this.hiddenKinds;\n    }\n    set hiddenGeometryKinds(kinds) {\n        this.hiddenKinds = kinds;\n        this.incrementVisibilityCounter();\n    }\n    get visibilityCounter() {\n        return this.m_visibilityCounter;\n    }\n    /**\n     * Process the {@link Tile}s for rendering. May alter the content of the tile per frame.\n     */\n    updateTiles(tiles) {\n        let prio = 0;\n        for (const tile of tiles) {\n            //this assumes the tiles are ordered by priority, this is currently done in\n            // the visible tile set with 0 as the highest priority\n            const tilePriority = prio++;\n            const updateDone = tile.updateGeometry(tilePriority, this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined);\n            if (updateDone && this.m_tileUpdateCallback) {\n                this.m_tileUpdateCallback(tile);\n            }\n        }\n        // If the visibility status of the kinds changed since the last update, the new visibility\n        // status is applied (again).\n        if (this.updateTileObjectVisibility(tiles)) {\n            this.mapView.update();\n        }\n    }\n    /**\n     * Clear the enabled, disabled and hidden sets.\n     */\n    clear() {\n        this.enabledKinds.clear();\n        this.disabledKinds.clear();\n        this.hiddenKinds.clear();\n    }\n    /**\n     * Enable a [[GeometryKind]] by adding it to the enabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the enabled set.\n     * @param {boolean} addOrRemoveToEnabledSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     */\n    enableKind(kind, addOrRemoveToEnabledSet = true) {\n        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);\n    }\n    /**\n     * Disable a [[GeometryKind]] by adding it to the disabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the disabled set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     */\n    disableKind(kind, addOrRemoveToDisabledSet = true) {\n        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);\n    }\n    /**\n     * Hide a [[GeometryKind]] by adding it to the hidden set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the hidden set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to hide the kind(s), `false` to show\n     *      it again.\n     */\n    hideKind(kind, addOrRemoveToHiddenSet = true) {\n        let visibilityHasChanged = false;\n        if (Array.isArray(kind) || kind instanceof Set) {\n            for (const oneKind of kind) {\n                const visibilityChange = this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);\n                visibilityHasChanged = visibilityHasChanged || visibilityChange;\n            }\n        }\n        else {\n            visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);\n        }\n        // Will be evaluated in the next update()\n        if (visibilityHasChanged) {\n            this.incrementVisibilityCounter();\n        }\n    }\n    /**\n     * Return all [[GeometryKind]]s that are contained in the tiles.\n     *\n     * @param {IterableIterator<Tile>} tiles The\n     * @returns {GeometryKindSet}\n     */\n    getAvailableKinds(tiles) {\n        const visibleKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        for (const tile of tiles) {\n            const tileKinds = tile.loadedGeometryKinds;\n            if (tileKinds !== undefined) {\n                for (const kind of tileKinds) {\n                    visibleKinds.add(kind);\n                }\n            }\n        }\n        return visibleKinds;\n    }\n    /**\n     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified\n     * tiles.\n     *\n     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.\n     */\n    updateTileObjectVisibility(tiles) {\n        let needUpdate = false;\n        for (const tile of tiles) {\n            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {\n                continue;\n            }\n            tile.visibilityCounter = this.visibilityCounter;\n            for (const object of tile.objects) {\n                const objectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);\n                const geometryKind = objectAdapter === null || objectAdapter === void 0 ? void 0 : objectAdapter.kind;\n                if (geometryKind !== undefined) {\n                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));\n                    needUpdate = needUpdate || object.visible !== nowVisible;\n                    object.visible = nowVisible;\n                }\n            }\n        }\n        return needUpdate;\n    }\n    /**\n     * Sets a callback that will be called for every updated tile on [[updateTiles]].\n     *\n     * @param {TileUpdateCallback} callback The callback that will be called after a tile has been\n     * updated, passing the updated tile as argument. If `undefined`, a previously set callback will\n     * be cleared.\n     */\n    setTileUpdateCallback(callback) {\n        this.m_tileUpdateCallback = callback;\n    }\n    incrementVisibilityCounter() {\n        return ++this.m_visibilityCounter;\n    }\n    /**\n     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    enableDisableKinds(set, kind, addToSet) {\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        }\n        else if (kind instanceof Set) {\n            const kindSet = kind;\n            for (const oneKind of kindSet) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        }\n        else if (kind !== undefined) {\n            this.addRemove(set, kind, addToSet);\n        }\n    }\n    /**\n     * Add or remove a single kind from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    addRemove(kindsSet, kind, addToSet) {\n        if (addToSet) {\n            if (!kindsSet.has(kind)) {\n                kindsSet.add(kind);\n                return true;\n            }\n        }\n        else {\n            if (kindsSet.has(kind)) {\n                kindsSet.delete(kind);\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.TileGeometryManager = TileGeometryManager;\n//# sourceMappingURL=TileGeometryManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VertexCache = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n// Offsets for the fields stored in cache for each vertex.\nvar Field;\n(function (Field) {\n    Field[Field[\"VertexId\"] = 0] = \"VertexId\";\n    Field[Field[\"OlderIdx\"] = 1] = \"OlderIdx\";\n    Field[Field[\"NewerIdx\"] = 2] = \"NewerIdx\";\n    Field[Field[\"X\"] = 3] = \"X\";\n    Field[Field[\"Y\"] = 4] = \"Y\";\n    Field[Field[\"Z\"] = 5] = \"Z\";\n    Field[Field[\"Count\"] = 6] = \"Count\";\n})(Field || (Field = {}));\nconst Invalid = -1;\n/**\n * Compact vertex LRU Cache for on the fly temporary mesh transformations.\n * @internal\n */\nclass VertexCache {\n    /**\n     * Creates a new cache with the specified maximum size.\n     * @param maxVertexCount - The maximum number of vertices the cache will store.\n     */\n    constructor(maxVertexCount) {\n        this.maxVertexCount = maxVertexCount;\n        this.m_cache = []; // Stores all fields for every cached vertex (see Field).\n        this.m_vertexCount = 0;\n        this.m_oldestIdx = 0;\n        this.m_newestIdx = 0;\n        this.m_cache.length = this.maxVertexCount * Field.Count;\n        this.clear();\n    }\n    /**\n     * Clears the vertex cache.\n     */\n    clear() {\n        this.m_cache.fill(Invalid);\n        this.m_vertexCount = 0;\n    }\n    /**\n     * Gets a vertex from cache.\n     * @param vertexId - The id of the vertex to get.\n     * @param vertex - The vertex coordinates will be set here if found.\n     * @returns whether the vertex was found on cache.\n     */\n    get(vertexId, vertex) {\n        const vertexIdx = this.find(vertexId);\n        if (vertexIdx === undefined) {\n            return false;\n        }\n        this.promoteEntry(vertexIdx);\n        this.getVertex(vertexIdx, vertex);\n        return true;\n    }\n    /**\n     * Sets a vertex in cache. It's assumed there's no vertex with the same id already in cache.\n     * @param vertexId - The vertex id.\n     * @param vertex - The vertex coordinates.\n     */\n    set(vertexId, vertex) {\n        let vertexIdx = Invalid;\n        if (this.m_vertexCount < this.maxVertexCount) {\n            vertexIdx = this.m_vertexCount * Field.Count;\n            this.m_vertexCount++;\n        }\n        else {\n            vertexIdx = this.m_oldestIdx;\n        }\n        if (this.m_vertexCount === 1) {\n            this.m_oldestIdx = this.m_newestIdx = vertexIdx;\n        }\n        else {\n            this.promoteEntry(vertexIdx);\n        }\n        this.setVertex(vertexIdx, vertexId, vertex);\n    }\n    find(vertexId) {\n        const size = this.m_cache.length;\n        for (let i = 0; i < size; i += Field.Count) {\n            if (this.m_cache[i] === vertexId) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n    promoteEntry(vertexIdx) {\n        if (vertexIdx === this.m_newestIdx) {\n            return;\n        } // already newest, nothing to do\n        // re-link newer and older items\n        const newerIdx = this.getNewerIdx(vertexIdx);\n        const olderIdx = this.getOlderIdx(vertexIdx);\n        if (newerIdx !== Invalid) {\n            harp_utils_1.assert(this.getOlderIdx(newerIdx) === vertexIdx);\n            this.setOlderIdx(newerIdx, olderIdx);\n        }\n        if (olderIdx !== Invalid) {\n            harp_utils_1.assert(this.getNewerIdx(olderIdx) === vertexIdx);\n            this.setNewerIdx(olderIdx, newerIdx);\n        }\n        if (vertexIdx === this.m_oldestIdx) {\n            this.m_oldestIdx = newerIdx;\n        }\n        // re-link ourselves\n        this.setNewerIdx(vertexIdx, Invalid);\n        this.setOlderIdx(vertexIdx, this.m_newestIdx);\n        // finally, set ourselves as the newest entry\n        harp_utils_1.assert(this.m_newestIdx !== Invalid);\n        harp_utils_1.assert(this.getNewerIdx(this.m_newestIdx) === Invalid);\n        this.setNewerIdx(this.m_newestIdx, vertexIdx);\n        this.m_newestIdx = vertexIdx;\n    }\n    getOlderIdx(vertexIdx) {\n        return this.m_cache[vertexIdx + Field.OlderIdx];\n    }\n    setOlderIdx(vertexIdx, olderIdx) {\n        this.m_cache[vertexIdx + Field.OlderIdx] = olderIdx;\n    }\n    getNewerIdx(vertexIdx) {\n        return this.m_cache[vertexIdx + Field.NewerIdx];\n    }\n    setNewerIdx(vertexIdx, newerIdx) {\n        this.m_cache[vertexIdx + Field.NewerIdx] = newerIdx;\n    }\n    getVertex(vertexIdx, vertex) {\n        vertex.x = this.m_cache[vertexIdx + Field.X];\n        vertex.y = this.m_cache[vertexIdx + Field.Y];\n        vertex.z = this.m_cache[vertexIdx + Field.Z];\n    }\n    setVertex(vertexIdx, vertexId, vertex) {\n        this.m_cache[vertexIdx] = vertexId;\n        this.m_cache[vertexIdx + Field.X] = vertex.x;\n        this.m_cache[vertexIdx + Field.Y] = vertex.y;\n        this.m_cache[vertexIdx + Field.Z] = vertex.z;\n    }\n}\nexports.VertexCache = VertexCache;\n//# sourceMappingURL=VertexCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.overlayOnElevation = exports.overlayTextElement = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * Overlays the specified object's geometry on the elevation represented by the given displacement\n * map .\n *\n * @param object - The object to be overlaid.\n * @param displacementMap - Texture representing the elevation data used to overlay the object.\n */\nfunction overlayObject(object, displacementMap) {\n    if (!(\"material\" in object)) {\n        return;\n    }\n    const setDisplacementMap = harp_materials_1.setDisplacementMapToMaterial.bind(null, displacementMap);\n    const material = object.material;\n    if (Array.isArray(material)) {\n        material.forEach(setDisplacementMap);\n    }\n    else if (material) {\n        setDisplacementMap(material);\n    }\n}\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param worldCoords - World coordinates to overlay.\n * @param elevationProvider - Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation\n * data not available).\n */\nfunction overlayPosition(worldCoords, elevationProvider, displacementMap, projection) {\n    // TODO: Move calculation of text element geoCoordinates to decoder.\n    const geoCoords = projection.unprojectPoint(worldCoords);\n    if (displacementMap.geoBox.contains(geoCoords)) {\n        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);\n    }\n    else {\n        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);\n        if (geoCoords.altitude === undefined) {\n            return false;\n        }\n    }\n    projection.projectPoint(geoCoords, worldCoords);\n    return true;\n}\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param path - World coordinates to overlay.\n * @param elevationProvider - Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation\n * data not available).\n */\nfunction overlayPath(path, elevationProvider, displacementMap, projection) {\n    for (const position of path) {\n        if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Overlays a text element on top of elevation data if available.\n *\n * @param textElement - The text element whose geometry will be overlaid.\n * @param elevationProvider -  Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n */\nfunction overlayTextElement(textElement, elevationProvider, displacementMap, projection) {\n    harp_utils_1.assert(!textElement.elevated);\n    if (!displacementMap) {\n        return;\n    }\n    textElement.elevated = textElement.path\n        ? overlayPath(textElement.path, elevationProvider, displacementMap, projection)\n        : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);\n}\nexports.overlayTextElement = overlayTextElement;\n/**\n * Overlays the geometry in the given tile on top of elevation data if available. The tile's\n * elevation may be updated with a more precise range.\n *\n * @param tile - The tile whose geometry will be overlaid.\n */\nfunction overlayOnElevation(tile) {\n    const elevationProvider = tile.mapView.elevationProvider;\n    if (elevationProvider === undefined || tile.objects.length === 0) {\n        return;\n    }\n    const firstObject = tile.objects[0];\n    if (!firstObject.userData ||\n        !firstObject.userData.kind ||\n        !firstObject.userData.kind.find((kind) => {\n            return kind !== harp_datasource_protocol_1.GeometryKind.All && kind !== harp_datasource_protocol_1.GeometryKind.Terrain;\n        })) {\n        return;\n    }\n    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);\n    if (displacementMap === undefined) {\n        return;\n    }\n    // TODO: HARP-8808 Apply displacement maps once per material.\n    for (const object of tile.objects) {\n        overlayObject(object, displacementMap.texture);\n    }\n}\nexports.overlayOnElevation = overlayOnElevation;\n//# sourceMappingURL=overlayOnElevation.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/Image.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/Image.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageItem = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MipMapGenerator_1 = __webpack_require__(/*! ./MipMapGenerator */ \"./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"loadImage\");\nconst mipMapGenerator = new MipMapGenerator_1.MipMapGenerator();\n/**\n * `ImageItem` is used to identify an image in the {@link ImageCache}.\n */\nclass ImageItem {\n    /**\n     * Create the `ImageItem`.\n     *\n     * @param url - URL of the image, or unique identifier.\n     * @param image - Optional image if already loaded.\n     */\n    constructor(url, image) {\n        this.url = url;\n        this.image = image;\n    }\n    get loaded() {\n        return this.image !== undefined && this.mipMaps !== undefined;\n    }\n    get loading() {\n        return this.loadingPromise !== undefined;\n    }\n    /**\n     * Load an {@link ImageItem}.\n     *\n     * @remarks\n     * If the loading process is already running, it returns the current promise.\n     *\n     * @param imageItem - `ImageItem` containing the URL to load image from.\n     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.\n     */\n    loadImage() {\n        if (this.loaded) {\n            return Promise.resolve(this);\n        }\n        if (this.loading) {\n            return this.loadingPromise;\n        }\n        this.loadingPromise = new Promise((resolve, reject) => {\n            if (this.image) {\n                const image = this.image;\n                if (image instanceof HTMLImageElement && !image.complete) {\n                    image.addEventListener(\"load\", this.finalizeImage.bind(this, image, resolve));\n                    image.addEventListener(\"error\", reject);\n                }\n                else {\n                    this.finalizeImage(this.image, resolve);\n                }\n                return;\n            }\n            logger.debug(`Loading image: ${this.url}`);\n            if (this.cancelled === true) {\n                logger.debug(`Cancelled loading image: ${this.url}`);\n                resolve(undefined);\n            }\n            else {\n                new THREE.ImageLoader().load(this.url, (image) => {\n                    if (this.cancelled === true) {\n                        logger.debug(`Cancelled loading image: ${this.url}`);\n                        resolve(undefined);\n                        return;\n                    }\n                    this.finalizeImage(image, resolve);\n                }, undefined, errorEvent => {\n                    logger.error(`... loading image failed: ${this.url} : ${errorEvent}`);\n                    this.loadingPromise = undefined;\n                    reject(`... loading image failed: ${this.url} : ${errorEvent}`);\n                });\n            }\n        });\n        return this.loadingPromise;\n    }\n    finalizeImage(image, resolve) {\n        this.image = image;\n        this.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(this);\n        this.loadingPromise = undefined;\n        resolve(this);\n    }\n}\nexports.ImageItem = ImageItem;\n//# sourceMappingURL=Image.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/Image.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/ImageCache.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageCache = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst Image_1 = __webpack_require__(/*! ./Image */ \"./node_modules/@here/harp-mapview/lib/image/Image.js\");\n/**\n * Combines an {@link ImageItem} with a list of owners (which can be any object) that reference it.\n */\nclass ImageCacheItem {\n    /**\n     * Instantiates `ImageCacheItem`.\n     *\n     * @param imageItem - The {@link ImageItem} referenced by the associated owners.\n     * @param owner - First owner referencing the {@link ImageItem}.\n     */\n    constructor(imageItem, owner) {\n        this.imageItem = imageItem;\n        /**\n         * The list of owners referencing the {@link ImageItem}.\n         */\n        this.owners = [];\n        this.owners.push(owner);\n    }\n}\n/**\n * @internal\n *\n * `ImageCache` is a singleton, so it can be used with multiple owners on a single page.\n *\n * @remarks\n * This allows to have an image loaded only once for multiple views.\n * THREE is doing something similar,\n * but does not allow to share images that have been loaded from a canvas (which we may need to do\n * if we use SVG images for textures).\n *\n * One application that makes our own cache necessary is the generation of our own textures from\n * data that is not an URL.\n *\n * The `ImageCache` can be improved by adding statistics for memory footprint as well.\n */\nclass ImageCache {\n    constructor() {\n        this.m_images = new Map();\n    }\n    /**\n     * Returns the singleton `instance` of the `ImageCache`.\n     */\n    static get instance() {\n        if (ImageCache.m_instance === undefined) {\n            ImageCache.m_instance = new ImageCache();\n        }\n        return ImageCache.m_instance;\n    }\n    /**\n     * Dispose the singleton object.\n     *\n     * @remarks\n     * Not normally implemented for singletons, but good for debugging.\n     */\n    static dispose() {\n        ImageCache.m_instance = undefined;\n    }\n    /**\n     * Add an image definition to the global cache. Useful when the image data is already loaded.\n     *\n     * @param owner - Specify which {@link any} requests the image.\n     * @param url - URL of image.\n     * @param image - Optional {@link TexturizableImage}.\n     */\n    registerImage(owner, url, image) {\n        let imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem) {\n            if (owner !== undefined && !imageCacheItem.owners.includes(owner)) {\n                imageCacheItem.owners.push(owner);\n            }\n            return imageCacheItem.imageItem;\n        }\n        imageCacheItem = {\n            imageItem: new Image_1.ImageItem(url, image),\n            owners: [owner]\n        };\n        this.m_images.set(url, imageCacheItem);\n        return imageCacheItem.imageItem;\n    }\n    /**\n     * Remove an image from the cache..\n     *\n     * @param url - URL of the image.\n     * @param owner - Owner removing the image.\n     * @returns `true` if image has been removed.\n     */\n    removeImage(url, owner) {\n        const cacheItem = this.m_images.get(url);\n        if (cacheItem !== undefined) {\n            this.unlinkCacheItem(cacheItem, owner);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Find {@link ImageItem} for the specified URL.\n     *\n     * @param url - URL of image.\n     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.\n     */\n    findImage(url) {\n        const cacheItem = this.m_images.get(url);\n        if (cacheItem !== undefined) {\n            return cacheItem.imageItem;\n        }\n        return undefined;\n    }\n    /**\n     * Clear all {@link ImageItem}s belonging to an owner.\n     *\n     * @remarks\n     * May remove cached items if no owner is registered anymore.\n     *\n     * @param owner - specify to remove all items registered by {@link any}.\n     * @returns Number of images removed.\n     */\n    clear(owner) {\n        this.m_images.forEach(cacheItem => {\n            this.unlinkCacheItem(cacheItem, owner);\n        });\n    }\n    /**\n     * Returns the number of all cached {@link ImageItem}s.\n     */\n    get size() {\n        return this.m_images.size;\n    }\n    /**\n     * Find the cached {@link ImageItem} by URL.\n     *\n     * @param url - URL of image.\n     */\n    findImageCacheItem(url) {\n        return this.m_images.get(url);\n    }\n    /**\n     * Cancel loading an image.\n     *\n     * @param imageItem - Item to cancel loading.\n     */\n    cancelLoading(imageItem) {\n        if (imageItem.loading) {\n            // Notify that we are cancelling.\n            imageItem.cancelled = true;\n        }\n    }\n    /**\n     * Remove the cacheItem from cache, unless the item is used by another owner, in that case the\n     * link to the owner is removed from the item, just like a reference count.\n     *\n     * @param cacheItem The cache item to be removed.\n     * @param owner - Specify which owner removes the image.\n     * If no owner is specified, the cache item is removed even if it has owners.\n     */\n    unlinkCacheItem(cacheItem, owner) {\n        const ownerIndex = cacheItem.owners.indexOf(owner);\n        if (ownerIndex >= 0) {\n            cacheItem.owners.splice(ownerIndex, 1);\n        }\n        if (cacheItem.owners.length === 0) {\n            this.m_images.delete(cacheItem.imageItem.url);\n            this.cancelLoading(cacheItem.imageItem);\n        }\n    }\n}\nexports.ImageCache = ImageCache;\n//# sourceMappingURL=ImageCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/ImageCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewImageCache = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst ImageCache_1 = __webpack_require__(/*! ./ImageCache */ \"./node_modules/@here/harp-mapview/lib/image/ImageCache.js\");\n/**\n * Cache images wrapped into {@link ImageItem}s for a {@link MapView}.\n *\n * @remarks\n * An image may have multiple names in a theme, the `MapViewImageCache` maps different names to the\n * same image URL, and allows to share the image by URL to different MapViews.\n * Within a MapView instance, the (optional) name is unique, so registering multiple images with the\n * same name is invalid.\n *\n * The `MapViewImageCache` uses a global {@link ImageCache} to actually store (and generate) the\n * image data.\n */\nclass MapViewImageCache {\n    constructor() {\n        this.m_name2Url = new Map();\n        this.m_urlNameCount = new Map();\n    }\n    addImage(name, urlOrImage, startLoading = true) {\n        if (typeof urlOrImage === \"string\") {\n            const url = urlOrImage;\n            const imageItem = this.registerImage(name, url);\n            return startLoading ? imageItem.loadImage() : imageItem;\n        }\n        const image = urlOrImage;\n        return this.registerImage(name, undefined, image);\n    }\n    /**\n     * Remove the image with this name from the cache.\n     *\n     * @param name - Name of the image.\n     * @returns `true` if item has been removed.\n     */\n    removeImage(name) {\n        const url = this.m_name2Url.get(name);\n        if (url !== undefined) {\n            this.m_name2Url.delete(name);\n            let nameCount = 1;\n            if (name !== url) {\n                const result = this.m_urlNameCount.get(url);\n                harp_utils_1.assert(result !== undefined);\n                nameCount = result;\n                harp_utils_1.assert(nameCount > 0);\n            }\n            if (nameCount > 1) {\n                // There is another name sharing this URL.\n                this.m_urlNameCount.set(url, nameCount - 1);\n            }\n            else {\n                // URL was used by this image only, remove the image.\n                this.m_urlNameCount.delete(url);\n                ImageCache_1.ImageCache.instance.removeImage(url, this);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Find {@link ImageItem} by its name.\n     *\n     * @param name - Name of image.\n     */\n    findImageByName(name) {\n        const url = this.m_name2Url.get(name);\n        if (url === undefined) {\n            return undefined;\n        }\n        return ImageCache_1.ImageCache.instance.findImage(url);\n    }\n    /**\n     * Remove all {@link ImageItem}s from the cache.\n     *\n     * @remarks\n     * Also removes all {@link ImageItem}s that belong to this\n     * {@link MapView} from the global {@link ImageCache}.\n     * @returns Number of images removed.\n     */\n    clear() {\n        ImageCache_1.ImageCache.instance.clear(this);\n        this.m_name2Url.clear();\n        this.m_urlNameCount.clear();\n    }\n    /**\n     * Register an existing image by name. If the name already exists and error is thrown.\n     *\n     * @param name - Image name.\n     * @param url - Optional image URL.\n     * @param image - Optional {@link TexturizableImage}.\n     */\n    registerImage(name, url, image) {\n        var _a;\n        if (this.hasName(name)) {\n            throw new Error(\"duplicate name in cache\");\n        }\n        if (url === undefined) {\n            // If no url given, an image must be provided directly. In this case the name is used\n            // as url.\n            harp_utils_1.assert(image !== undefined);\n            url = name;\n        }\n        if (url !== name) {\n            const nameCount = (_a = this.m_urlNameCount.get(url)) !== null && _a !== void 0 ? _a : 0;\n            this.m_urlNameCount.set(url, nameCount + 1);\n        }\n        this.m_name2Url.set(name, url);\n        return ImageCache_1.ImageCache.instance.registerImage(this, url, image);\n    }\n    hasName(name) {\n        return this.m_name2Url.get(name) !== undefined;\n    }\n}\nexports.MapViewImageCache = MapViewImageCache;\n//# sourceMappingURL=MapViewImageCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MipMapGenerator = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst isNode = typeof window === \"undefined\";\n/**\n * Mip map generator resizes textures to next bigger power-of-two size by adding padding\n * and creates mip map levels.\n * @internal\n */\nclass MipMapGenerator {\n    constructor() {\n        if (!isNode) {\n            this.m_paddingCanvas = document.createElement(\"canvas\");\n            this.m_paddingContext = this.m_paddingCanvas.getContext(\"2d\");\n            this.m_resizeCanvas = document.createElement(\"canvas\");\n            this.m_resizeContext = this.m_resizeCanvas.getContext(\"2d\");\n        }\n    }\n    /**\n     * Gets size of an image padded to the next bigger power-of-two size\n     * @param width - Width of image\n     * @param height - Height of image\n     */\n    static getPaddedSize(width, height) {\n        return {\n            width: THREE.MathUtils.ceilPowerOfTwo(width),\n            height: THREE.MathUtils.ceilPowerOfTwo(height)\n        };\n    }\n    /**\n     * Generate downsampled mip map levels from an image.\n     * If the input image is not power-of-two the image is padded to the\n     * next bigger power-of-two size.\n     * @param image - Input image\n     * @returns A list of images with mip maps of the input image\n     */\n    generateTextureAtlasMipMap(image) {\n        if (isNode) {\n            throw new Error(\"MipMapGenerator only works in browser.\");\n        }\n        if (image.image === undefined) {\n            throw new Error(\"Can not generate mip maps. Image data not loaded!\");\n        }\n        const imageData = image.image;\n        const mipMaps = [];\n        // Add initial texture with padding as level 0\n        const { width: paddedWidth, height: paddedHeight } = MipMapGenerator.getPaddedSize(imageData.width, imageData.height);\n        this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);\n        mipMaps.push(this.m_paddingContext.getImageData(0, 0, paddedWidth, paddedHeight));\n        let width = paddedWidth * 0.5;\n        let height = paddedHeight * 0.5;\n        // HARP-10765 WebGL complains if we don't generate down to a 1x1 texture (this was the case\n        // previously when height != width), and thus the final texture generated was 2x1 texture\n        // and not 1x1.\n        while (width >= 1 || height >= 1) {\n            const mipMapLevel = mipMaps.length;\n            const previousImage = mipMaps[mipMapLevel - 1];\n            // Resize previous mip map level\n            mipMaps.push(this.resizeImage(previousImage, Math.max(width, 1), Math.max(height, 1)));\n            width *= 0.5;\n            height *= 0.5;\n        }\n        return mipMaps;\n    }\n    /**\n     * Copy image to a canvas and add padding if necessary.\n     * @param image - Input image.\n     * @param width - Width of output image\n     * @param height - Width of output image\n     * @returns Canvas with image and padding.\n     */\n    copyImageWithPadding(image, width, height) {\n        this.m_paddingCanvas.width = width;\n        this.m_paddingCanvas.height = height;\n        this.m_paddingContext.clearRect(0, 0, width, height);\n        if (image instanceof ImageData) {\n            this.m_paddingContext.putImageData(image, 0, 0);\n        }\n        else {\n            this.m_paddingContext.drawImage(image, 0, 0);\n        }\n        // Add horizontal padding\n        if (image.width !== width) {\n            this.m_paddingContext.drawImage(this.m_paddingCanvas, image.width - 1, 0, 1, image.height, image.width, 0, width - image.width, image.height);\n        }\n        // Add vertical padding\n        if (image.height !== height) {\n            this.m_paddingContext.drawImage(this.m_paddingCanvas, 0, image.height - 1, width, 1, 0, image.height, width, height - image.height);\n        }\n        return this.m_paddingCanvas;\n    }\n    /**\n     * Resize an image.\n     *\n     * Quality of resized image is best when\n     * image.width and image.height are even numbers and the image\n     * is resized by factor 0.5 or 2.\n     * @param image - Input image\n     * @param width - Width of output image\n     * @param height - Height of output image\n     * @return Resized image\n     */\n    resizeImage(image, width, height) {\n        //  Copy image data to canvas because ImageData can't be resized directly\n        const paddedImage = this.copyImageWithPadding(image, image.width, image.height);\n        // Resize image to resize canvas\n        this.m_resizeCanvas.width = width;\n        this.m_resizeCanvas.height = height;\n        this.m_resizeContext.clearRect(0, 0, width, height);\n        this.m_resizeContext.drawImage(paddedImage, 0, 0, width, height);\n        return this.m_resizeContext.getImageData(0, 0, width, height);\n    }\n}\nexports.MipMapGenerator = MipMapGenerator;\n//# sourceMappingURL=MipMapGenerator.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BoxBuffer = exports.BoxBufferMesh = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ \"./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js\");\n/**\n * Initial number of boxes in BoxBuffer.\n */\nconst START_BOX_BUFFER_SIZE = 0;\n/**\n * Maximum number of boxes in BoxBuffer.\n */\nconst MAX_BOX_BUFFER_SIZE = 32 * 1024;\n/**\n * Number of vertices per box/glyph element: 4 corners.\n */\nconst NUM_VERTICES_PER_ELEMENT = 4;\n/**\n * Number of indices added per box/glyph: 2 triangles, 6 indices.\n */\nconst NUM_INDICES_PER_ELEMENT = 6;\n/**\n * Number of values per position.\n */\nconst NUM_POSITION_VALUES_PER_VERTEX = 3;\n/**\n * Number of values per color.\n */\nconst NUM_COLOR_VALUES_PER_VERTEX = 4;\n/**\n * Number of values per UV.\n */\nconst NUM_UV_VALUES_PER_VERTEX = 4;\n/**\n * Number of values per index.\n */\nconst NUM_INDEX_VALUES_PER_VERTEX = 1;\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n/**\n * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and\n * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.\n */\nclass BoxBufferMesh extends THREE.Mesh {\n    constructor(geometry, material) {\n        super(geometry, material);\n        this.type = \"BoxBufferMesh\";\n    }\n    /**\n     * A mesh that has no positions and indices set is defined to be empty.\n     *\n     * @returns `True` if no indices have been added to the mesh.\n     */\n    get isEmpty() {\n        if (this.geometry === undefined) {\n            return true;\n        }\n        else {\n            const bufferGeometry = this.geometry;\n            return bufferGeometry.index === null || bufferGeometry.index.count === 0;\n        }\n    }\n}\nexports.BoxBufferMesh = BoxBufferMesh;\n/**\n * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-\n * aligned boxes, like POIs.\n */\nclass BoxBuffer {\n    /**\n     * Creates a new `BoxBuffer`.\n     *\n     * @param m_material - Material to be used for [[Mesh]] of this `BoxBuffer`.\n     * @param m_renderOrder - Optional renderOrder of this buffer.\n     * @param startElementCount - Initial number of elements this `BoxBuffer` can hold.\n     * @param m_maxElementCount - Maximum number of elements this `BoxBuffer` can hold.\n     */\n    constructor(m_material, m_renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, m_maxElementCount = MAX_BOX_BUFFER_SIZE) {\n        this.m_material = m_material;\n        this.m_renderOrder = m_renderOrder;\n        this.m_maxElementCount = m_maxElementCount;\n        this.m_size = 0;\n        this.resizeBuffer(startElementCount);\n        this.m_pickInfos = new Array();\n    }\n    /**\n     * Duplicate this `BoxBuffer` with same material and renderOrder.\n     *\n     * @returns A clone of this `BoxBuffer`.\n     */\n    clone() {\n        return new BoxBuffer(this.m_material, this.m_renderOrder);\n    }\n    /**\n     * Dispose of the geometry.\n     */\n    dispose() {\n        if (this.m_geometry !== undefined) {\n            this.m_geometry.dispose();\n            this.m_geometry = undefined;\n        }\n        this.m_mesh = undefined;\n    }\n    /**\n     * Return the current number of elements the buffer can hold.\n     */\n    get size() {\n        return this.m_size;\n    }\n    /**\n     * Clear's the `BoxBuffer` attribute buffers.\n     */\n    reset() {\n        if (this.m_positionAttribute !== undefined) {\n            this.m_positionAttribute.count = 0;\n            this.m_colorAttribute.count = 0;\n            this.m_uvAttribute.count = 0;\n            this.m_indexAttribute.count = 0;\n            this.m_pickInfos.length = 0;\n        }\n    }\n    /**\n     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer\n     * can only add the glyph by increasing the buffer size, the resize() method is called, which\n     * will then create a new geometry for the mesh.\n     *\n     * @param glyphCount - Number of glyphs to be added to the buffer.\n     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.\n     */\n    canAddElements(glyphCount = 1) {\n        const indexAttribute = this.m_indexAttribute;\n        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=\n            indexAttribute.array.length) {\n            // Too many elements for the current buffer, check if we can resize the buffer.\n            if (indexAttribute.array.length >= this.m_maxElementCount * NUM_INDICES_PER_ELEMENT) {\n                return false;\n            }\n            const newSize = Math.min(this.m_maxElementCount, this.size === 0 ? 256 : this.size * 2);\n            this.resize(newSize);\n        }\n        return true;\n    }\n    /**\n     * Returns this `BoxBuffer`'s attribute [[State]].\n     */\n    saveState() {\n        const state = {\n            positionAttributeCount: this.m_positionAttribute.count,\n            colorAttributeCount: this.m_colorAttribute.count,\n            uvAttributeCount: this.m_uvAttribute.count,\n            indexAttributeCount: this.m_indexAttribute.count,\n            pickInfoCount: this.m_pickInfos.length\n        };\n        return state;\n    }\n    /**\n     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.\n     *\n     * @param state - [[State]] struct describing a previous attribute state.\n     */\n    restoreState(state) {\n        this.m_positionAttribute.count = state.positionAttributeCount;\n        this.m_colorAttribute.count = state.colorAttributeCount;\n        this.m_uvAttribute.count = state.uvAttributeCount;\n        this.m_indexAttribute.count = state.indexAttributeCount;\n        this.m_pickInfos.length = state.pickInfoCount;\n    }\n    /**\n     * Adds a new box to this `BoxBuffer`.\n     *\n     * @param screenBox - [[Math2D.Box]] holding screen coordinates for this box.\n     * @param uvBox - [[Math2D.UvBox]] holding uv coordinates for this box.\n     * @param color - Box's color.\n     * @param opacity - Box's opacity.\n     * @param distance - Box's distance to camera.\n     * @param pickInfo - Box's picking information.\n     */\n    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {\n        if (!this.canAddElements()) {\n            return false;\n        }\n        const { s0, t0, s1, t1 } = uvBox;\n        const { x, y, w, h } = screenBox;\n        // Premultiply alpha into vertex colors\n        const r = Math.round(color.r * opacity * 255);\n        const g = Math.round(color.g * opacity * 255);\n        const b = Math.round(color.b * opacity * 255);\n        const a = Math.round(opacity * 255);\n        const positionAttribute = this.m_positionAttribute;\n        const colorAttribute = this.m_colorAttribute;\n        const uvAttribute = this.m_uvAttribute;\n        const indexAttribute = this.m_indexAttribute;\n        const baseVertex = positionAttribute.count;\n        const baseIndex = indexAttribute.count;\n        positionAttribute.setXYZ(baseVertex, x, y, distance);\n        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);\n        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);\n        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);\n        colorAttribute.setXYZW(baseVertex, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);\n        uvAttribute.setXY(baseVertex, s0, t0);\n        uvAttribute.setXY(baseVertex + 1, s1, t0);\n        uvAttribute.setXY(baseVertex + 2, s0, t1);\n        uvAttribute.setXY(baseVertex + 3, s1, t1);\n        indexAttribute.setX(baseIndex, baseVertex);\n        indexAttribute.setX(baseIndex + 1, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 2, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 3, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 4, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 5, baseVertex + 3);\n        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        indexAttribute.count += NUM_INDICES_PER_ELEMENT;\n        this.m_pickInfos.push(pickInfo);\n        return true;\n    }\n    /**\n     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute\n     * data.\n     */\n    updateBufferGeometry() {\n        const positionAttribute = this.m_positionAttribute;\n        const colorAttribute = this.m_colorAttribute;\n        const uvAttribute = this.m_uvAttribute;\n        const indexAttribute = this.m_indexAttribute;\n        if (positionAttribute.count > 0) {\n            positionAttribute.needsUpdate = true;\n            positionAttribute.updateRange.offset = 0;\n            positionAttribute.updateRange.count =\n                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n        if (colorAttribute.count > 0) {\n            colorAttribute.needsUpdate = true;\n            colorAttribute.updateRange.offset = 0;\n            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n        if (uvAttribute.count > 0) {\n            uvAttribute.needsUpdate = true;\n            uvAttribute.updateRange.offset = 0;\n            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n        if (indexAttribute.count > 0) {\n            indexAttribute.needsUpdate = true;\n            indexAttribute.updateRange.offset = 0;\n            indexAttribute.updateRange.count = indexAttribute.count;\n        }\n        if (this.m_geometry !== undefined) {\n            this.m_geometry.clearGroups();\n            this.m_geometry.addGroup(0, this.m_indexAttribute.count);\n        }\n    }\n    /**\n     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce\n     * footprint.\n     */\n    cleanUp() {\n        // If there is nothing in this buffer, resize it, it may never be used again.\n        if (this.m_indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {\n            this.clearAttributes();\n        }\n    }\n    /**\n     * Determine if the mesh is empty.\n     */\n    get isEmpty() {\n        return this.m_mesh.isEmpty;\n    }\n    /**\n     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are\n     * resized. The mesh, once created, will not change, so it can always be added to the scene.\n     */\n    get mesh() {\n        if (this.m_mesh === undefined) {\n            this.resize();\n        }\n        return this.m_mesh;\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     * @param image - Image to test if the pixel is transparent\n     */\n    pickBoxes(screenPosition, pickCallback, image) {\n        const n = this.m_pickInfos.length;\n        const pickInfos = this.m_pickInfos;\n        const positions = this.m_positionAttribute;\n        const screenX = screenPosition.x;\n        const screenY = screenPosition.y;\n        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {\n            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;\n            const minX = positions.getX(positionIndex);\n            if (screenX < minX) {\n                continue;\n            }\n            const maxX = positions.getX(positionIndex + 1);\n            if (screenX > maxX) {\n                continue;\n            }\n            const minY = positions.getY(positionIndex);\n            if (screenY < minY) {\n                continue;\n            }\n            const maxY = positions.getY(positionIndex + 2);\n            if (screenY > maxY) {\n                continue;\n            }\n            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);\n            if (image !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&\n                this.isPixelTransparent(image, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, document.createElement(\"canvas\"))) {\n                continue;\n            }\n            if (pickInfos[pickInfoIndex] !== undefined) {\n                pickCallback(pickInfos[pickInfoIndex]);\n            }\n        }\n    }\n    /**\n     * Creates a new {@link @here/harp-datasource-protocol#Geometry} object\n     * from all the attribute data stored in this `BoxBuffer`.\n     *\n     * @remarks\n     * The [[Mesh]] object may be created if it is not initialized already.\n     *\n     * @param newSize - Optional number of elements to resize the buffer to.\n     * @param forceResize - Optional flag to force a resize even if new size is smaller than before.\n     */\n    resize(newSize, forceResize) {\n        if (this.m_geometry !== undefined) {\n            this.m_geometry.dispose();\n        }\n        this.m_geometry = new THREE.BufferGeometry();\n        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {\n            this.resizeBuffer(newSize);\n        }\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setIndex(this.m_indexAttribute);\n        this.m_geometry.addGroup(0, this.m_indexAttribute.count);\n        if (this.m_mesh === undefined) {\n            this.m_mesh = new BoxBufferMesh(this.m_geometry, this.m_material);\n            this.m_mesh.renderOrder = this.m_renderOrder;\n        }\n        else {\n            this.m_mesh.geometry = this.m_geometry;\n        }\n        return this.m_mesh;\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.\n     *\n     * @param info - The info object to increment with the values from this `BoxBuffer`.\n     */\n    updateMemoryUsage(info) {\n        const numBytes = this.m_positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.m_colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +\n            this.m_uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.m_indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n    /**\n     * Check if a pixel is transparent or not.\n     *\n     * @param image - Image source.\n     * @param xScreenPos - X position of the pixel.\n     * @param yScreenPos - Y position of the pixel.\n     * @param box - Bounding box of the image in screen coordinates.\n     * @param uvBox - Uv box referred to the given bounding box.\n     * @param canvas - Canvas element to draw the image if it's not a `ImageData` object.\n     */\n    isPixelTransparent(image, xScreenPos, yScreenPos, box, uvBox, canvas) {\n        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);\n        const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;\n        const x = width * u;\n        const y = height * v;\n        const pixel = PixelPicker_1.getPixelFromImage(x, y, image, canvas);\n        return pixel !== undefined && pixel[3] === 0;\n    }\n    /**\n     * Remove current attributes and arrays. Minimizes memory footprint.\n     */\n    clearAttributes() {\n        this.m_positionAttribute = undefined;\n        this.m_colorAttribute = undefined;\n        this.m_uvAttribute = undefined;\n        this.m_indexAttribute = undefined;\n        this.resize(START_BOX_BUFFER_SIZE, true);\n    }\n    /**\n     * Resize the attribute buffers. New value must be larger than the previous one.\n     *\n     * @param newSize - New number of elements in the buffer. Number has to be larger than the\n     *      previous size.\n     */\n    resizeBuffer(newSize) {\n        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);\n        if (this.m_positionAttribute !== undefined && this.m_positionAttribute.array.length > 0) {\n            const positionAttributeCount = this.m_positionAttribute.count;\n            newPositionArray.set(this.m_positionAttribute.array);\n            this.m_positionAttribute.array = newPositionArray;\n            this.m_positionAttribute.count = positionAttributeCount;\n        }\n        else {\n            this.m_positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);\n            this.m_positionAttribute.count = 0;\n            this.m_positionAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);\n        if (this.m_colorAttribute !== undefined) {\n            const colorAttributeCount = this.m_colorAttribute.count;\n            newColorArray.set(this.m_colorAttribute.array);\n            this.m_colorAttribute.array = newColorArray;\n            this.m_colorAttribute.count = colorAttributeCount;\n        }\n        else {\n            this.m_colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);\n            this.m_colorAttribute.count = 0;\n            this.m_colorAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);\n        if (this.m_uvAttribute !== undefined) {\n            const uvAttributeCount = this.m_uvAttribute.count;\n            newUvArray.set(this.m_uvAttribute.array);\n            this.m_uvAttribute.array = newUvArray;\n            this.m_uvAttribute.count = uvAttributeCount;\n        }\n        else {\n            this.m_uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);\n            this.m_uvAttribute.count = 0;\n            this.m_uvAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;\n        const newIndexArray = numIndexValues > 65535\n            ? new Uint32Array(numIndexValues)\n            : new Uint16Array(numIndexValues);\n        if (this.m_indexAttribute !== undefined) {\n            const indexAttributeCount = this.m_indexAttribute.count;\n            newIndexArray.set(this.m_indexAttribute.array);\n            this.m_indexAttribute.array = newIndexArray;\n            this.m_indexAttribute.count = indexAttributeCount;\n        }\n        else {\n            this.m_indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);\n            this.m_indexAttribute.count = 0;\n            this.m_indexAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        this.m_size = newSize;\n    }\n}\nexports.BoxBuffer = BoxBuffer;\n//# sourceMappingURL=BoxBuffer.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPixelFromImageData = exports.getPixelFromCanvasImageSource = exports.screenToUvCoordinates = exports.getPixelFromImage = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * It returns an array containing the channel colors for the pixel at the given coordinates.\n *\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param image - The image source.\n * @param canvas - Canvas element that will be used to draw the image, in case the imageData is an\n * ImageBitmap\n */\nfunction getPixelFromImage(xPos, yPos, image, canvas) {\n    if (image instanceof ImageData) {\n        const stride = image.data.length / (image.height * image.width);\n        return getPixelFromImageData(image, xPos, yPos, stride);\n    }\n    if (!canvas) {\n        canvas = document.createElement(\"canvas\");\n    }\n    return getPixelFromCanvasImageSource(image, xPos, yPos, canvas);\n}\nexports.getPixelFromImage = getPixelFromImage;\n/**\n * Given the x and y position in screen coordinates inside the target box, it map them to the UV\n * coordinates.\n * @param screenX - X value in screen coordinates.\n * @param screenY - Y value in screen coordinates.\n * @param box - Bounding box in screen coordinates.\n * @param uvBox - Uv box referred to the given bounding box.\n */\nfunction screenToUvCoordinates(screenX, screenY, box, uvBox) {\n    const minX = box.x;\n    const maxX = box.x + box.w;\n    const minY = box.y;\n    const maxY = box.y + box.h;\n    const u = harp_utils_1.MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);\n    const v = harp_utils_1.MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);\n    return { u, v };\n}\nexports.screenToUvCoordinates = screenToUvCoordinates;\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image - Image source.\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param canvas - HTML Canvas element on which the image is drawn.\n */\nfunction getPixelFromCanvasImageSource(image, xPos, yPos, canvas) {\n    const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;\n    if (xPos > width || xPos < 0 || yPos > height || yPos < 0) {\n        return undefined;\n    }\n    let pixelData;\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    if (context !== null) {\n        context.drawImage(image, 0, 0);\n        pixelData = context.getImageData(xPos, yPos, 1, 1).data;\n    }\n    return pixelData;\n}\nexports.getPixelFromCanvasImageSource = getPixelFromCanvasImageSource;\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image - Image data in which the pixels are stored.\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param stride - The stride value of the image data.\n */\nfunction getPixelFromImageData(imgData, xPos, yPos, stride) {\n    const getPixel = (imageData, index, strd) => {\n        const i = index * strd;\n        const d = imageData.data;\n        const pixel = new Uint8ClampedArray(strd);\n        for (let s = 0; s < strd; s++) {\n            pixel[0] = d[i + s];\n        }\n        return pixel;\n    };\n    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {\n        return undefined;\n    }\n    return getPixel(imgData, yPos * imgData.width + xPos, stride);\n}\nexports.getPixelFromImageData = getPixelFromImageData;\n//# sourceMappingURL=PixelPicker.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiBuilder.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiBuilder.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoiBuilder = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst ColorCache_1 = __webpack_require__(/*! ../ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiBuilder\");\nfunction getImageTexture(technique, env) {\n    return technique.imageTexture !== undefined\n        ? harp_datasource_protocol_1.composeTechniqueTextureName(harp_datasource_protocol_1.getPropertyValue(technique.imageTexture, env), technique)\n        : undefined;\n}\n/**\n * Constructs {@link PoiInfo} objects from {@link @here/harp-datasource-protocol/Technique} and\n * an icon.\n */\nclass PoiBuilder {\n    /**\n     * Constructor\n     *\n     * @param m_env - The {@link @link @here/harp-datasource-protocol#MapEnv} used to evaluate\n     * technique properties.\n     */\n    constructor(m_env) {\n        this.m_env = m_env;\n    }\n    /**\n     * Sets a technique that will be used to create PoiInfos on subsequent calls to\n     * {@link PoiBuilder.build} until the next call to this method.\n     *\n     * @param technique - The {@link @here/harp-datasource-protocol/Technique}.\n     * @return This builder.\n     */\n    withTechnique(technique) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.m_imageTextureName = getImageTexture(technique, this.m_env);\n        this.m_iconMinZoomLevel = (_b = harp_datasource_protocol_1.getPropertyValue((_a = technique.iconMinZoomLevel) !== null && _a !== void 0 ? _a : technique.minZoomLevel, this.m_env)) !== null && _b !== void 0 ? _b : undefined;\n        this.m_iconMaxZoomLevel = (_d = harp_datasource_protocol_1.getPropertyValue((_c = technique.iconMaxZoomLevel) !== null && _c !== void 0 ? _c : technique.maxZoomLevel, this.m_env)) !== null && _d !== void 0 ? _d : undefined;\n        this.m_textMinZoomLevel = (_f = harp_datasource_protocol_1.getPropertyValue((_e = technique.textMinZoomLevel) !== null && _e !== void 0 ? _e : technique.minZoomLevel, this.m_env)) !== null && _f !== void 0 ? _f : undefined;\n        this.m_textMaxZoomLevel = (_h = harp_datasource_protocol_1.getPropertyValue((_g = technique.textMaxZoomLevel) !== null && _g !== void 0 ? _g : technique.maxZoomLevel, this.m_env)) !== null && _h !== void 0 ? _h : undefined;\n        this.m_technique = technique;\n        return this;\n    }\n    /**\n     * Sets an icon that will be used to create PoiInfos on subsequent calls to\n     * {@link PoiBuilder.build} until the next call to this method.\n     *\n     * @param imageTextureName - The name of the icon image. If undefined, the image defined by the\n     * technique set on the last call to {@link PoiBuilder.withTechnique} wil be used.\n     * @param shieldGroupIndex - Index to a shield group if the icon belongs to one.\n     * @return This builder.\n     */\n    withIcon(imageTextureName, shieldGroupIndex) {\n        if (imageTextureName !== undefined) {\n            this.m_imageTextureName = imageTextureName;\n        }\n        this.m_shieldGroupIndex = shieldGroupIndex;\n        return this;\n    }\n    /**\n     * Creates a {@link PoiInfo} for the given {@link TextElement}.\n     *\n     * @param textElement - The text element the poi info will be attached to.\n     * @return The created PoiInfo or undefined if no icon image was set for it.\n     */\n    build(textElement) {\n        var _a, _b, _c, _d, _e;\n        harp_utils_1.assert(this.m_technique !== undefined);\n        const technique = this.m_technique;\n        const env = this.m_env;\n        const imageTextureName = this.m_imageTextureName;\n        // The POI name to be used is taken from the data, since it will\n        // specify the name of the texture to use.\n        // The POI name in the technique may override the POI name from the\n        // data.\n        const poiName = technique.poiTable !== undefined ? (_a = technique.poiName) !== null && _a !== void 0 ? _a : imageTextureName : undefined;\n        if (imageTextureName !== undefined && poiName !== undefined) {\n            logger.warn(\"Possible duplicate POI icon definition via imageTextureName and poiTable!\");\n        }\n        if (imageTextureName === undefined && poiName === undefined) {\n            textElement.minZoomLevel = (_b = textElement.minZoomLevel) !== null && _b !== void 0 ? _b : this.m_textMinZoomLevel;\n            textElement.maxZoomLevel = (_c = textElement.maxZoomLevel) !== null && _c !== void 0 ? _c : this.m_textMaxZoomLevel;\n            return undefined;\n        }\n        const textIsOptional = technique.textIsOptional === true;\n        const iconIsOptional = technique.iconIsOptional === true;\n        const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);\n        const iconMayOverlap = (_d = technique.iconMayOverlap) !== null && _d !== void 0 ? _d : technique.textMayOverlap;\n        const iconReserveSpace = (_e = technique.iconReserveSpace) !== null && _e !== void 0 ? _e : technique.textReserveSpace;\n        const iconColorRaw = harp_datasource_protocol_1.getPropertyValue(technique.iconColor, env);\n        const iconColor = iconColorRaw !== null ? ColorCache_1.ColorCache.instance.getColor(iconColorRaw) : undefined;\n        const poiInfo = {\n            technique,\n            imageTextureName,\n            poiTableName: technique.poiTable,\n            poiName,\n            shieldGroupIndex: this.m_shieldGroupIndex,\n            textElement,\n            textIsOptional,\n            iconIsOptional,\n            renderTextDuringMovements,\n            mayOverlap: iconMayOverlap,\n            reserveSpace: iconReserveSpace,\n            featureId: textElement.featureId,\n            iconBrightness: technique.iconBrightness,\n            iconColor,\n            iconMinZoomLevel: this.m_iconMinZoomLevel,\n            iconMaxZoomLevel: this.m_iconMaxZoomLevel,\n            textMinZoomLevel: this.m_textMinZoomLevel,\n            textMaxZoomLevel: this.m_textMaxZoomLevel\n        };\n        return poiInfo;\n    }\n}\nexports.PoiBuilder = PoiBuilder;\n//# sourceMappingURL=PoiBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiBuilder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiManager.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoiManager = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextElementBuilder_1 = __webpack_require__(/*! ../text/TextElementBuilder */ \"./node_modules/@here/harp-mapview/lib/text/TextElementBuilder.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiManager\");\nfunction getImageTexture(poiGeometry, index = 0) {\n    if (poiGeometry.imageTextures) {\n        const textureNameIndex = poiGeometry.imageTextures[index];\n        if (textureNameIndex >= 0) {\n            harp_utils_1.assert(poiGeometry.imageTextures.length > index);\n            return poiGeometry.stringCatalog[textureNameIndex];\n        }\n    }\n    return undefined;\n}\nfunction getAttributes(poiGeometry, index = 0) {\n    return poiGeometry.objInfos ? poiGeometry.objInfos[index] : undefined;\n}\nfunction getPosition(positionAttribute, worldOffsetX, index = 0) {\n    const position = new THREE.Vector3().fromBufferAttribute(positionAttribute, index);\n    position.x += worldOffsetX;\n    return position;\n}\nfunction getText(poiGeometry, index = 0) {\n    var _a;\n    harp_utils_1.assert(poiGeometry.texts.length > index);\n    const stringIndex = poiGeometry.texts[index];\n    harp_utils_1.assert(poiGeometry.stringCatalog.length > stringIndex);\n    return (_a = poiGeometry.stringCatalog[stringIndex]) !== null && _a !== void 0 ? _a : \"\";\n}\n/**\n * POI manager class, responsible for loading the\n * {@link @here/harp-datasource-protocol#PoiGeometry} objects\n * from the {@link @here/harp-datasource-protocol#DecodedTile},\n * and preparing them for rendering.\n *\n * @remarks\n * Also loads and manages the texture atlases for the icons.\n */\nclass PoiManager {\n    /**\n     * The constructor of the `PoiManager`.\n     *\n     * @param mapView - The {@link MapView} instance that should display the POIs.\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        this.m_imageTextures = new Map();\n        this.m_poiShieldGroups = new Map();\n    }\n    /**\n     * Warn about a missing POI table name, but only once.\n     * @param poiTableName - POI mapping table name.\n     * @param poiTable - POI table instance.\n     */\n    static notifyMissingPoiTable(poiTableName, poiTable) {\n        if (poiTableName === undefined) {\n            poiTableName = \"undefined\";\n        }\n        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {\n            PoiManager.m_missingPoiTableName.set(poiTableName, true);\n            if (poiTable !== undefined && !poiTable.loadedOk) {\n                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);\n            }\n            else {\n                logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);\n            }\n        }\n    }\n    /**\n     * Warn about a missing POI name, but only once.\n     * @param poiName - name of POI.\n     * @param poiTableName - POI mapping table name.\n     */\n    static notifyMissingPoi(poiName, poiTableName) {\n        if (poiName === undefined) {\n            poiName = \"undefined\";\n        }\n        const key = `${poiTableName}[${poiName}]`;\n        if (PoiManager.m_missingPoiName.get(key) === undefined) {\n            PoiManager.m_missingPoiName.set(key, true);\n            logger.warn(`updatePoiFromPoiTable: ` +\n                `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);\n        }\n    }\n    /**\n     * Add all POIs from a decoded tile and store them as {@link TextElement}s in the {@link Tile}.\n     *\n     * Also handles LineMarkers, which is a recurring marker along a line (road).\n     *\n     * @param tile - Tile to add POIs to.\n     * @param decodedTile - DecodedTile containing the raw\n     *                      {@link @here/harp-datasource-protocol#PoiGeometry}\n     *                      objects describing the POIs.\n     */\n    addPois(tile, decodedTile) {\n        const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);\n        const worldOffsetX = tile.computeWorldOffsetX();\n        const mapView = tile.mapView;\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const intZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const poiBuilder = new TextElementBuilder_1.TextElementBuilder(intZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);\n        for (const poiGeometry of poiGeometries) {\n            harp_utils_1.assert(poiGeometry.technique !== undefined);\n            const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);\n            const technique = decodedTile.techniques[techniqueIndex];\n            if (technique._kindState === false ||\n                (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique))) {\n                continue;\n            }\n            if (technique.showOnMap === false) {\n                continue;\n            }\n            const positions = new THREE.BufferAttribute(new Float32Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);\n            poiBuilder.withTechnique(technique);\n            if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {\n                this.addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX);\n            }\n            else if (harp_datasource_protocol_1.isPoiTechnique(technique)) {\n                this.addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX);\n            }\n        }\n    }\n    /**\n     * Load the texture atlas that defines the segments of the texture that should be used for\n     * specific icons.\n     *\n     * @remarks\n     * Creates an {@link @here/harp-datasource-protocol#ImageTexture}\n     * for every element in the atlas, such that it can\n     * be addressed in the theme file.\n     *\n     * @param imageName - Name of the image from the theme (NOT the url!).\n     * @param atlas - URL of the JSON file defining the texture atlas.\n     * @param abortSignal - Signal to Abort the loading of the Atlas Image\n     */\n    async addTextureAtlas(imageName, atlas, abortSignal) {\n        const response = await fetch(atlas, { signal: abortSignal });\n        if (!response.ok) {\n            throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);\n        }\n        try {\n            const jsonAtlas = await response.json();\n            if (jsonAtlas === undefined) {\n                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);\n                return;\n            }\n            logger.debug(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);\n            for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {\n                const imageTextureDef = jsonAtlas[textureName];\n                const imageTexture = {\n                    name: textureName,\n                    image: imageName,\n                    xOffset: imageTextureDef.x,\n                    yOffset: imageTextureDef.y,\n                    width: imageTextureDef.width,\n                    height: imageTextureDef.height\n                };\n                this.addImageTexture(imageTexture);\n            }\n            this.mapView.update();\n        }\n        catch (error) {\n            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${error}`);\n        }\n    }\n    /**\n     * Add an {@link @here/harp-datasource-protocol#ImageTexture} such that it\n     * is available as a named entity for techniques in theme files.\n     *\n     * @param imageTexture - {@link @here/harp-datasource-protocol#ImageTexture}\n     *                       that should be available for POIs.\n     */\n    addImageTexture(imageTexture) {\n        if (imageTexture.name === undefined) {\n            logger.error(\"addImageTexture: Name required\", imageTexture);\n            return;\n        }\n        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {\n            logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);\n        }\n        this.m_imageTextures.set(imageTexture.name, imageTexture);\n    }\n    /**\n     * Return the {@link @here/harp-datasource-protocol#ImageTexture}\n     * registered under the specified name.\n     *\n     * @param name - Name of the {@link @here/harp-datasource-protocol#ImageTexture}.\n     */\n    getImageTexture(name) {\n        return this.m_imageTextures.get(name);\n    }\n    /**\n     * Update the {@link TextElement} with the information taken from the {@link PoiTable} which is\n     * referenced in the {@link PoiInfo} of the pointLabel.\n     *\n     * If the requested {@link PoiTable} is not available yet, the function returns `false`.\n     * If the {@link PoiTable} is not defined, or if the references POI has no entry in\n     * the {@link PoiTable}, no action is taken, and the function returns `false`.\n     *\n     * If the {@link PoiTable} has been processed, it returns `true`, indicating that this function\n     * doesn't have to be called again.\n     *\n     * @param pointLabel - The {@link TextElement} to update.\n     *\n     * @returns `true` if the {@link PoiTable} has been processed, and the\n     *          function does not have to be called again.\n     */\n    updatePoiFromPoiTable(pointLabel) {\n        var _a, _b, _c, _d, _e, _f;\n        const poiInfo = pointLabel.poiInfo;\n        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is\n        // not possible, such as table key is not defined.\n        if (!poiInfo || poiInfo.poiTableName === undefined || poiInfo.poiName === undefined) {\n            return true;\n        }\n        // Try to acquire PoiTable\n        const poiTableName = poiInfo.poiTableName;\n        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);\n        // Check if PoiTable is found, but its still loading.\n        if (poiTable && poiTable.isLoading) {\n            // The PoiTable is still loading, we have to try again.\n            return false;\n        }\n        // Remove poiTableName to mark this POI as processed.\n        poiInfo.poiTableName = undefined;\n        // PoiTable not found or can not be loaded.\n        if (!poiTable || !poiTable.loadedOk) {\n            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);\n            return true;\n        }\n        // Try to acquire PoiTableEntry.\n        const poiName = poiInfo.poiName;\n        const poiTableEntry = poiTable.getEntry(poiName);\n        if (!poiTableEntry) {\n            PoiManager.notifyMissingPoi(poiName, poiTableName);\n            return true;\n        }\n        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {\n            poiInfo.imageTextureName = harp_datasource_protocol_1.composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);\n        }\n        pointLabel.visible = (_a = poiTableEntry.visible) !== null && _a !== void 0 ? _a : pointLabel.visible;\n        pointLabel.priority = (_b = poiTableEntry.priority) !== null && _b !== void 0 ? _b : pointLabel.priority;\n        poiInfo.iconMinZoomLevel = (_c = poiTableEntry.iconMinLevel) !== null && _c !== void 0 ? _c : poiInfo.iconMinZoomLevel;\n        poiInfo.iconMaxZoomLevel = (_d = poiTableEntry.iconMaxLevel) !== null && _d !== void 0 ? _d : poiInfo.iconMaxZoomLevel;\n        poiInfo.textMinZoomLevel = (_e = poiTableEntry.textMinLevel) !== null && _e !== void 0 ? _e : poiInfo.textMinZoomLevel;\n        poiInfo.textMaxZoomLevel = (_f = poiTableEntry.textMaxLevel) !== null && _f !== void 0 ? _f : poiInfo.textMaxZoomLevel;\n        TextElementBuilder_1.TextElementBuilder.alignZoomLevelRanges(pointLabel);\n        return true;\n    }\n    /**\n     * Clear internal state. Applicable when switching themes.\n     */\n    clear() {\n        this.m_imageTextures.clear();\n        this.m_poiShieldGroups.clear();\n    }\n    /**\n     * Add the LineMarker as a POI with multiple positions sharing the same `shieldGroupIndex`.\n     */\n    addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {\n        const text = getText(poiGeometry);\n        const imageTextureName = getImageTexture(poiGeometry);\n        // let the combined image texture name (name of image in atlas, not the URL) and\n        // text of the shield be the group key, at worst scenario it may be: \"undefined-\"\n        const groupKey = imageTextureName + \"-\" + text;\n        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);\n        if (shieldGroupIndex === undefined) {\n            shieldGroupIndex = this.m_poiShieldGroups.size;\n            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);\n        }\n        const positionArray = [];\n        for (let i = 0; i < positions.count; i += 3) {\n            positionArray.push(getPosition(positions, worldOffsetX, i));\n        }\n        const textElement = poiBuilder\n            .withIcon(imageTextureName, shieldGroupIndex)\n            .build(text, positionArray, tile.offset, getAttributes(poiGeometry));\n        tile.addTextElement(textElement);\n    }\n    /**\n     * Create and add POI {@link TextElement}s to tile with a series of positions.\n     */\n    addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {\n        var _a, _b;\n        for (let i = 0; i < positions.count; ++i) {\n            const offsetDirection = (_b = (_a = poiGeometry.offsetDirections) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : 0;\n            const textElement = poiBuilder\n                .withIcon(getImageTexture(poiGeometry, i))\n                .build(getText(poiGeometry, i), getPosition(positions, worldOffsetX, i), tile.offset, getAttributes(poiGeometry, i), undefined, offsetDirection);\n            tile.addTextElement(textElement);\n        }\n    }\n}\nexports.PoiManager = PoiManager;\n// Keep track of the missing POI table names, but only warn once.\nPoiManager.m_missingPoiTableName = new Map();\nPoiManager.m_missingPoiName = new Map();\n//# sourceMappingURL=PoiManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoiRenderer = exports.PoiBatchRegistry = exports.PoiBuffer = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MipMapGenerator_1 = __webpack_require__(/*! ../image/MipMapGenerator */ \"./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js\");\nconst BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ \"./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiRenderer\");\n/**\n * Neutral color used as `vColor` attribute of [[IconMaterial]] if no `iconColor` color was\n * specified.\n */\nconst neutralColor = new THREE.Color(1, 1, 1);\n/**\n * Temporary color instance used by `addPoi` to pass color derived from `iconBrightness` property.\n */\nconst tmpIconColor = new THREE.Color();\n/**\n * @internal\n * Buffer for POIs sharing same material and render order, renderable in a single draw call\n * (WebGL limits apply, see {@link BoxBuffer}).\n */\nclass PoiBuffer {\n    /**\n     * Creates a `PoiBuffer`\n     * @param buffer -\n     * @param layer - The {@link TextCanvas} layer used to render the POIs.\n     */\n    constructor(buffer, layer, m_onDispose) {\n        this.buffer = buffer;\n        this.layer = layer;\n        this.m_onDispose = m_onDispose;\n        this.m_refCount = 0;\n    }\n    /**\n     * Increases this `PoiBuffer`'s reference count.\n     * @returns this `PoiBuffer`.\n     */\n    increaseRefCount() {\n        ++this.m_refCount;\n        return this;\n    }\n    /**\n     * Decreases this `PoiBuffer`'s reference count. All resources will be disposed when the\n     * reference count reaches 0.\n     * @returns this `PoiBuffer`.\n     */\n    decreaseRefCount() {\n        harp_utils_1.assert(this.m_refCount > 0);\n        if (--this.m_refCount === 0) {\n            this.dispose();\n        }\n        return this;\n    }\n    dispose() {\n        this.layer.scene.remove(this.buffer.mesh);\n        this.buffer.dispose();\n        this.m_onDispose();\n    }\n}\nexports.PoiBuffer = PoiBuffer;\n/**\n * @internal\n *\n * The `PoiBatch` contains the geometry and the material for all POIs that share the same icon image\n * ({@link @here/harp-datasource-protocol#ImageTexture}).\n *\n * There is a `PoiBatch` for every icon in a texture atlas, since the size of the icon in the atlas\n * as well as the texture coordinates are specified in the `PoiBatch`.\n */\nclass PoiBatch {\n    /**\n     * Create the `PoiBatch`.\n     *\n     * @param m_rendererCapabilities - The {@link THREE.WebGLCapabilities} used for material\n     * creation.\n     * @param imageItem - The icon that will have his material shared.\n     * @param m_onDispose - Callback executed when the `PoiBatch` is disposed.\n     */\n    constructor(m_rendererCapabilities, imageItem, m_onDispose) {\n        this.m_rendererCapabilities = m_rendererCapabilities;\n        this.imageItem = imageItem;\n        this.m_onDispose = m_onDispose;\n        // Texture images should be generated with premultiplied alpha\n        const premultipliedAlpha = true;\n        const texture = new THREE.Texture(this.imageItem.image, THREE.UVMapping, undefined, undefined, PoiBatch.trilinear ? THREE.LinearFilter : THREE.LinearFilter, PoiBatch.trilinear ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter, THREE.RGBAFormat);\n        if (PoiBatch.trilinear && this.imageItem.mipMaps) {\n            // Generate mipmaps for distance scaling of icon\n            texture.mipmaps = this.imageItem.mipMaps;\n            texture.image = texture.mipmaps[0];\n        }\n        texture.flipY = false;\n        texture.premultiplyAlpha = premultipliedAlpha;\n        texture.needsUpdate = true;\n        this.m_material = new harp_materials_1.IconMaterial({\n            rendererCapabilities: this.m_rendererCapabilities,\n            map: texture\n        });\n        this.m_poiBuffers = new Map();\n    }\n    /**\n     * Gets the {@link PoiBuffer} for a given layer, creating it if necessary.\n     * @param layer - The {@link PoiLayer} to be used.\n     * @returns The {@link PoiBuffer}.\n     */\n    getBuffer(layer) {\n        let poiBuffer = this.m_poiBuffers.get(layer.id);\n        if (poiBuffer) {\n            return poiBuffer.increaseRefCount();\n        }\n        const boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, layer.id);\n        const mesh = boxBuffer.mesh;\n        mesh.frustumCulled = false;\n        layer.scene.add(mesh);\n        poiBuffer = new PoiBuffer(boxBuffer, layer, () => {\n            this.disposeBuffer(layer.id);\n        });\n        this.m_poiBuffers.set(layer.id, poiBuffer);\n        return poiBuffer.increaseRefCount();\n    }\n    /**\n     * Clean the `PoiBatch`, remove all icon boxes. Called before starting a new frame.\n     */\n    reset() {\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.reset();\n        }\n    }\n    /**\n     * Update the geometry with all the added boxes during the frame.\n     */\n    update() {\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.updateBufferGeometry();\n        }\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     * @param image - Image to test if the pixel is transparent\n     */\n    pickBoxes(screenPosition, pickCallback, image) {\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.pickBoxes(screenPosition, pickCallback, image);\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiBatch`.\n     *\n     * @param info - The info object to increment with the values from this `PoiBatch`.\n     */\n    updateMemoryUsage(info) {\n        if (this.imageItem.image !== undefined) {\n            const imageBytes = this.imageItem.image.width * this.imageItem.image.height * 4;\n            info.heapSize += imageBytes;\n            info.gpuSize += imageBytes;\n        }\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.updateMemoryUsage(info);\n        }\n    }\n    dispose() {\n        this.m_poiBuffers.clear();\n        this.m_material.map.dispose();\n        this.m_material.dispose();\n        this.m_onDispose();\n    }\n    disposeBuffer(renderOrder) {\n        harp_utils_1.assert(this.m_poiBuffers.size > 0);\n        this.m_poiBuffers.delete(renderOrder);\n        if (this.m_poiBuffers.size === 0) {\n            this.dispose();\n        }\n    }\n}\n// Enable trilinear filtering to reduce flickering due to distance scaling\nPoiBatch.trilinear = true;\n/**\n * @internal\n * Contains all [[PoiBatch]]es. Selects (and initializes) the correct batch for a POI.\n */\nclass PoiBatchRegistry {\n    /**\n     * Create the `PoiBatchRegistry`.\n     *\n     * @param m_rendererCapabilities - The {@link THREE.WebGLCapabilities} to be used.\n     */\n    constructor(m_rendererCapabilities) {\n        this.m_rendererCapabilities = m_rendererCapabilities;\n        this.m_batchMap = new Map();\n    }\n    /**\n     * Register the POI and prepare the [[PoiBatch]] for the POI at first usage.\n     *\n     * @param poiInfo - Describes the POI icon.\n     * @param layer - The {@link PoiLayer} to render to.\n     */\n    registerPoi(poiInfo, layer) {\n        var _a;\n        const { imageItem, imageTexture } = poiInfo;\n        if (!imageItem) {\n            // No image -> invisible -> ignore\n            poiInfo.isValid = false;\n            return undefined;\n        }\n        // There is a batch for every ImageDefinition, which could be a texture atlas with many\n        // ImageTextures in it. If the imageTexture is not set, imageTextureName has the actual\n        // image name.\n        harp_utils_1.assert(poiInfo.imageTextureName !== undefined);\n        const batchKey = (_a = imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.image) !== null && _a !== void 0 ? _a : poiInfo.imageTextureName;\n        let batch = this.m_batchMap.get(batchKey);\n        if (batch === undefined) {\n            batch = new PoiBatch(this.m_rendererCapabilities, imageItem, () => {\n                this.deleteBatch(batchKey);\n            });\n            this.m_batchMap.set(batchKey, batch);\n        }\n        return batch.getBuffer(layer);\n    }\n    /**\n     * Render a POI image at the specified location.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenBox - Box to render icon into in 2D coordinates.\n     * @param viewDistance - Box's distance to camera.\n     * @param opacity - Opacity of icon to allow fade in/out.\n     */\n    addPoi(poiInfo, screenBox, viewDistance, opacity) {\n        if (poiInfo.isValid === false || !poiInfo.buffer) {\n            logger.warn(\"PoiBatchRegistry: trying to add poiInfo without buffer prepared: \", poiInfo.poiName);\n            return;\n        }\n        harp_utils_1.assert(poiInfo.uvBox !== undefined);\n        let color;\n        if (poiInfo.iconBrightness !== undefined) {\n            color = tmpIconColor.setScalar(poiInfo.iconBrightness);\n            if (poiInfo.iconColor !== undefined) {\n                color = tmpIconColor.multiply(poiInfo.iconColor);\n            }\n        }\n        else if (poiInfo.iconColor !== undefined) {\n            color = poiInfo.iconColor;\n        }\n        else {\n            color = neutralColor;\n        }\n        poiInfo.buffer.buffer.addBox(screenBox, poiInfo.uvBox, color, opacity, viewDistance, poiInfo.textElement);\n    }\n    /**\n     * Reset all batches, removing all content from the [[PoiBatch]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset() {\n        for (const batch of this.m_batchMap.values()) {\n            batch.reset();\n        }\n    }\n    /**\n     * Update the geometry of all [[PoiBatch]]es. Called before rendering.\n     */\n    update() {\n        for (const batch of this.m_batchMap.values()) {\n            batch.update();\n        }\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link PoiInfo}s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickTextElements(screenPosition, pickCallback) {\n        for (const batch of this.m_batchMap.values()) {\n            batch.pickBoxes(screenPosition, pickCallback, batch.imageItem.image);\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiBatchRegistry`.\n     *\n     * @param info - The info object to increment with the values from this `PoiBatchRegistry`.\n     */\n    updateMemoryUsage(info) {\n        for (const batch of this.m_batchMap.values()) {\n            batch.updateMemoryUsage(info);\n        }\n    }\n    deleteBatch(batchKey) {\n        this.m_batchMap.delete(batchKey);\n    }\n}\nexports.PoiBatchRegistry = PoiBatchRegistry;\n// keep track of the missing textures, but only warn once\nconst missingTextureName = new Map();\nfunction findImageItem(poiInfo, imageCaches, imageTexture) {\n    var _a;\n    harp_utils_1.assert(poiInfo.imageTextureName !== undefined);\n    const imageTextureName = poiInfo.imageTextureName;\n    let imageItem;\n    for (const imageCache of imageCaches) {\n        imageItem = imageTexture\n            ? imageCache.findImageByName(imageTexture.image)\n            : imageCache.findImageByName(imageTextureName);\n        if (imageItem) {\n            break;\n        }\n    }\n    if (!imageItem) {\n        logger.error(`init: No imageItem found with name\n            '${(_a = imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.image) !== null && _a !== void 0 ? _a : imageTextureName}'`);\n        poiInfo.isValid = false;\n        if (missingTextureName.get(imageTextureName) === undefined) {\n            missingTextureName.set(imageTextureName, true);\n            logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);\n        }\n    }\n    return imageItem;\n}\n/**\n * @internal\n * Manage POI rendering. Uses a [[PoiBatchRegistry]] to actually create the geometry that is being\n * rendered.\n */\nclass PoiRenderer {\n    /**\n     * Create the `PoiRenderer` for the specified {@link MapView}.\n     *\n     * @param m_renderer - The {@link THREE.WebGLRenderer} to be rendered to.\n     * @param m_poiManager - The {@link PoiManager} to be used.\n     * @param m_imageCaches - The {@link ImageCache}s to look for loaded images.\n     */\n    constructor(m_renderer, m_poiManager, m_imageCaches) {\n        this.m_renderer = m_renderer;\n        this.m_poiManager = m_poiManager;\n        this.m_imageCaches = m_imageCaches;\n        // temporary variable to save allocations\n        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();\n        this.m_layers = [];\n        this.m_poiBatchRegistry = new PoiBatchRegistry(this.renderer.capabilities);\n    }\n    /**\n     * Compute screen box for icon. It is required that `prepareRender` has been successfully called\n     * before `computeScreenBox` may be called.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition - Position on screen (2D).\n     * @param scale - Scale to apply to icon.\n     * @param env - Current zoom level.\n     * @param screenBox - Box that will be used to store the result.\n     * @returns The computed screen box for the icon.\n     */\n    static computeIconScreenBox(poiInfo, screenPosition, scale, env, \n    /* out */ screenBox = new harp_utils_1.Math2D.Box()) {\n        harp_utils_1.assert(poiInfo.buffer !== undefined);\n        const width = poiInfo.computedWidth * scale;\n        const height = poiInfo.computedHeight * scale;\n        const technique = poiInfo.technique;\n        const iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);\n        const iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);\n        const centerX = screenPosition.x + (typeof iconXOffset === \"number\" ? iconXOffset : 0) * scale;\n        const centerY = screenPosition.y + (typeof iconYOffset === \"number\" ? iconYOffset : 0) * scale;\n        screenBox.x = centerX - width / 2;\n        screenBox.y = centerY - height / 2;\n        screenBox.w = width;\n        screenBox.h = height;\n        return screenBox;\n    }\n    get renderer() {\n        return this.m_renderer;\n    }\n    /**\n     * Prepare the POI for rendering, and determine which {@link PoiBuffer} should be used. If a\n     * {@link PoiBuffer} is assigned, the POI is ready to be rendered.\n     *\n     * @param pointLabel - TextElement with PoiInfo for rendering the POI icon.\n     * @param env - TODO! The current zoomLevel level of {@link MapView}\n     *\n     * @returns `True` if the space is not already allocated by another object (text label or POI)\n     */\n    prepareRender(pointLabel, env) {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined) {\n            return false;\n        }\n        if (poiInfo.buffer === undefined) {\n            this.preparePoi(pointLabel, env);\n        }\n        return poiInfo.buffer !== undefined;\n    }\n    /**\n     * Reset all batches, removing all content from the [[PoiBatchRegistry]]. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset() {\n        this.m_poiBatchRegistry.reset();\n    }\n    /**\n     * Add the icon. Icon will only be added if opacity > 0, otherwise only its space will be\n     * allocated.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition - Position on screen (2D):\n     * @param screenCollisions - Object handling the collision checks for screen-aligned 2D boxes.\n     * @param viewDistance - Box's distance to camera.\n     * @param scale - Scaling factor to apply to text and icon.\n     * @param allocateScreenSpace - If `true` screen space will be allocated for the icon.\n     * @param opacity - Opacity of icon to allow fade in/out.\n     * @returns - `true` if icon has been actually rendered, `false` otherwise.\n     */\n    addPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {\n        harp_utils_1.assert(poiInfo.buffer !== undefined);\n        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);\n        if (allocateScreenSpace) {\n            screenCollisions.allocate(this.m_tempScreenBox);\n        }\n        if (opacity > 0) {\n            if (!poiInfo.buffer) {\n                this.preparePoi(poiInfo.textElement, env);\n            }\n            this.m_poiBatchRegistry.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);\n        }\n    }\n    /**\n     * Update the geometry of all [[PoiBatch]]es. Called before rendering.\n     */\n    update() {\n        this.m_poiBatchRegistry.update();\n    }\n    /**\n     * @internal\n     *\n     * Adds a layer to the PoiRenderer\n     * @param layerId\n     */\n    addLayer(layerId) {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                scene: new THREE.Scene()\n            };\n            this.m_layers.push(result);\n            this.m_layers.sort((a, b) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n    /**\n     * Retrieves a specific `Poi` rendering layer.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Selected {@link PoiLayer}\n     */\n    getLayer(layerId) {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n    /**\n     * @internal\n     *\n     * Returns all {@link PoiLayer}s of this {@link PoiRenderer}\n     */\n    get layers() {\n        return this.m_layers;\n    }\n    /**\n     * Renders the content of this `PoiRenderer`.\n     *\n     * @param camera - Orthographic camera.\n     * @param layer - The Layer to be rendered.\n     */\n    render(camera, layer) {\n        this.m_renderer.render(layer.scene, camera);\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link PoiInfo}s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickTextElements(screenPosition, pickCallback) {\n        this.m_poiBatchRegistry.pickTextElements(screenPosition, pickCallback);\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.\n     *\n     * @param info - The info object to increment with the values from this `PoiRenderer`.\n     */\n    getMemoryUsage(info) {\n        this.m_poiBatchRegistry.updateMemoryUsage(info);\n    }\n    /**\n     * Register the POI at the [[PoiBatchRegistry]] which may require some setup, for example\n     * loading of the actual image.\n     */\n    preparePoi(pointLabel, env) {\n        const poiInfo = pointLabel.poiInfo;\n        if (!poiInfo || !pointLabel.visible) {\n            return;\n        }\n        if (poiInfo.buffer !== undefined || poiInfo.isValid === false) {\n            // Already set up, nothing to be done here.\n            return;\n        }\n        if (poiInfo.poiTableName !== undefined) {\n            if (this.m_poiManager.updatePoiFromPoiTable(pointLabel)) {\n                if (!pointLabel.visible) {\n                    // PoiTable set this POI to not visible.\n                    return;\n                }\n            }\n            else {\n                // PoiTable has not been loaded, but is required to determine visibility.\n                return;\n            }\n        }\n        const imageTextureName = poiInfo.imageTextureName;\n        if (imageTextureName === undefined) {\n            poiInfo.isValid = false;\n            return;\n        }\n        const imageTexture = this.m_poiManager.getImageTexture(imageTextureName);\n        const imageItem = findImageItem(poiInfo, this.m_imageCaches, imageTexture);\n        if (!imageItem) {\n            return;\n        }\n        if (imageItem.loaded) {\n            this.setupPoiInfo(poiInfo, imageItem, env, imageTexture);\n            return;\n        }\n        if (imageItem.loading) {\n            // already being loaded, will be rendered once available\n            return;\n        }\n        imageItem\n            .loadImage()\n            .then(loadedImageItem => {\n            // Skip setup if image was not loaded (cancelled).\n            if (loadedImageItem === null || loadedImageItem === void 0 ? void 0 : loadedImageItem.image) {\n                this.setupPoiInfo(poiInfo, loadedImageItem, env, imageTexture);\n            }\n        })\n            .catch(error => {\n            logger.error(`preparePoi: Failed to load imageItem: '${imageItem.url}`, error);\n            poiInfo.isValid = false;\n        });\n    }\n    /**\n     * Setup texture and material for the batch.\n     *\n     * @param poiInfo - {@link PoiInfo} to initialize.\n     * @param imageTexture - Shared {@link @here/harp-datasource-protocol#ImageTexture},\n     *                       defines used area in atlas.\n     * @param imageItem - Shared {@link ImageItem}, contains cached image for texture.\n     * @param env - The current zoom level of {@link MapView}\n     */\n    setupPoiInfo(poiInfo, imageItem, env, imageTexture) {\n        harp_utils_1.assert(poiInfo.uvBox === undefined);\n        if (!imageItem.image) {\n            logger.error(\"setupPoiInfo: No imageItem/imageData found\");\n            poiInfo.isValid = false;\n            return;\n        }\n        const technique = poiInfo.technique;\n        const imageWidth = imageItem.image.width;\n        const imageHeight = imageItem.image.height;\n        const paddedSize = MipMapGenerator_1.MipMapGenerator.getPaddedSize(imageWidth, imageHeight);\n        const trilinearFiltering = PoiBatch.trilinear && imageItem.mipMaps;\n        const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;\n        const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;\n        const iconWidth = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.width) !== undefined ? imageTexture.width : imageWidth;\n        const iconHeight = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.height) !== undefined ? imageTexture.height : imageHeight;\n        const width = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.width) !== undefined ? imageTexture.width : imageWidth;\n        const height = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.height) !== undefined ? imageTexture.height : imageHeight;\n        const xOffset = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.xOffset) !== undefined ? imageTexture.xOffset : 0;\n        const yOffset = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.yOffset) !== undefined ? imageTexture.yOffset : 0;\n        const minS = xOffset / paddedImageWidth;\n        const maxS = (xOffset + width) / paddedImageWidth;\n        const minT = yOffset / paddedImageHeight;\n        const maxT = (yOffset + height) / paddedImageHeight;\n        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;\n        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;\n        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.\n        const screenWidth = harp_datasource_protocol_1.getPropertyValue(technique.screenWidth, env);\n        if (screenWidth !== undefined && screenWidth !== null) {\n            iconScaleV = iconScaleH = screenWidth / iconWidth;\n        }\n        const screenHeight = harp_datasource_protocol_1.getPropertyValue(technique.screenHeight, env);\n        if (screenHeight !== undefined && screenHeight !== null) {\n            iconScaleV = screenHeight / iconHeight;\n            if (screenWidth !== undefined) {\n                iconScaleH = iconScaleV;\n            }\n        }\n        // compute stored values in imageTexture\n        poiInfo.computedWidth = iconWidth * iconScaleH;\n        poiInfo.computedHeight = iconHeight * iconScaleV;\n        poiInfo.uvBox = {\n            s0: minS,\n            t0: maxT,\n            s1: maxS,\n            t1: minT\n        };\n        poiInfo.imageItem = imageItem;\n        poiInfo.imageTexture = imageTexture;\n        poiInfo.buffer = this.m_poiBatchRegistry.registerPoi(poiInfo, this.addLayer(poiInfo.renderOrder));\n        poiInfo.isValid = true;\n    }\n}\nexports.PoiRenderer = PoiRenderer;\n//# sourceMappingURL=PoiRenderer.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoiTableManager = exports.PoiTable = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiTable\");\n/**\n * Class to store and maintain individual POI information for the {@link PoiTable}.\n */\nclass PoiTableEntry {\n    /**\n     * Verify that the JSON description of the POI table entry is valid.\n     *\n     * @param jsonEntry - JSON description of the POI table entry.\n     *\n     * @returns `true` if the `jsonEntry` is valid.\n     */\n    static verifyJSON(jsonEntry) {\n        let isOK = typeof jsonEntry.name === \"string\" &&\n            jsonEntry.name.length > 0 &&\n            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&\n            (jsonEntry.stackMode === undefined ||\n                jsonEntry.stackMode === \"yes\" ||\n                jsonEntry.stackMode === \"no\" ||\n                jsonEntry.stackMode === \"parent\") &&\n            (jsonEntry.visible === undefined || typeof jsonEntry.visible === \"boolean\") &&\n            (jsonEntry.priority === undefined || typeof jsonEntry.priority === \"number\") &&\n            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === \"number\") &&\n            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === \"number\") &&\n            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === \"number\") &&\n            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === \"number\");\n        if (isOK && jsonEntry.altNames !== undefined) {\n            const altNames = jsonEntry.altNames;\n            // eslint-disable-next-line @typescript-eslint/no-for-in-array\n            for (const str in altNames) {\n                if (typeof str !== \"string\") {\n                    isOK = false;\n                    break;\n                }\n            }\n        }\n        return isOK;\n    }\n    /**\n     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has\n     * been verified with [[PoiTableEntry#verifyJSON]].\n     *\n     * @param jsonEntry - JSON description of the POI table entry. Expected to have been verified\n     *                    with [[PoiTableEntry#verifyJSON]].\n     */\n    setup(jsonEntry) {\n        this.name = jsonEntry.name;\n        this.altNames = jsonEntry.altNames;\n        this.iconName = jsonEntry.iconName;\n        this.visible = jsonEntry.visible;\n        this.priority = jsonEntry.priority;\n        this.iconMinLevel = jsonEntry.iconMinLevel;\n        this.iconMaxLevel = jsonEntry.iconMaxLevel;\n        this.textMinLevel = jsonEntry.textMinLevel;\n        this.textMaxLevel = jsonEntry.textMaxLevel;\n        switch (jsonEntry.stackMode) {\n            case \"yes\":\n                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;\n                break;\n            case \"no\":\n                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;\n                break;\n            case \"parent\":\n                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;\n                break;\n            default:\n        }\n    }\n}\n/**\n * The `PoiTable` stores individual information for each POI type.\n *\n * @remarks\n * If a {@link TextElement} has a\n * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the\n * TextElement and its icon are read from the PoiTable.\n *\n * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the\n * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key\n * to look up the POIs in the {@link PoiTable}.\n *\n * On the side of the {@link PoiTable}, the key to look up the PoiTableEntry is either the property\n * \"name\" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names\n * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to\n * `true`, the `altNames` will be used.\n */\nclass PoiTable {\n    /**\n     * Creates an instance of PoiTable.\n     *\n     * @param {string} name Name of the `PoiTable`. Must be unique.\n     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`\n     *          to find a [[PoiTableEntry]] in the table.\n     */\n    constructor(name, useAltNamesForKey) {\n        this.name = name;\n        this.useAltNamesForKey = useAltNamesForKey;\n        /**\n         * Stores the list of [[PoiTableEntry]]s.\n         */\n        this.poiList = new Array();\n        /**\n         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for\n         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of\n         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.\n         * Value assigned to key it is the index to [[poiList]] array which contain actual\n         * [[PoiTabelEntry]] objects.\n         */\n        this.poiDict = new Map();\n        this.m_isLoading = false;\n        this.m_loadedOk = undefined;\n    }\n    /**\n     * Returns `true` if the table is currently being loaded, `false` otherwise.\n     *\n     * @readonly\n     */\n    get isLoading() {\n        return this.m_isLoading;\n    }\n    /**\n     * Returns `true` if the table has been loaded correctly, `false` otherwise.\n     *\n     * @readonly\n     */\n    get loadedOk() {\n        return this.m_loadedOk === true;\n    }\n    /**\n     * Gets [[PoiTableEntry]] for poi name specified.\n     *\n     * @param poiName - poi name or one of its alternative names if [[useAltNamesForKey]] is\n     * set to `true`.\n     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.\n     */\n    getEntry(poiName) {\n        const entryIdx = this.poiDict.get(poiName);\n        if (entryIdx !== undefined) {\n            if (entryIdx < this.poiList.length) {\n                return this.poiList[entryIdx];\n            }\n            else {\n                throw new Error(\"Poi table entry index out of stored list!\");\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Start to load the PoiTable from the specified URL. Can only be called once per table.\n     *\n     * @param {string} poiTableUrl URL that points to the JSON file.\n     * @param {AbortSignal} abortSignal Signal to abort the loading of the poi table file\n     *\n     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and\n     *          the `PoiTable` has been set up.\n     */\n    async load(poiTableUrl, abortSignal) {\n        if (this.m_loadedOk !== undefined) {\n            // Only load once.\n            return true;\n        }\n        this.m_loadedOk = false;\n        const response = await fetch(poiTableUrl, { signal: abortSignal });\n        if (!response.ok) {\n            throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);\n        }\n        const jsonPoiTable = (await response.json());\n        if (jsonPoiTable === undefined) {\n            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);\n            return true;\n        }\n        this.startLoading();\n        try {\n            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);\n            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {\n                for (const tableEntry of jsonPoiTable.poiList) {\n                    if (PoiTableEntry.verifyJSON(tableEntry)) {\n                        const newPoiEntry = new PoiTableEntry();\n                        newPoiEntry.setup(tableEntry);\n                        const entryIdx = this.poiList.push(newPoiEntry) - 1;\n                        if (!this.useAltNamesForKey) {\n                            // Use actual name of entry as the key\n                            if (newPoiEntry.name === undefined) {\n                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                    `. No name set in entry: ${tableEntry}.`);\n                            }\n                            else {\n                                this.poiDict.set(newPoiEntry.name, entryIdx);\n                            }\n                        }\n                        else {\n                            if (newPoiEntry.altNames !== undefined &&\n                                newPoiEntry.altNames.length > 0) {\n                                // Use the list of alternative names as keys.\n                                for (const altName of newPoiEntry.altNames) {\n                                    this.poiDict.set(altName, entryIdx);\n                                }\n                            }\n                            else {\n                                logger.debug(`load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                    `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);\n                            }\n                        }\n                    }\n                    else {\n                        logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);\n                    }\n                }\n            }\n            this.m_loadedOk = true;\n            this.finishedLoading();\n        }\n        catch (ex) {\n            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);\n            this.m_loadedOk = false;\n            this.finishedLoading();\n            return false;\n        }\n        return true;\n    }\n    startLoading() {\n        this.m_isLoading = true;\n    }\n    finishedLoading() {\n        this.m_isLoading = false;\n    }\n}\nexports.PoiTable = PoiTable;\n/**\n * The `PoiTableManager` manages the list of [[PoiTables]] that\n * can be defined in the {@link @here/harp-datasource-protocol#Theme} sfile.\n */\nclass PoiTableManager {\n    /**\n     * Creates an instance of PoiTableManager.\n     * @param {MapView} mapView Owning {@link MapView}.\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        this.m_isLoading = false;\n        this.m_poiTables = new Map();\n        this.m_abortControllers = new Map();\n    }\n    /**\n     * Load the {@link PoiTable}s that are stored in the {@link MapView}s\n     * {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @remarks\n     * Note that duplicate names of {@link PoiTable}s in the\n     * {@link @here/harp-datasource-protocol#Theme} will lead to inaccessible {@link PoiTable}s.\n     *\n     * @param poiTables - {@link @here/harp-datasource-protocol#PoiTableRef[]}\n     *                containing all {@link PoiTable}s to load.\n     *\n     * @returns Resolved once all the {@link PoiTable}s in\n     *          the {@link @here/harp-datasource-protocol#Theme} have been loaded.\n     */\n    async loadPoiTables(poiTables) {\n        const finished = new Promise(resolve => {\n            this.clear();\n            // Add the POI tables defined in the theme.\n            if (poiTables !== undefined) {\n                this.startLoading();\n                // Gather promises to signal the success of having loaded them all\n                const loadPromises = new Array();\n                poiTables.forEach((poiTableRef) => {\n                    var _a;\n                    if (poiTableRef !== undefined &&\n                        poiTableRef.name !== undefined &&\n                        typeof poiTableRef.name === \"string\") {\n                        const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);\n                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === \"string\") {\n                            this.addTable(poiTable);\n                            this.m_abortControllers.set(poiTableRef.name, new AbortController());\n                            loadPromises.push(poiTable.load(poiTableRef.url, (_a = this.m_abortControllers.get(poiTableRef.name)) === null || _a === void 0 ? void 0 : _a.signal));\n                        }\n                        else {\n                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);\n                        }\n                    }\n                    else {\n                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);\n                    }\n                });\n                if (loadPromises.length > 0) {\n                    Promise.all(loadPromises).finally(() => {\n                        this.finishLoading();\n                        resolve();\n                    });\n                }\n                else {\n                    this.finishLoading();\n                    resolve();\n                }\n            }\n            else {\n                this.finishLoading();\n                resolve();\n            }\n        });\n        return finished;\n    }\n    /**\n     * Clear the list of {@link PoiTable}s.\n     */\n    clear() {\n        this.m_poiTables = new Map();\n        this.m_abortControllers.forEach((abortController, name) => {\n            abortController.abort();\n            this.m_abortControllers.delete(name);\n        });\n    }\n    /**\n     * Return the map of {@link PoiTable}s.\n     */\n    get poiTables() {\n        return this.m_poiTables;\n    }\n    /**\n     * Manually add a {@link PoiTable}. Normally, the [[PoiTables]]s\n     * are specified in the {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @remarks\n     * Ensure that the name is unique.\n     */\n    addTable(poiTable) {\n        this.m_poiTables.set(poiTable.name, poiTable);\n    }\n    /**\n     * Retrieve a {@link PoiTable} by name.\n     *\n     * @param {(string | undefined)} poiTableName Name of the {@link PoiTable}.\n     *\n     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`\n     *          otherwise.\n     */\n    getPoiTable(poiTableName) {\n        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);\n    }\n    /**\n     * Return `true` if the {@link PoiTable}s have finished loading.\n     *\n     * @readonly\n     */\n    get finishedLoading() {\n        return !this.m_isLoading;\n    }\n    startLoading() {\n        this.m_isLoading = true;\n    }\n    finishLoading() {\n        this.m_isLoading = false;\n    }\n}\nexports.PoiTableManager = PoiTableManager;\n//# sourceMappingURL=PoiTableManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadFontCatalog = void 0;\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"FontCatalogLoader\");\nasync function loadFontCatalog(fontCatalogConfig, onSuccess, onError) {\n    return await harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)\n        .then(onSuccess.bind(undefined, fontCatalogConfig.name))\n        .catch((error) => {\n        logger.error(\"Failed to load FontCatalog: \", fontCatalogConfig.name, error);\n        if (onError) {\n            onError(error);\n        }\n    });\n}\nexports.loadFontCatalog = loadFontCatalog;\n//# sourceMappingURL=FontCatalogLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/LayoutState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/LayoutState.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LayoutState = void 0;\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\n/**\n * Layout state of the text part of the `TextElement`.\n *\n * Used mainly for multi-anchor placement algorithm.\n * @hidden\n */\nclass LayoutState {\n    constructor(placement) {\n        this.m_hAlign = harp_text_canvas_1.DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;\n        this.m_vAlign = harp_text_canvas_1.DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;\n        this.textPlacement = placement;\n    }\n    /**\n     * Set layout based on theme style defined and optional text placement.\n     *\n     * @param placement - The optional new anchor placement.\n     */\n    set textPlacement(placement) {\n        this.m_hAlign = harp_text_canvas_1.hAlignFromPlacement(placement.h);\n        this.m_vAlign = harp_text_canvas_1.vAlignFromPlacement(placement.v);\n    }\n    /**\n     * Acquire current placement setup.\n     *\n     * Function returns alternative or base placement depending on layout state.\n     *\n     * @returns The current anchor placement.\n     */\n    get textPlacement() {\n        return {\n            h: harp_text_canvas_1.hPlacementFromAlignment(this.m_hAlign),\n            v: harp_text_canvas_1.vPlacementFromAlignment(this.m_vAlign)\n        };\n    }\n    /**\n     * Reset existing `LayoutState` to contain values from style/theme layout.\n     */\n    reset(layoutStyle) {\n        this.m_hAlign = layoutStyle.horizontalAlignment;\n        this.m_vAlign = layoutStyle.verticalAlignment;\n    }\n    get horizontalAlignment() {\n        return this.m_hAlign;\n    }\n    get verticalAlignment() {\n        return this.m_vAlign;\n    }\n}\nexports.LayoutState = LayoutState;\n//# sourceMappingURL=LayoutState.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/LayoutState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/MapViewState.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/MapViewState.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapViewState = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * View state obtained from a MapView instance.\n */\nclass MapViewState {\n    constructor(m_mapView, m_renderedTilesChangeCheck) {\n        this.m_mapView = m_mapView;\n        this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;\n        this.m_lookAtVector = new THREE.Vector3();\n    }\n    get worldCenter() {\n        return this.m_mapView.worldCenter;\n    }\n    get cameraIsMoving() {\n        return this.m_mapView.cameraIsMoving;\n    }\n    get maxVisibilityDist() {\n        return this.m_mapView.viewRanges.maximum;\n    }\n    get zoomLevel() {\n        return this.m_mapView.zoomLevel;\n    }\n    get env() {\n        return this.m_mapView.env;\n    }\n    get frameNumber() {\n        return this.m_mapView.frameNumber;\n    }\n    get lookAtVector() {\n        return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);\n    }\n    get lookAtDistance() {\n        return this.m_mapView.targetDistance;\n    }\n    get isDynamic() {\n        return this.m_mapView.isDynamicFrame;\n    }\n    get hiddenGeometryKinds() {\n        return this.m_mapView.tileGeometryManager === undefined\n            ? undefined\n            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;\n    }\n    get renderedTilesChanged() {\n        return this.m_renderedTilesChangeCheck();\n    }\n    get projection() {\n        return this.m_mapView.projection;\n    }\n    get elevationProvider() {\n        return this.m_mapView.elevationProvider;\n    }\n}\nexports.MapViewState = MapViewState;\n//# sourceMappingURL=MapViewState.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/MapViewState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/Placement.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/Placement.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWorldPosition = exports.isPathLabelTooSmall = exports.placePathLabel = exports.placePointLabel = exports.placeIcon = exports.PlacementResult = exports.newPointLabelTextMarginPercent = exports.persistentPointLabelTextMargin = exports.checkReadyForPlacement = exports.PrePlacementResult = exports.getMaxViewDistance = exports.pointToPlaneDistance = exports.computeViewDistance = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ \"./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js\");\nconst ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ \"./node_modules/@here/harp-mapview/lib/ScreenCollisions.js\");\nconst TextElement_1 = __webpack_require__(/*! ./TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n/**\n * Functions related to text element placement.\n */\nconst tmpPosition = new THREE.Vector3(0, 0, 0);\nconst tmpCameraDir = new THREE.Vector3(0, 0, 0);\nconst tmpPointDir = new THREE.Vector3(0, 0, 0);\nconst COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)\n/**\n * Checks whether the distance of the text element to the camera plane meets threshold criteria.\n *\n * @param textElement - The textElement of which the view distance will be checked, with coordinates\n * in world space.\n * @param poiIndex - If TextElement is a line marker, the index into the line marker positions.\n * @param eyePos - The eye (or camera) position that will be used as reference to calculate\n * the distance.\n * @param eyeLookAt - The eye looking direction - normalized.\n * @param maxViewDistance - The maximum distance value.\n * @returns The text element view distance if it's lower than the maximum value, otherwise\n * `undefined`.\n */\nfunction checkViewDistance(textElement, poiIndex, eyePos, eyeLookAt, projectionType, maxViewDistance) {\n    const textDistance = computeViewDistance(textElement, poiIndex, eyePos, eyeLookAt);\n    if (projectionType !== harp_geoutils_1.ProjectionType.Spherical) {\n        return textDistance <= maxViewDistance ? textDistance : undefined;\n    }\n    // For sphere projection: Filter labels that are close to the horizon\n    tmpPosition.copy(textElement.position).normalize();\n    tmpCameraDir.copy(eyePos).normalize();\n    const cosAlpha = tmpPosition.dot(tmpCameraDir);\n    const viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance\n        ? textDistance\n        : undefined;\n    return viewDistance;\n}\n/**\n * Computes distance of the specified text element to camera plane given with position and normal.\n *\n * The distance is measured as projection of the vector between `eyePosition` and text\n * onto the `eyeLookAt` vector, so it actually computes the distance to plane that\n * contains `eyePosition` and is described with `eyeLookAt` as normal.\n *\n * @note Used for measuring the distances to camera, results in the metric that describes\n * distance to camera near plane (assuming near = 0). Such metric is better as input for labels\n * scaling or fading factors then simple euclidean distance because it does not fluctuate during\n * simple camera panning.\n *\n * @param textElement - The textElement of which the view distance will be checked. It must have\n *                      coordinates in world space.\n * @param poiIndex - If TextElement is a line marker, the index into the line marker positions.\n * @param eyePosition - The world eye coordinates used a reference position to calculate\n *                      the distance.\n * @param eyeLookAt - The eye looking direction or simply said projection plane normal.\n * @returns The text element view distance.\n */\nfunction computeViewDistance(textElement, poiIndex, eyePosition, eyeLookAt) {\n    let viewDistance;\n    // Compute the distances as the distance along plane normal.\n    const path = textElement.path;\n    if (path && path.length > 1) {\n        if (poiIndex !== undefined && path && path.length > poiIndex) {\n            viewDistance = pointToPlaneDistance(path[poiIndex], eyePosition, eyeLookAt);\n        }\n        else {\n            const viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);\n            const viewDistance1 = pointToPlaneDistance(path[path.length - 1], eyePosition, eyeLookAt);\n            viewDistance = Math.min(viewDistance0, viewDistance1);\n        }\n    }\n    else {\n        viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);\n    }\n    return viewDistance;\n}\nexports.computeViewDistance = computeViewDistance;\n/**\n * Computes distance between the given point and a plane.\n *\n * May be used to measure distance of point labels to the camera projection (near) plane.\n *\n * @param pointPos - The position to measure distance to.\n * @param planePos - The position of any point on the plane.\n * @param planeNorm - The plane normal vector (have to be normalized already).\n */\nfunction pointToPlaneDistance(pointPos, planePos, planeNorm) {\n    const labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);\n    return labelCamVec.dot(planeNorm);\n}\nexports.pointToPlaneDistance = pointToPlaneDistance;\n/**\n * Computes the maximum view distance for text elements as a ratio of the given view's maximum far\n * plane distance.\n * @param viewState - The view for which the maximum view distance will be calculated.\n * @param farDistanceLimitRatio - The ratio to apply to the maximum far plane distance.\n * @returns Maximum view distance.\n */\nfunction getMaxViewDistance(viewState, farDistanceLimitRatio) {\n    return viewState.maxVisibilityDist * farDistanceLimitRatio;\n}\nexports.getMaxViewDistance = getMaxViewDistance;\n/**\n * State of fading.\n */\nvar PrePlacementResult;\n(function (PrePlacementResult) {\n    PrePlacementResult[PrePlacementResult[\"Ok\"] = 0] = \"Ok\";\n    PrePlacementResult[PrePlacementResult[\"NotReady\"] = 1] = \"NotReady\";\n    PrePlacementResult[PrePlacementResult[\"Invisible\"] = 2] = \"Invisible\";\n    PrePlacementResult[PrePlacementResult[\"TooFar\"] = 3] = \"TooFar\";\n    PrePlacementResult[PrePlacementResult[\"Duplicate\"] = 4] = \"Duplicate\";\n    PrePlacementResult[PrePlacementResult[\"Count\"] = 5] = \"Count\";\n})(PrePlacementResult = exports.PrePlacementResult || (exports.PrePlacementResult = {}));\nconst tmpPlacementPosition = new THREE.Vector3();\n/**\n * Applies early rejection tests for a given text element meant to avoid trying to place labels\n * that are not visible, not ready, duplicates etc...\n * @param textElement - The Text element to check.\n * @param poiIndex - If TextElement is a line marker, the index into the line marker positions\n * @param viewState - The view for which the text element will be placed.\n * @param m_poiManager - To prepare pois for rendering.\n * @param maxViewDistance - If specified, text elements farther than this max distance will be\n *                          rejected.\n * @returns An object with the result code and the text element view distance\n * ( or `undefined` of the checks failed) as second.\n */\nfunction checkReadyForPlacement(textElement, poiIndex, viewState, poiManager, maxViewDistance) {\n    // eslint-disable-next-line prefer-const\n    let viewDistance;\n    if (!textElement.visible) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n    // If a PoiTable is specified in the technique, the table is required to be\n    // loaded before the POI can be rendered.\n    if (!poiManager.updatePoiFromPoiTable(textElement)) {\n        // PoiTable has not been loaded, but is required to determine\n        // visibility.\n        return { result: PrePlacementResult.NotReady, viewDistance };\n    }\n    // Text element visibility and zoom level ranges must be checked after calling\n    // updatePoiFromPoiTable, since that function may change those values.\n    if (!textElement.visible ||\n        viewState.zoomLevel === textElement.maxZoomLevel ||\n        !harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n    viewDistance =\n        maxViewDistance === undefined\n            ? computeViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector)\n            : checkViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector, viewState.projection.type, maxViewDistance);\n    if (viewDistance === undefined) {\n        return { result: PrePlacementResult.TooFar, viewDistance };\n    }\n    return { result: PrePlacementResult.Ok, viewDistance };\n}\nexports.checkReadyForPlacement = checkReadyForPlacement;\n/**\n * Computes the offset for a point text accordingly to text alignment (and icon, if any).\n * @param textElement - The text element of which the offset will computed. It must be a point\n * label with [[layoutStyle]] and [[bounds]] already computed.\n * @param textBounds - The text screen bounds.\n * @param placement - The relative anchor placement (may be different then original alignment).\n * @param scale - The scaling factor (due to distance, etc.).\n * @param env - The {@link @here/harp-datasource-protocol#Env} used\n *                  to evaluate technique attributes.\n * @param offset - The offset result.\n */\nfunction computePointTextOffset(textElement, textBounds, placement, scale, env, offset = new THREE.Vector2()) {\n    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PoiLabel ||\n        textElement.type === TextElementType_1.TextElementType.LineMarker);\n    harp_utils_1.assert(textElement.layoutStyle !== undefined);\n    offset.x = textElement.xOffset;\n    offset.y = textElement.yOffset;\n    switch (placement.h) {\n        case harp_text_canvas_1.HorizontalPlacement.Left:\n            // Already accounts for any margin that is already applied to the text element bounds.\n            offset.x -= textBounds.max.x;\n            break;\n        case harp_text_canvas_1.HorizontalPlacement.Right:\n            // Account for any margin applied as above.\n            offset.x -= textBounds.min.x;\n            break;\n    }\n    switch (placement.v) {\n        case harp_text_canvas_1.VerticalPlacement.Top:\n            offset.y -= textBounds.min.y;\n            break;\n        case harp_text_canvas_1.VerticalPlacement.Center:\n            offset.y -= 0.5 * (textBounds.max.y + textBounds.min.y);\n            break;\n        case harp_text_canvas_1.VerticalPlacement.Bottom:\n            // Accounts for vertical margin that may be applied to the text bounds.\n            offset.y -= textBounds.max.y;\n            break;\n    }\n    if (textElement.poiInfo !== undefined && TextElement_1.poiIsRenderable(textElement.poiInfo)) {\n        harp_utils_1.assert(textElement.poiInfo.computedWidth !== undefined);\n        harp_utils_1.assert(textElement.poiInfo.computedHeight !== undefined);\n        // Apply offset moving text out of the icon\n        offset.x += textElement.poiInfo.computedWidth * (0.5 + placement.h);\n        offset.y += textElement.poiInfo.computedHeight * (0.5 + placement.v);\n        // Reverse, mirror or project offsets on different axis depending on the placement\n        // required only for alternative placements.\n        const hAlign = harp_text_canvas_1.hPlacementFromAlignment(textElement.layoutStyle.horizontalAlignment);\n        const vAlign = harp_text_canvas_1.vPlacementFromAlignment(textElement.layoutStyle.verticalAlignment);\n        if (hAlign !== placement.h || vAlign !== placement.v) {\n            // Read icon offset used.\n            const technique = textElement.poiInfo.technique;\n            let iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);\n            let iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);\n            iconXOffset = typeof iconXOffset === \"number\" ? iconXOffset : 0;\n            iconYOffset = typeof iconYOffset === \"number\" ? iconYOffset : 0;\n            // Now mirror the text offset relative to icon so manhattan distance is preserved, when\n            // alternative position is taken, this ensures that text-icon relative position is\n            // the same as in base alignment.\n            const hAlignDiff = hAlign - placement.h;\n            const vAlignDiff = vAlign - placement.v;\n            const relOffsetX = iconXOffset - textElement.xOffset;\n            const relOffsetY = iconYOffset - textElement.yOffset;\n            const centerBased = hAlign === harp_text_canvas_1.HorizontalPlacement.Center || vAlign === harp_text_canvas_1.VerticalPlacement.Center;\n            if (centerBased) {\n                // Center based alternative placements.\n                offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;\n                offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);\n                offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;\n                offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);\n            }\n            else {\n                // Corner alternative placements\n                offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;\n                offset.y -=\n                    2 *\n                        Math.sign(vAlignDiff) *\n                        Math.min(Math.abs(vAlignDiff), 0.5) *\n                        Math.abs(relOffsetX);\n                offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;\n                offset.x -=\n                    2 *\n                        Math.sign(hAlignDiff) *\n                        Math.min(Math.abs(hAlignDiff), 0.5) *\n                        Math.abs(relOffsetY);\n            }\n        }\n    }\n    offset.multiplyScalar(scale);\n    return offset;\n}\nconst tmpBox = new THREE.Box2();\nconst tmpBounds = new THREE.Box2();\nconst tmpBoxes = [];\nconst tmpMeasurementParams = {};\nconst tmpCollisionBoxes = [];\nconst tmpCollisionBox = new ScreenCollisions_1.CollisionBox();\nconst tmpScreenPosition = new THREE.Vector2();\nconst tmpTextOffset = new THREE.Vector2();\nconst tmp2DBox = new harp_utils_1.Math2D.Box();\nconst tmpCenter = new THREE.Vector2();\nconst tmpSize = new THREE.Vector2();\n/**\n * The margin applied to the text bounds of every point label.\n */\nexports.persistentPointLabelTextMargin = new THREE.Vector2(2, 2);\n/**\n * Additional bounds scaling (described as percentage of full size) applied to the new labels.\n *\n * This additional scaling (margin) allows to account for slight camera position and\n * orientation changes, so new labels are placed only if there is enough space around them.\n * Such margin limits collisions with neighboring labels while doing small camera movements and\n * thus reduces labels flickering.\n */\nexports.newPointLabelTextMarginPercent = 0.1;\nvar PlacementResult;\n(function (PlacementResult) {\n    PlacementResult[PlacementResult[\"Ok\"] = 0] = \"Ok\";\n    PlacementResult[PlacementResult[\"Rejected\"] = 1] = \"Rejected\";\n    PlacementResult[PlacementResult[\"Invisible\"] = 2] = \"Invisible\";\n})(PlacementResult = exports.PlacementResult || (exports.PlacementResult = {}));\n/**\n * Places an icon on screen.\n * @param iconRenderState - The icon state.\n * @param poiInfo - Icon information necessary to compute its dimensions.\n * @param screenPosition - Screen position of the icon.\n * @param scaleFactor - Scaling factor to apply to the icon dimensions.\n * @param screenCollisions - Used to check the icon visibility and collisions.\n * @param env - Current map env.\n * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n */\nfunction placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, env, screenCollisions) {\n    PoiRenderer_1.PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n    const iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);\n    return !iconSpaceAvailable ? PlacementResult.Rejected : PlacementResult.Ok;\n}\nexports.placeIcon = placeIcon;\n/**\n * Place a point label text using single or multiple alternative placement anchors.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env} used\n *              to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @param multiAnchor - The parameter decides if multi-anchor placement algorithm should be\n * used, be default [[false]] meaning try to place label using current alignment settings only.\n * @returns `PlacementResult.Ok` if point __label can be placed__ at the base or any optional\n * anchor point. `PlacementResult.Rejected` if there's a collision for all placements. Finally\n * `PlacementResult.Invisible` if it's text is not visible at any placement position.\n */\nfunction placePointLabel(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition, multiAnchor = false) {\n    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);\n    const layoutStyle = labelState.element.layoutStyle;\n    // Check if alternative placements have been provided.\n    multiAnchor =\n        multiAnchor && layoutStyle.placements !== undefined && layoutStyle.placements.length > 1;\n    // For single placement labels or labels with icon rejected, do only current anchor testing.\n    if (!multiAnchor) {\n        return placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);\n    }\n    // Otherwise test also alternative text placements.\n    else {\n        return placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);\n    }\n}\nexports.placePointLabel = placePointLabel;\n/**\n * Try to place a point label text using multiple optional placements.\n *\n * @note Function should be called only for labels with icons not rejected and for text alignments\n * different then [[HorizontalAlignment.Center]] and [[VerticalAlignment.Center]].\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if label can be placed at the base or optional anchor point,\n * `PlacementResult.Rejected` if there's a collision for all placements, `PlacementResult.Invisible`\n * if it's not visible at any placement position.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {\n    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);\n    const label = labelState.element;\n    // Store label state - persistent or new label.\n    const persistent = labelState.visible;\n    // Start with last alignment settings if layout state was stored or\n    // simply begin from layout defined in theme.\n    const lastPlacement = labelState.textPlacement;\n    const placements = label.layoutStyle.placements;\n    const placementsNum = placements.length;\n    // Find current anchor placement on the optional placements list.\n    // Index of exact match.\n    const matchIdx = placements.findIndex(p => p.h === lastPlacement.h && p.v === lastPlacement.v);\n    harp_utils_1.assert(matchIdx >= 0);\n    // Will be true if all text placements are invisible.\n    let allInvisible = true;\n    // Iterate all placements starting from current one.\n    for (let i = matchIdx; i < placementsNum + matchIdx; ++i) {\n        const anchorPlacement = placements[i % placementsNum];\n        // Bounds may be already calculated for persistent label, force re-calculation only\n        // for alternative (new) placements.\n        const isLastPlacement = i === matchIdx && persistent;\n        // Compute label bounds, visibility or collision according to new layout settings.\n        const placementResult = placePointLabelAtAnchor(labelState, screenPosition, anchorPlacement, scale, textCanvas, env, screenCollisions, !isLastPlacement, tmpPlacementPosition);\n        if (placementResult === PlacementResult.Ok) {\n            outScreenPosition.copy(tmpPlacementPosition);\n            return PlacementResult.Ok;\n        }\n        // Store last successful (previous frame) position even if it's now rejected (to fade out).\n        if (isLastPlacement) {\n            outScreenPosition.copy(tmpPlacementPosition);\n        }\n        // Invisible = Persistent label out of screen or the new label that is colliding.\n        allInvisible = allInvisible && placementResult === PlacementResult.Invisible;\n    }\n    return allInvisible\n        ? // All text's placements out of the screen.\n            PlacementResult.Invisible\n        : // All placements are either colliding or out of screen .\n            PlacementResult.Rejected;\n}\n/**\n * Places a point label on a specified text canvas using the alignment (anchor) currently set.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {\n    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);\n    // Use recently rendered (state stored) layout if available, otherwise theme based style.\n    const lastPlacement = labelState.textPlacement;\n    const result = placePointLabelAtAnchor(labelState, screenPosition, lastPlacement, scale, textCanvas, env, screenCollisions, !labelState.visible, outScreenPosition);\n    return result;\n}\n/**\n * Auxiliary function that tries to place a point label on a text canvas using specified alignment.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates\n * @param placement - Text placement relative to the label position.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param forceInvalidation - Set to true if text layout or other params has changed such as text\n * re-measurement is required and text buffer need to be invalidated.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelAtAnchor(labelState, screenPosition, placement, scale, textCanvas, env, screenCollisions, forceInvalidation, outScreenPosition) {\n    const label = labelState.element;\n    harp_utils_1.assert(label.glyphs !== undefined);\n    harp_utils_1.assert(label.layoutStyle !== undefined);\n    const measureText = !label.bounds || forceInvalidation;\n    const labelBounds = measureText ? tmpBounds : label.bounds;\n    if (measureText) {\n        // Override text canvas layout style for measurement.\n        applyTextPlacement(textCanvas, placement);\n        tmpMeasurementParams.outputCharacterBounds = undefined;\n        tmpMeasurementParams.path = undefined;\n        tmpMeasurementParams.pathOverflow = false;\n        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;\n        // Compute label bounds according to layout settings.\n        textCanvas.measureText(label.glyphs, labelBounds, tmpMeasurementParams);\n    }\n    // Compute text offset from the anchor point\n    const textOffset = computePointTextOffset(label, labelBounds, placement, scale, env, tmpTextOffset).add(screenPosition);\n    // Update output screen position.\n    outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);\n    // Apply additional persistent margin, keep in mind that text bounds just calculated\n    // are not (0, 0, w, h) based, so their coords usually are also non-zero.\n    // TODO: Make the margin configurable\n    tmpBox.copy(labelBounds).expandByVector(exports.persistentPointLabelTextMargin).translate(textOffset);\n    tmpBox.getCenter(tmpCenter);\n    tmpBox.getSize(tmpSize);\n    tmpSize.multiplyScalar(scale);\n    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);\n    // Check the text visibility if invisible finish immediately\n    // regardless of the persistence state - no fading required.\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n    if (measureText) {\n        // Up-scaled label bounds are used only for new labels and only for collision check, this\n        // is intentional to avoid processing labels out of the screen due to increased bounds,\n        // such labels would be again invisible in the next frame.\n        tmpBox.getSize(tmpSize);\n        tmpSize.multiplyScalar(scale * (1 + exports.newPointLabelTextMarginPercent));\n        tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);\n    }\n    // Check label's text collision. Collision is more important than visibility (now), because for\n    // icon/text combinations the icon should be rendered if the text is out of bounds, but it may\n    // _not_ be rendered if the text is colliding with another label.\n    if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {\n        return PlacementResult.Rejected;\n    }\n    // Don't allocate space for rejected text. When zooming, this allows placement of a\n    // lower priority text element that was displaced by a higher priority one (not\n    // present in the new zoom level) before an even lower priority one takes the space.\n    // Otherwise the lowest priority text will fade in and back out.\n    // TODO: Add a unit test for this scenario.\n    if (label.textReservesSpace) {\n        screenCollisions.allocate(tmp2DBox);\n    }\n    // Glyphs arrangement have been changed remove text buffer object which needs to be\n    // re-created.\n    if (measureText) {\n        label.textBufferObject = undefined;\n        label.bounds = label.bounds ? label.bounds.copy(labelBounds) : labelBounds.clone();\n    }\n    else {\n        // Override text canvas layout style for placement.\n        applyTextPlacement(textCanvas, placement);\n    }\n    // Save current placement in label state.\n    // TextElementState creates layout snapshot solely for alternative placements which saves\n    // memory that could be wasted on unnecessary objects construction.\n    labelState.textPlacement = placement;\n    return PlacementResult.Ok;\n}\n/**\n * Applied modified text layout style to TextCanvas for further use.\n * @param textCanvas - TextCanvas reference.\n * @param placement - The text placement to be used.\n */\nfunction applyTextPlacement(textCanvas, placement) {\n    // Setup TextCanvas layout settings of the new placement as it is required for further\n    // TextBufferObject creation and measurements in addText().\n    textCanvas.textLayoutStyle.horizontalAlignment = harp_text_canvas_1.hAlignFromPlacement(placement.h);\n    textCanvas.textLayoutStyle.verticalAlignment = harp_text_canvas_1.vAlignFromPlacement(placement.v);\n}\n/**\n * Places a path label along a given path on a specified text canvas.\n * @param labelState - The state of the path label to place.\n * @param textPath - The text path along which the label will be placed.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param screenCollisions - Used to check collisions with other labels.\n * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's\n * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.\n */\nfunction placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {\n    // Recalculate the text bounds for this path label. If measurement fails, the whole\n    // label doesn't fit the path and should be discarded.\n    tmpMeasurementParams.path = textPath;\n    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;\n    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;\n    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but\n    // without storing the result. If the measurement succeeds, the placement work is done\n    // twice.\n    // This could be done in one step (e.g measureAndAddText). Collision test could be injected\n    // in the middle as a function.\n    if (!textCanvas.measureText(labelState.element.glyphs, tmpBox, tmpMeasurementParams)) {\n        return PlacementResult.Rejected;\n    }\n    // Coarse collision check.\n    tmpCollisionBox.copy(tmpBox.translate(screenPosition));\n    if (!screenCollisions.isVisible(tmpCollisionBox)) {\n        return PlacementResult.Invisible;\n    }\n    let checkGlyphCollision = false;\n    let candidateBoxes;\n    if (!labelState.element.textMayOverlap) {\n        candidateBoxes = screenCollisions.search(tmpCollisionBox);\n        checkGlyphCollision = candidateBoxes.length > 0;\n    }\n    // Perform per-character collision checks.\n    tmpCollisionBoxes.length = tmpBoxes.length;\n    for (let i = 0; i < tmpBoxes.length; ++i) {\n        const glyphBox = tmpBoxes[i].translate(screenPosition);\n        let collisionBox = tmpCollisionBoxes[i];\n        if (collisionBox === undefined) {\n            collisionBox = new ScreenCollisions_1.CollisionBox(glyphBox);\n            tmpCollisionBoxes[i] = collisionBox;\n        }\n        else {\n            collisionBox.copy(glyphBox);\n        }\n        if (checkGlyphCollision &&\n            screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {\n            return PlacementResult.Rejected;\n        }\n    }\n    // Allocate collision info if needed.\n    if (labelState.element.textReservesSpace) {\n        const collisionBox = new ScreenCollisions_1.DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());\n        tmpCollisionBoxes.length = 0;\n        screenCollisions.allocate(collisionBox);\n    }\n    return PlacementResult.Ok;\n}\nexports.placePathLabel = placePathLabel;\n/**\n * Check if a given path label is too small to be rendered.\n * @param textElement - The text element to check.\n * @param screenProjector - Used to project coordinates from world to screen space.\n * @param outScreenPoints - Label path projected to screen space.\n * @returns `true` if label is too small, `false` otherwise.\n */\nfunction isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {\n    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PathLabel);\n    // Get the screen points that define the label's segments and create a path with\n    // them.\n    outScreenPoints.length = 0;\n    let anyPointVisible = false;\n    for (const pt of textElement.points) {\n        // Skip invisible points at the beginning of the path.\n        const screenPoint = anyPointVisible\n            ? screenProjector.project(pt, tmpScreenPosition)\n            : screenProjector.projectToScreen(pt, tmpScreenPosition);\n        if (screenPoint === undefined) {\n            continue;\n        }\n        anyPointVisible = true;\n        outScreenPoints.push(tmpScreenPosition.clone());\n    }\n    // TODO: (HARP-3515)\n    //      The rendering of a path label that contains just a single point that is not\n    //      visible is impossible, which is problematic with long paths.\n    //      Fix: Skip/clip the invisible points at beginning and end of the path to get\n    //      the visible part of the path.\n    // If not a single point is visible, skip the path\n    if (!anyPointVisible) {\n        return true;\n    }\n    // Check/guess if the screen box can hold a string of that length. It is important\n    // to guess that value without measuring the font first to save time.\n    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;\n    tmpBox.setFromPoints(outScreenPoints);\n    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();\n    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {\n        textElement.dbgPathTooSmall = true;\n        return true;\n    }\n    return false;\n}\nexports.isPathLabelTooSmall = isPathLabelTooSmall;\nconst tmpOrientedBox = new harp_geoutils_1.OrientedBox3();\n/**\n * Calculates the world position of the supplied label. The label will be shifted if there is a\n * specified offsetDirection and value to shift it in.\n * @param poiLabel - The label to shift\n * @param projection - The projection, required to compute the correct direction offset for\n *                     spherical projections.\n * @param env - The environment to extract the worldOffset needed to shift the icon in world space,\n *              if configured in the style.\n * @param outWorldPosition - Preallocated vector to store the result in\n * @returns the [[outWorldPosition]] vector.\n */\nfunction getWorldPosition(poiLabel, projection, env, outWorldPosition) {\n    var _a, _b;\n    const worldOffsetShiftValue = harp_datasource_protocol_1.getPropertyValue((_b = (_a = poiLabel.poiInfo) === null || _a === void 0 ? void 0 : _a.technique) === null || _b === void 0 ? void 0 : _b.worldOffset, env);\n    outWorldPosition === null || outWorldPosition === void 0 ? void 0 : outWorldPosition.copy(poiLabel.position);\n    if (worldOffsetShiftValue !== null &&\n        worldOffsetShiftValue !== undefined &&\n        poiLabel.offsetDirection !== undefined) {\n        projection.localTangentSpace(poiLabel.position, tmpOrientedBox);\n        const offsetDirectionVector = tmpOrientedBox.yAxis;\n        const offsetDirectionRad = THREE.MathUtils.degToRad(poiLabel.offsetDirection);\n        // Negate to get the normal, i.e. the vector pointing to the sky.\n        offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);\n        outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);\n    }\n    return outWorldPosition;\n}\nexports.getWorldPosition = getWorldPosition;\n//# sourceMappingURL=Placement.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/Placement.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/PlacementStats.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/PlacementStats.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PlacementStats = void 0;\nclass PlacementStats {\n    constructor(m_logger) {\n        this.m_logger = m_logger;\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n    clear() {\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n    log() {\n        const numNotRendered = this.uninitialized +\n            this.numPoiTextsInvisible +\n            this.tooFar +\n            this.numNotVisible +\n            this.numCannotAdd;\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"Resorted groups\", this.resortedGroups);\n        this.m_logger.debug(\"Total labels\", this.total);\n        this.m_logger.debug(\"Rendered labels\", this.numRenderedTextElements);\n        this.m_logger.debug(\"Rejected labels\", numNotRendered);\n        this.m_logger.debug(\"Unitialized labels\", this.uninitialized);\n        this.m_logger.debug(\"Rendered poi icons\", this.numRenderedPoiIcons);\n        this.m_logger.debug(\"Rendered poi texts\", this.numRenderedPoiTexts);\n        this.m_logger.debug(\"Poi text invisible\", this.numPoiTextsInvisible);\n        this.m_logger.debug(\"Too far\", this.tooFar);\n        this.m_logger.debug(\"Not visible\", this.numNotVisible);\n        this.m_logger.debug(\"Path too small\", this.numPathTooSmall);\n        this.m_logger.debug(\"Rejected, max glyphs reached\", this.numCannotAdd);\n    }\n}\nexports.PlacementStats = PlacementStats;\n//# sourceMappingURL=PlacementStats.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/PlacementStats.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/RenderState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/RenderState.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderState = exports.DEFAULT_FADE_TIME = exports.FadingState = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * State of fading.\n */\nvar FadingState;\n(function (FadingState) {\n    FadingState[FadingState[\"Undefined\"] = 0] = \"Undefined\";\n    FadingState[FadingState[\"FadingIn\"] = 1] = \"FadingIn\";\n    FadingState[FadingState[\"FadedIn\"] = 2] = \"FadedIn\";\n    FadingState[FadingState[\"FadingOut\"] = -1] = \"FadingOut\";\n    FadingState[FadingState[\"FadedOut\"] = -2] = \"FadedOut\";\n})(FadingState = exports.FadingState || (exports.FadingState = {}));\n/**\n * Time to fade in/fade out the labels in milliseconds.\n */\nexports.DEFAULT_FADE_TIME = 800;\n/**\n * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements\n * in and out, to compute the opacity.\n *\n * @hidden\n */\nclass RenderState {\n    /**\n     * Create a `RenderState`.\n     *\n     * @param fadeTime - The duration of the fading in milliseconds.\n     */\n    constructor(fadeTime = exports.DEFAULT_FADE_TIME) {\n        this.fadeTime = fadeTime;\n        /**\n         * Current fading value [0..1]\n         */\n        this.value = 0.0;\n        /**\n         * Timestamp the fading started.\n         */\n        this.startTime = 0;\n        /**\n         * Computed opacity depending on value.\n         */\n        this.opacity = 0.0;\n        this.m_state = FadingState.Undefined;\n    }\n    /**\n     * Reset existing `RenderState` to appear like a fresh state.\n     */\n    reset() {\n        this.m_state = FadingState.Undefined;\n        this.value = 0.0;\n        this.startTime = 0.0;\n        this.opacity = 0.0;\n    }\n    /**\n     * @returns `true` if element state is `FadingState.Undefined`.\n     */\n    isUndefined() {\n        return this.m_state === FadingState.Undefined;\n    }\n    /**\n     * @returns `true` if element is either fading in or fading out.\n     */\n    isFading() {\n        const fading = this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;\n        return fading;\n    }\n    /**\n     * @returns `true` if element is fading in.\n     */\n    isFadingIn() {\n        const fadingIn = this.m_state === FadingState.FadingIn;\n        return fadingIn;\n    }\n    /**\n     * @returns `true` if element is fading out.\n     */\n    isFadingOut() {\n        const fadingOut = this.m_state === FadingState.FadingOut;\n        return fadingOut;\n    }\n    /**\n     * @returns `true` if element is done with fading in.\n     */\n    isFadedIn() {\n        const fadedIn = this.m_state === FadingState.FadedIn;\n        return fadedIn;\n    }\n    /**\n     * @returns `true` if element is done with fading out.\n     */\n    isFadedOut() {\n        const fadedOut = this.m_state === FadingState.FadedOut;\n        return fadedOut;\n    }\n    /**\n     * @returns `true` if state is neither faded out nor undefined and the opacity is larger\n     * than 0.\n     */\n    isVisible() {\n        return (this.m_state !== FadingState.FadedOut &&\n            this.m_state !== FadingState.Undefined &&\n            this.opacity > 0);\n    }\n    /**\n     * Updates the state to [[FadingState.FadingIn]].\n     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains\n     * unchanged.\n     *\n     * @param time - Current time.\n     * @param disableFading - Optional flag to disable fading.\n     */\n    startFadeIn(time, disableFading) {\n        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {\n            return;\n        }\n        if (disableFading === true) {\n            this.value = 1;\n            this.opacity = 1;\n            this.m_state = FadingState.FadedIn;\n            this.startTime = time;\n            return;\n        }\n        if (this.m_state === FadingState.FadingOut) {\n            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.value = 1.0 - this.value;\n            this.startTime = time - this.value * this.fadeTime;\n        }\n        else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 0;\n        }\n        this.m_state = FadingState.FadingIn;\n    }\n    /**\n     * Updates the state to [[FadingState.FadingOut]].\n     * If previous state is [[FadingState.FadingOut]], [[FadingState.FadedOut]] or\n     * [[FadingState.Undefined]] it remains unchanged.\n     *\n     * @param time - Current time.\n     */\n    startFadeOut(time) {\n        if (this.m_state === FadingState.FadingOut ||\n            this.m_state === FadingState.FadedOut ||\n            this.m_state === FadingState.Undefined) {\n            return;\n        }\n        if (this.m_state === FadingState.FadingIn) {\n            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.startTime = time - this.value * this.fadeTime;\n            this.value = 1.0 - this.value;\n        }\n        else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 1;\n        }\n        this.m_state = FadingState.FadingOut;\n    }\n    /**\n     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or\n     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.\n     * It does nothing if [[isFading]] !== `true`.\n     *\n     * @param time - Current time.\n     * @param disableFading - `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time, disableFading) {\n        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {\n            return;\n        }\n        if (this.startTime === 0) {\n            this.startTime = time;\n        }\n        const fadingTime = time - this.startTime;\n        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;\n        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;\n        if (disableFading || fadingTime >= this.fadeTime) {\n            this.value = 1.0;\n            this.opacity = endValue;\n            this.m_state =\n                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;\n        }\n        else {\n            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value\n            // increment).\n            this.value = fadingTime / this.fadeTime;\n            this.opacity = THREE.MathUtils.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, this.value), 0, 1);\n            harp_utils_1.assert(this.isFading());\n        }\n    }\n}\nexports.RenderState = RenderState;\n//# sourceMappingURL=RenderState.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/RenderState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/SimplePath.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/SimplePath.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimplePath = exports.PathParam = exports.SimpleLineCurve = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * @hidden\n */\nclass SimpleLineCurve extends THREE.LineCurve {\n    constructor(v1, v2) {\n        super(v1, v2);\n    }\n    getLengths() {\n        if (this.m_lengths === undefined) {\n            this.m_lengths = [0, this.v2.distanceTo(this.v1)];\n        }\n        return this.m_lengths;\n    }\n}\nexports.SimpleLineCurve = SimpleLineCurve;\n/**\n * @hidden\n */\nclass PathParam {\n    constructor(path, index, t) {\n        this.path = path;\n        this.index = index;\n        this.t = t;\n    }\n    get curve() {\n        return this.path.curves[this.index];\n    }\n    get point() {\n        if (this.m_point === undefined) {\n            this.m_point = this.curve.getPoint(this.t);\n        }\n        return this.m_point;\n    }\n}\nexports.PathParam = PathParam;\n/**\n * @hidden\n */\nclass SimplePath extends THREE.Path {\n    constructor() {\n        super();\n    }\n    getLengths() {\n        if (this.m_cache) {\n            return this.m_cache;\n        }\n        let sum = 0;\n        const lengths = new Array();\n        lengths.push(0);\n        this.curves.forEach(curve => {\n            const lineCurve = curve;\n            sum += lineCurve.v1.distanceTo(lineCurve.v2);\n            lengths.push(sum);\n        });\n        this.m_cache = lengths;\n        return lengths;\n    }\n    getParamAt(t) {\n        const distance = t * this.getLength();\n        const curveLengths = this.getCurveLengths();\n        for (let index = 0; index < curveLengths.length; ++index) {\n            if (curveLengths[index] < distance) {\n                continue;\n            }\n            const diff = curveLengths[index] - distance;\n            const curve = this.curves[index];\n            const segmentLength = curve.getLength();\n            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n            return new PathParam(this, index, u);\n        }\n        return null;\n    }\n}\nexports.SimplePath = SimplePath;\n//# sourceMappingURL=SimplePath.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/SimplePath.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextCanvasFactory = void 0;\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nclass TextCanvasFactory {\n    /**\n     * Creates an instance of text canvas factory.\n     * @param m_renderer -\n     */\n    constructor(m_renderer) {\n        this.m_renderer = m_renderer;\n        this.m_minGlyphCount = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.\n        this.m_maxGlyphCount = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.\n    }\n    setGlyphCountLimits(min, max) {\n        this.m_minGlyphCount = min;\n        this.m_maxGlyphCount = max;\n    }\n    /**\n     * Creates text canvas\n     * @param fontCatalog - Initial [[FontCatalog]].\n     * @param name - Optional name for the TextCavas\n     */\n    createTextCanvas(fontCatalog, name) {\n        harp_utils_1.assert(this.m_maxGlyphCount > 0);\n        return new harp_text_canvas_1.TextCanvas({\n            renderer: this.m_renderer,\n            fontCatalog,\n            minGlyphCount: this.m_minGlyphCount,\n            maxGlyphCount: this.m_maxGlyphCount,\n            name\n        });\n    }\n}\nexports.TextCanvasFactory = TextCanvasFactory;\n//# sourceMappingURL=TextCanvasFactory.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElement.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElement = exports.LoadingState = exports.poiIsRenderable = void 0;\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * Return 'true' if the POI has been successfully prepared for rendering.\n *\n * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n * @internal\n */\nfunction poiIsRenderable(poiInfo) {\n    return poiInfo.buffer !== undefined;\n}\nexports.poiIsRenderable = poiIsRenderable;\n/**\n * State of loading.\n */\nvar LoadingState;\n(function (LoadingState) {\n    LoadingState[LoadingState[\"Requested\"] = 0] = \"Requested\";\n    LoadingState[LoadingState[\"Loaded\"] = 1] = \"Loaded\";\n    LoadingState[LoadingState[\"Initialized\"] = 2] = \"Initialized\";\n})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));\n/**\n * `TextElement` is used to create 2D text elements (for example, labels).\n */\nclass TextElement {\n    /**\n     * Creates a new `TextElement`.\n     *\n     * @param text - The text to display.\n     * @param points - The position or a list of points for a curved text, both in world space.\n     * @param renderParams - `TextElement` text rendering parameters.\n     * @param layoutParams - `TextElement` text layout parameters.\n     * @param priority - The priority of the `TextElement. Elements with the highest priority get\n     *              placed first, elements with priority of `0` are placed last, elements with a\n     *              negative value are always rendered, ignoring priorities and allowing overrides.\n     * @param xOffset - Optional X offset of this `TextElement` in screen coordinates.\n     * @param yOffset - Optional Y offset of this `TextElement` in screen coordinates.\n     * @param featureId - Optional number to identify feature (originated from `OmvDataSource`).\n     * @param fadeNear - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label starts fading out (opacity decreases).\n     * @param fadeFar - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label becomes transparent. A value of <= 0.0 disables fading.\n     * @param offsetDirection - Direction represented as an angle in degrees clockwise from north to\n     * offset the icon in world space.\n     */\n    constructor(text, points, renderParams, layoutParams, priority = 0, xOffset = 0, yOffset = 0, featureId, style, fadeNear, fadeFar, tileOffset, offsetDirection) {\n        this.text = text;\n        this.points = points;\n        this.renderParams = renderParams;\n        this.layoutParams = layoutParams;\n        this.priority = priority;\n        this.xOffset = xOffset;\n        this.yOffset = yOffset;\n        this.featureId = featureId;\n        this.style = style;\n        this.fadeNear = fadeNear;\n        this.fadeFar = fadeFar;\n        this.tileOffset = tileOffset;\n        this.offsetDirection = offsetDirection;\n        /**\n         * Determines visibility. If set to `false`, it will not be rendered.\n         */\n        this.visible = true;\n        /**\n         * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.\n         */\n        this.distanceScale = 0.5;\n        /**\n         * If specified, determines the render order between `TextElement`s. The number different\n         * renderOrders should be as small as possible, because every specific `renderOrder` may result\n         * in one or more draw calls.\n         *\n         * TextElements with the same integer `renderOrder` will be rendered in the same batch.\n         *\n         * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other\n         * map elements.\n         *\n         * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a\n         * lower `renderOrder`.\n         */\n        this.renderOrder = 0;\n        /**\n         * If set to `true` the geometry has been already overlaid on elevation.\n         */\n        this.elevated = false;\n        if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {\n            this.renderStyle = renderParams;\n        }\n        if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {\n            this.layoutStyle = layoutParams;\n        }\n        this.type =\n            points instanceof THREE.Vector3 ? TextElementType_1.TextElementType.PoiLabel : TextElementType_1.TextElementType.PathLabel;\n    }\n    /**\n     * The text element position or the first point of the path used to render a curved text, both\n     * in world space.\n     */\n    get position() {\n        if (this.points instanceof Array) {\n            const p = this.points[0];\n            return p;\n        }\n        return this.points;\n    }\n    /**\n     * The list of points in world space used to render the text along a path or `undefined`.\n     */\n    get path() {\n        if (this.points instanceof Array) {\n            return this.points;\n        }\n        return undefined;\n    }\n    /**\n     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.\n     *\n     * @default `false`\n     */\n    get textMayOverlap() {\n        return this.mayOverlap === true;\n    }\n    set textMayOverlap(mayOverlap) {\n        this.mayOverlap = mayOverlap;\n    }\n    /**\n     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not\n     * be able to overlap.\n     *\n     * @default `true`\n     */\n    get textReservesSpace() {\n        return this.reserveSpace !== false;\n    }\n    set textReservesSpace(reserveSpace) {\n        this.reserveSpace = reserveSpace;\n    }\n    /**\n     * Contains additional information about icon to be rendered along with text.\n     */\n    get poiInfo() {\n        return this.m_poiInfo;\n    }\n    set poiInfo(poiInfo) {\n        this.m_poiInfo = poiInfo;\n        if (poiInfo !== undefined) {\n            if (this.path !== undefined) {\n                this.type = TextElementType_1.TextElementType.LineMarker;\n            }\n            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;\n            poiInfo.renderOrder = poiRenderOrder;\n        }\n    }\n    /**\n     * @returns The style used to render this text element, undefined if not set yet.\n     */\n    get renderStyle() {\n        return this.m_renderStyle;\n    }\n    /**\n     * Sets style used for text rendering.\n     * @param style - The style to use.\n     */\n    set renderStyle(style) {\n        this.m_renderStyle = style;\n    }\n    /**\n     * @returns The style used to layout this text element, undefined if not set yet.\n     */\n    get layoutStyle() {\n        return this.m_layoutStyle;\n    }\n    /**\n     * Sets the style used for text layout.\n     * @param style - The style to use.\n     */\n    set layoutStyle(style) {\n        this.m_layoutStyle = style;\n    }\n    hasFeatureId() {\n        return this.featureId !== undefined && this.featureId !== 0;\n    }\n    /**\n     * Disposes of any allocated resources.\n     */\n    dispose() {\n        var _a;\n        const poiBuffer = (_a = this.poiInfo) === null || _a === void 0 ? void 0 : _a.buffer;\n        if (poiBuffer) {\n            poiBuffer.decreaseRefCount();\n        }\n    }\n}\nexports.TextElement = TextElement;\n/**\n * Text elements with this priority are placed on screen before any others.\n */\nTextElement.HIGHEST_PRIORITY = Number.MAX_SAFE_INTEGER;\n//# sourceMappingURL=TextElement.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElement.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementBuilder.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementBuilder.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementBuilder = void 0;\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst PoiBuilder_1 = __webpack_require__(/*! ../poi/PoiBuilder */ \"./node_modules/@here/harp-mapview/lib/poi/PoiBuilder.js\");\nconst TextElement_1 = __webpack_require__(/*! ./TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementsRenderer_1 = __webpack_require__(/*! ./TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextElementBuilder\");\n/**\n * Constructs {@link TextElement} objects from {@link @here/harp-datasource-protocol/Technique},\n * text, coordinates and optional icon.\n */\nclass TextElementBuilder {\n    /**\n     * Constructor\n     *\n     * @param m_env - The {@link @link @here/harp-datasource-protocol#MapEnv} used to evaluate\n     * technique properties.\n     * @param m_styleCache - To cache instances of {@link @here/harp-text-canvas/TextRenderStyle}\n     * and {@link @here/harp-text-canvas/TextLayoutStyle}.\n     */\n    constructor(m_env, m_styleCache, m_baseRenderOrder) {\n        this.m_env = m_env;\n        this.m_styleCache = m_styleCache;\n        this.m_baseRenderOrder = m_baseRenderOrder;\n        this.m_distanceScale = TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;\n        this.m_renderOrder = m_baseRenderOrder;\n        if (Number.isInteger(m_baseRenderOrder)) {\n            this.renderOrderUpBound = TextElementBuilder.RENDER_ORDER_UP_BOUND;\n        }\n        else {\n            // If base render order is not an integer, lower render order upper bound to leave room\n            // for the decimal places.\n            const absBaseRenderOrder = Math.abs(m_baseRenderOrder);\n            this.renderOrderUpBound =\n                (absBaseRenderOrder - Math.floor(absBaseRenderOrder)) *\n                    TextElementBuilder.RENDER_ORDER_UP_BOUND;\n        }\n        if (!this.isValidRenderOrder(m_baseRenderOrder)) {\n            logger.warn(`Large base render order (${m_baseRenderOrder}) might cause precision issues.`);\n        }\n    }\n    /**\n     * Aligns a {@link TextElement}'s minZoomLevel and maxZoomLevel with values set in\n     * {@link PoiInfo}.\n     * @remarks Selects the smaller/larger one of the two min/max values for icon and text, because\n     * the TextElement is a container for both.\n     * @param textElement - The {@link TextElement} whose zoom level ranges will be aligned.\n     */\n    static alignZoomLevelRanges(textElement) {\n        var _a, _b;\n        if (!textElement.poiInfo) {\n            return;\n        }\n        const poiInfo = textElement.poiInfo;\n        textElement.minZoomLevel = (_a = textElement.minZoomLevel) !== null && _a !== void 0 ? _a : harp_utils_1.MathUtils.min2(poiInfo.iconMinZoomLevel, poiInfo.textMinZoomLevel);\n        textElement.maxZoomLevel = (_b = textElement.maxZoomLevel) !== null && _b !== void 0 ? _b : harp_utils_1.MathUtils.max2(poiInfo.iconMaxZoomLevel, poiInfo.textMaxZoomLevel);\n    }\n    /**\n     * Combines two render order numbers into a single one.\n     * @param baseRenderOrder - The most significative part of the render order.\n     * @param offset - The least significative part of the render order. It must be within the\n     * interval (-RENDER_ORDER_UP_BOUND, RENDER_ORDER_UP_BOUND).\n     * @return The combined render order.\n     */\n    static composeRenderOrder(baseRenderOrder, offset) {\n        return baseRenderOrder * TextElementBuilder.RENDER_ORDER_UP_BOUND + offset;\n    }\n    /**\n     * Sets a technique that will be used to create text elements on subsequent calls to\n     * {@link TextElementBuilder.build} until the next call to this method.\n     *\n     * @param technique - The {@link @here/harp-datasource-protocol/Technique}.\n     * @return This builder.\n     */\n    withTechnique(technique) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.m_technique = technique;\n        // Make sorting stable.\n        this.m_priority = (_a = harp_datasource_protocol_1.getPropertyValue(technique.priority, this.m_env)) !== null && _a !== void 0 ? _a : 0;\n        this.m_fadeNear = (_b = harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, this.m_env)) !== null && _b !== void 0 ? _b : undefined;\n        this.m_fadeFar = (_c = harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, this.m_env)) !== null && _c !== void 0 ? _c : undefined;\n        this.m_minZoomLevel = (_d = harp_datasource_protocol_1.getPropertyValue(technique.minZoomLevel, this.m_env)) !== null && _d !== void 0 ? _d : undefined;\n        this.m_maxZoomLevel = (_e = harp_datasource_protocol_1.getPropertyValue(technique.maxZoomLevel, this.m_env)) !== null && _e !== void 0 ? _e : undefined;\n        this.m_distanceScale = (_f = technique.distanceScale) !== null && _f !== void 0 ? _f : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;\n        this.m_renderStyle = this.m_styleCache.getRenderStyle(technique);\n        this.m_layoutStype = this.m_styleCache.getLayoutStyle(technique);\n        this.m_xOffset = harp_datasource_protocol_1.getPropertyValue(technique.xOffset, this.m_env);\n        this.m_yOffset = harp_datasource_protocol_1.getPropertyValue(technique.yOffset, this.m_env);\n        const techniqueRenderOrder = (_g = harp_datasource_protocol_1.getPropertyValue(technique.renderOrder, this.m_env)) !== null && _g !== void 0 ? _g : 0;\n        if (!this.isValidRenderOrder(techniqueRenderOrder)) {\n            const msg = `Unsupported large render order (${techniqueRenderOrder})`;\n            logger.error(msg);\n            harp_utils_1.assert(false, msg);\n        }\n        this.m_renderOrder = TextElementBuilder.composeRenderOrder(this.m_baseRenderOrder, techniqueRenderOrder);\n        if (harp_datasource_protocol_1.isTextTechnique(technique)) {\n            this.withTextTechnique(technique);\n        }\n        else {\n            this.withPoiTechnique(technique);\n        }\n        return this;\n    }\n    /**\n     * Sets an icon that will be used to create text elements on subsequent calls to\n     * {@link TextElementBuilder.build} until the next call to this method.\n     *\n     * @param imageTextureName - The name of the icon image.\n     * @param shieldGroupIndex - Index to the shield group.\n     * @return This builder.\n     */\n    withIcon(imageTextureName, shieldGroupIndex) {\n        harp_utils_1.assert(this.m_poiBuilder !== undefined);\n        this.m_poiBuilder.withIcon(imageTextureName, shieldGroupIndex);\n        return this;\n    }\n    /**\n     * Creates a {@link TextElement} with the given properties.\n     *\n     * @param text - The text to be displayed.\n     * @param points - The position(s) for the text element.\n     * @param tileOffset - The TextElement's tile offset, see {@link Tile.offset}.\n     * @param attributes - TextElement attribute map.\n     * @param pathLengthSqr - Precomputed path length squared for path labels.\n     * @return The created text element.\n     */\n    build(text, points, tileOffset, attributes, pathLengthSqr, offsetDirection) {\n        var _a;\n        const featureId = harp_datasource_protocol_1.getFeatureId(attributes);\n        harp_utils_1.assert(this.m_technique !== undefined);\n        harp_utils_1.assert(this.m_renderStyle !== undefined);\n        harp_utils_1.assert(this.m_layoutStype !== undefined);\n        const technique = this.m_technique;\n        const renderStyle = this.m_renderStyle;\n        const layoutStyle = this.m_layoutStype;\n        const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), points, renderStyle, layoutStyle, this.m_priority, this.m_xOffset, this.m_yOffset, featureId, technique.style, this.m_fadeNear, this.m_fadeFar, tileOffset, offsetDirection);\n        textElement.minZoomLevel = this.m_minZoomLevel;\n        textElement.maxZoomLevel = this.m_maxZoomLevel;\n        textElement.distanceScale = this.m_distanceScale;\n        textElement.mayOverlap = this.m_mayOverlap;\n        textElement.reserveSpace = this.m_reserveSpace;\n        textElement.kind = technique.kind;\n        // Get the userData for text element picking.\n        textElement.userData = attributes;\n        textElement.textFadeTime =\n            technique.textFadeTime !== undefined ? technique.textFadeTime * 1000 : undefined;\n        textElement.pathLengthSqr = pathLengthSqr;\n        textElement.alwaysOnTop = this.m_alwaysOnTop;\n        textElement.renderOrder = this.m_renderOrder;\n        textElement.poiInfo = (_a = this.m_poiBuilder) === null || _a === void 0 ? void 0 : _a.build(textElement);\n        TextElementBuilder.alignZoomLevelRanges(textElement);\n        return textElement;\n    }\n    withTextTechnique(technique) {\n        this.m_mayOverlap = technique.mayOverlap === true;\n        this.m_reserveSpace = technique.reserveSpace !== false;\n        this.m_poiBuilder = undefined;\n    }\n    withPoiTechnique(technique) {\n        this.m_mayOverlap = technique.textMayOverlap === true;\n        this.m_reserveSpace = technique.textReserveSpace !== false;\n        this.m_alwaysOnTop = technique.alwaysOnTop === true;\n        if (!this.m_poiBuilder) {\n            this.m_poiBuilder = new PoiBuilder_1.PoiBuilder(this.m_env);\n        }\n        this.m_poiBuilder.withTechnique(technique);\n    }\n    isValidRenderOrder(renderOrder) {\n        return Math.abs(renderOrder) < this.renderOrderUpBound;\n    }\n}\nexports.TextElementBuilder = TextElementBuilder;\n// Upper bound for render order values coming from a technique. The lowest upper bound\n// (`renderOrderUpBound`) will be smaller if `baseRenderOrder` is not an integer.\nTextElementBuilder.RENDER_ORDER_UP_BOUND = 1e7;\n//# sourceMappingURL=TextElementBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementBuilder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementGroup = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * Group of {@link TextElement} sharing same priority.\n */\nclass TextElementGroup extends harp_utils_1.PriorityListGroup {\n}\nexports.TextElementGroup = TextElementGroup;\n//# sourceMappingURL=TextElementGroup.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementGroupPriorityList = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * List of {@link TextElement} groups sorted by priority.\n */\nclass TextElementGroupPriorityList extends harp_utils_1.GroupedPriorityList {\n}\nexports.TextElementGroupPriorityList = TextElementGroupPriorityList;\n//# sourceMappingURL=TextElementGroupPriorityList.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementGroupState = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TextElementState_1 = __webpack_require__(/*! ./TextElementState */ \"./node_modules/@here/harp-mapview/lib/text/TextElementState.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * `TextElementGroupState` keeps the state of a text element group and each element in it while\n * they're being rendered.\n */\nclass TextElementGroupState {\n    /**\n     * Creates the state for specified group.\n     * @param group - The group of which the state will be created.\n     * @param tileKey - The key of the tile to which this group belongs.\n     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    constructor(group, tileKey, filter) {\n        this.group = group;\n        this.tileKey = tileKey;\n        this.m_visited = false;\n        harp_utils_1.assert(group.elements.length > 0);\n        const length = group.elements.length;\n        this.m_textElementStates = [];\n        this.m_visited = true;\n        // TODO: HARP-7648. Reduce number of allocations here:\n        // a) Avoid creating the state for labels that don't pass early placement checks and make\n        //    this checks more strict.\n        // b) Break label state objects into a set of arrays held at group level, one for each\n        //    primitive field in the label state.\n        for (let i = 0; i < length; ++i) {\n            const textElement = group.elements[i];\n            if (textElement.type === TextElementType_1.TextElementType.LineMarker && textElement.path !== undefined) {\n                const numPoints = textElement.path.length;\n                for (let p = 0; p < numPoints; p++) {\n                    const state = new TextElementState_1.TextElementState(textElement, p);\n                    const textDistance = filter(state);\n                    state.update(textDistance);\n                    this.m_textElementStates.push(state);\n                }\n            }\n            else {\n                const state = new TextElementState_1.TextElementState(textElement);\n                const textDistance = filter(state);\n                state.update(textDistance);\n                this.m_textElementStates.push(state);\n            }\n        }\n    }\n    /**\n     * Indicates whether the group has been submitted to the\n     * {@link TextElementsRenderer} in the current frame.\n     */\n    get visited() {\n        return this.m_visited;\n    }\n    set visited(visited) {\n        this.m_visited = visited;\n    }\n    /**\n     * @returns the priority of the text elements in the group.\n     */\n    get priority() {\n        return this.group.priority;\n    }\n    /**\n     * Updates the fading state of all text elements within the group to the specified time.\n     * @param time - The time to which the fading state will be updated.\n     * @param disableFading - `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time, disableFading) {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined) {\n                elementState.updateFading(time, disableFading);\n            }\n        }\n    }\n    /**\n     * Calls the specified callback for every visible text elements in the group.\n     * @param visibleElementsCallback - Functions that will be called for every visible text element\n     * in the group.\n     */\n    traverseVisibleElements(visibleElementsCallback) {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined && elementState.visible) {\n                visibleElementsCallback(elementState);\n            }\n        }\n    }\n    /**\n     * Updates the states of elements within the group.\n     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    updateElements(filter) {\n        for (const elementState of this.m_textElementStates) {\n            const textDistance = filter(elementState);\n            elementState.update(textDistance);\n        }\n    }\n    get size() {\n        return this.m_textElementStates.length;\n    }\n    /**\n     * Returns text element states.\n     * @returns Array of element states.\n     */\n    get textElementStates() {\n        return this.m_textElementStates;\n    }\n}\nexports.TextElementGroupState = TextElementGroupState;\n//# sourceMappingURL=TextElementGroupState.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementState.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementState.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLineMarkerElementState = exports.TextElementState = void 0;\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst LayoutState_1 = __webpack_require__(/*! ./LayoutState */ \"./node_modules/@here/harp-mapview/lib/text/LayoutState.js\");\nconst RenderState_1 = __webpack_require__(/*! ./RenderState */ \"./node_modules/@here/harp-mapview/lib/text/RenderState.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * `TextElementState` keeps the current state of a text element while it's being rendered.\n */\nclass TextElementState {\n    /**\n     *\n     * @param element - TextElement this state represents\n     * @param positionIndex - Optional index for TextElements of type LineMarker.\n     */\n    constructor(element, positionIndex) {\n        this.element = element;\n        this.m_lineMarkerIndex = positionIndex;\n    }\n    get initialized() {\n        return this.m_textRenderState !== undefined || this.m_iconRenderState !== undefined;\n    }\n    /**\n     * @returns `true` if any component of the element is visible, `false` otherwise.\n     */\n    get visible() {\n        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {\n            return true;\n        }\n        const iconRenderState = this.iconRenderState;\n        if (iconRenderState !== undefined && iconRenderState.isVisible()) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Return the last text placement used.\n     *\n     * If the text wasn't yet rendered or have no alternative placements it will fallback to\n     * style/theme based placement.\n     *\n     * @returns [[TextPlacement]] object containing vertical/horizontal align.\n     */\n    get textPlacement() {\n        const themeLayout = this.element.layoutStyle;\n        const stateLayout = this.m_textLayoutState;\n        // Would be good to test for persistence when getting state layout, but with this\n        // most of the isolated placement unit tests will fail.\n        const lastPlacement = stateLayout !== undefined\n            ? stateLayout.textPlacement\n            : {\n                h: harp_text_canvas_1.hPlacementFromAlignment(themeLayout.horizontalAlignment),\n                v: harp_text_canvas_1.vPlacementFromAlignment(themeLayout.verticalAlignment)\n            };\n        return lastPlacement;\n    }\n    /**\n     * Set text placement to be used.\n     *\n     * This may be base text anchor placement as defined by style or alternative placement.\n     *\n     * @param placement - The new [[TextPlacement]] to be used.\n     */\n    set textPlacement(placement) {\n        if (this.m_textLayoutState === undefined && this.isBaseTextPlacement(placement) === true) {\n            // Do nothing, layout state is not required cause we leave the base placement.\n            return;\n        }\n        if (this.m_textLayoutState === undefined) {\n            // State is not yet defined, but we have placement to store, either alternative or\n            // not yet specified in the context of layoutStyle.\n            this.m_textLayoutState = new LayoutState_1.LayoutState(placement);\n        }\n        else {\n            this.m_textLayoutState.textPlacement = placement;\n        }\n    }\n    /**\n     * Returns information if the text placement provided is the base one defined in style (theme).\n     *\n     * @param placement - The [[TextPlacement]] to check.\n     * @returns [[true]] if the placement provided is exactly the same as in theme base layout,\n     * [[false]] if it differs from the basic layout provided in style or\n     * [[undefined]] if the layout style is not yet defined so it is hard to say.\n     */\n    isBaseTextPlacement(placement) {\n        const themeLayout = this.element.layoutStyle;\n        if (themeLayout !== undefined) {\n            return (harp_text_canvas_1.hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment &&\n                harp_text_canvas_1.vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment);\n        }\n        return undefined;\n    }\n    /**\n     * Resets the element to an initialized state.\n     */\n    reset() {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.reset();\n        }\n        if (this.m_textLayoutState !== undefined) {\n            if (this.element.layoutStyle !== undefined) {\n                this.m_textLayoutState.reset(this.element.layoutStyle);\n            }\n            else {\n                this.m_textLayoutState = undefined;\n            }\n        }\n        if (this.iconRenderState) {\n            this.m_iconRenderState.reset();\n        }\n        this.m_viewDistance = undefined;\n        this.element.textBufferObject = undefined;\n        this.element.bounds = undefined;\n    }\n    /**\n     * Replaces given text element, inheriting its current state.\n     * The predecessor text element state is erased.\n     * @param predecessor - Text element state to be replaced.\n     */\n    replace(predecessor) {\n        this.m_textRenderState = predecessor.m_textRenderState;\n        this.m_textLayoutState = predecessor.m_textLayoutState;\n        this.m_iconRenderState = predecessor.m_iconRenderState;\n        predecessor.m_textRenderState = undefined;\n        predecessor.m_textLayoutState = undefined;\n        predecessor.m_iconRenderState = undefined;\n        if (this.element.glyphs === undefined) {\n            // Use the predecessor glyphs and case array until proper ones are computed.\n            this.element.glyphs = predecessor.element.glyphs;\n            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;\n        }\n        this.element.bounds = undefined;\n        this.element.textBufferObject = undefined;\n    }\n    /**\n     * Returns the last computed distance of the text element to the camera.\n     * @returns Distance to camera.\n     */\n    get viewDistance() {\n        return this.m_viewDistance;\n    }\n    /**\n     * Updates the text element state.\n     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    update(viewDistance) {\n        if (!this.initialized && viewDistance !== undefined) {\n            this.initializeRenderStates();\n        }\n        this.setViewDistance(viewDistance);\n    }\n    /**\n     * Sets the distance of the element to the current view center.\n     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    setViewDistance(viewDistance) {\n        this.m_viewDistance = viewDistance;\n    }\n    /**\n     * Return the last distance that has been computed for sorting during placement. This may not be\n     * the actual distance if the camera is moving, as the distance is computed only during\n     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.\n     *\n     * @returns 0 or negative distance to camera.\n     */\n    get renderDistance() {\n        return this.element.alwaysOnTop === true\n            ? 0\n            : this.m_viewDistance !== undefined\n                ? -this.m_viewDistance\n                : 0;\n    }\n    /**\n     * @returns The text render state.\n     */\n    get textRenderState() {\n        return this.m_textRenderState;\n    }\n    /**\n     * Returns the icon render state for the case where the text element has only one icon.\n     * @returns The icon render state if the text element has a single icon, otherwise undefined.\n     */\n    get iconRenderState() {\n        return this.m_iconRenderState;\n    }\n    /**\n     * Returns the index into the path of the TextElement if the TextElement is of type LineMarker,\n     * `undefined` otherwise.\n     */\n    get lineMarkerIndex() {\n        return this.m_lineMarkerIndex;\n    }\n    /**\n     * Returns the position of the TextElement. If this TextElementState belongs to a TextElement\n     * of type LineMarker, it returns the position of the marker at the references index in the\n     * path of the TextElement.\n     */\n    get position() {\n        return this.element.path !== undefined && this.m_lineMarkerIndex !== undefined\n            ? this.element.path[this.m_lineMarkerIndex]\n            : this.element.position;\n    }\n    /**\n     * Updates the fading state to the specified time.\n     * @param time - The current time.\n     * @param disableFading - If `True` there will be no fading transitions, i.e., state will go\n     * directly from FadedIn to FadedOut and vice versa.\n     */\n    updateFading(time, disableFading) {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.updateFading(time, disableFading);\n        }\n        if (this.iconRenderState !== undefined) {\n            this.iconRenderState.updateFading(time, disableFading);\n        }\n    }\n    /**\n     * Initialize text and icon render states\n     */\n    initializeRenderStates() {\n        var _a;\n        harp_utils_1.assert(this.m_textRenderState === undefined);\n        harp_utils_1.assert(this.m_textLayoutState === undefined);\n        harp_utils_1.assert(this.m_iconRenderState === undefined);\n        const { textFadeTime } = this.element;\n        this.m_textRenderState = new RenderState_1.RenderState(textFadeTime);\n        if (this.element.type === TextElementType_1.TextElementType.PoiLabel ||\n            this.element.type === TextElementType_1.TextElementType.LineMarker) {\n            // If there's no fade time for icon, use same as text to keep fading of text and icon\n            // in sync.\n            const techniqueIconFadeTime = (_a = this.element.poiInfo) === null || _a === void 0 ? void 0 : _a.technique.iconFadeTime;\n            const iconFadeTime = techniqueIconFadeTime !== undefined ? techniqueIconFadeTime * 1000 : textFadeTime;\n            this.m_iconRenderState = new RenderState_1.RenderState(iconFadeTime);\n        }\n    }\n}\nexports.TextElementState = TextElementState;\n/**\n * Test if the TextElement this {@link TextElementState} refers to is of type LineMarker.\n * @param state - Text element state to test.\n */\nfunction isLineMarkerElementState(state) {\n    return state.m_lineMarkerIndex !== undefined;\n}\nexports.isLineMarkerElementState = isLineMarkerElementState;\n//# sourceMappingURL=TextElementState.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementStateCache = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TextElementGroupState_1 = __webpack_require__(/*! ./TextElementGroupState */ \"./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js\");\nconst TextElementState_1 = __webpack_require__(/*! ./TextElementState */ \"./node_modules/@here/harp-mapview/lib/text/TextElementState.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextElementsStateCache\", { level: harp_utils_1.LogLevel.Log });\n/**\n * Label distance tolerance squared in meters. Point labels with the same name that are closer in\n * world space than this value are treated as the same label. Used to identify duplicate labels in\n * overlapping tiles and label replacements at different storage levels.\n */\nfunction getDedupSqDistTolerance(zoomLevel) {\n    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.\n    const minSqTol = 100;\n    const minSqTolLevel = 13;\n    const maxLevelDelta = 4;\n    const levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));\n    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a\n    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum\n    // tolerance zoom level.\n    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)\n    return minSqTol << (levelDelta << 2);\n}\nconst tmpCachedDuplicate = {\n    entries: [],\n    index: -1\n};\nfunction getCacheKey(element) {\n    return element.hasFeatureId() ? element.featureId : element.text;\n}\n/**\n * Finds a duplicate for a text element among a list of candidates using their feature ids.\n * @param elementState - The state of the text element for which the duplicate will be found.\n * @param candidates - The list of candidates to check.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateById(elementState, candidates) {\n    // Cached entries with same feature id found, find the entry with the same tile offset.\n    const element = elementState.element;\n    const duplicateIndex = candidates.findIndex(entry => entry.element.tileOffset === element.tileOffset);\n    if (duplicateIndex === -1) {\n        return -1;\n    }\n    const candidateElement = candidates[duplicateIndex];\n    const candidate = candidateElement.element;\n    harp_utils_1.assert(element.featureId === candidate.featureId);\n    if (candidate.text !== element.text) {\n        // Labels with different text shouldn't share the same feature id. This points to\n        // an issue on the map data side. Submit a ticket to the corresponding map backend\n        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),\n        // indicating affected labels including tile keys, texts and feature id.\n        logger.debug(`Text feature id ${element.featureId} collision between \"${element.text} and \\\n             ${candidate.text}`);\n        return undefined;\n    }\n    return duplicateIndex;\n}\n// Duplicate criteria for path labels. Candidates are better the longer their paths are.\nfunction isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {\n    if (newCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    if (oldCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;\n}\n// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being\n// tested for duplicates.\nfunction isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {\n    return newDistance < oldDistance;\n}\n/**\n * Finds a duplicate for a text element among a list of candidates using their text and distances.\n * @param elementState - The state of the text element for which the duplicate will be found.\n * @param candidates - The list of candidates to check.\n * @param zoomLevel - Current zoom level.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateByText(elementState, candidates, zoomLevel) {\n    const element = elementState.element;\n    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);\n    const entryCount = candidates.length;\n    const elementPosition = elementState.position;\n    const elementVisible = elementState.visible;\n    const isLineMarker = TextElementState_1.isLineMarkerElementState(elementState);\n    let dupIndex = -1;\n    let duplicate;\n    let dupDistSquared = Infinity;\n    const isBetterDuplicate = element.type === TextElementType_1.TextElementType.PathLabel ? isBetterPathDuplicate : isBetterPointDuplicate;\n    for (let i = 0; i < entryCount; ++i) {\n        const candidateEntry = candidates[i];\n        const cachedElement = candidateEntry.element;\n        const areDiffType = element.type !== cachedElement.type ||\n            isLineMarker !== TextElementState_1.isLineMarkerElementState(candidateEntry);\n        const areBothVisible = elementVisible && candidateEntry.visible;\n        if (areDiffType || areBothVisible) {\n            // Two text elements with different type or visible at the same time are always\n            // considered distinct.\n            continue;\n        }\n        const distSquared = elementPosition.distanceToSquared(cachedElement.position);\n        if (distSquared > maxSqDistError) {\n            // Cached text element is too far away to be a duplicate.\n            continue;\n        }\n        if (duplicate === undefined ||\n            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {\n            dupIndex = i;\n            duplicate = cachedElement;\n            dupDistSquared = distSquared;\n        }\n    }\n    return dupIndex;\n}\n/**\n * Caches the state of text element groups currently rendered as well as the text element states\n * belonging to them, including their fading state and text deduplication information.\n */\nclass TextElementStateCache {\n    constructor() {\n        this.m_referenceMap = new Map();\n        // Cache for point labels which may have duplicates in same tile or in neighboring tiles.\n        this.m_textMap = new Map();\n    }\n    /**\n     * Gets the state corresponding to a given text element group or sets a newly created state if\n     * not found. It updates the states of the text elements belonging to the group using the\n     * specified parameters.\n     * @param textElementGroup - The group of which the state will be obtained.\n     * @param tileKey - The key of the tile to which the group belongs.\n     * @param textElementFilter - Filter used to decide if a text element must be initialized,\n     * @see [[TextElementGroupState]] construction.\n     * @returns Tuple with the group state as first element and a boolean indicating whether the\n     * state was found in cache (`true`) or newly created (`false`) as second element.\n     */\n    getOrSet(textElementGroup, tileKey, textElementFilter) {\n        let groupState = this.get(textElementGroup);\n        if (groupState !== undefined) {\n            groupState.updateElements(textElementFilter);\n            return [groupState, true];\n        }\n        groupState = new TextElementGroupState_1.TextElementGroupState(textElementGroup, tileKey, textElementFilter);\n        this.set(textElementGroup, groupState);\n        return [groupState, false];\n    }\n    get size() {\n        return this.m_referenceMap.size;\n    }\n    /**\n     * @hidden\n     * @returns Size of internal cache for deduplication for debugging purposes.\n     */\n    get cacheSize() {\n        return this.m_textMap.size;\n    }\n    /**\n     * @returns All text element group states in the cache by group priority.\n     */\n    get sortedGroupStates() {\n        if (this.m_sortedGroupStates === undefined) {\n            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());\n            this.m_sortedGroupStates.sort((a, b) => {\n                return b.group.priority - a.group.priority;\n            });\n        }\n        harp_utils_1.assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);\n        return this.m_sortedGroupStates;\n    }\n    /**\n     * Updates state of all cached groups, discarding those that are not needed anymore.\n     * @param time - The current time.\n     * @param disableFading - `True` if fading is currently disabled, `false` otherwise.\n     * @param findReplacements - `True` to replace each visible unvisited text element with a\n     * visited duplicate.\n     * @param zoomLevel - Current zoom level.\n     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.\n     */\n    update(time, disableFading, findReplacements, zoomLevel) {\n        const replaceCallback = findReplacements\n            ? this.replaceElement.bind(this, zoomLevel)\n            : undefined;\n        let anyEviction = false;\n        for (const [key, groupState] of this.m_referenceMap.entries()) {\n            if (groupState.visited) {\n                groupState.updateFading(time, disableFading);\n            }\n            else {\n                if (findReplacements) {\n                    groupState.traverseVisibleElements(replaceCallback);\n                }\n                this.m_referenceMap.delete(key);\n                this.m_sortedGroupStates = undefined;\n                anyEviction = true;\n            }\n        }\n        return anyEviction;\n    }\n    /**\n     * Clears visited state for all text element groups in cache.\n     */\n    clearVisited() {\n        for (const groupState of this.m_referenceMap.values()) {\n            groupState.visited = false;\n        }\n    }\n    clearTextCache() {\n        this.m_textMap.clear();\n    }\n    /**\n     * Clears the whole cache contents.\n     */\n    clear() {\n        this.m_referenceMap.clear();\n        this.m_sortedGroupStates = undefined;\n        this.m_textMap.clear();\n    }\n    /**\n     * Removes duplicates for a given text element.\n     *\n     * @param zoomLevel - Current zoom level.\n     * @param elementState - State of the text element to deduplicate.\n     * @returns True if it's the remaining element after deduplication, false if it's been marked\n     * as duplicate.\n     */\n    deduplicateElement(zoomLevel, elementState) {\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n        if (cacheResult === undefined) {\n            // Text not found so far, add this element to cache.\n            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);\n            return true;\n        }\n        if (cacheResult.index === -1) {\n            // No duplicate found among elements with same text,add this one to cache.\n            cacheResult.entries.push(elementState);\n            return true;\n        }\n        // Duplicate found, check whether there's a label already visible and keep that one.\n        const cachedDuplicate = cacheResult.entries[cacheResult.index];\n        if (!cachedDuplicate.visible && elementState.visible) {\n            // New label is visible, substitute the cached label.\n            cacheResult.entries[cacheResult.index] = elementState;\n            cachedDuplicate.reset();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Replaces a visible unvisited text element with a visited duplicate.\n     * @param zoomLevel - Current zoom level.\n     * @param elementState - State of the text element to deduplicate.\n     * @returns `true` if an item from the cache has been reused and its state has been replaced,\n     * `false` otherwise.\n     */\n    replaceElement(zoomLevel, elementState) {\n        harp_utils_1.assert(elementState.visible);\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n        if (cacheResult === undefined || cacheResult.index === -1) {\n            // No replacement found;\n            return false;\n        }\n        const replacement = cacheResult.entries[cacheResult.index];\n        harp_utils_1.assert(!replacement.visible);\n        replacement.replace(elementState);\n        return true;\n    }\n    /**\n     * Gets the state corresponding to a given text element group.\n     * @param textElementGroup - The group of which the state will be obtained.\n     * @returns The group state if cached, otherwise `undefined`.\n     */\n    get(textElementGroup) {\n        const groupState = this.m_referenceMap.get(textElementGroup);\n        if (groupState !== undefined) {\n            groupState.visited = true;\n        }\n        return groupState;\n    }\n    /**\n     * Sets a specified state for a given text element group.\n     * @param textElementGroup -  The group of which the state will be set.\n     * @param textElementGroupState - The state to set for the group.\n     */\n    set(textElementGroup, textElementGroupState) {\n        harp_utils_1.assert(textElementGroup.elements.length > 0);\n        this.m_referenceMap.set(textElementGroup, textElementGroupState);\n        this.m_sortedGroupStates = undefined;\n    }\n    findDuplicate(elementState, zoomLevel) {\n        // Point labels may have duplicates (as can path labels), Identify them\n        // and keep the one we already display.\n        const element = elementState.element;\n        const cachedEntries = this.m_textMap.get(getCacheKey(element));\n        if (cachedEntries === undefined) {\n            // No labels found with the same key.\n            return undefined;\n        }\n        tmpCachedDuplicate.entries = cachedEntries;\n        const index = element.hasFeatureId()\n            ? findDuplicateById(elementState, cachedEntries)\n            : findDuplicateByText(elementState, cachedEntries, zoomLevel);\n        if (index === undefined) {\n            // Feature id collision, try finding duplicates using text as key.\n            element.featureId = undefined;\n            return this.findDuplicate(elementState, zoomLevel);\n        }\n        tmpCachedDuplicate.index = index;\n        return tmpCachedDuplicate;\n    }\n}\nexports.TextElementStateCache = TextElementStateCache;\n//# sourceMappingURL=TextElementStateCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementType = void 0;\n/**\n * Types of text elements.\n */\nvar TextElementType;\n(function (TextElementType) {\n    TextElementType[TextElementType[\"PoiLabel\"] = 0] = \"PoiLabel\";\n    TextElementType[TextElementType[\"PathLabel\"] = 1] = \"PathLabel\";\n    TextElementType[TextElementType[\"LineMarker\"] = 2] = \"LineMarker\";\n})(TextElementType = exports.TextElementType || (exports.TextElementType = {}));\n//# sourceMappingURL=TextElementType.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementType.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextElementsRenderer = exports.DEFAULT_TEXT_DISTANCE_SCALE = exports.DEFAULT_FONT_CATALOG_NAME = void 0;\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DebugContext_1 = __webpack_require__(/*! ../DebugContext */ \"./node_modules/@here/harp-mapview/lib/DebugContext.js\");\nconst overlayOnElevation_1 = __webpack_require__(/*! ../geometry/overlayOnElevation */ \"./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js\");\nconst PickHandler_1 = __webpack_require__(/*! ../PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\");\nconst PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ \"./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js\");\nconst ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ \"./node_modules/@here/harp-mapview/lib/ScreenCollisions.js\");\nconst FontCatalogLoader_1 = __webpack_require__(/*! ./FontCatalogLoader */ \"./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js\");\nconst Placement_1 = __webpack_require__(/*! ./Placement */ \"./node_modules/@here/harp-mapview/lib/text/Placement.js\");\nconst PlacementStats_1 = __webpack_require__(/*! ./PlacementStats */ \"./node_modules/@here/harp-mapview/lib/text/PlacementStats.js\");\nconst SimplePath_1 = __webpack_require__(/*! ./SimplePath */ \"./node_modules/@here/harp-mapview/lib/text/SimplePath.js\");\nconst TextCanvasFactory_1 = __webpack_require__(/*! ./TextCanvasFactory */ \"./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js\");\nconst TextElement_1 = __webpack_require__(/*! ./TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementsRendererOptions_1 = __webpack_require__(/*! ./TextElementsRendererOptions */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js\");\nconst TextElementStateCache_1 = __webpack_require__(/*! ./TextElementStateCache */ \"./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\nconst TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ \"./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js\");\nconst UpdateStats_1 = __webpack_require__(/*! ./UpdateStats */ \"./node_modules/@here/harp-mapview/lib/text/UpdateStats.js\");\nvar Pass;\n(function (Pass) {\n    Pass[Pass[\"PersistentLabels\"] = 0] = \"PersistentLabels\";\n    Pass[Pass[\"NewLabels\"] = 1] = \"NewLabels\";\n})(Pass || (Pass = {}));\nexports.DEFAULT_FONT_CATALOG_NAME = \"default\";\n/**\n * Default distance scale. Will be applied if distanceScale is not defined in the technique.\n * Defines the scale that will be applied to labeled icons (icon and text) in the distance.\n * @internal\n */\nexports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;\n/**\n * Maximum number of recommended labels. If more labels are encountered, the \"overloaded\" mode is\n * set, which modifies the behavior of label placement and rendering, trying to keep delivering an\n * interactive performance. The overloaded mode should not be activated if the {@link MapView} is\n * rendering a static image (camera not moving and no animation running).\n */\nconst OVERLOAD_LABEL_LIMIT = 20000;\n/**\n * If \"overloaded\" is `true`:\n *\n * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the\n * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATED_LABEL_LIMIT = 100;\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATE_TIME_LIMIT = 5;\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_PLACE_TIME_LIMIT = 10;\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextElementsRenderer\", { level: harp_utils_1.LogLevel.Log });\n// Development flag: Enable debug print.\nconst PRINT_LABEL_DEBUG_INFO = false;\nconst updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats_1.UpdateStats(logger) : undefined;\nconst placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats_1.PlacementStats(logger) : undefined;\nconst tempPosition = new THREE.Vector3();\nconst tempScreenPosition = new THREE.Vector2();\nconst tempScreenPoints = [];\nconst tempPoiScreenPosition = new THREE.Vector2();\nconst tmpTextBufferCreationParams = {};\nconst tmpAdditionParams = {};\nconst tmpBufferAdditionParams = {};\nconst cache = {\n    vector2: [new THREE.Vector2()]\n};\nclass TileTextElements {\n    constructor(tile, group) {\n        this.tile = tile;\n        this.group = group;\n    }\n}\nclass TextElementLists {\n    constructor(lists) {\n        this.lists = lists;\n    }\n    get priority() {\n        harp_utils_1.assert(this.lists.length > 0);\n        // All text element lists here have the same priority.\n        return this.lists[0].group.priority;\n    }\n    /**\n     * Sum up the number of elements in all lists.\n     */\n    count() {\n        let n = 0;\n        for (const list of this.lists) {\n            n += list.group.elements.length;\n        }\n        return n;\n    }\n}\nfunction checkIfTextElementsChanged(dataSourceTileList) {\n    let textElementsChanged = false;\n    dataSourceTileList.forEach(({ renderedTiles }) => {\n        renderedTiles.forEach(tile => {\n            if (tile.textElementsChanged) {\n                tile.textElementsChanged = false;\n                textElementsChanged = true;\n            }\n        });\n    });\n    return textElementsChanged;\n}\nfunction hasTextElements(dataSourceTileList) {\n    for (let i = 0; i < dataSourceTileList.length; i++) {\n        for (const [_key, value] of dataSourceTileList[i].renderedTiles) {\n            if (value.hasTextElements()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction addTextToCanvas(textElement, canvas, screenPosition, path, pathOverflow) {\n    tmpAdditionParams.path = path;\n    tmpAdditionParams.pathOverflow = pathOverflow;\n    tmpAdditionParams.layer = textElement.renderOrder;\n    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;\n    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addText(textElement.glyphs, screenPosition, tmpAdditionParams);\n}\nfunction addTextBufferToCanvas(textElementState, canvas, screenPosition, fadeFactor, scaleFactor) {\n    const textElement = textElementState.element;\n    const textRenderState = textElementState.textRenderState;\n    const opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;\n    if (opacity === 0) {\n        return false;\n    }\n    // Compute the TextBufferObject when we know we're gonna render this label.\n    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;\n    if (textElement.textBufferObject === undefined) {\n        textElement.textBufferObject = canvas.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);\n    }\n    const backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 &&\n        canvas.textRenderStyle.fontSize.backgroundSize > 0;\n    tmpBufferAdditionParams.layer = textElement.renderOrder;\n    tmpBufferAdditionParams.position = screenPosition;\n    tmpBufferAdditionParams.scale = scaleFactor;\n    tmpBufferAdditionParams.opacity = opacity;\n    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible\n        ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity\n        : 0.0;\n    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);\n    return true;\n}\nfunction shouldRenderPointText(labelState, viewState, options) {\n    const textRenderState = labelState.textRenderState;\n    const label = labelState.element;\n    const poiInfo = label.poiInfo;\n    harp_utils_1.assert(label.type !== TextElementType_1.TextElementType.PathLabel);\n    const hasText = textRenderState !== undefined && label.text !== \"\";\n    if (!hasText) {\n        return false;\n    }\n    const visibleInZoomLevel = poiInfo === undefined ||\n        harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, poiInfo.textMinZoomLevel, poiInfo.textMaxZoomLevel);\n    if (!visibleInZoomLevel) {\n        return false;\n    }\n    const poiTextMaxDistance = Placement_1.getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);\n    const visibleAtDistance = label.ignoreDistance === true ||\n        labelState.viewDistance === undefined ||\n        (labelState.viewDistance < poiTextMaxDistance && labelState.viewDistance > 0);\n    if (!visibleAtDistance) {\n        return false;\n    }\n    // If there's an icon, render text only if icon is valid or optional.\n    return !poiInfo || poiInfo.isValid === true || poiInfo.iconIsOptional === true;\n}\nfunction shouldRenderPoiText(labelState, viewState) {\n    // Do not actually render (just allocate space) if camera is moving and\n    // renderTextDuringMovements is not true.\n    const poiInfo = labelState.element.poiInfo;\n    return (!viewState.cameraIsMoving ||\n        poiInfo === undefined ||\n        poiInfo.renderTextDuringMovements === true);\n}\nfunction isPlacementTimeExceeded(startTime) {\n    // startTime is set in overload mode.\n    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {\n        return false;\n    }\n    const endTime = harp_utils_1.PerformanceTimer.now();\n    const elapsedTime = endTime - startTime;\n    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {\n        logger.debug(\"Placement time limit exceeded.\");\n        return true;\n    }\n    return false;\n}\nfunction createDefaultFontCatalogConfig(defaultFontCatalogUrl) {\n    return {\n        name: exports.DEFAULT_FONT_CATALOG_NAME,\n        url: defaultFontCatalogUrl\n    };\n}\n/**\n *\n * Internal class to manage all text rendering.\n */\nclass TextElementsRenderer {\n    /**\n     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as\n     * a preprocessing step, which is not done every frame, and also renders the placed\n     * {@link TextElement}s every frame.\n     *\n     * @param m_viewState - State of the view for which this renderer will draw text.\n     * @param m_viewUpdateCallback - To be called whenever the view needs to be updated.\n     * @param m_screenProjector - Projects 3D coordinates into screen space.\n     * @param m_poiManager - To prepare pois for rendering.\n     * @param m_renderer - The renderer to be used.\n     * @param m_imageCaches - The Image Caches to look for Icons.\n     * @param options - Configuration options for the text renderer. See\n     * @param textCanvasFactory - Optional A TextCanvasFactory to override the default.\n     * @param poiRenderer - Optional A PoiRenderer to override the default.\n     * @param screenCollisions - Optional  ScreenCollisions to override the default.\n     * [[TextElementsRendererOptions]].\n     */\n    constructor(m_viewState, m_viewUpdateCallback, m_screenProjector, m_poiManager, m_renderer, m_imageCaches, options, textCanvasFactory, poiRenderer, screenCollisions) {\n        this.m_viewState = m_viewState;\n        this.m_viewUpdateCallback = m_viewUpdateCallback;\n        this.m_screenProjector = m_screenProjector;\n        this.m_poiManager = m_poiManager;\n        this.m_renderer = m_renderer;\n        this.m_imageCaches = m_imageCaches;\n        this.m_loadPromisesCount = 0;\n        this.m_textCanvases = new Map();\n        this.m_tmpVector = new THREE.Vector2();\n        this.m_tmpVector3 = new THREE.Vector3();\n        this.m_cameraLookAt = new THREE.Vector3();\n        this.m_overloaded = false;\n        this.m_cacheInvalidated = false;\n        this.m_forceNewLabelsPass = false;\n        this.m_addNewLabels = true;\n        this.m_textElementStateCache = new TextElementStateCache_1.TextElementStateCache();\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1);\n        this.m_textStyleCache = new TextStyleCache_1.TextStyleCache();\n        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();\n        this.m_options = Object.assign({}, options);\n        TextElementsRendererOptions_1.initializeDefaultOptions(this.m_options);\n        if (screenCollisions) {\n            this.m_screenCollisions = screenCollisions;\n        }\n        else if (this.m_options.collisionDebugCanvas !== undefined &&\n            this.m_options.collisionDebugCanvas !== null) {\n            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_options.collisionDebugCanvas);\n        }\n        this.m_textCanvasFactory = textCanvasFactory !== null && textCanvasFactory !== void 0 ? textCanvasFactory : new TextCanvasFactory_1.TextCanvasFactory(this.m_renderer);\n        this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);\n        this.m_poiRenderer = poiRenderer !== null && poiRenderer !== void 0 ? poiRenderer : new PoiRenderer_1.PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);\n        this.initializeCamera();\n        this.initializeDefaultFontCatalog();\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n    /**\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable) {\n        this.m_options.disableFading = disable;\n    }\n    get disableFading() {\n        return this.m_options.disableFading === true;\n    }\n    get styleCache() {\n        return this.m_textStyleCache;\n    }\n    get delayLabelsUntilMovementFinished() {\n        return this.m_options.delayLabelsUntilMovementFinished === true;\n    }\n    set delayLabelsUntilMovementFinished(delay) {\n        this.m_options.delayLabelsUntilMovementFinished = delay;\n    }\n    /**\n     * If `true`, a replacement glyph (\"?\") is rendered for every missing glyph.\n     */\n    get showReplacementGlyphs() {\n        return this.m_options.showReplacementGlyphs === true;\n    }\n    /**\n     * If `true`, a replacement glyph (\"?\") is rendered for every missing glyph.\n     */\n    set showReplacementGlyphs(value) {\n        this.m_options.showReplacementGlyphs = value;\n        this.m_textCanvases.forEach(textCanvas => {\n            if (textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.fontCatalog) {\n                textCanvas.fontCatalog.showReplacementGlyphs = value;\n            }\n        });\n    }\n    restoreRenderers(renderer) {\n        this.m_renderer = renderer;\n        this.m_poiRenderer = new PoiRenderer_1.PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);\n        //TODO: restore TextCanvasRenderers\n    }\n    /**\n     * Updates the FontCatalogs used by this {@link TextElementsRenderer}.\n     *\n     * @param fontCatalogs - The new list of {@link FontCatalogConfig}s\n     */\n    async updateFontCatalogs(fontCatalogs) {\n        if (this.m_defaultFontCatalogConfig) {\n            if (!fontCatalogs ||\n                fontCatalogs.findIndex(config => {\n                    return config.name === exports.DEFAULT_FONT_CATALOG_NAME;\n                }) === -1) {\n                // not other default catalog available, keep the old one\n                if (!fontCatalogs) {\n                    fontCatalogs = [];\n                }\n                // Never remove the default Canvas if set per configuration\n                fontCatalogs.unshift(this.m_defaultFontCatalogConfig);\n            }\n            else {\n                if (this.m_textCanvases.has(exports.DEFAULT_FONT_CATALOG_NAME)) {\n                    this.m_textCanvases.delete(exports.DEFAULT_FONT_CATALOG_NAME);\n                }\n            }\n        }\n        if (fontCatalogs && fontCatalogs.length > 0) {\n            // Remove obsolete ones\n            for (const [name] of this.m_textCanvases) {\n                if (fontCatalogs.findIndex(catalog => {\n                    return catalog.name === name;\n                }) < 0) {\n                    this.m_textCanvases.delete(name);\n                }\n            }\n            // Add new catalogs\n            for (const fontCatalog of fontCatalogs) {\n                await this.addTextCanvas(fontCatalog);\n            }\n        }\n        else {\n            this.m_textCanvases.clear();\n        }\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n    async updateTextStyles(textStyles, defaultTextStyle) {\n        this.m_textStyleCache.updateTextStyles(textStyles, defaultTextStyle);\n        await this.waitLoaded();\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n    /**\n     * Render the text using the specified camera into the current canvas.\n     *\n     * @param camera - Orthographic camera to use.\n     */\n    renderText(farPlane) {\n        this.m_camera.far = farPlane;\n        this.updateGlyphDebugMesh();\n        let previousLayer;\n        this.m_poiRenderer.update();\n        for (const poiLayer of this.m_poiRenderer.layers) {\n            for (const [, textCanvas] of this.m_textCanvases) {\n                textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.render(this.m_camera, previousLayer === null || previousLayer === void 0 ? void 0 : previousLayer.id, poiLayer.id, undefined, false);\n            }\n            this.m_poiRenderer.render(this.m_camera, poiLayer);\n            previousLayer = poiLayer;\n        }\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.render(this.m_camera, previousLayer === null || previousLayer === void 0 ? void 0 : previousLayer.id, undefined, undefined, false);\n        }\n    }\n    /**\n     * Forces update of text elements in the next call to [[placeText]].\n     */\n    invalidateCache() {\n        this.m_cacheInvalidated = true;\n    }\n    /**\n     * Notify `TextElementsRenderer` that the camera has started a movement.\n     */\n    movementStarted() {\n        if (this.delayLabelsUntilMovementFinished) {\n            this.m_addNewLabels = false;\n        }\n    }\n    /**\n     * Notify `TextElementsRenderer` that the camera has finished its movement.\n     */\n    movementFinished() {\n        this.invalidateCache();\n        if (this.delayLabelsUntilMovementFinished) {\n            this.m_addNewLabels = true;\n        }\n    }\n    /**\n     * Is `true` if number of {@link TextElement}s in visible tiles is larger than the recommended\n     * number `OVERLOAD_LABEL_LIMIT`.\n     */\n    get overloaded() {\n        return this.m_overloaded;\n    }\n    /**\n     * Places text elements for the current frame.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     * @param time - Current frame time.\n     */\n    placeText(dataSourceTileList, time) {\n        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);\n        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged || hasTextElements(dataSourceTileList);\n        if (!textElementsAvailable &&\n            !this.m_cacheInvalidated &&\n            !this.m_viewState.renderedTilesChanged) {\n            return;\n        }\n        const updateTextElements = this.m_cacheInvalidated ||\n            tileTextElementsChanged ||\n            this.m_viewState.renderedTilesChanged;\n        const findReplacements = updateTextElements && this.m_addNewLabels;\n        if (findReplacements) {\n            this.m_textElementStateCache.clearVisited();\n            this.updateTextElements(dataSourceTileList);\n        }\n        const anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);\n        // TODO: this seems extremly suboptimal.. review if an update is possible\n        this.reset();\n        if (this.m_addNewLabels) {\n            this.prepopulateScreenWithBlockingElements(dataSourceTileList);\n        }\n        // New text elements must be placed either if text elements were updated in this frame\n        // or if any text element group was evicted. The second case happens when the group is not\n        // visited anymore and all it's elements just became invisible, which means there's newly\n        // available screen space where new text elements could be placed. A common scenario where\n        // this happens is zooming in/out: text groups from the old level may still be fading out\n        // after all groups in the new level were updated.\n        const placeNewTextElements = (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;\n        this.placeTextElements(time, placeNewTextElements);\n        this.placeOverlayTextElements();\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    addOverlayText(textElements) {\n        if (textElements.length === 0) {\n            return;\n        }\n        this.m_overlayTextElements =\n            this.m_overlayTextElements === undefined\n                ? textElements.slice()\n                : this.m_overlayTextElements.concat(textElements);\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    clearOverlayText() {\n        this.m_overlayTextElements = [];\n    }\n    /**\n     * @returns Whether there's overlay text to be rendered.\n     */\n    hasOverlayText() {\n        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;\n    }\n    get overlayText() {\n        return this.m_overlayTextElements;\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link TextElement}s are found, the order of the results is unspecified.\n     *\n     * Note: {@link TextElement}s with identical `featureId` or\n     * identical `userData` will only appear\n     * once in the list `pickResults`.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickResults - Array filled with pick results.\n     */\n    pickTextElements(screenPosition, pickListener) {\n        const pickHandler = (pickData, pickObjectType) => {\n            if (pickData === undefined) {\n                return;\n            }\n            const textElement = pickData;\n            const pickResult = {\n                type: pickObjectType,\n                point: screenPosition,\n                distance: 0,\n                renderOrder: textElement.renderOrder,\n                featureId: textElement.featureId,\n                userData: textElement.userData,\n                text: textElement.text\n            };\n            pickListener.addResult(pickResult);\n        };\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.pickText(screenPosition, (pickData) => {\n                pickHandler(pickData, PickHandler_1.PickObjectType.Text);\n            });\n        }\n        this.m_poiRenderer.pickTextElements(screenPosition, (pickData) => {\n            pickHandler(pickData, PickHandler_1.PickObjectType.Icon);\n        });\n    }\n    /**\n     * `true` if any resource used by any `FontCatalog` is still loading.\n     */\n    get loading() {\n        return this.m_loadPromisesCount > 0;\n    }\n    /**\n     * Waits till all pending resources from any `FontCatalog` are loaded.\n     */\n    async waitLoaded() {\n        if (this.m_loadPromise !== undefined) {\n            return await this.m_loadPromise;\n        }\n    }\n    /**\n     * Reset the current text render states of all visible tiles.\n     *\n     * @remarks\n     * All {@link TextElement}s will fade in\n     * after that as if they have just been added.\n     */\n    clearRenderStates() {\n        this.m_textElementStateCache.clear();\n    }\n    /**\n     * Return memory used by all objects managed by `TextElementsRenderer`.\n     *\n     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.\n     */\n    getMemoryUsage() {\n        const memoryUsage = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.getMemoryUsage(memoryUsage);\n        }\n        this.m_poiRenderer.getMemoryUsage(memoryUsage);\n        return memoryUsage;\n    }\n    async addDefaultTextCanvas() {\n        if (this.m_textCanvases.has(exports.DEFAULT_FONT_CATALOG_NAME) ||\n            !this.m_defaultFontCatalogConfig) {\n            return;\n        }\n        await this.addTextCanvas(this.m_defaultFontCatalogConfig);\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n    /**\n     * Reset internal state at the beginning of a frame.\n     */\n    reset() {\n        this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);\n        this.m_screenCollisions.reset();\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.clear();\n        }\n        this.m_poiRenderer.reset();\n    }\n    /**\n     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].\n     * @note These boxes have highest priority, so will block all other labels.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     */\n    prepopulateScreenWithBlockingElements(dataSourceTileList) {\n        const boxes = [];\n        dataSourceTileList.forEach(renderListEntry => {\n            const startLinePointProj = new THREE.Vector3();\n            const endLinePointProj = new THREE.Vector3();\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                for (const pathBlockingElement of tile.blockingElements) {\n                    if (pathBlockingElement.points.length < 2) {\n                        continue;\n                    }\n                    this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);\n                    for (let i = 1; i < pathBlockingElement.points.length; i++) {\n                        this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);\n                        const line = pathBlockingElement.screenSpaceLines[i - 1];\n                        line.start.copy(startLinePointProj);\n                        line.end.copy(endLinePointProj);\n                        const lineWithBound = {\n                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),\n                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),\n                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),\n                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),\n                            line\n                        };\n                        boxes.push(lineWithBound);\n                        startLinePointProj.copy(endLinePointProj);\n                    }\n                }\n            }\n        });\n        this.m_screenCollisions.allocateIBoxes(boxes);\n    }\n    /**\n     * @returns True if whole group was processed for placement,\n     * false otherwise (e.g. placement limit reached).\n     */\n    placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {\n        var _a;\n        // Unvisited text elements are never placed.\n        harp_utils_1.assert(groupState.visited);\n        const shieldGroups = [];\n        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;\n        const projection = this.m_viewState.projection;\n        const elevationProvider = this.m_viewState.elevationProvider;\n        const elevationMap = elevationProvider === null || elevationProvider === void 0 ? void 0 : elevationProvider.getDisplacementMap(groupState.tileKey);\n        for (const textElementState of groupState.textElementStates) {\n            if (pass === Pass.PersistentLabels) {\n                if (placementStats) {\n                    ++placementStats.total;\n                }\n            }\n            // Limit labels only in new labels pass (Pass.NewLabels).\n            else if (maxNumPlacedLabels >= 0 &&\n                renderParams.numRenderedTextElements >= maxNumPlacedLabels) {\n                logger.debug(\"Placement label limit exceeded.\");\n                return false;\n            }\n            // Skip all labels that are not initialized (didn't pass early placement tests)\n            // or don't belong to this pass.\n            if (!textElementState.initialized) {\n                if (placementStats) {\n                    ++placementStats.uninitialized;\n                }\n                continue;\n            }\n            if (textElementState.viewDistance === undefined || textElementState.viewDistance < 0) {\n                if (placementStats) {\n                    ++placementStats.tooFar;\n                }\n                continue;\n            }\n            const elementVisible = textElementState.visible;\n            if ((pass === Pass.PersistentLabels && !elementVisible) ||\n                (pass === Pass.NewLabels && elementVisible)) {\n                continue;\n            }\n            const textElement = textElementState.element;\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.\n            // Check if the label should be hidden.\n            if (hiddenKinds !== undefined &&\n                textElement.kind !== undefined &&\n                hiddenKinds.hasOrIntersects(textElement.kind)) {\n                continue;\n            }\n            if (elevationProvider !== undefined && !textElement.elevated) {\n                if (!elevationMap) {\n                    this.m_viewUpdateCallback(); // Update view until elevation is loaded.\n                    this.m_forceNewLabelsPass = true;\n                    continue;\n                }\n                overlayOnElevation_1.overlayTextElement(textElement, elevationProvider, elevationMap, projection);\n            }\n            const elementType = textElement.type;\n            const isPathLabel = elementType === TextElementType_1.TextElementType.PathLabel;\n            // For paths, check if the label may fit.\n            if (isPathLabel) {\n                if (Placement_1.isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {\n                    if (placementStats) {\n                        placementStats.numNotVisible++;\n                    }\n                    if (textElement.dbgPathTooSmall === true) {\n                        if (placementStats) {\n                            placementStats.numPathTooSmall++;\n                        }\n                    }\n                    textElementState.reset();\n                    continue;\n                }\n            }\n            const forceNewPassOnLoaded = true;\n            if (textCanvas) {\n                // This ensures that textElement.renderStyle and textElement.layoutStyle are\n                // already instantiated and initialized with theme style values.\n                if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {\n                    continue;\n                }\n                const layer = textCanvas.getLayer((_a = textElement.renderOrder) !== null && _a !== void 0 ? _a : harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);\n                // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n                if (layer !== undefined) {\n                    if (layer.storage.drawCount + textElement.glyphs.length >\n                        layer.storage.capacity) {\n                        if (placementStats) {\n                            ++placementStats.numCannotAdd;\n                        }\n                        logger.warn(\"layer glyph storage capacity exceeded.\");\n                        continue;\n                    }\n                }\n                // Set the current style for the canvas.\n                // This means text canvas has always references (not a copy) to text element styles.\n                // The only exception is multi-anchor placement where layoutStyle need to be\n                // modified and thus textCanvas will using its own copy of textElement.layoutStyle.\n                // See: placePointLabel()\n                textCanvas.textRenderStyle = textElement.renderStyle;\n                textCanvas.textLayoutStyle = textElement.layoutStyle;\n            }\n            switch (elementType) {\n                case TextElementType_1.TextElementType.PoiLabel:\n                    this.addPoiLabel(textElementState, textCanvas, renderParams);\n                    break;\n                case TextElementType_1.TextElementType.LineMarker:\n                    this.addLineMarkerLabel(textElementState, shieldGroups, textCanvas, renderParams);\n                    break;\n                case TextElementType_1.TextElementType.PathLabel:\n                    if (textCanvas) {\n                        this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);\n                    }\n            }\n        }\n        return true;\n    }\n    initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {\n        // Trigger the glyph load if needed.\n        if (textElement.loadingState === TextElement_1.LoadingState.Initialized) {\n            return textElement.glyphs !== undefined;\n        }\n        harp_utils_1.assert(textElementStyle.textCanvas !== undefined);\n        const textCanvas = textElementStyle.textCanvas;\n        if (textElement.loadingState === undefined) {\n            textElement.loadingState = TextElement_1.LoadingState.Requested;\n            if (textElement.renderStyle === undefined) {\n                textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, textElementStyle.renderParams), textElement.renderParams));\n            }\n            if (textElement.layoutStyle === undefined) {\n                textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, textElementStyle.layoutParams), textElement.layoutParams));\n            }\n            if (textElement.text === \"\") {\n                textElement.loadingState = TextElement_1.LoadingState.Loaded;\n            }\n            else {\n                const newLoadPromise = textCanvas.fontCatalog\n                    .loadCharset(textElement.text, textElement.renderStyle)\n                    .then(() => {\n                    --this.m_loadPromisesCount;\n                    textElement.loadingState = TextElement_1.LoadingState.Loaded;\n                    // Ensure that text elements still loading glyphs get a chance to\n                    // be rendered if there's no text element updates in the next frames.\n                    this.m_forceNewLabelsPass =\n                        this.m_forceNewLabelsPass || forceNewPassOnLoaded;\n                    this.m_viewUpdateCallback();\n                });\n                if (this.m_loadPromisesCount === 0) {\n                    this.m_loadPromise = undefined;\n                }\n                ++this.m_loadPromisesCount;\n                this.m_loadPromise =\n                    this.m_loadPromise === undefined\n                        ? newLoadPromise\n                        : Promise.all([this.m_loadPromise, newLoadPromise]);\n            }\n        }\n        if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {\n            textCanvas.textRenderStyle = textElement.renderStyle;\n            textCanvas.textLayoutStyle = textElement.layoutStyle;\n            textElement.glyphCaseArray = [];\n            textElement.bounds = undefined;\n            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);\n            textElement.loadingState = TextElement_1.LoadingState.Initialized;\n        }\n        // Return true as soon as a text element has some glyphs assigned so that it's rendered.\n        // The glyphs may be either the final ones or some temporal glyphs inherited from a\n        // predecessor as part of the text element replacement process.\n        // See TextElementState.replace().\n        return textElement.glyphs !== undefined;\n    }\n    initializeCamera() {\n        this.m_camera.position.z = 1;\n        this.m_camera.near = 0;\n    }\n    updateCamera() {\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.left = width / -2;\n        this.m_camera.right = width / 2;\n        this.m_camera.bottom = height / -2;\n        this.m_camera.top = height / 2;\n        this.m_camera.updateProjectionMatrix();\n        this.m_camera.updateMatrixWorld(false);\n        this.m_screenCollisions.update(width, height);\n    }\n    initializeDefaultFontCatalog() {\n        if (this.m_options.fontCatalog) {\n            this.m_defaultFontCatalogConfig = createDefaultFontCatalogConfig(this.m_options.fontCatalog);\n            this.addDefaultTextCanvas();\n        }\n    }\n    async addTextCanvas(fontCatalogConfig) {\n        const catalogCallback = (name, catalog) => {\n            if (this.m_textCanvases.has(name)) {\n                const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog, name);\n                catalog.showReplacementGlyphs = this.showReplacementGlyphs;\n                // Check if the textCanvas has not been removed in the meantime\n                this.m_textCanvases.set(name, loadedTextCanvas);\n            }\n        };\n        const errorCallback = () => {\n            this.m_textCanvases.delete(fontCatalogConfig.name);\n        };\n        if (this.m_textCanvases.has(fontCatalogConfig.name)) {\n            return Promise.resolve();\n        }\n        else {\n            // Reserve map space, until loaded or error\n            this.m_textCanvases.set(fontCatalogConfig.name, undefined);\n            const newLoadPromise = FontCatalogLoader_1.loadFontCatalog(fontCatalogConfig, catalogCallback, errorCallback)\n                .then(() => {\n                --this.m_loadPromisesCount;\n                this.m_viewUpdateCallback();\n            })\n                .catch(error => {\n                logger.info(\"rendering without font catalog, only icons possible\", error);\n                --this.m_loadPromisesCount;\n            });\n            if (this.m_loadPromisesCount === 0) {\n                this.m_loadPromise = undefined;\n            }\n            ++this.m_loadPromisesCount;\n            this.m_loadPromise =\n                this.m_loadPromise === undefined\n                    ? newLoadPromise\n                    : Promise.all([this.m_loadPromise, newLoadPromise]);\n            return newLoadPromise;\n        }\n    }\n    updateGlyphDebugMesh() {\n        const debugGlyphs = DebugContext_1.debugContext.getValue(\"DEBUG_GLYPHS\");\n        if (debugGlyphs === undefined) {\n            return;\n        }\n        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {\n            this.initializeGlyphDebugMesh();\n        }\n        harp_utils_1.assert(this.m_debugGlyphTextureCacheMesh !== undefined);\n        harp_utils_1.assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);\n        this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;\n        this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;\n    }\n    initializeGlyphDebugMesh() {\n        if (this.m_textCanvases.size === 0) {\n            return;\n        }\n        const defaultTextCanvas = this.m_textCanvases.values().next().value;\n        const defaultFontCatalog = defaultTextCanvas.fontCatalog;\n        // Initialize glyph-debugging mesh.\n        const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);\n        const material = new THREE.MeshBasicMaterial({\n            transparent: true,\n            depthWrite: false,\n            depthTest: false,\n            map: defaultFontCatalog.texture\n        });\n        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);\n        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;\n        this.m_debugGlyphTextureCacheMesh.visible = false;\n        this.m_debugGlyphTextureCacheMesh.name = \"glyphDebug\";\n        const wireframe = new THREE.WireframeGeometry(planeGeometry);\n        const wireframeMaterial = new THREE.LineBasicMaterial({\n            transparent: true,\n            color: 0x999999,\n            depthWrite: false,\n            depthTest: false\n        });\n        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);\n        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;\n        this.m_debugGlyphTextureCacheWireMesh.visible = false;\n        this.m_debugGlyphTextureCacheWireMesh.name = \"glyphDebug\";\n        defaultTextCanvas\n            .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)\n            .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);\n    }\n    /**\n     * Visit all visible tiles and add/ their text elements to cache.\n     *\n     * @remarks\n     * The update of {@link TextElement}s is a time consuming process,\n     * and cannot be done every frame, but should only\n     * be done when the camera moved (a lot) of whenever the set of visible tiles change.\n     *\n     * The actually rendered {@link TextElement}s are stored internally\n     * until the next update is done\n     * to speed up rendering when no camera movement was detected.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     */\n    updateTextElements(dataSourceTileList) {\n        if (updateStats) {\n            updateStats.clear();\n        }\n        this.m_textElementStateCache.clearTextCache();\n        this.m_cacheInvalidated = false;\n        this.checkIfOverloaded(dataSourceTileList);\n        // Used with tile offset to compute the x coordinate offset for tiles.\n        const updateStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;\n        // TODO: HARP-7648. Skip all data sources that won't contain text.\n        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones\n        // across all data sources.\n        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,\n        // including fallbacks if necessary) instead of visible tiles (target tiles that might not\n        // be decoded yet).\n        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out\n        // and back in) due to the delay in decoding the visible tiles.\n        dataSourceTileList.forEach(tileList => {\n            this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), updateStartTime);\n        });\n        if (updateStats) {\n            updateStats.log();\n        }\n    }\n    updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, updateStartTime) {\n        if (updateStats) {\n            updateStats.tiles += visibleTiles.length;\n        }\n        const sortedTiles = visibleTiles;\n        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?\n        sortedTiles.sort((a, b) => {\n            return a.tileKey.mortonCode() - b.tileKey.mortonCode();\n        });\n        const sortedGroups = [];\n        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);\n        let numTextElementsUpdated = 0;\n        for (const textElementLists of sortedGroups) {\n            this.selectTextElementsToUpdateByDistance(textElementLists);\n            // The value of updateStartTime is set if this.overloaded is true.\n            if (updateStartTime !== undefined) {\n                // If overloaded and all time is used up, exit early.\n                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {\n                    const endTime = harp_utils_1.PerformanceTimer.now();\n                    const elapsedTime = endTime - updateStartTime;\n                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {\n                        logger.debug(\"Update time limit exceeded.\");\n                        break;\n                    }\n                }\n                // Try not to update too many elements. They will be checked for visibility each\n                // frame.\n                numTextElementsUpdated += textElementLists.count();\n                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {\n                    logger.debug(\"Update label limit exceeded.\");\n                    break;\n                }\n            }\n        }\n    }\n    prepareTextElementGroup(textElementGroup, tileKey, maxViewDistance) {\n        if (textElementGroup.elements.length === 0) {\n            return;\n        }\n        const textElementSelection = (textElementState) => {\n            let { result, viewDistance } = Placement_1.checkReadyForPlacement(textElementState.element, textElementState.element.type === TextElementType_1.TextElementType.LineMarker\n                ? textElementState.lineMarkerIndex\n                : undefined, this.m_viewState, this.m_poiManager, maxViewDistance);\n            if (result === Placement_1.PrePlacementResult.Ok &&\n                !this.m_textElementStateCache.deduplicateElement(this.m_viewState.zoomLevel, textElementState)) {\n                result = Placement_1.PrePlacementResult.Duplicate;\n                viewDistance = undefined;\n            }\n            if (updateStats) {\n                updateStats.totalLabels++;\n                updateStats.results[result]++;\n            }\n            return viewDistance;\n        };\n        const [, found] = this.m_textElementStateCache.getOrSet(textElementGroup, tileKey, textElementSelection);\n        if (updateStats) {\n            ++updateStats.totalGroups;\n            if (!found) {\n                ++updateStats.newGroups;\n            }\n        }\n    }\n    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {\n        if (sortedTiles.length === 0) {\n            return;\n        }\n        const tilesToRender = [];\n        for (const tile of sortedTiles) {\n            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {\n                tilesToRender.push(tile);\n            }\n        }\n        const groupedPriorityLists = new Map();\n        for (const tile of tilesToRender) {\n            for (const group of tile.textElementGroups.groups.values()) {\n                if (group.elements.length === 0) {\n                    continue;\n                }\n                const foundGroup = groupedPriorityLists.get(group.priority);\n                if (foundGroup === undefined) {\n                    groupedPriorityLists.set(group.priority, new TextElementLists([new TileTextElements(tile, group)]));\n                }\n                else {\n                    foundGroup.lists.push(new TileTextElements(tile, group));\n                }\n            }\n        }\n        if (groupedPriorityLists.size === 0) {\n            return;\n        }\n        for (const g of groupedPriorityLists) {\n            const lists = g[1];\n            sortedGroups.push(lists);\n        }\n        sortedGroups.sort((a, b) => {\n            return b.priority - a.priority;\n        });\n        const printTextInfo = false;\n        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {\n            let outString = \"\";\n            for (const textElementLists of sortedGroups) {\n                let size = 0;\n                for (const tileTextElements of textElementLists.lists) {\n                    size += tileTextElements.group.elements.length;\n                }\n                outString += `priority ${textElementLists.priority} size: ${size}\\n`;\n            }\n            logger.log(outString);\n        }\n    }\n    selectTextElementsToUpdateByDistance(textElementLists) {\n        const farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);\n        const maxViewDistance = Placement_1.getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);\n        for (const tileTextElements of textElementLists.lists) {\n            this.prepareTextElementGroup(tileTextElements.group, tileTextElements.tile.tileKey, maxViewDistance);\n        }\n    }\n    placeTextElements(time, placeNewTextElements) {\n        const renderParams = {\n            numRenderedTextElements: 0,\n            fadeAnimationRunning: false,\n            time\n        };\n        const placeStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;\n        if (placementStats) {\n            placementStats.clear();\n        }\n        if (this.m_textElementStateCache.size === 0) {\n            logger.debug(\"Text element cache empty.\");\n            return;\n        }\n        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;\n        if (this.m_forceNewLabelsPass) {\n            this.m_forceNewLabelsPass = false;\n        }\n        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;\n        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected\n        // candidates from previous frame if there's been no placement in this one.\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        let currentPriority = groupStates[0].priority;\n        let currentPriorityBegin = 0;\n        for (let i = 0; i < groupStates.length; ++i) {\n            const textElementGroupState = groupStates[i];\n            if (placementStats) {\n                ++placementStats.totalGroups;\n            }\n            const newPriority = textElementGroupState.priority;\n            if (placeNew && currentPriority !== newPriority) {\n                // Place all new labels of the previous priority before placing the persistent\n                // labels of this priority.\n                this.placeNewTextElements(currentPriorityBegin, i, renderParams);\n                if (isPlacementTimeExceeded(placeStartTime)) {\n                    break;\n                }\n                currentPriority = newPriority;\n                currentPriorityBegin = i;\n            }\n            if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, Pass.PersistentLabels)) {\n                break;\n            }\n            if (isPlacementTimeExceeded(placeStartTime)) {\n                break;\n            }\n        }\n        if (placeNew) {\n            // Place new text elements of the last priority.\n            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);\n        }\n        if (placementStats) {\n            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;\n            placementStats.log();\n        }\n        if (renderParams.fadeAnimationRunning) {\n            this.m_viewUpdateCallback();\n        }\n    }\n    placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {\n            if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, Pass.NewLabels)) {\n                break;\n            }\n        }\n    }\n    placeOverlayTextElements() {\n        var _a;\n        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {\n            return;\n        }\n        const screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);\n        const screenXOrigin = -screenSize.width / 2.0;\n        const screenYOrigin = screenSize.height / 2.0;\n        // Place text elements one by one.\n        for (const textElement of this.m_overlayTextElements) {\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            if (textCanvas === undefined) {\n                continue;\n            }\n            const forceNewPassOnLoaded = false;\n            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);\n            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {\n                continue;\n            }\n            const layer = textCanvas.getLayer((_a = textElement.renderOrder) !== null && _a !== void 0 ? _a : harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {\n                    continue;\n                }\n            }\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle;\n            textCanvas.textLayoutStyle = textElement.layoutStyle;\n            // Place text.\n            let textPath;\n            if (!(textElement.type === TextElementType_1.TextElementType.PathLabel)) {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;\n                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n                tempPosition.x = tempScreenPosition.x;\n                tempPosition.y = tempScreenPosition.y;\n                tempPosition.z = 0.0;\n                addTextToCanvas(textElement, textCanvas, tempPosition);\n            }\n            else {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin;\n                tempScreenPosition.y = screenYOrigin;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n                // Get the screen points that define the label's segments and create a path with\n                // them.\n                // TODO: HARP-7648. Optimize array allocations.\n                const screenPoints = [];\n                for (const pt of textElement.path) {\n                    const pX = tempScreenPosition.x + pt.x * screenSize.width;\n                    const pY = tempScreenPosition.y - pt.y * screenSize.height;\n                    screenPoints.push(new THREE.Vector2(pX, pY));\n                }\n                textPath = new SimplePath_1.SimplePath();\n                for (let i = 0; i < screenPoints.length - 1; ++i) {\n                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));\n                }\n                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);\n            }\n        }\n    }\n    getDistanceScalingFactor(label, distance, lookAtDistance) {\n        // Distance scale is based on relation between camera focus point distance and\n        // the actual label distance. For labels close to camera look at point the scale\n        // remains unchanged, the farther is label from that point the smaller size it is\n        // rendered in screen space. This method is unaffected by near and far clipping planes\n        // distances, but may be improved by taking FOV into equation or customizing the\n        // focus point screen position based on horizon, actual ground, tilt ets.\n        let factor = lookAtDistance / distance;\n        // The label.distanceScale property defines the influence ratio at which\n        // distance affects the final scaling of label.\n        factor = 1.0 + (factor - 1.0) * label.distanceScale;\n        // Preserve the constraints\n        factor = Math.max(factor, this.m_options.labelDistanceScaleMin);\n        factor = Math.min(factor, this.m_options.labelDistanceScaleMax);\n        return factor;\n    }\n    getDistanceFadingFactor(label, state, maxVisibilityDist) {\n        let distanceFadeValue = 1.0;\n        const textDistance = state.viewDistance;\n        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {\n            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;\n            const fadeFar = label.fadeFar;\n            if (fadeFar > fadeNear) {\n                distanceFadeValue =\n                    1.0 -\n                        THREE.MathUtils.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n            }\n        }\n        return distanceFadeValue;\n    }\n    addPointLabel(labelState, position, screenPosition, textCanvas, renderParams) {\n        var _a;\n        const pointLabel = labelState.element;\n        const textRenderState = labelState.textRenderState;\n        const isLineMarker = pointLabel.type === TextElementType_1.TextElementType.LineMarker;\n        const iconRenderState = labelState.iconRenderState;\n        harp_utils_1.assert(iconRenderState !== undefined);\n        // Find the label's original position.\n        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;\n        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;\n        // Scale the text depending on the label's distance to the camera \"zero\" plane.\n        const textDistance = Placement_1.pointToPlaneDistance(position, this.m_viewState.worldCenter, this.m_cameraLookAt);\n        if (pointLabel.fadeFar !== undefined &&\n            (pointLabel.fadeFar <= 0.0 ||\n                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent.\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            return false;\n        }\n        labelState.setViewDistance(textDistance);\n        // Check if there is need to check for screen space for the label's icon.\n        const poiInfo = pointLabel.poiInfo;\n        let iconRejected = false;\n        // Check if icon should be rendered at this zoomLevel\n        const renderIcon = poiInfo !== undefined &&\n            harp_utils_1.MathUtils.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) &&\n            poiInfo.isValid !== false;\n        const distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);\n        const iconReady = renderIcon && this.m_poiRenderer.prepareRender(pointLabel, this.m_viewState.env);\n        let iconInvisible = false;\n        if (iconReady) {\n            const result = Placement_1.placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.env, this.m_screenCollisions);\n            iconInvisible = result === Placement_1.PlacementResult.Invisible;\n            iconRejected = result === Placement_1.PlacementResult.Rejected;\n            if (iconInvisible) {\n                iconRenderState.reset();\n            }\n        }\n        else if (renderIcon && poiInfo.isValid !== false) {\n            // Ensure that text elements still loading icons get a chance to be rendered if\n            // there are no text element updates in the next frames.\n            this.m_forceNewLabelsPass = true;\n            this.m_viewUpdateCallback();\n        }\n        const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);\n        // Render the label's text...\n        // textRenderState is always defined at this point.\n        if (textCanvas && shouldRenderPointText(labelState, this.m_viewState, this.m_options)) {\n            // For the new labels with rejected icons we don't need to go further.\n            const newLabel = !labelState.visible;\n            // Multi point (icons) features (line markers) will use single placement anchor, but\n            // single point labels (POIs, etc.) may use multi-placement algorithm.\n            const placeResult = iconRejected && newLabel\n                ? Placement_1.PlacementResult.Rejected\n                : Placement_1.placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_viewState.env, this.m_screenCollisions, tempPosition, !isLineMarker);\n            const textInvisible = placeResult === Placement_1.PlacementResult.Invisible;\n            if (textInvisible) {\n                if (placementStats) {\n                    placementStats.numPoiTextsInvisible++;\n                }\n                if (!renderIcon || iconInvisible) {\n                    labelState.reset();\n                    return false;\n                }\n                textRenderState.reset();\n            }\n            const iconIsOptional = (poiInfo === null || poiInfo === void 0 ? void 0 : poiInfo.iconIsOptional) === true;\n            // Rejected icons are only considered to hide the text if they are valid, so a missing\n            // icon image will not keep the text from showing up.\n            const requiredIconRejected = iconRejected && iconReady && !iconIsOptional;\n            const textRejected = requiredIconRejected || placeResult === Placement_1.PlacementResult.Rejected;\n            if (!iconRejected && !iconInvisible) {\n                const textIsOptional = ((_a = pointLabel.poiInfo) === null || _a === void 0 ? void 0 : _a.textIsOptional) === true;\n                iconRejected = textRejected && !textIsOptional;\n            }\n            if (textRejected) {\n                textRenderState.startFadeOut(renderParams.time);\n            }\n            const textNeedsDraw = !textInvisible &&\n                ((!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||\n                    textRenderState.isFading());\n            if (textNeedsDraw) {\n                if (!textRejected) {\n                    textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);\n                }\n                renderParams.fadeAnimationRunning =\n                    renderParams.fadeAnimationRunning || textRenderState.isFading();\n                if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) &&\n                    placementStats) {\n                    placementStats.numRenderedPoiTexts++;\n                }\n            }\n        }\n        // ... and render the icon (if any).\n        if (iconReady && !iconInvisible) {\n            if (iconRejected) {\n                iconRenderState.startFadeOut(renderParams.time);\n            }\n            else {\n                iconRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);\n            }\n            renderParams.fadeAnimationRunning =\n                renderParams.fadeAnimationRunning || iconRenderState.isFading();\n            const opacity = iconRenderState.opacity * distanceFadeFactor;\n            if (opacity > 0) {\n                // Same as for text, don't allocate screen space for an icon that's fading out so\n                // that any label blocked by it gets a chance to be placed as soon as any other\n                // surrounding new labels.\n                const allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;\n                this.m_poiRenderer.addPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.env);\n                if (placementStats) {\n                    placementStats.numRenderedPoiIcons++;\n                }\n            }\n        }\n        renderParams.numRenderedTextElements++;\n        return true;\n    }\n    addPoiLabel(labelState, textCanvas, renderParams) {\n        const worldPosition = Placement_1.getWorldPosition(labelState.element, this.m_viewState.projection, this.m_viewState.env, this.m_tmpVector3);\n        // Only process labels that are potentially within the frustum.\n        if (!this.labelPotentiallyVisible(worldPosition, tempScreenPosition)) {\n            return false;\n        }\n        // Add this POI as a point label.\n        return this.addPointLabel(labelState, worldPosition, tempScreenPosition, textCanvas, renderParams);\n    }\n    addLineMarkerLabel(labelState, shieldGroups, textCanvas, renderParams) {\n        var _a;\n        const lineMarkerLabel = labelState.element;\n        // Early exit if the line marker doesn't have the necessary data.\n        const poiInfo = lineMarkerLabel.poiInfo;\n        if (!((_a = this.m_poiRenderer) === null || _a === void 0 ? void 0 : _a.prepareRender(lineMarkerLabel, this.m_viewState.env))) {\n            return;\n        }\n        // Initialize the shield group for this lineMarker.\n        let shieldGroup;\n        if (poiInfo.shieldGroupIndex !== undefined) {\n            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];\n            if (shieldGroup === undefined) {\n                shieldGroup = [];\n                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;\n            }\n        }\n        const lineTechnique = poiInfo.technique;\n        const minDistanceSqr = lineTechnique.minDistance !== undefined\n            ? lineTechnique.minDistance * lineTechnique.minDistance\n            : 0;\n        // Process markers (with shield groups).\n        if (minDistanceSqr > 0 && shieldGroup !== undefined) {\n            let numShieldsVisible = 0;\n            const point = labelState.position;\n            // Only process potentially visible labels\n            if (this.labelPotentiallyVisible(point, tempScreenPosition)) {\n                // Find a suitable location for the lineMarker to be placed at.\n                let tooClose = false;\n                for (let j = 0; j < shieldGroup.length; j += 2) {\n                    const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);\n                    tooClose = distanceSqr < minDistanceSqr;\n                    if (tooClose) {\n                        break;\n                    }\n                }\n                // Place it as a point label if it's not to close to another marker in the\n                // same shield group.\n                if (!tooClose) {\n                    if (this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams)) {\n                        shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);\n                        numShieldsVisible++;\n                    }\n                }\n            }\n            if (numShieldsVisible === 0) {\n                // For road shields the shared textRenderState may only be reset if none of the\n                // icons can be rendered.\n                labelState.reset();\n            }\n        }\n        // Process markers (without shield groups).\n        else {\n            const point = labelState.position;\n            // Only process potentially visible labels\n            if (this.labelPotentiallyVisible(point, tempScreenPosition)) {\n                this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams);\n            }\n        }\n    }\n    addPathLabel(labelState, screenPoints, textCanvas, renderParams) {\n        // TODO: HARP-7649. Add fade out transitions for path labels.\n        const textMaxDistance = Placement_1.getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);\n        const pathLabel = labelState.element;\n        // Limit the text rendering of path labels in the far distance.\n        if (!(pathLabel.ignoreDistance === true ||\n            labelState.viewDistance === undefined ||\n            labelState.viewDistance < textMaxDistance)) {\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState.reset();\n            return false;\n        }\n        if (pathLabel.fadeFar !== undefined &&\n            (pathLabel.fadeFar <= 0.0 ||\n                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState.reset();\n            return false;\n        }\n        // Get the screen points that define the label's segments and create a path with\n        // them.\n        let textPath = new THREE.Path();\n        tempScreenPosition.copy(screenPoints[0]);\n        for (let i = 0; i < screenPoints.length - 1; ++i) {\n            textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));\n        }\n        // Flip the path if the label is gonna be rendered downwards.\n        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {\n            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);\n            textPath = new THREE.Path();\n            for (let i = screenPoints.length - 1; i > 0; --i) {\n                textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));\n            }\n        }\n        // Update the real rendering distance to have smooth fading and scaling\n        labelState.setViewDistance(Placement_1.computeViewDistance(pathLabel, undefined, this.m_viewState.worldCenter, this.m_cameraLookAt));\n        const textRenderDistance = -labelState.renderDistance;\n        // Scale the text depending on the label's distance to the camera.\n        const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);\n        const prevSize = textCanvas.textRenderStyle.fontSize.size;\n        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;\n        if (Placement_1.placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== Placement_1.PlacementResult.Ok) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            if (placementStats) {\n                ++placementStats.numNotVisible;\n            }\n            labelState.textRenderState.reset();\n            return false;\n        }\n        labelState.textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);\n        let opacity = pathLabel.renderStyle.opacity;\n        if (labelState.textRenderState.isFading()) {\n            opacity *= labelState.textRenderState.opacity;\n            renderParams.fadeAnimationRunning = true;\n        }\n        if (labelState.textRenderState.opacity === 0) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            return false;\n        }\n        const prevOpacity = textCanvas.textRenderStyle.opacity;\n        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;\n        const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);\n        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;\n        textCanvas.textRenderStyle.backgroundOpacity =\n            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;\n        tempPosition.z = labelState.renderDistance;\n        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);\n        renderParams.numRenderedTextElements++;\n        // Restore previous style values for text elements using the same style.\n        textCanvas.textRenderStyle.fontSize.size = prevSize;\n        textCanvas.textRenderStyle.opacity = prevOpacity;\n        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;\n        return true;\n    }\n    checkIfOverloaded(dataSourceTileList) {\n        // Count the number of TextElements in the scene to see if we have to switch to\n        // \"overloadMode\".\n        let numTextElementsInScene = 0;\n        dataSourceTileList.forEach(renderListEntry => {\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                numTextElementsInScene += tile.textElementGroups.count();\n            }\n        });\n        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;\n        if (newOverloaded && !this.m_overloaded) {\n            logger.debug(\"Overloaded Mode enabled.\");\n        }\n        this.m_overloaded = newOverloaded;\n        return this.m_overloaded;\n    }\n    /**\n     * Project point to screen and check if it is on screen or within a fixed distance to the\n     * border.\n     *\n     * @param point center point of label.\n     * @param outPoint projected screen point of label.\n     */\n    labelPotentiallyVisible(point, outPoint) {\n        var _a;\n        const maxDistance = THREE.MathUtils.clamp((_a = this.m_options.maxPoiDistanceToBorder) !== null && _a !== void 0 ? _a : 0, 0, 1);\n        const projectionResult = this.m_screenProjector.projectAreaToScreen(point, maxDistance, maxDistance, outPoint);\n        return projectionResult !== undefined;\n    }\n}\nexports.TextElementsRenderer = TextElementsRenderer;\n//# sourceMappingURL=TextElementsRenderer.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.initializeDefaultOptions = void 0;\n/**\n * Default number of labels/POIs rendered in the scene\n */\nconst DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;\n/**\n * Number of elements that are put into second queue. This second chance queue is used to render\n * TextElements that have not been on screen before. This is a quick source for elements that can\n * appear when the camera moves a bit, before new elements are placed.\n */\nconst DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;\n/**\n * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the\n * far plane (1.0). May be synchronized with fog value ?\n */\nconst DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;\n/**\n * Minimum scaling factor that may be applied to labels when their are distant from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;\n/**\n * Maximum scaling factor that may be applied to labels due to their distance from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;\n// Allowed distance to screen border for early rejection of POIs during placement. Its range is\n// [0..1] of screen size.\n// A value of 0 will lead to POI labels popping in at the border of the screen. A large value will\n// lead to many labels being placed outside the screen, with all the required actions for measuring\n// and loading glyphs impacting performance.\nconst DEFAULT_MAX_DISTANCE_TO_BORDER = 0.2;\nconst MIN_GLYPH_COUNT = 1024;\nconst MAX_GLYPH_COUNT = 32768;\n/**\n * Initializes undefined text renderer options to default values.\n * @param options - The options to be initialized.\n */\nfunction initializeDefaultOptions(options) {\n    if (options.minNumGlyphs === undefined) {\n        options.minNumGlyphs = MIN_GLYPH_COUNT;\n    }\n    if (options.maxNumGlyphs === undefined) {\n        options.maxNumGlyphs = MAX_GLYPH_COUNT;\n    }\n    if (options.maxNumVisibleLabels === undefined) {\n        options.maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;\n    }\n    // TODO: Unused so far.\n    if (options.numSecondChanceLabels === undefined) {\n        options.numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;\n    }\n    if (options.labelDistanceScaleMin === undefined) {\n        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;\n    }\n    if (options.labelDistanceScaleMax === undefined) {\n        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;\n    }\n    if (options.maxDistanceRatioForTextLabels === undefined) {\n        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.maxDistanceRatioForPoiLabels === undefined) {\n        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.disableFading === undefined) {\n        options.disableFading = false;\n    }\n    if (options.delayLabelsUntilMovementFinished === undefined) {\n        options.delayLabelsUntilMovementFinished = true;\n    }\n    if (options.showReplacementGlyphs === undefined) {\n        options.showReplacementGlyphs = false;\n    }\n    if (options.maxPoiDistanceToBorder === undefined) {\n        options.maxPoiDistanceToBorder = DEFAULT_MAX_DISTANCE_TO_BORDER;\n    }\n}\nexports.initializeDefaultOptions = initializeDefaultOptions;\n//# sourceMappingURL=TextElementsRendererOptions.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextStyleCache = void 0;\n/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst ColorCache_1 = __webpack_require__(/*! ../ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\nconst TextElementsRenderer_1 = __webpack_require__(/*! ./TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextStyleCache\");\nconst defaultTextRenderStyle = new harp_text_canvas_1.TextRenderStyle({\n    fontSize: {\n        unit: harp_text_canvas_1.FontUnit.Pixel,\n        size: 32,\n        backgroundSize: 8\n    },\n    color: ColorCache_1.ColorCache.instance.getColor(\"#6d7477\"),\n    opacity: 1.0,\n    backgroundColor: ColorCache_1.ColorCache.instance.getColor(\"#f7fbfd\"),\n    backgroundOpacity: 0.5\n});\n// By default text layout provides no options for placement, but single alignment.\nconst defaultTextLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({\n    verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,\n    horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center,\n    placements: []\n});\nconst DEFAULT_STYLE_NAME = \"default\";\nclass TextStyleCache {\n    constructor() {\n        this.m_textStyles = new Map();\n        this.m_defaultStyle = {\n            name: DEFAULT_STYLE_NAME,\n            fontCatalog: undefined,\n            renderParams: defaultTextRenderStyle.params,\n            layoutParams: defaultTextLayoutStyle.params\n        };\n        this.updateDefaultTextStyle();\n    }\n    updateTextStyles(textStyleDefinitions, defaultTextStyleDefinition) {\n        this.m_textStyles.clear();\n        textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions.forEach(element => {\n            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));\n        });\n        this.updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions);\n    }\n    updateTextCanvases(textCanvases) {\n        // Initialize default text style.\n        this.initializeTextCanvas(this.m_defaultStyle, textCanvases);\n        for (const [, style] of this.m_textStyles) {\n            this.initializeTextCanvas(style, textCanvases);\n        }\n    }\n    /**\n     * Retrieves a {@link TextElementStyle} for {@link @here/harp-datasource-protocol#Theme}'s\n     * [[TextStyle]] id.\n     */\n    getTextElementStyle(styleId) {\n        let result;\n        if (styleId === undefined) {\n            result = this.m_defaultStyle;\n        }\n        else {\n            result = this.m_textStyles.get(styleId);\n            if (result === undefined) {\n                result = this.m_defaultStyle;\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets the appropriate {@link @here/harp-text-canvas#TextRenderStyle}\n     * to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     */\n    createRenderStyle(tile, technique) {\n        const mapView = tile.mapView;\n        const zoomLevel = mapView.zoomLevel;\n        const discreteZoomLevel = Math.floor(zoomLevel);\n        // Environment with $zoom forced to integer to achieve stable interpolated values.\n        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const defaultRenderParams = this.m_defaultStyle.renderParams;\n        // Sets opacity to 1.0 if default and technique attribute are undefined.\n        const defaultOpacity = harp_utils_1.getOptionValue(defaultRenderParams.opacity, 1.0);\n        // Interpolate opacity but only on discreet zoom levels (step interpolation).\n        let opacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.opacity, defaultOpacity), discreteZoomEnv);\n        let color;\n        // Store color (RGB) in cache and multiply opacity value with the color alpha channel.\n        if (technique.color !== undefined) {\n            let hexColor = DecodedTileHelpers_1.evaluateColorProperty(technique.color, discreteZoomEnv);\n            if (hexColor !== undefined) {\n                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexColor)) {\n                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexColor);\n                    opacity = opacity * alpha;\n                    hexColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexColor);\n                }\n                color = ColorCache_1.ColorCache.instance.getColor(hexColor);\n            }\n        }\n        // Sets background size to 0.0 if default and technique attribute is undefined.\n        const defaultBackgroundSize = harp_utils_1.getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);\n        const backgroundSize = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundSize, defaultBackgroundSize), discreteZoomEnv);\n        const hasBackgroundDefined = technique.backgroundColor !== undefined &&\n            technique.backgroundSize !== undefined &&\n            backgroundSize > 0;\n        // Sets background opacity to 1.0 if default and technique value is undefined while\n        // background size and color is specified, otherwise set value in default render\n        // params or 0.0 if neither set. Makes label opaque when backgroundColor and\n        // backgroundSize are set.\n        const defaultBackgroundOpacity = harp_utils_1.getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);\n        let backgroundOpacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity), discreteZoomEnv);\n        let backgroundColor;\n        // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.\n        if (technique.backgroundColor !== undefined) {\n            let hexBgColor = DecodedTileHelpers_1.evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);\n            if (hexBgColor !== undefined) {\n                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexBgColor)) {\n                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexBgColor);\n                    backgroundOpacity = backgroundOpacity * alpha;\n                    hexBgColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexBgColor);\n                }\n                backgroundColor = ColorCache_1.ColorCache.instance.getColor(hexBgColor);\n            }\n        }\n        const renderParams = {\n            fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),\n            fontSize: {\n                unit: harp_text_canvas_1.FontUnit.Pixel,\n                size: harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.size, defaultRenderParams.fontSize.size), discreteZoomEnv),\n                backgroundSize\n            },\n            fontStyle: technique.fontStyle === \"Regular\" ||\n                technique.fontStyle === \"Bold\" ||\n                technique.fontStyle === \"Italic\" ||\n                technique.fontStyle === \"BoldItalic\"\n                ? harp_text_canvas_1.FontStyle[technique.fontStyle]\n                : defaultRenderParams.fontStyle,\n            fontVariant: technique.fontVariant === \"Regular\" ||\n                technique.fontVariant === \"AllCaps\" ||\n                technique.fontVariant === \"SmallCaps\"\n                ? harp_text_canvas_1.FontVariant[technique.fontVariant]\n                : defaultRenderParams.fontVariant,\n            rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),\n            color: harp_utils_1.getOptionValue(color, harp_utils_1.getOptionValue(defaultRenderParams.color, harp_text_canvas_1.DefaultTextStyle.DEFAULT_COLOR)),\n            backgroundColor: harp_utils_1.getOptionValue(backgroundColor, harp_utils_1.getOptionValue(defaultRenderParams.backgroundColor, harp_text_canvas_1.DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),\n            opacity,\n            backgroundOpacity\n        };\n        const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;\n        const renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, themeRenderParams), renderParams));\n        return renderStyle;\n    }\n    /**\n     * Create the appropriate {@link @here/harp-text-canvas#TextLayoutStyle}\n     * to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param tile - The {@link Tile} to process.\n     * @param technique - Label's technique.\n     */\n    createLayoutStyle(tile, technique) {\n        var _a, _b, _c, _d, _e, _f;\n        const mapView = tile.mapView;\n        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);\n        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: floorZoomLevel }, mapView.env);\n        const defaultLayoutParams = this.m_defaultStyle.layoutParams;\n        const hAlignment = harp_datasource_protocol_1.getPropertyValue(technique.hAlignment, discreteZoomEnv);\n        const vAlignment = harp_datasource_protocol_1.getPropertyValue(technique.vAlignment, discreteZoomEnv);\n        // Text alternative placements are currently supported only for PoiTechnique.\n        const textPlacements = harp_datasource_protocol_1.isPoiTechnique(technique)\n            ? harp_datasource_protocol_1.getPropertyValue(technique.placements, discreteZoomEnv)\n            : null;\n        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(hAlignment, vAlignment, textPlacements);\n        const wrapping = harp_datasource_protocol_1.getPropertyValue(technique.wrappingMode, discreteZoomEnv);\n        const wrappingMode = wrapping === \"None\" || wrapping === \"Character\" || wrapping === \"Word\"\n            ? harp_text_canvas_1.WrappingMode[wrapping]\n            : defaultLayoutParams.wrappingMode;\n        const layoutParams = {\n            tracking: (_a = harp_datasource_protocol_1.getPropertyValue(technique.tracking, discreteZoomEnv)) !== null && _a !== void 0 ? _a : defaultLayoutParams.tracking,\n            leading: (_b = harp_datasource_protocol_1.getPropertyValue(technique.leading, discreteZoomEnv)) !== null && _b !== void 0 ? _b : defaultLayoutParams.leading,\n            maxLines: (_c = harp_datasource_protocol_1.getPropertyValue(technique.maxLines, discreteZoomEnv)) !== null && _c !== void 0 ? _c : defaultLayoutParams.maxLines,\n            lineWidth: (_d = harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, discreteZoomEnv)) !== null && _d !== void 0 ? _d : defaultLayoutParams.lineWidth,\n            canvasRotation: (_e = harp_datasource_protocol_1.getPropertyValue(technique.canvasRotation, discreteZoomEnv)) !== null && _e !== void 0 ? _e : defaultLayoutParams.canvasRotation,\n            lineRotation: (_f = harp_datasource_protocol_1.getPropertyValue(technique.lineRotation, discreteZoomEnv)) !== null && _f !== void 0 ? _f : defaultLayoutParams.lineRotation,\n            wrappingMode,\n            horizontalAlignment,\n            verticalAlignment,\n            placements\n        };\n        const themeLayoutParams = this.getTextElementStyle(technique.style);\n        const layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, themeLayoutParams), layoutParams));\n        return layoutStyle;\n    }\n    updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions) {\n        var _a, _b;\n        this.m_defaultStyle.fontCatalog = undefined;\n        const style = (_b = (_a = textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions.find(definition => {\n            return definition.name === DEFAULT_STYLE_NAME;\n        })) !== null && _a !== void 0 ? _a : defaultTextStyleDefinition) !== null && _b !== void 0 ? _b : textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions[0];\n        if (style) {\n            this.m_defaultStyle = this.createTextElementStyle(style, DEFAULT_STYLE_NAME);\n        }\n        this.m_defaultStyle.textCanvas = undefined;\n    }\n    initializeTextCanvas(style, textCanvases) {\n        var _a;\n        if (style.textCanvas) {\n            return;\n        }\n        if (style.fontCatalog !== undefined) {\n            const styledTextCanvas = textCanvases.get(style.fontCatalog);\n            style.textCanvas = styledTextCanvas;\n            if (textCanvases.has(style.fontCatalog) && !styledTextCanvas) {\n                logger.info(`fontCatalog(${style.fontCatalog}), not yet loaded`);\n                return;\n            }\n        }\n        // specified canvas not found\n        if (style.textCanvas === undefined) {\n            if (style.fontCatalog !== undefined &&\n                style.fontCatalog !== TextElementsRenderer_1.DEFAULT_FONT_CATALOG_NAME) {\n                logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle\n                     '${style.name}' not found`);\n            }\n            // find another canvas to use then\n            let alternativeTextCanvas = textCanvases.get(TextElementsRenderer_1.DEFAULT_FONT_CATALOG_NAME);\n            if (!alternativeTextCanvas && textCanvases.size > 0) {\n                for (const [, canvas] of textCanvases) {\n                    if (canvas) {\n                        alternativeTextCanvas = canvas;\n                        break;\n                    }\n                }\n            }\n            // if an alternative canvas is found, use it\n            if (alternativeTextCanvas) {\n                style.textCanvas = alternativeTextCanvas;\n                if (style.fontCatalog !== undefined) {\n                    logger.info(`fontCatalog: '${style.fontCatalog}' not found,\n                      using default fontCatalog(${(_a = style.textCanvas) === null || _a === void 0 ? void 0 : _a.name}).`);\n                }\n            }\n        }\n    }\n    createTextElementStyle(style, styleName) {\n        var _a;\n        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(style.hAlignment, style.vAlignment, style.placements);\n        return {\n            name: styleName,\n            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),\n            renderParams: {\n                fontName: style.fontName,\n                fontSize: {\n                    unit: harp_text_canvas_1.FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: (_a = style.backgroundSize) !== null && _a !== void 0 ? _a : 8\n                },\n                fontStyle: style.fontStyle === \"Regular\" ||\n                    style.fontStyle === \"Bold\" ||\n                    style.fontStyle === \"Italic\" ||\n                    style.fontStyle === \"BoldItalic\"\n                    ? harp_text_canvas_1.FontStyle[style.fontStyle]\n                    : undefined,\n                fontVariant: style.fontVariant === \"Regular\" ||\n                    style.fontVariant === \"AllCaps\" ||\n                    style.fontVariant === \"SmallCaps\"\n                    ? harp_text_canvas_1.FontVariant[style.fontVariant]\n                    : undefined,\n                rotation: style.rotation,\n                color: style.color !== undefined\n                    ? ColorCache_1.ColorCache.instance.getColor(style.color)\n                    : undefined,\n                backgroundColor: style.backgroundColor !== undefined\n                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)\n                    : undefined,\n                opacity: style.opacity,\n                backgroundOpacity: style.backgroundOpacity\n            },\n            layoutParams: {\n                tracking: style.tracking,\n                leading: style.leading,\n                maxLines: style.maxLines,\n                lineWidth: style.lineWidth,\n                canvasRotation: style.canvasRotation,\n                lineRotation: style.lineRotation,\n                wrappingMode: style.wrappingMode === \"None\" ||\n                    style.wrappingMode === \"Character\" ||\n                    style.wrappingMode === \"Word\"\n                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]\n                    : harp_text_canvas_1.WrappingMode.Word,\n                verticalAlignment,\n                horizontalAlignment,\n                placements\n            }\n        };\n    }\n}\nexports.TextStyleCache = TextStyleCache;\nfunction parseAlignmentAndPlacements(hAlignment, vAlignment, placementsTokens) {\n    // Currently supported only for PoiTechnique.\n    const placements = placementsTokens\n        ? parseTechniquePlacements(placementsTokens)\n        : undefined;\n    return harp_text_canvas_1.resolvePlacementAndAlignment(parseTechniqueHAlignValue(hAlignment), parseTechniqueVAlignValue(vAlignment), placements);\n}\nfunction parseTechniqueHAlignValue(hAlignment) {\n    return hAlignment === \"Left\" || hAlignment === \"Center\" || hAlignment === \"Right\"\n        ? harp_text_canvas_1.HorizontalAlignment[hAlignment]\n        : defaultTextLayoutStyle.horizontalAlignment;\n}\nfunction parseTechniqueVAlignValue(vAlignment) {\n    return vAlignment === \"Above\" || vAlignment === \"Center\" || vAlignment === \"Below\"\n        ? harp_text_canvas_1.VerticalAlignment[vAlignment]\n        : defaultTextLayoutStyle.verticalAlignment;\n}\nfunction parseTechniquePlacements(placementsString) {\n    // Parse placement properties if available.\n    const placements = [];\n    const placementsTokens = placementsString\n        ? placementsString.toUpperCase().replace(\" \", \"\").split(\",\")\n        : [];\n    placementsTokens.forEach(p => {\n        const val = parseTechniquePlacementValue(p);\n        if (val !== undefined) {\n            placements.push(val);\n        }\n    });\n    return placements;\n}\nfunction parseTechniquePlacementValue(p) {\n    // May be only literal of single or two characters.\n    if (p.length < 1 || p.length > 2) {\n        return undefined;\n    }\n    // If no value is specified for vertical/horizontal placement it is by default center.\n    const textPlacement = {\n        h: harp_text_canvas_1.HorizontalPlacement.Center,\n        v: harp_text_canvas_1.VerticalPlacement.Center\n    };\n    // Firstly try to find vertical placement.\n    let modifier = p.charAt(0);\n    let found = true;\n    switch (modifier) {\n        // Top / north\n        case harp_datasource_protocol_1.PlacementToken.Top:\n        case harp_datasource_protocol_1.PlacementToken.North:\n            textPlacement.v = harp_text_canvas_1.VerticalPlacement.Top;\n            break;\n        // Bottom / south\n        case harp_datasource_protocol_1.PlacementToken.Bottom:\n        case harp_datasource_protocol_1.PlacementToken.South:\n            textPlacement.v = harp_text_canvas_1.VerticalPlacement.Bottom;\n            break;\n        default:\n            found = false;\n            if (p.length === 2) {\n                // For 2 characters tag both vertical/horizontal should be defined.\n                return undefined;\n            }\n    }\n    if (found && p.length === 1) {\n        return textPlacement;\n    }\n    modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);\n    switch (modifier) {\n        // Right / east\n        case harp_datasource_protocol_1.PlacementToken.Right:\n        case harp_datasource_protocol_1.PlacementToken.East:\n            textPlacement.h = harp_text_canvas_1.HorizontalPlacement.Right;\n            break;\n        // Left / west\n        case harp_datasource_protocol_1.PlacementToken.Left:\n        case harp_datasource_protocol_1.PlacementToken.West:\n            textPlacement.h = harp_text_canvas_1.HorizontalPlacement.Left;\n            break;\n        default:\n            // Either for single character or multi-char tag, we must surrender.\n            return undefined;\n    }\n    return textPlacement;\n}\n//# sourceMappingURL=TextStyleCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TileTextStyleCache = void 0;\nclass TileTextStyleCache {\n    constructor(tile) {\n        this.textRenderStyles = [];\n        this.textLayoutStyles = [];\n        this.tile = tile;\n    }\n    clear() {\n        this.textRenderStyles.length = 0;\n        this.textLayoutStyles.length = 0;\n    }\n    getRenderStyle(technique) {\n        let style = this.textRenderStyles[technique._index];\n        if (style === undefined) {\n            style = this.textRenderStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(this.tile, technique);\n        }\n        return style;\n    }\n    getLayoutStyle(technique) {\n        let style = this.textLayoutStyles[technique._index];\n        if (style === undefined) {\n            style = this.textLayoutStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(this.tile, technique);\n        }\n        return style;\n    }\n}\nexports.TileTextStyleCache = TileTextStyleCache;\n//# sourceMappingURL=TileTextStyleCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/UpdateStats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/UpdateStats.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateStats = void 0;\nconst Placement_1 = __webpack_require__(/*! ./Placement */ \"./node_modules/@here/harp-mapview/lib/text/Placement.js\");\nclass UpdateStats {\n    constructor(m_logger) {\n        this.m_logger = m_logger;\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results = new Array(Placement_1.PrePlacementResult.Count);\n        this.results.fill(0);\n    }\n    clear() {\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results.fill(0);\n    }\n    log() {\n        this.m_logger.debug(\"Tiles\", this.tiles);\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"New groups\", this.newGroups);\n        this.m_logger.debug(\"Total labels\", this.totalLabels);\n        this.m_logger.debug(\"Placed labels\", this.results[Placement_1.PrePlacementResult.Ok]);\n        this.m_logger.debug(\"Invisible\", this.results[Placement_1.PrePlacementResult.Invisible]);\n        this.m_logger.debug(\"Poi not ready\", this.results[Placement_1.PrePlacementResult.NotReady]);\n        this.m_logger.debug(\"Too far\", this.results[Placement_1.PrePlacementResult.TooFar]);\n        this.m_logger.debug(\"Duplicate\", this.results[Placement_1.PrePlacementResult.Duplicate]);\n    }\n}\nexports.UpdateStats = UpdateStats;\n//# sourceMappingURL=UpdateStats.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/UpdateStats.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isWorkerBootstrapResponse = exports.isWorkerBootstrapRequest = void 0;\nfunction isWorkerBootstrapRequest(message) {\n    return (message &&\n        message.type === \"worker-bootstrap-request\" &&\n        Array.isArray(message.dependencies));\n}\nexports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;\nfunction isWorkerBootstrapResponse(message) {\n    return (message &&\n        message.type === \"worker-bootstrap-response\" &&\n        Array.isArray(message.resolvedDependencies));\n}\nexports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;\n//# sourceMappingURL=WorkerBootstrapDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerLoader = void 0;\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ \"./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"WorkerLoader\");\n/**\n * Set of `Worker` loading and initialization helpers:\n *  - starting Worker from URL with fallback to XHR+blob {@link WorkerLoader.startWorker}\n *  - waiting for proper worker initialization, see {@link WorkerLoader.waitWorkerInitialized}\n */\nclass WorkerLoader {\n    /**\n     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.\n     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful\n     * initialization.\n     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to\n     * [[startWorkerBlob]].\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).\n     *\n     * This method is needed as browsers in general forbid to load worker if it's not on 'same\n     * origin' regardless of Content-Security-Policy.\n     *\n     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows\n     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but\n     * this may change.\n     *\n     * Following snippet setups CSP, so workers can be started from blob urls:\n     *\n     *     <head>\n     *         <meta http-equiv=\"Content-Security-Policy\" content=\"child-src blob:\">\n     *     </head>\n     *\n     * Tested on:\n     *   * Chrome 67 / Linux, Window, OSX, Android\n     *   * Firefox 60 / Linux, Windows, OSX\n     *   * Edge 41 / Windows\n     *   * Safari 11 / OSX\n     *   * Samsung Internet 7.2\n     *\n     * See\n     *  * https://benohead.com/cross-domain-cross-browser-web-workers/\n     *  * MapBox\n     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/559\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058\n     *\n     * Findings:\n     *\n     * * Chrome reports CSP by exception when constructing [[Worker]] instance.\n     * * Firefox reports CSP errors when loading in first event:\n     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888\n     * * Firefox 62, Chrome 67 obeys `<meta http-equiv=\"Content-Security-Policy\">` with\n     *   `worker-src blob:` but doesn't obey `worker-src URL` when used\n     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported\n     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)\n     *\n     * @param scriptUrl - web worker script URL\n     * @param timeout - timeout in milliseconds, in which worker should set initial message\n     *    (default 10 seconds)\n     */\n    static startWorker(scriptUrl, timeout = 10000) {\n        if (scriptUrl.startsWith(\"blob:\")) {\n            return this.startWorkerImmediately(scriptUrl, timeout);\n        }\n        if (this.directlyFallbackToBlobBasedLoading) {\n            return this.startWorkerBlob(scriptUrl, timeout);\n        }\n        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {\n            if (typeof window !== \"undefined\") {\n                const pageUrl = window.location.href;\n                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;\n                if (harp_utils_1.getUrlOrigin(fullScriptUrl) === harp_utils_1.getUrlOrigin(pageUrl)) {\n                    throw error;\n                }\n                logger.log(\"#startWorker: cross-origin worker construction failed, trying load with blob\");\n                this.directlyFallbackToBlobBasedLoading = true;\n                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);\n            }\n            else {\n                throw error;\n            }\n        });\n    }\n    /**\n     * Start worker, loading it immediately from `scriptUrl`. Waits (using\n     * [[waitWorkerInitialized]]) for successful worker start.\n     *\n     * @param scriptUrl - web worker script URL\n     */\n    static startWorkerImmediately(scriptUrl, timeout) {\n        try {\n            const worker = new Worker(scriptUrl);\n            return this.waitWorkerInitialized(worker, timeout);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    /**\n     * Start worker \"via blob\" by first loading worker script code with [[fetch]], creating `Blob`\n     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for\n     * successful worker start.\n     *\n     * @param scriptUrl - web worker script URL\n     */\n    static startWorkerBlob(scriptUrl, timeout) {\n        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {\n            return this.startWorkerImmediately(blobUrl, timeout);\n        });\n    }\n    /**\n     * Fetch script source as `Blob` url.\n     *\n     * Reuses results, if there are many simultaneous requests.\n     *\n     * @param scriptUrl - web worker script URL\n     * @return promise that resolves to url of a `Blob` with script source code\n     */\n    static fetchScriptSourceToBlobUrl(scriptUrl) {\n        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);\n        if (loadingPromise !== undefined) {\n            return loadingPromise;\n        }\n        loadingPromise = fetch(scriptUrl)\n            .then(response => response.text())\n            .catch(error => {\n            throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);\n        })\n            .then(scriptSource => {\n            this.sourceLoaderCache.delete(scriptUrl);\n            const blob = new Blob([scriptSource], { type: \"application/javascript\" });\n            return URL.createObjectURL(blob);\n        });\n        this.sourceLoaderCache.set(scriptUrl, loadingPromise);\n        return loadingPromise;\n    }\n    /**\n     * Waits for successful Web Worker start.\n     *\n     * Expects that worker script sends initial message.\n     *\n     * If first event is `message` then assumes that worker has been loaded sussesfully and promise\n     * resolves to `worker` object passed as argument.\n     *\n     * If first event is 'error', then it is assumed that worker failed to load and promise is\n     * rejected.\n     *\n     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's\n     * `dispatchEvent`, so application code can also consume it as confirmation of successful\n     * worker initialization.\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     *\n     * @param worker - [[Worker]] instance to be checked\n     * @param timeout - timeout in milliseconds, in which worker should set initial message\n     * @returns `Promise` that resolves to `worker` on success\n     */\n    static waitWorkerInitialized(worker, timeout) {\n        return new Promise((resolve, reject) => {\n            const firstMessageCallback = (event) => {\n                const message = event.data;\n                if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {\n                    const dependencies = message.dependencies;\n                    const resolvedDependencies = [];\n                    for (const dependency of dependencies) {\n                        const resolved = this.dependencyUrlMapping[dependency];\n                        if (!resolved) {\n                            cleanup();\n                            reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +\n                                ` as needed by worker script.`));\n                            return;\n                        }\n                        resolvedDependencies.push(resolved);\n                    }\n                    const response = {\n                        type: \"worker-bootstrap-response\",\n                        resolvedDependencies\n                    };\n                    worker.postMessage(response);\n                    return;\n                }\n                cleanup();\n                resolve(worker);\n                // We've just consumed first message from worker before client has any chance to\n                // even call `addEventListener` on it, so here after resolve, we wait next tick and\n                // replay message so user has chance to intercept it in its own handler.\n                setTimeout(() => {\n                    worker.dispatchEvent(event);\n                }, 0);\n            };\n            const errorCallback = (error) => {\n                cleanup();\n                // Error events do not carry any useful information on tested browsers, so we assume\n                // that any error before 'firstMessageCallback' as failed Worker initialization.\n                let message = \"Error during worker initialization\";\n                if (error.message) {\n                    message = message + `: ${error.message}`;\n                }\n                if (typeof error.filename === \"string\" && typeof error.lineno === \"number\") {\n                    message = message + ` in ${error.filename}:${error.lineno}`;\n                }\n                reject(new Error(message));\n            };\n            const cleanup = () => {\n                clearTimeout(timerId);\n                worker.removeEventListener(\"message\", firstMessageCallback);\n                worker.removeEventListener(\"error\", errorCallback);\n            };\n            worker.addEventListener(\"error\", errorCallback);\n            worker.addEventListener(\"message\", firstMessageCallback);\n            const timerId = setTimeout(() => {\n                cleanup();\n                reject(new Error(\"Timeout exceeded when waiting for first message from worker.\"));\n            }, timeout);\n        });\n    }\n}\nexports.WorkerLoader = WorkerLoader;\nWorkerLoader.directlyFallbackToBlobBasedLoading = false;\nWorkerLoader.sourceLoaderCache = new Map();\nWorkerLoader.dependencyUrlMapping = {};\n//# sourceMappingURL=WorkerLoader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-materials/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Materials defining the appearance of map objects.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/CirclePointsMaterial */ \"./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/CopyMaterial */ \"./node_modules/@here/harp-materials/lib/CopyMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/DisplacementFeature */ \"./node_modules/@here/harp-materials/lib/DisplacementFeature.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/EdgeMaterial */ \"./node_modules/@here/harp-materials/lib/EdgeMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GroundAtmosphereMaterial */ \"./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ \"./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ \"./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/IconMaterial */ \"./node_modules/@here/harp-materials/lib/IconMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ \"./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MapMeshMaterials */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterials.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MSAAMaterial */ \"./node_modules/@here/harp-materials/lib/MSAAMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/SepiaShader */ \"./node_modules/@here/harp-materials/lib/SepiaShader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/SkyAtmosphereMaterial */ \"./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/SolidLineMaterial */ \"./node_modules/@here/harp-materials/lib/SolidLineMaterial.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/VignetteShader */ \"./node_modules/@here/harp-materials/lib/VignetteShader.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CirclePointsMaterial = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst vertexShader = `\nuniform float size;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec3 position;\n\nvoid main() {\n    vec3 transformed = vec3(position);\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n    gl_PointSize = size;\n}\n`;\nconst fragmentShader = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nvoid main() {\n    float alpha = opacity;\n\n    float radius = 0.5;\n    vec2 coords = gl_PointCoord.xy - vec2(0.5);\n    float len = length(coords);\n    float falloff = fwidth(len);\n    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);\n    alpha *= threshold;\n\n    gl_FragColor = vec4(diffuse, alpha);\n}`;\n/**\n * Material designed to render circle points. Note that it is always transparent since the circle\n * shape is created with an alpha channel to benefit an antialising that a mere `discard` could\n * not bring.\n */\nclass CirclePointsMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `CirclePointsMaterial`.\n     *\n     * @param parameters - The constructor's parameters. Always required except when cloning another\n     */\n    constructor(parameters) {\n        const defaultColor = new THREE.Color();\n        const defaultOpacity = 1.0;\n        let sizeValue, colorValue, opacityValue;\n        let shaderParameters;\n        if (parameters) {\n            const { size, color, opacity } = parameters, shaderParams = __rest(parameters, [\"size\", \"color\", \"opacity\"]);\n            sizeValue = size;\n            colorValue = color;\n            opacityValue = opacity;\n            shaderParams.name = \"CirclePointsMaterial\";\n            shaderParams.vertexShader = vertexShader;\n            shaderParams.fragmentShader = fragmentShader;\n            shaderParams.uniforms = THREE.UniformsUtils.merge([\n                {\n                    size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),\n                    diffuse: new THREE.Uniform(defaultColor),\n                    opacity: new THREE.Uniform(defaultOpacity)\n                },\n                THREE.UniformsLib.fog\n            ]);\n            shaderParams.depthTest = false;\n            shaderParams.extensions = Object.assign(Object.assign({}, shaderParams.extensions), { derivatives: true });\n            shaderParameters = shaderParams;\n        }\n        super(shaderParameters);\n        // Blending needs to always be enabled to support smooth edges\n        Utils_1.enforceBlending(this);\n        this.type = \"CirclePointsMaterial\";\n        this.setOpacity(defaultOpacity);\n        if (sizeValue !== undefined) {\n            this.size = sizeValue;\n        }\n        if (colorValue !== undefined) {\n            this.color = colorValue;\n        }\n        if (opacityValue !== undefined) {\n            this.setOpacity(opacityValue);\n        }\n    }\n    /**\n     * Gets the circle screen size.\n     */\n    get size() {\n        return this.uniforms.size.value;\n    }\n    /**\n     * Sets the circle screen size.\n     */\n    set size(size) {\n        this.uniforms.size.value = size;\n    }\n    get color() {\n        return this.uniforms.diffuse.value;\n    }\n    set color(value) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n}\nexports.CirclePointsMaterial = CirclePointsMaterial;\nCirclePointsMaterial.DEFAULT_CIRCLE_SIZE = 1;\n//# sourceMappingURL=CirclePointsMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CopyMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CopyMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CopyMaterial = exports.CopyShader = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * The base shader to use for {@link @here/harp-mapview#MapView}'s\n * composing passes, like {@link MSAAMaterial}.\n */\nexports.CopyShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        opacity: { value: 1.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform float opacity;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n    }`\n};\n/**\n * The material is used for composing.\n */\nclass CopyMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `CopyMaterial`.\n     *\n     * @param uniforms - The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms) {\n        super({\n            name: \"CopyMaterial\",\n            uniforms,\n            vertexShader: exports.CopyShader.vertexShader,\n            fragmentShader: exports.CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: false,\n            blending: THREE.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\nexports.CopyMaterial = CopyMaterial;\n//# sourceMappingURL=CopyMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/CopyMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/DisplacementFeature.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/DisplacementFeature.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setDisplacementMapToMaterial = exports.hasDisplacementFeature = void 0;\n/**\n * Determines whether a given material supports displacement maps for elevation overlay.\n * @param material - The material to check.\n * @returns Whether the given material supports displacement maps for elevation overlay.\n */\nfunction hasDisplacementFeature(material) {\n    return \"displacementMap\" in material;\n}\nexports.hasDisplacementFeature = hasDisplacementFeature;\n/**\n * Sets the displacement map to the given material.\n * @param displacementMap - Texture representing the elevation data used to overlay the object.\n * @param material - The Material to be updated.\n */\nfunction setDisplacementMapToMaterial(displacementMap, material) {\n    if (hasDisplacementFeature(material) && material.displacementMap !== displacementMap) {\n        material.displacementMap = displacementMap;\n        material.needsUpdate = true;\n        if (material.displacementMap !== null) {\n            material.displacementMap.needsUpdate = true;\n        }\n    }\n}\nexports.setDisplacementMapToMaterial = setDisplacementMapToMaterial;\n//# sourceMappingURL=DisplacementFeature.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/DisplacementFeature.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/EdgeMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/EdgeMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EdgeMaterial = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterials.js\");\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst vertexSource = `\n#define EDGE_DEPTH_OFFSET 0.0001\n\n#ifdef USE_COLOR\nattribute vec4 color;\n#else\nuniform vec3 color;\n#endif\n\n// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are\n// already defined\n#ifndef SHADER_NAME\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n#endif\n\nuniform vec3 edgeColor;\nuniform float edgeColorMix;\n\n#ifdef USE_DISPLACEMENTMAP\nattribute vec3 normal;\nattribute vec2 uv;\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_vertex>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\nvoid main() {\n\n    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);\n\n    vec3 transformed = vec3( position );\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_vertex>\n    #endif\n\n    #ifdef USE_DISPLACEMENTMAP\n    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = projectionMatrix * mvPosition;\n    // After projection gl_Position contains clip space coordinates of each vertex\n    // before perspective division (1 / w), thus only vertexes with -w < z < w should\n    // be displayed and offset. We offset only those edges which z coordinate in NDC\n    // space is between: -inf < z < 1\n    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;\n    gl_Position.z -= depthOffset;\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\nvoid main() {\n    float alphaValue = 1.0;\n    gl_FragColor = vec4(vColor, alphaValue);\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n/**\n * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid\n * colors, vertex colors, color mixing and distance fading.\n */\nclass EdgeMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `EdgeMaterial`.\n     *\n     * @param params - `EdgeMaterial` parameters. Always required except when cloning another\n     * material.\n     */\n    constructor(params) {\n        var _a;\n        let shaderParams;\n        if (params) {\n            const defines = {};\n            const hasExtrusion = params.extrusionRatio !== undefined &&\n                params.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&\n                params.extrusionRatio < MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n            if (params.displacementMap) {\n                Utils_1.setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n            }\n            if (hasExtrusion) {\n                Utils_1.setShaderDefine(defines, \"USE_EXTRUSION\", true);\n            }\n            if (params.vertexColors === true) {\n                Utils_1.setShaderDefine(defines, \"USE_COLOR\", true);\n            }\n            shaderParams = {\n                name: \"EdgeMaterial\",\n                vertexShader: vertexSource,\n                fragmentShader: fragmentSource,\n                uniforms: {\n                    color: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                    edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                    edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),\n                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),\n                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),\n                    extrusionRatio: new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),\n                    displacementMap: new THREE.Uniform((_a = params.displacementMap) !== null && _a !== void 0 ? _a : new THREE.Texture())\n                },\n                depthWrite: false,\n                defines,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n        Utils_1.enforceBlending(this);\n        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();\n        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                // Color may be set directly on object (omitting class setter), because we already\n                // know that is does no require any special handling nor material update\n                // (see: set color()).\n                this.color.set(params.color);\n            }\n            if (params.colorMix !== undefined) {\n                this.colorMix = params.colorMix;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.extrusionRatio !== undefined) {\n                this.extrusionRatio = params.extrusionRatio;\n            }\n        }\n    }\n    /**\n     * The color of the object that is rendered\n     * together with this edge.\n     *\n     * @remarks\n     * The final color of the edge is computed by\n     * interpolating the {@link edgeColor} with this color\n     * using the {@link colorMix} factor.\n     *\n     * Note that {@link objectColor} is used only\n     * when the geometry associated with this material\n     * does not have a vertex color buffer.\n     *\n     */\n    get objectColor() {\n        return this.uniforms.color.value;\n    }\n    set objectColor(value) {\n        this.uniforms.color.value.copy(value);\n    }\n    /**\n     * Edge color.\n     */\n    get color() {\n        return this.uniforms.edgeColor.value;\n    }\n    set color(value) {\n        this.uniforms.edgeColor.value.copy(value);\n    }\n    get lineWidth() {\n        return this.linewidth;\n    }\n    /**\n     * Only lineWidth of 0 and 1 is supported.\n     * lineWidth <= 0 will result in not visible lines, everything else into lines\n     * visible with lineWidth 1\n     */\n    set lineWidth(value) {\n        this.linewidth = value;\n        if (this.linewidth <= 0) {\n            this.visible = false;\n        }\n        else {\n            this.visible = true;\n        }\n    }\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    get colorMix() {\n        return this.uniforms.edgeColorMix.value;\n    }\n    set colorMix(value) {\n        if (this.uniforms.edgeColorMix.value === value) {\n            return;\n        }\n        this.uniforms.edgeColorMix.value = value;\n    }\n    get fadeNear() {\n        return this.uniforms.fadeNear.value;\n    }\n    set fadeNear(value) {\n        this.uniforms.fadeNear.value = value;\n    }\n    get fadeFar() {\n        return this.uniforms.fadeFar.value;\n    }\n    set fadeFar(value) {\n        if (this.uniforms.fadeFar.value === value) {\n            return;\n        }\n        this.uniforms.fadeFar.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n    get extrusionRatio() {\n        return this.uniforms.extrusionRatio.value;\n    }\n    set extrusionRatio(value) {\n        if (this.uniforms.extrusionRatio.value === value) {\n            return;\n        }\n        this.uniforms.extrusionRatio.value = value;\n        // NOTE: We could also disable shader extrusion chunks when it hits\n        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.\n        const useExtrusion = value >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        Utils_1.setShaderMaterialDefine(this, \"USE_EXTRUSION\", useExtrusion);\n    }\n    get displacementMap() {\n        return this.uniforms.displacementMap.value;\n    }\n    set displacementMap(map) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== null;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        Utils_1.setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n}\nexports.EdgeMaterial = EdgeMaterial;\nEdgeMaterial.DEFAULT_COLOR = 0x000000;\nEdgeMaterial.DEFAULT_COLOR_MIX = 0.0;\n//# sourceMappingURL=EdgeMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/EdgeMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GroundAtmosphereMaterial = exports.GroundAtmosphereShader = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst AtmosphereChunks_1 = __webpack_require__(/*! ./ShaderChunks/AtmosphereChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst EQUATORIAL_RADIUS = 6378137.0;\n/**\n * `GroundAtmosphereShader`.\n *\n * Describes shading of atmosphere as seen from outer space.\n */\nexports.GroundAtmosphereShader = {\n    uniforms: {\n        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),\n        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),\n        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),\n        // Environment settings:\n        // atmosphere inner and outer radius, camera height\n        u_atmosphereEnv: new THREE.Uniform(new THREE.Vector3(\n        // Maximum inner radius\n        EQUATORIAL_RADIUS * 1.001, \n        // Maximum outer radius\n        EQUATORIAL_RADIUS * 1.025, \n        // Camera height\n        0)),\n        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),\n        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),\n        offset: new THREE.Uniform(33.0),\n        exponent: new THREE.Uniform(0.6),\n        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far\n    },\n    vertexShader: `\n\n    #define IMPROVE_INTERSECT_PRECISION 1\n    #define IMPROVE_DOT_PRECISION 1\n\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    // Base mandatory uniforms\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Km = 0.0015;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 25.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        1.0 / pow(0.650, 4.0), // Red\n        1.0 / pow(0.570, 4.0), // Green\n        1.0 / pow(0.475, 4.0)); // Blue\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ${AtmosphereChunks_1.default.atmosphere_vertex_utils}\n\n    //\n    // Computes rayleight and mia atmosphere factors for ground.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE.\n    //\n    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir)\n    {\n        // Retrieve environment variables\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be moved to const or define(s) at further optimizations:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n#if !defined(IMPROVE_DOT_PRECISION)\n        vec3 v3Dir = normalize(v3Pos);\n#endif\n\n#ifdef CAMERA_IN_SPACE\n\n        // Calculate first point of camera ray and sphere intersection.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection, setting it to\n        // the length of ray passed through atmosphere\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);\n\n#else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten\n        // fFar -= 0.0;\n        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);\n#endif\n\n#if defined(IMPROVE_DOT_PRECISION)\n        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\n#else\n        float fCameraAngle = dot(-v3Ray, v3Dir);\n#endif\n        float fCameraScale = scale(fCameraAngle);\n\n#ifdef DYNAMIC_LIGHT\n        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.\n        #if defined(IMPROVE_DOT_PRECISION)\n            // The light angle for given light source may be calculated as:\n            // angle = dot(vLightDir, v3Dir) / length(v3Dir);\n            // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)\n            float fLightAngle = dot(vLightDir, v3Pos) / length(v3Pos);\n        #else\n            float fLightAngle = dot(vLightDir, v3Dir);\n        #endif\n#else\n        float fLightAngle = 1.0;\n#endif\n        float fLightScale = scale(fLightAngle);\n\n        float fCameraOffset = fDepth * fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i = 0; i < nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n            float fScatter = fDepth * fTemp - fCameraOffset;\n            // Compute color factors\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);\n            // Move to the next point\n            v3SamplePoint += v3SampleRay;\n        }\n\n        AtmosphereColor color;\n        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);\n        // Calculate the attenuation factor for the ground\n        color.rayleigh = v3Attenuate;\n\n        return color;\n    }\n\n    void main(void)\n    {\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n        v_vertToOrigin = normalize(position.xyz);\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    `,\n    fragmentShader: `\n\n    // Exposure correction gives more subtle gradients on the ground.\n    #define CORRECT_EXPOSURE 1\n    #define FADE_DEPTH 1\n    #define NIGHT_LOCAL 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ${AtmosphereChunks_1.default.atmosphere_fragment_utils}\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        // GPU gems mix of ground solution, with custom alpha settings\n        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;\n\n        // Not needed for HDR frame buffer\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Interesting results with exposure factor: 2.0, 3.5, 4.0\n        cRgb = correctExposure(cRgb, 3.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Base atmosphere opacity\n        float fAtmosphereAlpha = 1.0;\n\n        // Factor based on the distance of camera atmosphere and ground, results are:\n        // 0.0 = camera on the ground surface,\n        // 1.0 = at the outer edge of the atmosphere.\n        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n    #ifdef FADE_DEPTH\n        // Fade alpha based on the distance of camera between atmosphere layers\n        #ifdef FADE_DEPTH_LINEAR\n            fAtmosphereAlpha *= fDepthFactor;\n        #else\n            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);\n        #endif\n    #endif\n\n#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)\n    #ifdef DYNAMIC_LIGHT\n        // Adjust factor based on time of day, results are:\n        // 0.0 = night,\n        // 1.0 = day.\n        #ifdef NIGHT_GLOBAL\n            // Global night fade based on camera and light orientation\n            float fNightFactor = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);\n            fNightFactor = pow(fNightFactor, 0.5);\n        #else // NIGHT_LOCAL\n            float fNightFactor =\n                clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0);\n            fNightFactor = pow(fNightFactor, 0.8);\n        #endif\n    #else\n        float fNightFactor = 1.0;\n    #endif\n#endif\n\n    #ifdef FADE_NIGHT\n        // Adjust alpha for night side of the globe\n        fAtmosphereAlpha *= fNightFactor;\n    #endif\n\n    #ifdef DARKEN_NIGHT\n        // Change the brightness depending on night / day side.\n        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,\n        // but it is much more GPU consuming.\n        const float minBrightness = 0.5;\n        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);\n        cRgb *= fDarkenFactor;\n    #endif\n\n    #ifdef EXPOSURE_DEPTH\n        // Control exposure depending from ground distance\n        float exposureBoost = 3.0 - fDepthFactor;\n        cRgb = correctExposure(cRgb, exposureBoost);\n    #endif\n\n        // Experimental fading out of focus point - similar to fresnel effect in top view.\n        // This fade is handy to better expose cartographic/map features in screen center.\n        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;\n        fFocusFactor = pow(fFocusFactor, 2.5);\n        fAtmosphereAlpha *= fFocusFactor;\n\n        // Integrate all features\n        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);\n    }\n    `\n};\nclass GroundAtmosphereMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `GroundAtmosphereMaterial`.\n     *\n     * @param params - `GroundAtmosphereMaterial` parameters. Always required except when cloning\n     * another material.\n     */\n    constructor(params) {\n        let shaderParams;\n        if (params) {\n            const defines = {};\n            defines.CAMERA_IN_SPACE = \"\";\n            shaderParams = {\n                name: \"GroundAtmosphereMaterial\",\n                vertexShader: exports.GroundAtmosphereShader.vertexShader,\n                fragmentShader: exports.GroundAtmosphereShader.fragmentShader,\n                uniforms: exports.GroundAtmosphereShader.uniforms,\n                transparent: true,\n                depthTest: false,\n                depthWrite: false,\n                side: THREE.FrontSide,\n                blending: THREE.NormalBlending,\n                fog: false,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n    }\n    setDynamicLighting(enableLighting) {\n        Utils_1.setShaderMaterialDefine(this, \"DYNAMIC_LIGHT\", enableLighting);\n    }\n    /**\n     * Set maximum outer radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025\n     */\n    set outerRadius(radius) {\n        this.uniforms.u_atmosphereEnv.value.y = radius;\n    }\n    get outerRadius() {\n        return this.uniforms.u_atmosphereEnv.value.y;\n    }\n    /**\n     * Set maximum inner radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.001.\n     */\n    set innerRadius(radius) {\n        this.uniforms.u_atmosphereEnv.value.x = radius;\n    }\n    get innerRadius() {\n        return this.uniforms.u_atmosphereEnv.value.x;\n    }\n    /**\n     * Updates the uniform data of a material used to render an atmosphere.\n     *\n     * This includes only uniforms that may change frame by frame, other uniforms are\n     * accessed with convenient material setters and getters.\n     *\n     * @param shaderMaterial - Material which uniforms will be updated.\n     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.\n     * @param lightDirection - The light directional vector in world space.\n     * @param camera - Camera used in rendering.\n     */\n    updateUniforms(shaderMaterial, object, camera, lightDirection) {\n        const cameraInfo = this.getCameraInfo(object, camera);\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_atmosphereEnv &&\n                shaderMaterial.uniforms.u_hsvCorrection &&\n                shaderMaterial.uniforms.u_eyePositionWorld &&\n                shaderMaterial.uniforms.u_modelViewProjection &&\n                shaderMaterial.uniforms.u_lightDirectionWorld) {\n                const eyePos = cameraInfo.eyePos;\n                const mvp = cameraInfo.modelViewProjection;\n                const cameraHeight = cameraInfo.eyeHeight;\n                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);\n                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);\n                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;\n                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();\n                const cameraInSpace = cameraHeight > this.outerRadius;\n                const needsUpdate0 = Utils_1.setShaderDefine(shaderMaterial.defines, \"CAMERA_IN_SPACE\", cameraInSpace);\n                const needsUpdate1 = Utils_1.setShaderDefine(shaderMaterial.defines, \"CAMERA_IN_ATMOSPHERE\", !cameraInSpace);\n                shaderMaterial.needsUpdate =\n                    shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;\n            }\n            else {\n                throw Error(\"Atmosphere material has missing uniforms\");\n            }\n        }\n        else {\n            throw Error(\"Wrong object used, only Material objects are supported\");\n        }\n    }\n    /*\n     * Calculate camera position used in vertex shader of atmosphere materials.\n     *\n     * @param object -\n     * @param camera - Camera used to get the eye position.\n     */\n    getCameraInfo(object, camera, reverse = false) {\n        if (reverse) {\n            const modelMatrix = new THREE.Matrix4().identity();\n            const viewMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert().transpose();\n            const projectionMatrix = camera.projectionMatrix;\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n            const eyePos = new THREE.Vector3();\n            object.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            camera.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n        else {\n            const modelMatrix = object.matrixWorld;\n            const viewMatrix = camera.matrixWorldInverse;\n            const projectionMatrix = camera.projectionMatrix;\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n            const eyePos = new THREE.Vector3();\n            camera.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            object.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            // Normally we would return simply camera position, but since camera is not moving in\n            // the globe view only the world, we need to calculate eye relative to object position.\n            eyePos.sub(objectPos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n    }\n}\nexports.GroundAtmosphereMaterial = GroundAtmosphereMaterial;\n//# sourceMappingURL=GroundAtmosphereMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHighPrecisionLineMaterial = exports.HighPrecisionLineMaterial = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js\");\nconst vertexSource = `\n#ifdef USE_COLOR\nattribute vec4 color;\nvarying vec3 vColor;\n#endif\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 position;        // high part\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifdef USE_COLOR\nvarying vec3 color;\n#endif\n\nvoid main() {\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( diffuse * vColor, opacity );\n    #else\n    gl_FragColor = vec4( diffuse, opacity );\n    #endif\n}`;\n/**\n * Material designed to render high precision lines (ideal for position-sensible data).\n */\nclass HighPrecisionLineMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `HighPrecisionLineMaterial`.\n     *\n     * @param params - `HighPrecisionLineMaterial` parameters.  Always required except when cloning\n     * another material.\n     */\n    constructor(params) {\n        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);\n        const shaderParams = params\n            ? {\n                name: \"HighPrecisionLineMaterial\",\n                vertexShader: vertexSource,\n                fragmentShader: fragmentSource,\n                uniforms: {\n                    diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),\n                    opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),\n                    u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n                    u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n                    u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n                },\n                rendererCapabilities: params.rendererCapabilities\n            }\n            : undefined;\n        Object.assign(shaderParams, params);\n        super(shaderParams);\n        this.type = \"HighPrecisionLineMaterial\";\n        this.isHighPrecisionLineMaterial = true;\n        // Apply initial parameter values.\n        if (params) {\n            if (params.color !== undefined) {\n                this.color.set(params.color);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n        }\n        this.updateTransparencyFeature();\n    }\n    /**\n     * Line color.\n     */\n    get color() {\n        return this.uniforms.diffuse.value;\n    }\n    set color(value) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n    updateTransparencyFeature() {\n        this.transparent = this.opacity < 1.0 ? true : false;\n    }\n}\nexports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;\nHighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;\nHighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;\nfunction isHighPrecisionLineMaterial(material) {\n    return (material !== undefined &&\n        material.isHighPrecisionLineMaterial === true);\n}\nexports.isHighPrecisionLineMaterial = isHighPrecisionLineMaterial;\n//# sourceMappingURL=HighPrecisionLineMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHighPrecisionPointMaterial = exports.HighPrecisionPointMaterial = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js\");\nconst vertexSource = `\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\nuniform float size;\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n\n    // ignore sizeAttenuation for now!\n    gl_PointSize = size;\n}`;\n/**\n * Material designed to render high precision points (ideal for position-sensible data).\n */\nclass HighPrecisionPointMaterial extends THREE.PointsMaterial {\n    /**\n     * Constructs a new `HighPrecisionPointMaterial`.\n     *\n     * @param params - `HighPrecisionPointMaterial` parameters.\n     */\n    constructor(params) {\n        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);\n        const shaderParams = params;\n        super(shaderParams);\n        this.type = \"HighPrecisionPointMaterial\";\n        this.vertexShader = vertexSource;\n        this.fragmentShader = THREE.ShaderChunk.points_frag;\n        this.fog = false;\n        this.uniforms = {\n            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),\n            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),\n            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),\n            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),\n            map: new THREE.Uniform(new THREE.Texture()),\n            uvTransform: new THREE.Uniform(new THREE.Matrix3()),\n            u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n            u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n        };\n        this.isHighPrecisionPointMaterial = true;\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.size !== undefined) {\n                this.size = params.size;\n            }\n            if (params.scale !== undefined) {\n                this.scale = params.scale;\n            }\n            if (params.uvTransform !== undefined) {\n                this.uvTransform = params.uvTransform;\n            }\n            if (params.map !== undefined) {\n                this.map = params.map;\n            }\n        }\n    }\n    /**\n     *  Point scale.\n     */\n    get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n     * UV transformation matrix.\n     */\n    get uvTransform() {\n        return this.uniforms.uvTransform.value;\n    }\n    set uvTransform(value) {\n        this.uniforms.uvTransform.value = value;\n    }\n}\nexports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;\nHighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;\nHighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;\nHighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;\nHighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;\nfunction isHighPrecisionPointMaterial(material) {\n    return (material !== undefined &&\n        material.isHighPrecisionPointMaterial === true);\n}\nexports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;\n//# sourceMappingURL=HighPrecisionPointMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/IconMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/IconMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IconMaterial = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst vertexSource = `\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec4 color = texture2D(map, vUv.xy);\n    color *= vColor;\n    if (color.a < 0.05) {\n        discard;\n    }\n    gl_FragColor = color;\n}`;\n/**\n * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to\n * apply opacity.\n */\nclass IconMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `IconMaterial`.\n     *\n     * @param params - `IconMaterial` parameters. Always required except when cloning another\n     * material.\n     */\n    constructor(params) {\n        const shaderParams = params\n            ? {\n                name: \"IconMaterial\",\n                vertexShader: vertexSource,\n                fragmentShader: fragmentSource,\n                uniforms: {\n                    map: new THREE.Uniform(params.map)\n                },\n                depthTest: true,\n                depthWrite: false,\n                transparent: true,\n                vertexColors: true,\n                premultipliedAlpha: true,\n                rendererCapabilities: params.rendererCapabilities\n            }\n            : undefined;\n        super(shaderParams);\n    }\n    /**\n     * Icon texture map/atlas.\n     */\n    get map() {\n        return this.uniforms.map.value;\n    }\n}\nexports.IconMaterial = IconMaterial;\n//# sourceMappingURL=IconMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/IconMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LuminosityHighPassShader = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.\n */\nexports.LuminosityHighPassShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        luminosityThreshold: { value: 1.0 },\n        smoothWidth: { value: 1.0 },\n        defaultColor: { value: new THREE.Color(0x000000) },\n        defaultOpacity: { value: 0.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        vec3 luma = vec3( 0.299, 0.587, 0.114 );\n        float v = dot( texel.xyz, luma );\n        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n        gl_FragColor = mix( outputColor, texel, alpha );\n    }`\n};\n//# sourceMappingURL=LuminosityHighPassShader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MSAAMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MSAAMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MSAAMaterial = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ \"./node_modules/@here/harp-materials/lib/CopyMaterial.js\");\n/**\n * The material to use for the quad of the {@link @here/harp-mapview#MSAARenderPass}\n * in the composing.\n */\nclass MSAAMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `MSAAMaterial`.\n     *\n     * @param uniforms - The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms) {\n        super({\n            uniforms,\n            vertexShader: CopyMaterial_1.CopyShader.vertexShader,\n            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\nexports.MSAAMaterial = MSAAMaterial;\n//# sourceMappingURL=MSAAMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MSAAMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterials.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapMeshStandardMaterial = exports.MapMeshDepthMaterial = exports.MapMeshBasicMaterial = exports.ExtrusionFeatureMixin = exports.ExtrusionFeature = exports.FadingFeatureMixin = exports.FadingFeature = exports.DisplacementFeatureMixin = exports.hasExtrusionFeature = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js\");\nconst FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js\");\nconst ShadowChunks_1 = __webpack_require__(/*! ./ShaderChunks/ShadowChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst emptyTexture = new THREE.Texture();\n/**\n * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n * [0..maxVisibilityRange].\n *\n * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.\n *\n * @param distance - Distance from the camera (range: [0, 1]).\n * @param visibilityRange - object describing maximum and minimum visibility range - distances\n * from camera at which objects won't be rendered anymore.\n */\nfunction cameraToWorldDistance(distance, visibilityRange) {\n    return distance * visibilityRange.maximum;\n}\n/**\n * Provides common interface from mixin to internal material defines and shader uniforms.\n *\n * Call this function just after [THREE.Material] is constructed, so in derived classes after\n * super c-tor call.\n * @param mixin - The mixin that will add features to [[THREE.Material]].\n * @param material - The material that mixin feature is being applied.\n */\nfunction linkMixinWithMaterial(mixin, material) {\n    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.\n    // In such case create it manually, such defines will be also injected to the shader\n    // via generic THREE.js code - see THREE/WebGLProgram.js.\n    if (material.defines === undefined) {\n        material.defines = {};\n    }\n    // Link internal THREE.js material defines with mixin reference.\n    // Those defines are usually created in Material c-tor, if not we have fallback above.\n    mixin.shaderDefines = material.defines;\n    // Prepare map for holding uniforms references from the actual shader, but check if\n    // it was not already created with other mixin feature.\n    if (mixin.shaderUniforms === undefined) {\n        mixin.shaderUniforms = {};\n    }\n    // Shader uniforms may not be linked at this stage, they are injected available via Shader\n    // object in onBeforeCompile callback, see: linkMixinWithShader().\n}\n/**\n * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.\n *\n * Function injects features (mixin) specific shader uniforms to material's shader, it also\n * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full\n * uniforms map (both feature specific and internal ones).\n * This function should be called before material's shader is pre-compiled, so the new uniforms\n * from the mixin feature are known to shader processor. The best place to use is\n * [[Material.onBeforeCompile]].\n * @param mixin - The mixin feature being applied to the material.\n * @param shader - The actual shader linked to the [[THREE.Material]].\n */\nfunction linkMixinWithShader(mixin, shader) {\n    Object.assign(shader.uniforms, mixin.shaderUniforms);\n    mixin.shaderUniforms = shader.uniforms;\n}\n/**\n * Determines whether a given material supports extrusion.\n * @param material The material to check.\n * @returns Whether the given material supports extrusion.\n */\nfunction hasExtrusionFeature(material) {\n    return \"extrusionRatio\" in material;\n}\nexports.hasExtrusionFeature = hasExtrusionFeature;\n// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nvar DisplacementFeature;\n(function (DisplacementFeature) {\n    /**\n     * Checks if feature is enabled (displacement map defined).\n     *\n     * @param displacementMaterial -\n     */\n    function isEnabled(displacementMaterial) {\n        return displacementMaterial.displacementMap !== null;\n    }\n    DisplacementFeature.isEnabled = isEnabled;\n    /**\n     * Update the internals of the `DisplacementFeature` depending on the value of\n     * [[displacementMap]].\n     *\n     * @param displacementMaterial - DisplacementFeature\n     */\n    function updateDisplacementFeature(displacementMaterial) {\n        harp_utils_1.assert(displacementMaterial.shaderDefines !== undefined);\n        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);\n        const useDisplacementMap = isEnabled(displacementMaterial);\n        // Whenever displacement feature state changes (between enabled/disabled) material will be\n        // re-compiled, forcing new shader chunks to be added (or removed).\n        const needsUpdate = Utils_1.setShaderDefine(displacementMaterial.shaderDefines, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n        displacementMaterial.needsUpdate = needsUpdate;\n        // Update texture after change.\n        if (useDisplacementMap) {\n            const texture = displacementMaterial.displacementMap;\n            texture.needsUpdate = true;\n            displacementMaterial.shaderUniforms.displacementMap.value = texture;\n        }\n        else if (needsUpdate) {\n            displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;\n        }\n    }\n    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;\n    /**\n     * This function should be called on implementors of DisplacementFeature in the\n     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to\n     * apply displacement maps.\n     *\n     * @param displacementMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    function onBeforeCompile(displacementMaterial, shader) {\n        if (!isEnabled(displacementMaterial)) {\n            return;\n        }\n        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are required for this material, we use one define working as a flag,\n        // which enables/disables some chunks of shader code.\n        linkMixinWithShader(displacementMaterial, shader);\n        // Append the displacement map chunk to the vertex shader.\n        shader.vertexShader = shader.vertexShader.replace(\"#include <skinbase_vertex>\", `#include <skinbase_vertex>\n#ifndef USE_ENVMAP\n    vec3 objectNormal = vec3( normal );\n#endif`);\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"uv2_pars_vertex\", \"displacementmap_pars_vertex\");\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"skinning_vertex\", \"displacementmap_vertex\", true);\n    }\n    DisplacementFeature.onBeforeCompile = onBeforeCompile;\n})(DisplacementFeature || (DisplacementFeature = {}));\nclass DisplacementFeatureMixin {\n    constructor() {\n        this.m_displacementMap = null;\n    }\n    // This is here to keep tslint from reporting a missing property, the getter that's actually\n    // used by materials is added in [[addDisplacementProperties]].\n    get displacementMap() {\n        return this.m_displacementMap;\n    }\n    // This is here to keep tslint from reporting a missing property, the setter that's actually\n    // used by materials is added in [[addDisplacementProperties]].\n    set displacementMap(map) {\n        this.setDisplacementMap(map);\n    }\n    getDisplacementMap() {\n        return this.m_displacementMap;\n    }\n    setDisplacementMap(map) {\n        if (map !== this.m_displacementMap) {\n            this.m_displacementMap = map;\n            DisplacementFeature.updateDisplacementFeature(this);\n        }\n    }\n    /**\n     * The mixin class should call this method to register the property [[displacementMap]]\n     */\n    addDisplacementProperties() {\n        Object.defineProperty(this, \"displacementMap\", {\n            get: () => {\n                return this.getDisplacementMap();\n            },\n            set: val => {\n                this.setDisplacementMap(val);\n            }\n        });\n    }\n    /**\n     * Apply the displacementMap value from the parameters to the respective properties.\n     */\n    applyDisplacementParameters(params) {\n        linkMixinWithMaterial(this, this);\n        harp_utils_1.assert(this.shaderDefines !== undefined);\n        harp_utils_1.assert(this.shaderUniforms !== undefined);\n        // Create uniforms with default values, this ensures they are always set created,\n        // so no need for checks in setters.\n        const uniforms = this.shaderUniforms;\n        uniforms.displacementMap = new THREE.Uniform(emptyTexture);\n        uniforms.displacementScale = new THREE.Uniform(1);\n        uniforms.displacementBias = new THREE.Uniform(0);\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.displacementMap !== undefined) {\n                this.setDisplacementMap(params.displacementMap);\n            }\n        }\n        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {\n            DisplacementFeature.onBeforeCompile(this, shader);\n        });\n        // Require material update at least once, because of new shader chunks added.\n        this.needsUpdate = DisplacementFeature.isEnabled(this);\n    }\n    /**\n     * Copy displacementMap from other DisplacementFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    copyDisplacementParameters(source) {\n        this.setDisplacementMap(source.displacementMap);\n        return this;\n    }\n}\nexports.DisplacementFeatureMixin = DisplacementFeatureMixin;\n/**\n * Namespace with support functions for implementors of `FadingFeature`.\n */\nvar FadingFeature;\n(function (FadingFeature) {\n    FadingFeature.DEFAULT_FADE_NEAR = -1.0;\n    FadingFeature.DEFAULT_FADE_FAR = -1.0;\n    /**\n     * Checks if feature is enabled based on feature params.\n     *\n     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.\n     * This function is crucial for shader switching (chunks injection), whenever feature state\n     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)\n     * whenever fading params are reasonable, even if it causes full fade in, no transparency.\n     *\n     * @param fadingMaterial - FadingFeature.\n     */\n    function isEnabled(fadingMaterial) {\n        // NOTE: We could also check if full fade is not achieved, then feature could be\n        // disabled, but causing material re-compile.\n        return (fadingMaterial.fadeNear !== undefined &&\n            fadingMaterial.fadeFar !== undefined &&\n            fadingMaterial.fadeFar > 0);\n    }\n    FadingFeature.isEnabled = isEnabled;\n    /**\n     * Checks if feature is defined based on feature params.\n     *\n     * Fading feature will be defined if fadeNear and fadeFar are defined, their values\n     * are not checked for reasonable values.\n     *\n     * @param fadingMaterial FadingFeature.\n     */\n    function isDefined(fadingMaterial) {\n        return fadingMaterial.fadeNear !== undefined && fadingMaterial.fadeFar !== undefined;\n    }\n    FadingFeature.isDefined = isDefined;\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);\n        }\n    }\n    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;\n    /**\n     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The\n     * fading feature will be disabled if fadeFar <= 0.0.\n     *\n     * @param fadingMaterial - FadingFeature\n     */\n    function updateFadingFeature(fadingMaterial) {\n        harp_utils_1.assert(fadingMaterial.shaderDefines !== undefined);\n        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);\n        // Update entire material to add/remove shader fading chunks, this happens when we\n        // enable/disable fading after material creation. Feature is marked via dummy define, which\n        // informs about fading feature state, even if such define is not required to control\n        // feature state, it makes it easy to check for shader changes.\n        const useFading = isEnabled(fadingMaterial);\n        const needsUpdate = Utils_1.setShaderDefine(fadingMaterial.shaderDefines, \"FADING_MATERIAL\", useFading);\n        // Enable/disable entire feature with material re-compile, this will also cause\n        // new uniforms injection.\n        fadingMaterial.needsUpdate = needsUpdate;\n        // Check if shader uniforms references are already set in onBeforeCompile callback.\n        harp_utils_1.assert(fadingMaterial.shaderUniforms.fadeNear !== undefined &&\n            fadingMaterial.shaderUniforms.fadeFar !== undefined);\n        // Update shader internal uniforms only if fading is enabled.\n        if (useFading) {\n            fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;\n            fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;\n            if (needsUpdate) {\n                Utils_1.enableBlending(fadingMaterial);\n            }\n        }\n        // Perform one time update of uniforms to defaults when feature disabled (for clarity).\n        else if (needsUpdate) {\n            fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;\n            fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;\n            Utils_1.disableBlending(fadingMaterial);\n        }\n    }\n    FadingFeature.updateFadingFeature = updateFadingFeature;\n    /**\n     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control fading based on view distance.\n     *\n     * @param fadingMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    function onBeforeCompile(fadingMaterial, shader) {\n        if (!isEnabled(fadingMaterial)) {\n            return;\n        }\n        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not required for this material, so the fading shader chunks\n        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature\n        // attached and easy control its state, but this define may be stripped out if needed.\n        linkMixinWithShader(fadingMaterial, shader);\n        // Append the new fading shader cod directly after the fog code. This is done by adding an\n        // include directive for the fading code.\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"fog_pars_vertex\", \"fading_pars_vertex\");\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"fog_vertex\", \"fading_vertex\", true);\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_pars_fragment\", \"fading_pars_fragment\");\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_fragment\", \"fading_fragment\", true);\n    }\n    FadingFeature.onBeforeCompile = onBeforeCompile;\n    /**\n     * As three.js is rendering the transparent objects last (internally), regardless of their\n     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In\n     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the\n     * fade distance value is less than 1.\n     *\n     * @param object - [[THREE.Object3D]] to prepare for rendering.\n     * @param viewRanges - The visibility ranges (clip planes and maximum visible distance) for\n     * actual camera setup.\n     * @param fadeNear - The fadeNear value to set in the material.\n     * @param fadeFar - The fadeFar value to set in the material.\n     * @param updateUniforms - If `true`, the fading uniforms are set. Not required if material is\n     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].\n     * @param additionalCallback - If defined, this function will be called before the function will\n     *          return.\n     */\n    function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {\n        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {\n            const fadingMaterial = material;\n            fadingMaterial.fadeNear =\n                fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR\n                    ? FadingFeature.DEFAULT_FADE_NEAR\n                    : cameraToWorldDistance(fadeNear, viewRanges);\n            fadingMaterial.fadeFar =\n                fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR\n                    ? FadingFeature.DEFAULT_FADE_FAR\n                    : cameraToWorldDistance(fadeFar, viewRanges);\n            if (additionalCallback !== undefined) {\n                additionalCallback(renderer, material);\n            }\n        });\n    }\n    FadingFeature.addRenderHelper = addRenderHelper;\n})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and\n * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some\n * setters and getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass FadingFeatureMixin {\n    constructor() {\n        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;\n        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;\n    }\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    getFadeNear() {\n        return this.m_fadeNear;\n    }\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    setFadeNear(value) {\n        const needsUpdate = value !== this.m_fadeNear;\n        if (needsUpdate) {\n            this.m_fadeNear = value;\n            FadingFeature.updateFadingFeature(this);\n        }\n    }\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    getFadeFar() {\n        return this.m_fadeFar;\n    }\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    setFadeFar(value) {\n        const needsUpdate = value !== this.m_fadeFar;\n        if (needsUpdate) {\n            this.m_fadeFar = value;\n            FadingFeature.updateFadingFeature(this);\n        }\n    }\n    /**\n     * The mixin classes should call this method to register the properties [[fadeNear]] and\n     * [[fadeFar]].\n     */\n    addFadingProperties() {\n        Object.defineProperty(this, \"fadeNear\", {\n            get: () => {\n                return this.getFadeNear();\n            },\n            set: val => {\n                this.setFadeNear(val);\n            }\n        });\n        Object.defineProperty(this, \"fadeFar\", {\n            get: () => {\n                return this.getFadeFar();\n            },\n            set: val => {\n                this.setFadeFar(val);\n            }\n        });\n    }\n    /**\n     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.\n     *\n     * @param params - `FadingMeshBasicMaterial` parameters.\n     */\n    applyFadingParameters(params) {\n        // Prepare maps for holding uniforms and defines references from the actual material.\n        linkMixinWithMaterial(this, this);\n        harp_utils_1.assert(this.shaderDefines !== undefined);\n        harp_utils_1.assert(this.shaderUniforms !== undefined);\n        // Create uniforms with default values, this ensures they are always set created,\n        // so no need for checks in setters.\n        this.shaderUniforms.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);\n        this.shaderUniforms.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.fadeNear !== undefined) {\n                this.setFadeNear(params.fadeNear);\n            }\n            if (params.fadeFar !== undefined) {\n                this.setFadeFar(params.fadeFar);\n            }\n        }\n        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {\n            FadingFeature.onBeforeCompile(this, shader);\n        });\n        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.\n        this.needsUpdate = FadingFeature.isEnabled(this);\n    }\n    /**\n     * Copy fadeNear/fadeFar values from other FadingFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    copyFadingParameters(source) {\n        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);\n        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);\n        return this;\n    }\n}\nexports.FadingFeatureMixin = FadingFeatureMixin;\nvar ExtrusionFeature;\n(function (ExtrusionFeature) {\n    /**\n     * Checks if feature is enabled based on {@link ExtrusionFeature} properties.\n     *\n     * @param extrusionMaterial -\n     */\n    function isEnabled(extrusionMaterial) {\n        return (extrusionMaterial.extrusionRatio !== undefined &&\n            extrusionMaterial.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN);\n    }\n    ExtrusionFeature.isEnabled = isEnabled;\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);\n        }\n    }\n    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;\n    /**\n     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].\n     *\n     * @param ExtrusionMaterial - ExtrusionFeature\n     */\n    function updateExtrusionFeature(extrusionMaterial) {\n        harp_utils_1.assert(extrusionMaterial.shaderDefines !== undefined);\n        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);\n        // Setup shader define that when changed will force material re-compile.\n        const useExtrusion = isEnabled(extrusionMaterial);\n        // Use shader define as marker if feature is enabled/disabled, this is not necessary\n        // required, but material requires update (re-compile) anyway to add/remove shader chunks.\n        const needsUpdate = Utils_1.setShaderDefine(extrusionMaterial.shaderDefines, \"EXTRUSION_MATERIAL\", useExtrusion);\n        // Enable/disable entire feature with material re-compile.\n        extrusionMaterial.needsUpdate = needsUpdate;\n        // Update uniform with new value\n        if (useExtrusion) {\n            extrusionMaterial.shaderUniforms.extrusionRatio.value =\n                extrusionMaterial.extrusionRatio;\n        }\n        // Reset uniform to default, one time only, when feature is disabled (just for clarity).\n        else if (needsUpdate) {\n            extrusionMaterial.shaderUniforms.extrusionRatio.value =\n                MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n        }\n    }\n    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;\n    /**\n     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control extrusion.\n     *\n     * @param extrusionMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    function onBeforeCompile(extrusionMaterial, shader) {\n        if (!isEnabled(extrusionMaterial)) {\n            return;\n        }\n        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them. No defines are required to preprocess\n        // shader chunks, but we utilize one just to note the feature is enabled/disabled\n        // (easier debugging), this define may be easily stripped out or replaced with simple\n        // boolean flag.\n        linkMixinWithShader(extrusionMaterial, shader);\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"common\", \"extrusion_pars_vertex\");\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"begin_vertex\", \"extrusion_vertex\", true);\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_pars_fragment\", \"extrusion_pars_fragment\");\n        shader.fragmentShader = shader.fragmentShader.replace(\"#include <normal_fragment_begin>\", \"#include <extrusion_normal_fragment_begin>\");\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_fragment\", \"extrusion_fragment\", true);\n    }\n    ExtrusionFeature.onBeforeCompile = onBeforeCompile;\n})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.\n *\n * @remarks\n * There is some special handling for the extrusionRatio property, which is animated via\n * {@link @here/harp-mapview#AnimatedExtrusionHandler} that is\n * using [[extrusionRatio]] setter and getter to update\n * extrusion in a way that works well with the mixin and EdgeMaterial.\n */\nclass ExtrusionFeatureMixin {\n    constructor() {\n        this.m_extrusion = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    getExtrusionRatio() {\n        return this.m_extrusion;\n    }\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    setExtrusionRatio(value) {\n        const needsUpdate = value !== this.m_extrusion;\n        if (needsUpdate) {\n            this.m_extrusion = value;\n            ExtrusionFeature.updateExtrusionFeature(this);\n        }\n    }\n    /**\n     * The mixin class should call this method to register the property [[extrusionRatio]]\n     */\n    addExtrusionProperties() {\n        Object.defineProperty(this, \"extrusionRatio\", {\n            get: () => {\n                return this.getExtrusionRatio();\n            },\n            set: val => {\n                this.setExtrusionRatio(val);\n            }\n        });\n    }\n    /**\n     * Apply the extrusionRatio value from the parameters to the respective properties.\n     */\n    applyExtrusionParameters(params) {\n        // Prepare maps for holding uniforms and defines references from the actual material.\n        linkMixinWithMaterial(this, this);\n        harp_utils_1.assert(this.shaderDefines !== undefined);\n        harp_utils_1.assert(this.shaderUniforms !== undefined);\n        if (params && params.zFightingWorkaround === true) {\n            this.shaderDefines.ZFIGHTING_WORKAROUND = \"\";\n        }\n        // Create uniform with default value, this ensures that it is always created,\n        // so no need for checks in setters.\n        this.shaderUniforms.extrusionRatio = new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.extrusionRatio !== undefined) {\n                this.setExtrusionRatio(params.extrusionRatio);\n            }\n        }\n        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {\n            ExtrusionFeature.onBeforeCompile(this, shader);\n        });\n        this.needsUpdate = ExtrusionFeature.isEnabled(this);\n    }\n    /**\n     * Copy extrusionRatio values from other ExtrusionFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    copyExtrusionParameters(source) {\n        if (source.extrusionRatio !== undefined) {\n            this.setExtrusionRatio(source.extrusionRatio);\n        }\n        return this;\n    }\n}\nexports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;\n/**\n * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and\n * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is\n * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]\n * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are\n * updated to world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass MapMeshBasicMaterial extends THREE.MeshBasicMaterial {\n    /**\n     * Constructs a new `FadingMeshBasicMaterial`.\n     *\n     * @param params - `FadingMeshBasicMaterial` parameters.\n     */\n    constructor(params) {\n        super(params);\n        FadingFeature.patchGlobalShaderChunks();\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n        ExtrusionFeature.patchGlobalShaderChunks();\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));\n        this.addDisplacementProperties();\n        this.applyDisplacementParameters(params);\n    }\n    // overrides with THREE.js base classes are not recognized by tslint.\n    clone() {\n        return new MapMeshBasicMaterial().copy(this);\n    }\n    // overrides with THREE.js base classes are not recognized by tslint.\n    copy(source) {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        this.copyDisplacementParameters(source);\n        return this;\n    }\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n    get fadeNear() {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    set fadeNear(value) {\n        // to be overridden\n    }\n    get fadeFar() {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    set fadeFar(value) {\n        // to be overridden\n    }\n    get extrusionRatio() {\n        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    set extrusionRatio(value) {\n        // to be overridden\n    }\n    get displacementMap() {\n        return null;\n    }\n    set displacementMap(value) {\n        // to be overridden\n    }\n    setDisplacementMap(value) {\n        // to be overridden\n    }\n    addFadingProperties() {\n        // to be overridden\n    }\n    applyFadingParameters(params) {\n        // to be overridden\n    }\n    copyFadingParameters(source) {\n        // to be overridden\n    }\n    addExtrusionProperties() {\n        // to be overridden\n    }\n    applyExtrusionParameters(params) {\n        // to be overridden\n    }\n    copyExtrusionParameters(source) {\n        // to be overridden\n    }\n    addDisplacementProperties() {\n        // to be overridden\n    }\n    applyDisplacementParameters(params) {\n        // to be overridden\n    }\n    copyDisplacementParameters(source) {\n        // to be overridden\n    }\n}\nexports.MapMeshBasicMaterial = MapMeshBasicMaterial;\nclass MapMeshDepthMaterial extends THREE.MeshDepthMaterial {\n    constructor(params) {\n        super(params);\n        ExtrusionFeature.patchGlobalShaderChunks();\n        this.addExtrusionProperties();\n        // We need to set these to false, because otherwise three.js complains that there are\n        // outputs of the vertex shader not used in the pixel shader, the properties in question\n        // are `vExtrusionRatio` and `vExtrusionAxis`.\n        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: false }));\n        this.flatShading = false;\n    }\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in{@link ExtrusionFeatureMixin}, see below:\n    //\n    // applyMixinsWithoutProperties(...);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n    get extrusionRatio() {\n        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    set extrusionRatio(value) {\n        // to be overridden\n    }\n    addExtrusionProperties() {\n        // to be overridden\n    }\n    applyExtrusionParameters(params) {\n        // to be overridden\n    }\n    copyExtrusionParameters(source) {\n        // to be overridden\n    }\n}\nexports.MapMeshDepthMaterial = MapMeshDepthMaterial;\n/**\n * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and\n * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also\n * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,\n * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to\n * world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass MapMeshStandardMaterial extends THREE.MeshStandardMaterial {\n    /**\n     * Constructs a new `FadingMeshStandardMaterial`.\n     *\n     * @param params - `FadingMeshStandardMaterial` parameters.\n     */\n    constructor(params) {\n        super(params);\n        FadingFeature.patchGlobalShaderChunks();\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n        ExtrusionFeature.patchGlobalShaderChunks();\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));\n        if ((params === null || params === void 0 ? void 0 : params.removeDiffuseLight) === true) {\n            this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, shaderParameters => {\n                const shader = shaderParameters;\n                shader.fragmentShader = THREE.ShaderChunk.meshphysical_frag.replace(\"#include <lights_physical_pars_fragment>\", ShadowChunks_1.simpleLightingShadowChunk);\n            });\n        }\n    }\n    // overrides with THREE.js base classes are not recognized by tslint.\n    clone() {\n        return new MapMeshStandardMaterial().copy(this);\n    }\n    // overrides with THREE.js base classes are not recognized by tslint.\n    copy(source) {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        return this;\n    }\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n    get fadeNear() {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    set fadeNear(value) {\n        // to be overridden\n    }\n    get fadeFar() {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    set fadeFar(value) {\n        // to be overridden\n    }\n    get extrusionRatio() {\n        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    set extrusionRatio(value) {\n        // to be overridden\n    }\n    /**\n     * This is needed to simplify the lighting calculation, currently there is no support for\n     * switching this at runtime. It is required here to be a property because the parameters\n     * are applied to this material, and if this isn't here, three.js will complain that the\n     * property is missing.\n     * @internal\n     */\n    get removeDiffuseLight() {\n        return false;\n    }\n    /** @internal */\n    set removeDiffuseLight(val) {\n        // Stays empty.\n    }\n    addFadingProperties() {\n        // to be overridden\n    }\n    applyFadingParameters(params) {\n        // to be overridden\n    }\n    copyFadingParameters(source) {\n        // to be overridden\n    }\n    addExtrusionProperties() {\n        // to be overridden\n    }\n    applyExtrusionParameters(params) {\n        // to be overridden\n    }\n    copyExtrusionParameters(source) {\n        // to be overridden\n    }\n}\nexports.MapMeshStandardMaterial = MapMeshStandardMaterial;\n/**\n * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual\n * implementations of the mixed in functions.\n */\nharp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);\n//# sourceMappingURL=MapMeshMaterials.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MapMeshMaterials.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtrusionFeatureDefs = void 0;\nvar ExtrusionFeatureDefs;\n(function (ExtrusionFeatureDefs) {\n    /**\n     * Minimum ratio value for extrusion effect\n     */\n    ExtrusionFeatureDefs.DEFAULT_RATIO_MIN = 0.0;\n    /**\n     * Maximum ratio value for extrusion effect\n     */\n    ExtrusionFeatureDefs.DEFAULT_RATIO_MAX = 1;\n    /**\n     * Buildings height used whenever no height-data is present or height is very small.\n     *\n     * Used to avoid z-fighting between ground plane and building.\n     */\n    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT = 0.01;\n})(ExtrusionFeatureDefs = exports.ExtrusionFeatureDefs || (exports.ExtrusionFeatureDefs = {}));\n//# sourceMappingURL=MapMeshMaterialsDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/RawShaderMaterial.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/RawShaderMaterial.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RawShaderMaterial = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\n/**\n * Base class for all raw shader materials. Ensures WebGL2 compatibility for WebGL1 shaders.\n */\nclass RawShaderMaterial extends THREE.RawShaderMaterial {\n    /**\n     * The constructor of `RawShaderMaterial`.\n     *\n     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning\n     * another material.\n     */\n    constructor(params) {\n        const isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;\n        const shaderParams = params\n            ? Object.assign(Object.assign({}, params), { glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1, vertexShader: isWebGL2 && params.vertexShader\n                    ? harp_utils_1.convertVertexShaderToWebGL2(params.vertexShader)\n                    : params.vertexShader, fragmentShader: isWebGL2 && params.fragmentShader\n                    ? harp_utils_1.convertFragmentShaderToWebGL2(params.fragmentShader)\n                    : params.fragmentShader }) : undefined;\n        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js\n        // will log warnings.\n        if (shaderParams) {\n            delete shaderParams.rendererCapabilities;\n        }\n        super(shaderParams);\n        this.invalidateFog();\n        this.setOpacity(shaderParams === null || shaderParams === void 0 ? void 0 : shaderParams.opacity);\n    }\n    invalidateFog() {\n        if (this.defines !== undefined && this.fog !== Utils_1.getShaderMaterialDefine(this, \"USE_FOG\")) {\n            Utils_1.setShaderMaterialDefine(this, \"USE_FOG\", this.fog);\n        }\n    }\n    /**\n     * To set the material's opacity property value and also update the opacity value of the uniforms if needed.\n     * @param opacity If undefined, the value is not set\n     */\n    setOpacity(opacity) {\n        var _a;\n        if (opacity !== undefined) {\n            // The base constructor may set the opacity property before,\n            // therefore we don't check unequality of the current and new opacity value:\n            this.opacity = opacity;\n            if ((_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.opacity) {\n                this.uniforms.opacity.value = opacity;\n            }\n        }\n    }\n}\nexports.RawShaderMaterial = RawShaderMaterial;\n//# sourceMappingURL=RawShaderMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/RawShaderMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SepiaShader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SepiaShader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SepiaShader = void 0;\n/**\n * `SepiaShader`.\n */\nexports.SepiaShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        amount: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float amount;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D( tDiffuse, vUv );\n            vec3 c = color.rgb;\n            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n        }`\n};\n//# sourceMappingURL=SepiaShader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/SepiaShader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    atmosphere_vertex_utils: `\n\n    const float RayleighScaleDepth = 0.25;\n\n    struct AtmosphereColor\n    {\n        vec3 mie;\n        vec3 rayleigh;\n    };\n\n    float scale(float cosAngle)\n    {\n        float x = 1.0 - cosAngle;\n        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x0 (first point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),\n        // we change the equation that gives better results especially around the poles.\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Intersection points distances are defined as follows:\n        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a\n        // we search for x0:\n        return 0.5 * (-fB - sqrt(fDet));\n    }\n\n    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x1 (second point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Compute second intersection distance:\n        // x1 = (-b + sqrt(det)) / 2*a\n        return 0.5 * (-fB + sqrt(fDet));\n    }\n    `,\n    atmosphere_fragment_utils: `\n\n    // Branch free RGB to HSV conversion.\n    // Based on article:\n    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\n    // and optimized OpenGL SL algorithm\n    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec3 rgb2Hsv(vec3 c)\n    {\n        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        // Ternary operator may be used explicitly if compiler can use fast conditional move.\n        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);\n        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));\n        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n\n    // Branch free HSV to RGB conversion\n    vec3 hsv2Rgb(vec3 c)\n    {\n        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);\n        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);\n    }\n\n    vec3 correctExposure(vec3 rgb, float exposure)\n    {\n        const vec3 fullColor = vec3(1.0);\n        return fullColor - exp(-exposure * rgb);\n    }\n\n    vec3 correctColor(vec3 rgb, vec3 hsvShift)\n    {\n        const float e = 0.0000001;\n        // Convert rgb color to hsv\n        vec3 hsv = rgb2Hsv(rgb);\n        // Shift hue value with angle wrapping\n        hsv.x = mod(hsv.x + hsvShift.x, 1.0);\n        // Shift and clamp saturation\n        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);\n        // Change value if it is significant (greater then epsilon)\n        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;\n        // Convert shifted hsv back to rgb\n        return hsv2Rgb(hsv);\n    }\n    `\n};\n//# sourceMappingURL=AtmosphereChunks.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! ../MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst MIN_BUILDING_HEIGHT_SQUARED = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;\nexports.default = {\n    extrusion_pars_vertex: `\n// Add define so we can check for it in the outline effect (see Outline.ts).\n#define HAS_EXTRUSION_PARS_VERTEX\n// Extrusion axis (xyz: vector, w: factor).\nattribute vec4 extrusionAxis;\nuniform float extrusionRatio;\n#ifdef FLAT_SHADED\nvarying vec4 vExtrusionAxis;\n#endif\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#endif\n`,\n    extrusion_vertex: `\n#define HAS_EXTRUSION_VERTEX\n#ifdef ZFIGHTING_WORKAROUND\n// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.\nconst float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};\nfloat extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);\nvExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;\n#else\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ntransformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);\n#ifdef FLAT_SHADED\nvExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);\n#endif\n`,\n    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded\n    // geometries, computes the normal either with the extrusion axis or fragment derivatives based\n    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).\n    extrusion_normal_fragment_begin: `\n#ifdef FLAT_SHADED\n    // Flattened this divergent path to prevent undefined behaviour in the following derivatives\n    // functions. For more info:\n    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches\n\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\n    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\n    vec3 normal = cross( fdx, fdy );\n    if (vExtrusionAxis.w > 0.999999) {\n        normal = vExtrusionAxis.xyz;\n    }\n    normal = normalize(normal);\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\tbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t#endif\n\t#endif\n#endif\n// non perturbed normal for clearcoat among others\nvec3 geometryNormal = normal;\n`,\n    extrusion_pars_fragment: `\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#else\nuniform float extrusionRatio;\n#endif\nvarying vec4 vExtrusionAxis;\n`,\n    extrusion_fragment: `\n#ifndef ZFIGHTING_WORKAROUND\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ngl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );\n`\n};\n//# sourceMappingURL=ExtrusionChunks.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The shader chunks have their lines \"#ifdef USE_FADING\" commented out, because currently the\n * mesh materials use individually created shader strings based on the materials settings.\n * @see [[FadingMeshBasicMaterial]]\n **/\nexports.default = {\n    fading_pars_vertex: `\nvarying float fadingDepth;\n`,\n    fading_vertex: `\nfadingDepth = -mvPosition.z;\n`,\n    fading_pars_fragment: `\nvarying float fadingDepth;\nuniform float fadeNear;\nuniform float fadeFar;\n`,\n    fading_fragment: `\n\n// lerp with \"hard\" edges\n//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n\n// smooth transitions\nfloat fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );\n\ngl_FragColor.a *= 1.0 - fadingFactor;\n\n// debugging color:\n// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);\n`\n};\n//# sourceMappingURL=FadingChunks.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LineCapsModes = void 0;\n/**\n * Lists supported line caps types/modes.\n */\nvar LineCapsModes;\n(function (LineCapsModes) {\n    LineCapsModes[LineCapsModes[\"CAPS_NONE\"] = 0] = \"CAPS_NONE\";\n    LineCapsModes[LineCapsModes[\"CAPS_SQUARE\"] = 1] = \"CAPS_SQUARE\";\n    LineCapsModes[LineCapsModes[\"CAPS_ROUND\"] = 2] = \"CAPS_ROUND\";\n    LineCapsModes[LineCapsModes[\"CAPS_TRIANGLE_IN\"] = 3] = \"CAPS_TRIANGLE_IN\";\n    LineCapsModes[LineCapsModes[\"CAPS_TRIANGLE_OUT\"] = 4] = \"CAPS_TRIANGLE_OUT\";\n})(LineCapsModes = exports.LineCapsModes || (exports.LineCapsModes = {}));\nexports.default = {\n    extrude_line_vert_func: `\nvec3 extrudeLine(\n        in vec3 vertexPosition,\n        in float linePosition,\n        in float extrusionWidth,\n        in vec4 bitangent,\n        in vec3 tangent,\n        in float tanHalfAngle,\n        inout vec2 uv\n    ) {\n    vec3 result = vertexPosition;\n    // Retrieve the angle between this segment and the previous one (stored in the bitangent w\n    // component).\n    float angle = bitangent.w;\n    // Extrude according to the angle between segments to properly render narrow joints...\n    if (angle != 0.0) {\n        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);\n        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;\n    }\n    // ... or extrude in a simple manner for segments that keep the same direction.\n    else {\n        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;\n        uv.x = linePosition + uv.x * extrusionWidth;\n    }\n    uv.y *= extrusionWidth;\n    return result;\n}\n`,\n    round_edges_and_add_caps: `\n#define CAPS_NONE ${LineCapsModes.CAPS_NONE}\n#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}\n#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}\n#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}\n#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}\n\nfloat roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {\n    // Compute the line's width to length ratio.\n    float widthRatio = range.y / range.x;\n\n    // Compute the inner segment distance (same for all cap mode).\n    float dist = abs(coords.y);\n    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);\n    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);\n    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));\n    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));\n\n    #if CAPS_MODE != CAPS_ROUND\n    // Compute the caps mask.\n    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);\n    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);\n    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);\n    float capMask = capRangeMask * max(beginCapMask, endCapMask);\n\n    // Compute the outer segment distance (specific for each cap mode).\n    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;\n    #if CAPS_MODE == CAPS_NONE\n    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);\n    #elif CAPS_MODE == CAPS_SQUARE\n    dist = mix(dist, max(abs(coords.y), capDist), capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_OUT\n    dist = mix(dist, abs(coords.y) + capDist, capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_IN\n    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);\n    #endif\n    #endif // CAPS_MODE != CAPS_ROUND\n\n    return dist;\n}\n`,\n    tile_clip_func: `\nvoid tileClip(vec2 tilePos, vec2 tileSize) {\n    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))\n        discard;\n    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))\n        discard;\n}\n`,\n    high_precision_vert_func: `\nvec3 subtractDblEyePos( const in vec3 pos ) {\n    vec3 t1 = positionLow - u_eyepos_lowpart;\n    vec3 e = t1 - positionLow;\n    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;\n    vec3 high_delta = t1 + t2;\n    vec3 low_delta = t2 - (high_delta - t1);\n    return (high_delta + low_delta);\n}\n`\n};\n//# sourceMappingURL=LinesChunks.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.simpleLightingShadowChunk = void 0;\n/**\n * This shader chunk replaces the default lighting in the standard material, the problem with this\n * is that the final pixel color is the addition of the material color and the light, this means\n * that the final map's rendered color is vastly different from that configured by the designers.\n * This chunk removes the extra highlight by providing just two colors, the material color when not\n * in shadow and a reduced color value when in shadow (currently 50% of the material's color).\n */\nexports.simpleLightingShadowChunk = `\n    struct PhysicalMaterial {\n        vec3\tdiffuseColor;\n        float\tspecularRoughness;\n        vec3\tspecularColor;\n    };\n\n    #define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n    void RE_Direct_Physical( const in IncidentLight directLight,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n        // directLight.color is the light color * shadow, internally three.js uses a step function, so\n        // this value is either the light color or black. in order to lighten up the shadows, we\n        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to\n        // the material's diffuse color.\n        #if defined(USE_SHADOWMAP)\n            reflectedLight.directDiffuse = (0.5 * directLight.color +\n                vec3(0.5,0.5,0.5)) * material.diffuseColor;\n        #else\n            reflectedLight.directDiffuse = material.diffuseColor;\n        #endif\n    }\n\n    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)\n    }\n\n    void RE_IndirectSpecular_Physical( const in vec3 radiance,\n        const in vec3 irradiance,\n        const in vec3 clearcoatRadiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight) {\n            // Disable specular reflection of light.\n    }\n\n    #define RE_Direct               RE_Direct_Physical\n    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical\n    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical\n`;\n//# sourceMappingURL=ShadowChunks.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SkyAtmosphereMaterial = exports.SkyAtmosphereShader = void 0;\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst AtmosphereChunks_1 = __webpack_require__(/*! ./ShaderChunks/AtmosphereChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst EQUATORIAL_RADIUS = 6378137.0;\n/**\n * `SkyAtmosphereShader`.\n *\n * Describes shading of atmosphere as seen from outer space.\n */\nexports.SkyAtmosphereShader = {\n    uniforms: {\n        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),\n        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),\n        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),\n        // Environment settings:\n        // atmosphere inner and outer radius, camera height\n        u_atmosphereEnv: new THREE.Uniform(new THREE.Vector3(\n        // Maximum inner radius\n        EQUATORIAL_RADIUS, \n        // Maximum outer radius\n        EQUATORIAL_RADIUS * 1.025, \n        // Camera height\n        0.0)),\n        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),\n        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),\n        offset: new THREE.Uniform(33.0),\n        exponent: new THREE.Uniform(0.6),\n        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far\n    },\n    vertexShader: `\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km = 0.0015;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 15.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ${AtmosphereChunks_1.default.atmosphere_vertex_utils}\n\n    //\n    // Computes rayleight and mia atmosphere factors for sky.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE\n    //\n    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir)\n    {\n        // Unpack attributes\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be const or define(s) at further optimization:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n    #ifdef CAMERA_IN_SPACE\n\n        // Calculate the closest intersection of the ray with the outer\n        // atmosphere, this is the first point of the ray passing through the atmosphere dome.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n\n        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n        float fStartDepth = exp(-1.0 / RayleighScaleDepth );\n        float fStartOffset = fStartDepth * scale(fStartAngle);\n\n    #else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        float height = length(v3Start);\n        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n        float fStartAngle = dot(v3Ray, v3Start) / height;\n        float fStartOffset = depth * scale(fStartAngle);\n\n    #endif\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i=0; i < nSamples; i++)\n        {\n            float height = length(v3SamplePoint);\n            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));\n            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;\n            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;\n            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (depth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Scale the Mie and Rayleigh colors and set up output of the function\n        AtmosphereColor color;\n        color.mie = v3BaseColor * KmESun;\n        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);\n        return color;\n    }\n\n    void main(void)\n    {\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    `,\n    fragmentShader: `\n    // Because of harsh light distribution the exposure correction is always enabled for the sky.\n    #define CORRECT_EXPOSURE 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ${AtmosphereChunks_1.default.atmosphere_fragment_utils}\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n            // Alter alpha based on time of day (0.0 = night , 1.0 = day)\n            float fNightAlpha = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n            float fNightAlpha = 1.0;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        // NOTE:\n        // For better precision normalization may be added on fragment (for mobile devices)\n        // while in vertex shader may be left un-normalized\n        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);\n        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);\n        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);\n        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);\n\n        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n\n        // Sky produces very harsh lighting effect so exposure correction is always enabled.\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Exposure factor may be exposed to uniform variable.\n        cRgb = correctExposure(cRgb, 2.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)\n        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);\n\n        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));\n    }\n    `\n};\nclass SkyAtmosphereMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `SkyAtmosphereMaterial`.\n     *\n     * @param params - `SkyAtmosphereMaterial` parameters. Always required except when cloning\n     * another material.\n     */\n    constructor(params) {\n        let shaderParams;\n        if (params) {\n            // Import shader chunks\n            const defines = {};\n            defines.CAMERA_IN_SPACE = \"\";\n            shaderParams = {\n                name: \"SkyAtmosphereMaterial\",\n                vertexShader: exports.SkyAtmosphereShader.vertexShader,\n                fragmentShader: exports.SkyAtmosphereShader.fragmentShader,\n                uniforms: exports.SkyAtmosphereShader.uniforms,\n                transparent: true,\n                depthTest: true,\n                depthWrite: false,\n                side: THREE.BackSide,\n                blending: THREE.NormalBlending,\n                fog: false,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n    }\n    setDynamicLighting(enableLighting) {\n        Utils_1.setShaderMaterialDefine(this, \"DYNAMIC_LIGHT\", enableLighting);\n    }\n    /**\n     * Set maximum outer radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025\n     */\n    set outerRadius(radius) {\n        this.uniforms.u_atmosphereEnv.value.y = radius;\n    }\n    get outerRadius() {\n        return this.uniforms.u_atmosphereEnv.value.y;\n    }\n    /**\n     * Set maximum inner radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]].\n     */\n    set innerRadius(radius) {\n        this.uniforms.u_atmosphereEnv.value.x = radius;\n    }\n    get innerRadius() {\n        return this.uniforms.u_atmosphereEnv.value.x;\n    }\n    /**\n     * Updates the uniform data of a material used to render an atmosphere.\n     *\n     * This includes only uniforms that may change frame by frame, other uniforms are\n     * accessed with convenient material setters and getters.\n     *\n     * @param shaderMaterial - Material which uniforms will be updated.\n     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.\n     * @param lightDirection - The light directional vector in world space.\n     * @param camera - Camera used in rendering.\n     */\n    updateUniforms(shaderMaterial, object, camera, lightDirection) {\n        const cameraInfo = this.getCameraInfo(object, camera);\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_atmosphereEnv &&\n                shaderMaterial.uniforms.u_hsvCorrection &&\n                shaderMaterial.uniforms.u_eyePositionWorld &&\n                shaderMaterial.uniforms.u_modelViewProjection &&\n                shaderMaterial.uniforms.u_lightDirectionWorld) {\n                const eyePos = cameraInfo.eyePos;\n                const mvp = cameraInfo.modelViewProjection;\n                const cameraHeight = cameraInfo.eyeHeight;\n                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);\n                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);\n                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;\n                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();\n                const cameraInSpace = cameraHeight > this.outerRadius;\n                const needsUpdate0 = Utils_1.setShaderDefine(shaderMaterial.defines, \"CAMERA_IN_SPACE\", cameraInSpace);\n                const needsUpdate1 = Utils_1.setShaderDefine(shaderMaterial.defines, \"CAMERA_IN_ATMOSPHERE\", !cameraInSpace);\n                shaderMaterial.needsUpdate =\n                    shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;\n            }\n            else {\n                throw Error(\"Atmosphere material has missing uniforms\");\n            }\n        }\n        else {\n            throw Error(\"Wrong object used, only Material objects are supported\");\n        }\n    }\n    /*\n     * Calculate camera position used in vertex shader of atmosphere materials.\n     *\n     * @param object -\n     * @param camera - Camera used to get the eye position.\n     */\n    getCameraInfo(object, camera, reverse = false) {\n        if (reverse) {\n            const modelMatrix = new THREE.Matrix4().identity();\n            const viewMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert().transpose();\n            const projectionMatrix = camera.projectionMatrix;\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n            const eyePos = new THREE.Vector3();\n            object.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            camera.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n        else {\n            const modelMatrix = object.matrixWorld;\n            const viewMatrix = camera.matrixWorldInverse;\n            const projectionMatrix = camera.projectionMatrix;\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n            const eyePos = new THREE.Vector3();\n            camera.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            object.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            // Normally we would return simply camera position, but since camera is not moving in\n            // the globe view only the world, we need to calculate eye relative to object position.\n            eyePos.sub(objectPos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n    }\n}\nexports.SkyAtmosphereMaterial = SkyAtmosphereMaterial;\n//# sourceMappingURL=SkyAtmosphereMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SolidLineMaterial.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SolidLineMaterial = exports.LineDashesModes = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterials.js\");\nconst RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ \"./node_modules/@here/harp-materials/lib/RawShaderMaterial.js\");\nconst LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst LineCapsDefinesMapping = {\n    None: LinesChunks_1.LineCapsModes.CAPS_NONE,\n    Square: LinesChunks_1.LineCapsModes.CAPS_SQUARE,\n    Round: LinesChunks_1.LineCapsModes.CAPS_ROUND,\n    TriangleIn: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_IN,\n    TriangleOut: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_OUT\n};\nconst DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {\n    const defineKey = lineCapsName;\n    const defineValue = LineCapsDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, {});\nvar LineDashesModes;\n(function (LineDashesModes) {\n    LineDashesModes[LineDashesModes[\"DASHES_SQUARE\"] = 0] = \"DASHES_SQUARE\";\n    LineDashesModes[LineDashesModes[\"DASHES_ROUND\"] = 1] = \"DASHES_ROUND\";\n    LineDashesModes[LineDashesModes[\"DASHES_DIAMOND\"] = 2] = \"DASHES_DIAMOND\";\n})(LineDashesModes = exports.LineDashesModes || (exports.LineDashesModes = {}));\nconst LineDashesDefinesMapping = {\n    Square: LineDashesModes.DASHES_SQUARE,\n    Round: LineDashesModes.DASHES_ROUND,\n    Diamond: LineDashesModes.DASHES_DIAMOND\n};\nconst DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce((r, lineDashesName) => {\n    const defineKey = lineDashesName;\n    const defineValue = LineDashesDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, {});\n/**\n * The vLength contains the actual line length, it's needed for the creation of line caps by\n * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`\n */\n/**\n * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was\n * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on\n * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than\n * the full line length.\n */\nconst tmpColor = new THREE.Color();\nconst vertexSource = `\n#define SEGMENT_OFFSET 0.1\n\nattribute vec3 extrusionCoord;\nattribute vec3 position;\nattribute vec4 bitangent;\nattribute vec3 tangent;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform float offset;\nuniform vec2 drawRange;\n\n#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nattribute vec3 color;\nvarying vec3 vColor;\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\n#include <fog_pars_vertex>\n\n#include <extrude_line_vert_func>\n\nvoid main() {\n    // Calculate the segment.\n    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;\n    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;\n\n    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.\n    float linePos = mix(segment.x, segment.y, segmentPos);\n    vec2 extrusionDir = sign(extrusionCoord.xy);\n    // Precompute to avoid computing multiple times\n    float tanHalfAngle = tan(bitangent.w / 2.0);\n    float extrusionFactor = extrusionDir.y * tanHalfAngle;\n\n    // Calculate the extruded vertex position (and scale the extrusion direction).\n    vec3 pos = extrudeLine(\n        position, linePos, extrusionWidth + outlineWidth, bitangent, tangent, tanHalfAngle,\n        extrusionDir);\n\n    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).\n    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);\n    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);\n\n    // Adjust the segment to fit the drawRange.\n    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;\n    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {\n        vCoords.zw += 1.0;\n    }\n    if (vCoords.z < drawRange.x) {\n        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);\n    }\n    if (vCoords.w > drawRange.y) {\n        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);\n    }\n\n    // Transform position.\n    #ifdef USE_DISPLACEMENTMAP\n    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    // Shift the line based on the offset, where the bitangent is the cross product of the average\n    // of the two direction vectors (the previous and next segment directions) and the normal of\n    // the line (facing into the sky). The w component is the angle between the two segments.\n    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how\n    // much we need to extend the offset. Note, orthough this looks complicated we are doing this\n    // in the vertex shader, so it should not cause a performance issue.\n    pos += bitangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));\n\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Pass extruded position to fragment shader.\n    #ifdef USE_TILE_CLIP\n    vPosition = pos;\n    #endif\n\n    #ifdef USE_COLOR\n    // Pass vertex color to fragment shader.\n    vColor = color;\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n\n    #include <fog_vertex>\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform vec3 outlineColor;\nuniform float opacity;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform vec2 tileSize;\nuniform vec2 drawRange;\n\n#ifdef USE_DASHED_LINE\nuniform float dashSize;\nuniform float gapSize;\nuniform vec3 dashColor;\n\n#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}\n#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}\n#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\n\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\n#include <round_edges_and_add_caps>\n#include <tile_clip_func>\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\n#include <fog_pars_fragment>\n\nvoid main() {\n    float alpha = opacity;\n    vec3 outputDiffuse = diffuse;\n\n    #ifdef USE_TILE_CLIP\n    tileClip(vPosition.xy, tileSize);\n    #endif\n\n    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).\n    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);\n    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).\n    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;\n\n    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope\n    // of distToChange increases (i.e. the line is further away).\n    float width = fwidth(distToEdge);\n\n    float s = opacity < 0.98\n        ? clamp((distToEdge + width) / (2.0 * width), 0.0, 1.0) // prefer a boxstep\n        : smoothstep(-width, width, distToEdge);\n\n    if (opacity < 0.98 && 1.0 - s < opacity) {\n        // drop the fragment when the line is using opacity.\n        discard;\n    }\n\n    alpha *= 1.0 - s;\n\n    #ifdef USE_DASHED_LINE\n    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).\n    float d = dashSize / vRange.x;\n    float g = gapSize / vRange.x;\n    float distToDashOrigin = mod(vCoords.x, d + g) / d;\n\n    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the\n    // dashBlendFactor similarly on how we did it for the line opacity.\n    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);\n    #if DASHES_MODE == DASHES_ROUND\n    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));\n    #elif DASHES_MODE == DASHES_DIAMOND\n    distToDashEdge -= distToCenter * 0.5;\n    #endif\n    float dashWidth = fwidth(distToDashEdge);\n    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);\n\n    #ifdef USE_DASH_COLOR\n    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);\n    #endif\n    #endif\n\n    #ifdef USE_OUTLINE\n    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and\n    // compute the outlineBlendFactor (used to mix line and outline colors).\n    float distToOutline = distToCenter - 1.0;\n    float outlineWidth = fwidth(distToOutline);\n    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);\n\n    // Mix the colors using the different computed factors.\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);\n    outputDiffuse = mix(\n      mix(\n        mix(outlineColor, diffuse, colorBlendFactor),\n        outputDiffuse,\n        dashBlendFactor\n      ),\n      outlineColor,\n      outlineBlendFactor\n    );\n    #else\n    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);\n    #endif\n    #endif\n\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    // Multiply the alpha by the dashBlendFactor.\n    #if defined(USE_OUTLINE)\n    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);\n    #else\n    alpha *= 1.0 - dashBlendFactor;\n    #endif\n    #endif\n\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( outputDiffuse * vColor, alpha );\n    #else\n    gl_FragColor = vec4( outputDiffuse, alpha );\n    #endif\n\n    #include <fog_fragment>\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n/**\n * Material designed to render solid variable-width lines.\n */\nclass SolidLineMaterial extends RawShaderMaterial_1.RawShaderMaterial {\n    /**\n     * Constructs a new `SolidLineMaterial`.\n     *\n     * @param params - `SolidLineMaterial` parameters. Always required except when cloning another\n     * material.\n     */\n    constructor(params) {\n        var _a;\n        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);\n        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();\n        // Setup default defines.\n        const defines = {\n            CAPS_MODE: LinesChunks_1.LineCapsModes.CAPS_ROUND,\n            DASHES_MODE: LineDashesModes.DASHES_SQUARE\n        };\n        // Prepare defines based on params passed in, before super class c-tor, this ensures\n        // proper set for shader compilation, without need to re-compile.\n        let fogParam = true;\n        let opacityParam = 1.0;\n        let displacementMap;\n        let shaderParams;\n        if (params) {\n            fogParam = params.fog === true;\n            if (fogParam) {\n                Utils_1.setShaderDefine(defines, \"USE_FOG\", true);\n            }\n            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;\n            displacementMap = params.displacementMap;\n            if (displacementMap !== undefined) {\n                Utils_1.setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n            }\n            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;\n            if (hasOutline) {\n                Utils_1.setShaderDefine(defines, \"USE_OUTLINE\", true);\n            }\n            shaderParams = {\n                name: \"SolidLineMaterial\",\n                vertexShader: vertexSource,\n                fragmentShader: fragmentSource,\n                uniforms: THREE.UniformsUtils.merge([\n                    {\n                        diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                        dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                        outlineColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                        extrusionWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),\n                        outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),\n                        offset: new THREE.Uniform(SolidLineMaterial.DEFAULT_OFFSET),\n                        opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),\n                        tileSize: new THREE.Uniform(new THREE.Vector2()),\n                        fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),\n                        fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),\n                        displacementMap: new THREE.Uniform(displacementMap !== undefined ? displacementMap : new THREE.Texture()),\n                        drawRange: new THREE.Uniform(new THREE.Vector2(SolidLineMaterial.DEFAULT_DRAW_RANGE_START, SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),\n                        dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),\n                        gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)\n                    },\n                    // We need the fog uniforms available when we use `fog` setter as the internal\n                    // recompilation cannot add or remove uniforms.\n                    THREE.UniformsLib.fog\n                ]),\n                defines,\n                // No need to pass overridden `fog` and `opacity` params they will be set\n                // after super c-tor call.\n                fog: fogParam,\n                opacity: opacityParam,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n        // Required to satisfy compiler error if fields has no initializer or are not definitely\n        // assigned in the constructor, this also mimics ShaderMaterial set of defaults\n        // for overridden props.\n        this.fog = fogParam;\n        this.setOpacity(opacityParam);\n        // initialize the stencil pass\n        this.stencilFunc = THREE.NotEqualStencilFunc;\n        this.stencilZPass = THREE.ReplaceStencilOp;\n        this.stencilRef = 1;\n        this.stencilWrite = false;\n        Utils_1.enforceBlending(this);\n        this.extensions.derivatives = true;\n        // Apply initial parameter values.\n        if (params) {\n            if (params.color !== undefined) {\n                tmpColor.set(params.color);\n                this.color = tmpColor;\n            }\n            if (params.outlineColor !== undefined) {\n                tmpColor.set(params.outlineColor);\n                this.outlineColor = tmpColor;\n            }\n            if (params.lineWidth !== undefined) {\n                this.lineWidth = params.lineWidth;\n            }\n            if (params.outlineWidth !== undefined) {\n                this.outlineWidth = params.outlineWidth;\n            }\n            if (params.opacity !== undefined) {\n                this.setOpacity(params.opacity);\n            }\n            if (params.depthTest !== undefined) {\n                this.depthTest = params.depthTest;\n            }\n            if (params.depthWrite !== undefined) {\n                this.depthWrite = params.depthWrite;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.caps !== undefined) {\n                this.caps = params.caps;\n            }\n            if (params.drawRangeStart !== undefined) {\n                this.drawRangeStart = params.drawRangeStart;\n            }\n            if (params.drawRangeEnd !== undefined) {\n                this.drawRangeEnd = params.drawRangeEnd;\n            }\n            if (params.dashes !== undefined) {\n                this.dashes = params.dashes;\n            }\n            if (params.dashColor !== undefined) {\n                tmpColor.set(params.dashColor);\n                this.dashColor = tmpColor;\n            }\n            if (params.dashSize !== undefined) {\n                this.dashSize = params.dashSize;\n            }\n            if (params.gapSize !== undefined) {\n                this.gapSize = params.gapSize;\n            }\n            if (params.fog !== undefined) {\n                this.fog = params.fog;\n                this.invalidateFog();\n            }\n            this.offset = (_a = params.offset) !== null && _a !== void 0 ? _a : 0;\n        }\n    }\n    /**\n     * Sets the offset used to shift the line in world space perpendicular to the direction.\n     */\n    set offset(offset) {\n        this.uniforms.offset.value = offset;\n    }\n    /**\n     * @return The offset to shift the line in world space perpendicular to the direction.\n     */\n    get offset() {\n        return this.uniforms.offset.value;\n    }\n    /**\n     * The method to call to recompile a material to enable/disable outline effect\n     *\n     * @param enable - Whether we want to use outline.\n     */\n    set outline(enable) {\n        Utils_1.setShaderMaterialDefine(this, \"USE_OUTLINE\", enable);\n    }\n    /**\n     * Checks if outline is enabled.\n     */\n    get outline() {\n        return Utils_1.getShaderMaterialDefine(this, \"USE_OUTLINE\") === true;\n    }\n    /** @override */\n    setOpacity(opacity) {\n        super.setOpacity(opacity);\n        if (opacity !== undefined) {\n            this.stencilWrite = opacity < 0.98;\n        }\n    }\n    /**\n     * Line color.\n     */\n    get color() {\n        return this.uniforms.diffuse.value;\n    }\n    set color(value) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n    /**\n     * Outline color.\n     *\n     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.\n     */\n    get outlineColor() {\n        return this.uniforms.outlineColor.value;\n    }\n    set outlineColor(value) {\n        this.uniforms.outlineColor.value.copy(value);\n    }\n    /**\n     * Dash color.\n     *\n     * @note The property [[gapSize]] need to be set to enable dashed line.\n     */\n    get dashColor() {\n        return this.uniforms.dashColor.value;\n    }\n    set dashColor(value) {\n        this.uniforms.dashColor.value.copy(value);\n        Utils_1.setShaderMaterialDefine(this, \"USE_DASH_COLOR\", true);\n    }\n    /**\n     * Line width.\n     */\n    get lineWidth() {\n        return this.uniforms.extrusionWidth.value * 2;\n    }\n    set lineWidth(value) {\n        this.uniforms.extrusionWidth.value = value / 2;\n    }\n    /**\n     * Outline width.\n     */\n    get outlineWidth() {\n        return this.uniforms.outlineWidth.value;\n    }\n    set outlineWidth(value) {\n        this.uniforms.outlineWidth.value = value;\n        this.outline = value > 0.0;\n    }\n    /**\n     * Size of the dashed segments.\n     *\n     * @note Ths [[gapSize]] need to be also set to enable dashed line.\n     * @see gapSize.\n     */\n    get dashSize() {\n        return this.uniforms.dashSize.value;\n    }\n    set dashSize(value) {\n        this.uniforms.dashSize.value = value;\n    }\n    /**\n     * Size of the gaps between dashed segments.\n     *\n     * @note You may also need to set [[dashSize]].\n     * @see dashSize.\n     */\n    get gapSize() {\n        return this.uniforms.gapSize.value;\n    }\n    set gapSize(value) {\n        var _a, _b;\n        this.uniforms.gapSize.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_DASHED_LINE\", value > 0.0);\n        if (((_b = (_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.gapSize) === null || _b === void 0 ? void 0 : _b.value) === 0) {\n            this.stencilWrite = this.opacity < 0.98;\n        }\n    }\n    /**\n     * Caps mode.\n     */\n    get caps() {\n        let result = \"Round\";\n        const capsMode = Utils_1.getShaderMaterialDefine(this, \"CAPS_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineCaps type.\n        if (typeof capsMode === \"number\" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {\n            result = DefinesLineCapsMapping[capsMode];\n        }\n        return result;\n    }\n    set caps(value) {\n        // Line caps mode may be set directly from theme, thus we need to check value\n        // for correctness and provide string to define mapping in fragment shader.\n        if (LineCapsDefinesMapping.hasOwnProperty(value)) {\n            Utils_1.setShaderMaterialDefine(this, \"CAPS_MODE\", LineCapsDefinesMapping[value]);\n        }\n    }\n    /**\n     * Dashes mode.\n     */\n    get dashes() {\n        let result = \"Square\";\n        const dashesMode = Utils_1.getShaderMaterialDefine(this, \"DASHES_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineDashes type.\n        if (typeof dashesMode === \"number\" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {\n            result = DefinesLineDashesMapping[dashesMode];\n        }\n        return result;\n    }\n    set dashes(value) {\n        // Line dashes mode may be set directly from theme, thus we need to check value\n        // for correctness and provide string to define mapping in fragment shader.\n        if (LineDashesDefinesMapping.hasOwnProperty(value)) {\n            Utils_1.setShaderMaterialDefine(this, \"DASHES_MODE\", LineDashesDefinesMapping[value]);\n        }\n    }\n    get fadeNear() {\n        return this.uniforms.fadeNear.value;\n    }\n    set fadeNear(value) {\n        this.uniforms.fadeNear.value = value;\n    }\n    get fadeFar() {\n        return this.uniforms.fadeFar.value;\n    }\n    set fadeFar(value) {\n        this.uniforms.fadeFar.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n    get displacementMap() {\n        return this.uniforms.displacementMap.value;\n    }\n    set displacementMap(map) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== null;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        Utils_1.setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n    get drawRangeStart() {\n        return this.uniforms.drawRange.value.x;\n    }\n    set drawRangeStart(value) {\n        this.uniforms.drawRange.value.x = value;\n    }\n    get drawRangeEnd() {\n        return this.uniforms.drawRange.value.y;\n    }\n    set drawRangeEnd(value) {\n        this.uniforms.drawRange.value.y = value;\n    }\n    set clipTileSize(tileSize) {\n        this.uniforms.tileSize.value.copy(tileSize);\n        const useTileClip = tileSize.x > 0 && tileSize.y > 0;\n        Utils_1.setShaderMaterialDefine(this, \"USE_TILE_CLIP\", useTileClip);\n    }\n    get clipTileSize() {\n        return this.uniforms.tileSize.value;\n    }\n    copy(other) {\n        super.copy(other);\n        this.invalidateFog();\n        this.setOpacity(other.opacity);\n        return this;\n    }\n}\nexports.SolidLineMaterial = SolidLineMaterial;\nSolidLineMaterial.DEFAULT_COLOR = 0xff0000;\nSolidLineMaterial.DEFAULT_WIDTH = 1.0;\nSolidLineMaterial.DEFAULT_OUTLINE_WIDTH = 0.0;\nSolidLineMaterial.DEFAULT_OPACITY = 1.0;\nSolidLineMaterial.DEFAULT_DRAW_RANGE_START = 0.0;\nSolidLineMaterial.DEFAULT_DRAW_RANGE_END = 1.0;\nSolidLineMaterial.DEFAULT_DASH_SIZE = 1.0;\nSolidLineMaterial.DEFAULT_GAP_SIZE = 1.0;\nSolidLineMaterial.DEFAULT_OFFSET = 0.0;\n//# sourceMappingURL=SolidLineMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/SolidLineMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/Utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/Utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getShaderDefine = exports.setShaderDefine = exports.getShaderMaterialDefine = exports.setShaderMaterialDefine = exports.disableBlending = exports.enableBlending = exports.enforceBlending = exports.insertShaderInclude = exports.DEFINE_BOOL_FALSE = exports.DEFINE_BOOL_TRUE = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Values for boolean shader defines\n */\nexports.DEFINE_BOOL_TRUE = \"\";\nexports.DEFINE_BOOL_FALSE = undefined;\n/**\n * Insert shader includes after another shader include.\n *\n * @param shaderContent - Original string.\n * @param shaderName - String to append to.\n * @param insertedShaderName - String to append after string `shaderA`.\n * @param addTab - If `true`, a tab character will be inserted before `shaderB`.\n */\nfunction insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {\n    const tabChar = addTab === true ? \"\\t\" : \"\";\n    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>\n${tabChar}#include <${insertedShaderName}>`);\n    return result;\n}\nexports.insertShaderInclude = insertShaderInclude;\n/**\n * THREE.js is enabling blending only when transparent is `true` or when a blend mode\n * different than `NormalBlending` is set.\n * Since we don't want to set transparent to true and mess up the render order we set\n * `CustomBlending` with the same parameters as the `NormalBlending`.\n\n * @param material - `Material` that should use blending\n * @note This function should not be used in frame update after material has been passed to WebGL.\n * In such cases use [[enableBlending]] instead.\n */\nfunction enforceBlending(material) {\n    if (material.transparent) {\n        // Nothing to do\n        return;\n    }\n    enableBlending(material);\n    material.forcedBlending = true;\n}\nexports.enforceBlending = enforceBlending;\n/**\n * Enable alpha blending using THREE.CustomBlending setup.\n *\n * Function enables blending using one of predefined modes, for both color and alpha components:\n * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled\n * for this material.\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @param material - The material or material parameters to modify.\n */\nfunction enableBlending(material) {\n    if (material.transparent === true || material.forcedBlending === true) {\n        // Nothing to do\n        return;\n    }\n    material.blending = THREE.CustomBlending;\n    if (material.premultipliedAlpha === true) {\n        material.blendSrc = THREE.OneFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n    else {\n        material.blendSrc = THREE.SrcAlphaFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n}\nexports.enableBlending = enableBlending;\n/**\n * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].\n *\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @see enableBlending.\n * @param material - The material or material parameters to modify.\n */\nfunction disableBlending(material) {\n    if (material.transparent === true || material.forcedBlending === true) {\n        // Nothing to do\n        return;\n    }\n    material.blending = THREE.NormalBlending;\n}\nexports.disableBlending = disableBlending;\n/**\n * Setup material shader _define_ using two allowable semantics.\n *\n * Function accepts two types of values for shader preprocessor _define_:\n * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,\n * such defines may be handled in the shader using __#ifdef__ semantics:\n * ```\n * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)\n * // do something\n * #endif\n * ```\n *\n * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some\n * code or even set compile time constants affecting shaders math:\n * ```\n * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0\n * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)\n * #endif\n * ```\n * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.\n *\n * @param material - The [[THREE.ShaderMaterial]] which shader _define_ will be set.\n * @param key - Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.\n * @param value - The value to be set as number or boolean specifying if preprocessor define\n * should be defined or not.\n * @returns [[true]] if material has been forced to update (re-compile) due to define changes,\n * return [[false]] whenever define has not been changed.\n */\nfunction setShaderMaterialDefine(material, key, value) {\n    harp_utils_1.assert(material.defines !== undefined, \"Do not use this function in ShaderMaterial derived c-tor.\");\n    const semanticValue = getShaderMaterialDefine(material, key);\n    const needsUpdate = value !== semanticValue;\n    // Nothing to change - early exit\n    if (!needsUpdate) {\n        return false;\n    }\n    setShaderDefine(material.defines, key, value);\n    material.needsUpdate = needsUpdate;\n    return true;\n}\nexports.setShaderMaterialDefine = setShaderMaterialDefine;\n/**\n * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.\n *\n * The semantic used in entire engine assumes that preprocessor defines may have only binary\n * (defined / not defined) or numerical values, this ensures consistency in the shaders and\n * materials code.\n * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but\n * not numerical value it returns [[true]], otherwise returns number.\n * @see setShaderMaterialDefine.\n *\n * @param material - The material which shader defines are accessed.\n * @param key - The _define_ name (identifier).\n * @param fallbackValue - The value returned when material `defines` are not initialized yet,\n * specified by default as [[false]], provide your own default if you expect numeric value.\n */\nfunction getShaderMaterialDefine(material, key, fallbackValue = false) {\n    if (material.defines === undefined) {\n        return fallbackValue;\n    }\n    return getShaderDefine(material.defines, key);\n}\nexports.getShaderMaterialDefine = getShaderMaterialDefine;\n/**\n * Sets new value of 'define' regardless of current value set.\n *\n * Update `defines` map with new key and value, if key is already occupied it overrides its value.\n * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before\n * material is create (i.e. in c-tor).\n *\n * @param defines - Shader `defines` stored in key-value map.\n * @param key - The key used to identify _define_.\n * @param value - The value to be stored.\n * @returns [[true]] if define has actually changed, false is stayed the same.\n * @see setShaderMaterialDefine.\n */\nfunction setShaderDefine(defines, key, value) {\n    let updated = false;\n    if (typeof value === \"number\") {\n        updated = defines[key] !== value;\n        defines[key] = value;\n    }\n    else if (value === true) {\n        updated = defines[key] !== exports.DEFINE_BOOL_TRUE;\n        defines[key] = exports.DEFINE_BOOL_TRUE;\n    }\n    else if (value === false && defines[key] !== undefined) {\n        // Sets to DEFINE_BOOL_FALSE === undefined\n        delete defines[key];\n        updated = true;\n    }\n    return updated;\n}\nexports.setShaderDefine = setShaderDefine;\n/**\n * Acquire shader 'define' value from `defines` map.\n *\n * If there is no value under [[key]] specified, function returns false, otherwise result is\n * true or numeric value if there is a number stored.\n * @param defines - The `defines` map.\n * @param key - The identifier of the _define_.\n */\nfunction getShaderDefine(defines, key) {\n    const currentValue = defines[key];\n    const semanticValue = currentValue === exports.DEFINE_BOOL_FALSE\n        ? false\n        : currentValue === exports.DEFINE_BOOL_TRUE\n            ? true\n            : currentValue;\n    return semanticValue;\n}\nexports.getShaderDefine = getShaderDefine;\n//# sourceMappingURL=Utils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/VignetteShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/VignetteShader.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VignetteShader = void 0;\n/**\n * `VignetteShader`.\n */\nexports.VignetteShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        offset: { value: 1.0 },\n        darkness: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float offset;\n        uniform float darkness;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 texel = texture2D( tDiffuse, vUv );\n            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n        }`\n};\n//# sourceMappingURL=VignetteShader.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/VignetteShader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoJsonDataProvider = exports.AuthenticationMethod = exports.APIFormat = void 0;\nvar harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ \"./node_modules/@here/harp-vectortile-datasource/index.js\");\nObject.defineProperty(exports, \"APIFormat\", { enumerable: true, get: function () { return harp_vectortile_datasource_1.APIFormat; } });\nObject.defineProperty(exports, \"AuthenticationMethod\", { enumerable: true, get: function () { return harp_vectortile_datasource_1.AuthenticationMethod; } });\nObject.defineProperty(exports, \"GeoJsonDataProvider\", { enumerable: true, get: function () { return harp_vectortile_datasource_1.GeoJsonDataProvider; } });\n__exportStar(__webpack_require__(/*! ./lib/OmvDataSource */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvDataSource = void 0;\nconst harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ \"./node_modules/@here/harp-vectortile-datasource/index.js\");\n/**\n * `OmvDataSource` is used for the visualization of vector tiles\n * provided in the OMV format.\n *\n * @example\n * ```typescript\n *    const dataSource = new OmvDataSource({\n *        baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n *        authenticationCode: apikey\n *    });\n *    mapView.addDataSource(dataSource);\n *   ```\n */\nclass OmvDataSource extends harp_vectortile_datasource_1.VectorTileDataSource {\n}\nexports.OmvDataSource = OmvDataSource;\n//# sourceMappingURL=OmvDataSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * SDF based text rendering for TypeScript.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/rendering/FontCatalog */ \"./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/rendering/GlyphData */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TextCanvas */ \"./node_modules/@here/harp-text-canvas/lib/TextCanvas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ \"./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/utils/MaterialUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/TextCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/TextCanvas.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextCanvas = exports.DEFAULT_TEXT_CANVAS_LAYER = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js\");\nconst TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js\");\nconst TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ \"./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js\");\nconst PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ \"./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js\");\nconst MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js\");\nconst tempTextPosition = new THREE.Vector3();\nconst tempTextBounds = {\n    array: [new THREE.Box2()],\n    offset: 0\n};\nlet tempVertexBuffer = new Float32Array();\n/**\n * Default's [[TextCanvas]] layer identifier.\n */\nexports.DEFAULT_TEXT_CANVAS_LAYER = 0;\n/**\n * three.js text rendering engine which can manage and render high-quality, transformable, stylable\n * and properly layout SDF and MSDF text.\n */\nclass TextCanvas {\n    /**\n     * Constructs a new `TextCanvas`.\n     *\n     * @param params - `TextCanvas` construction parameters.\n     *\n     * @returns New `TextCanvas`.\n     */\n    constructor(params) {\n        this.m_renderer = params.renderer;\n        this.m_fontCatalog = params.fontCatalog;\n        this.minGlyphCount = params.minGlyphCount;\n        this.maxGlyphCount = params.maxGlyphCount;\n        this.name = params.name;\n        if (params.material === undefined) {\n            this.m_ownsMaterial = true;\n            this.m_material = MaterialUtils_1.createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                rendererCapabilities: this.m_renderer.capabilities\n            });\n        }\n        else {\n            this.m_ownsMaterial = false;\n            this.m_material = params.material;\n        }\n        if (params.backgroundMaterial === undefined) {\n            this.m_ownsBgMaterial = true;\n            this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                isBackground: true,\n                rendererCapabilities: this.m_renderer.capabilities\n            });\n        }\n        else {\n            this.m_ownsBgMaterial = false;\n            this.m_bgMaterial = params.backgroundMaterial;\n        }\n        this.m_defaultLayer = {\n            id: exports.DEFAULT_TEXT_CANVAS_LAYER,\n            storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)\n        };\n        this.m_layers = [this.m_defaultLayer];\n        this.m_currentTextRenderStyle = new TextStyle_1.TextRenderStyle().copy(TextCanvas.defaultTextRenderStyle);\n        this.m_currentTextLayoutStyle = new TextStyle_1.TextLayoutStyle().copy(TextCanvas.defaultTextLayoutStyle);\n        this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();\n        this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();\n    }\n    /**\n     * Currently active [[FontCatalog]].\n     */\n    get fontCatalog() {\n        return this.m_fontCatalog;\n    }\n    set fontCatalog(value) {\n        this.m_fontCatalog = value;\n        const material = this.m_material;\n        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);\n        material.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n        const bgMaterial = this.m_bgMaterial;\n        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);\n        bgMaterial.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n    }\n    /**\n     * Currently active text rendering material.\n     */\n    get material() {\n        return this.m_material;\n    }\n    set material(value) {\n        if (this.m_ownsMaterial) {\n            this.m_material.dispose();\n            this.m_ownsMaterial = false;\n        }\n        this.m_material = value;\n        for (const layer of this.m_layers) {\n            layer.storage.mesh.material = this.m_material;\n        }\n    }\n    /**\n     * Currently active text background rendering material.\n     */\n    get backgroundMaterial() {\n        return this.m_bgMaterial;\n    }\n    set backgroundMaterial(value) {\n        if (this.m_ownsBgMaterial) {\n            this.m_bgMaterial.dispose();\n            this.m_ownsBgMaterial = false;\n        }\n        this.m_bgMaterial = value;\n        for (const layer of this.m_layers) {\n            layer.storage.backgroundMesh.material = this.m_bgMaterial;\n        }\n    }\n    /**\n     * Currently active text rendering style.\n     */\n    get textRenderStyle() {\n        return this.m_currentTextRenderStyle;\n    }\n    set textRenderStyle(style) {\n        this.m_currentTextRenderStyle.copy(style);\n    }\n    /**\n     * Currently active text layout style.\n     */\n    get textLayoutStyle() {\n        return this.m_currentTextLayoutStyle;\n    }\n    set textLayoutStyle(style) {\n        this.m_currentTextLayoutStyle.copy(style);\n    }\n    /**\n     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).\n     */\n    clear() {\n        for (const layer of this.m_layers) {\n            layer.storage.clear();\n        }\n        this.m_currentTextRenderStyle.copy(TextCanvas.defaultTextRenderStyle);\n        this.m_currentTextLayoutStyle.copy(TextCanvas.defaultTextLayoutStyle);\n    }\n    /**\n     * Renders the content of this `TextCanvas`.\n     *\n     * @param camera - Orthographic camera.\n     * @param lowerLayerId - Optional Id the first layer to be rendered has to be equal or above\n     * @param higherLayerId - Optional Id the last layer to be rendered has to be below\n     * @param target - Optional render target.\n     * @param clear - Optional render target clear operation.\n     */\n    render(camera, lowerLayerId, higherLayerId, target, clear) {\n        this.m_fontCatalog.update(this.m_renderer);\n        let oldTarget = null;\n        if (target !== undefined) {\n            oldTarget = this.m_renderer.getRenderTarget();\n            this.m_renderer.setRenderTarget(target);\n        }\n        if (clear === true) {\n            this.m_renderer.clear(true);\n        }\n        for (let i = 0; i < this.m_layers.length; i++) {\n            const layer = this.m_layers[i];\n            if (layer.id >= (lowerLayerId !== null && lowerLayerId !== void 0 ? lowerLayerId : 0)) {\n                if (higherLayerId === undefined || layer.id < higherLayerId) {\n                    layer.storage.update();\n                    this.m_renderer.render(layer.storage.scene, camera);\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        if (target !== undefined) {\n            this.m_renderer.setRenderTarget(oldTarget);\n        }\n    }\n    /**\n     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the\n     * input `layerId`, it just returns this one instead.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Created [[TextCanvasLayer]].\n     */\n    addLayer(layerId) {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)\n            };\n            this.m_layers.push(result);\n            this.m_layers.sort((a, b) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n    /**\n     * Retrieves a specific `TextCanvas` rendering layer.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Selected [[TextCanvasLayer]].\n     */\n    getLayer(layerId) {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n    /**\n     * Retrieves all `TextCanvas` rendering layers.\n     *\n     * @returns Array of [[TextCanvasLayer]]s.\n     */\n    getAllLayers() {\n        return this.m_layers;\n    }\n    /**\n     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and\n     * [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param outputBounds - Output text bounding box.\n     * @param params - Optional measurement parameters.\n     *\n     * @returns Result of the measurement. If `false`, some error occurred during execution and the\n     * input text couldn't be properly measured.\n     */\n    measureText(text, outputBounds, params) {\n        tempTextPosition.set(0, 0, 0);\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let outputCharacterBounds;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            outputCharacterBounds = params.outputCharacterBounds;\n            if (params.path !== undefined) {\n                const pathOrigin = params.path.getPoint(0);\n                if (pathOrigin === null) {\n                    return false;\n                }\n                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        return this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: outputBounds,\n            individualBounds: outputCharacterBounds,\n            letterCaseArray: upperCaseArray\n        });\n    }\n    /**\n     * Adds the input text to this `TextCanvas` in the specified screen position. The current\n     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param position - Screen position.\n     * @param params - Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addText(text, position, params) {\n        tempTextPosition.copy(position);\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let targetLayer = this.m_defaultLayer;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            if (params.path !== undefined) {\n                tempTextPosition.set(0, 0, tempTextPosition.z);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n        const result = this.placeText({\n            input: text,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            layer: targetLayer,\n            letterCaseArray: upperCaseArray\n        });\n        if (result && params !== undefined) {\n            if (params.updatePosition === true) {\n                position.copy(tempTextPosition);\n            }\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);\n            }\n        }\n        else if (!result) {\n            targetLayer.storage.m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n    /**\n     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the\n     * result of performing the `addText` function for the input text in the screen origin.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param params - Optional creation parameters.\n     *\n     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be\n     * retrieved from the current [[FontCatalog]]).\n     */\n    createTextBufferObject(text, params) {\n        tempTextPosition.set(0, 0, 0);\n        let glyphArray;\n        let upperCaseArray;\n        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        if (typeof text !== \"string\") {\n            glyphArray = text;\n            if (params !== undefined && params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        else {\n            upperCaseArray = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);\n            if (glyphArray === undefined) {\n                return undefined;\n            }\n        }\n        let path;\n        let pathOverflow;\n        let textBounds;\n        let characterBounds;\n        let renderStyle;\n        let layoutStyle;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.outputBounds === true) {\n                textBounds = new THREE.Box2();\n            }\n            if (params.outputCharacterBounds === true) {\n                characterBounds = [];\n            }\n            if (params.storeStyles === true) {\n                renderStyle = this.m_currentTextRenderStyle.clone();\n                layoutStyle = this.m_currentTextLayoutStyle.clone();\n            }\n        }\n        this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            computeTextBuffer: true,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: textBounds,\n            individualBounds: characterBounds,\n            letterCaseArray: upperCaseArray\n        });\n        return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);\n    }\n    /**\n     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can\n     * be provided to override the attributes stored in the buffer.\n     *\n     * @param textBufferObject - [[TextBufferObject]] to add.\n     * @param params - Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addTextBufferObject(textBufferObject, params) {\n        var _a;\n        let targetLayer = this.m_defaultLayer;\n        let position;\n        let scale;\n        let rotation;\n        let color;\n        let opacity;\n        let bgColor;\n        let bgOpacity;\n        if (params !== undefined) {\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            position = (_a = params.position) === null || _a === void 0 ? void 0 : _a.clone();\n            scale = params.scale;\n            rotation = params.rotation;\n            color = params.color;\n            opacity = params.opacity;\n            bgColor = params.backgroundColor;\n            bgOpacity = params.backgroundOpacity;\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n        const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);\n        if (result && params !== undefined) {\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);\n            }\n        }\n        else if (!result) {\n            targetLayer.storage.m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n    /**\n     * Executes the `pickCallback` for all previously stored picking data for text covering the\n     * specified screen position.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickText(position, callback) {\n        for (const layer of this.m_layers) {\n            layer.storage.pick(position, callback);\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.\n     *\n     * @param info - The info object to increment with the values from this `TextCanvas`.\n     */\n    getMemoryUsage(info) {\n        this.m_fontCatalog.updateMemoryUsage(info);\n        for (const layer of this.m_layers) {\n            layer.storage.updateMemoryUsage(info);\n        }\n    }\n    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs\n    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for\n    // the input (as a whole or on a per-character basis).\n    placeText(params) {\n        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {\n            if (params.bounds !== undefined) {\n                params.bounds.min.set(0, 0);\n                params.bounds.max.set(0, 0);\n            }\n            if (params.individualBounds !== undefined) {\n                params.individualBounds.length = 0;\n            }\n            return true;\n        }\n        let glyphArray;\n        let smallCapsTransformations;\n        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        if (typeof params.input !== \"string\") {\n            glyphArray = params.input;\n            if (params.letterCaseArray) {\n                smallCapsTransformations = params.letterCaseArray;\n            }\n        }\n        else {\n            smallCapsTransformations = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);\n            if (glyphArray === undefined) {\n                return false;\n            }\n        }\n        let glyphBounds;\n        if (params.individualBounds !== undefined) {\n            tempTextBounds.array = params.individualBounds;\n            tempTextBounds.offset = 0;\n            glyphBounds = tempTextBounds;\n        }\n        if (params.bounds !== undefined) {\n            params.bounds.min.set(Infinity, Infinity);\n            params.bounds.max.set(-Infinity, -Infinity);\n        }\n        if (params.computeTextBuffer === true) {\n            tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);\n        }\n        const isPath = params.textPath !== undefined;\n        const typesettingParams = {\n            glyphs: glyphArray,\n            fontCatalog: this.m_fontCatalog,\n            textRenderStyle: this.m_currentTextRenderStyle,\n            textLayoutStyle: this.m_currentTextLayoutStyle,\n            position: tempTextPosition,\n            geometry: params.layer.storage,\n            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,\n            globalBounds: params.bounds,\n            individualBounds: glyphBounds,\n            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined\n        };\n        let result = true;\n        if (isPath) {\n            Object.assign(typesettingParams, {\n                path: params.textPath,\n                pathOverflow: params.textPathOverflow === true\n            });\n            result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        else {\n            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        if (glyphBounds !== undefined) {\n            glyphBounds.array.length = glyphBounds.offset;\n        }\n        return result;\n    }\n}\nexports.TextCanvas = TextCanvas;\nTextCanvas.defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();\nTextCanvas.defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();\n//# sourceMappingURL=TextCanvas.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/TextCanvas.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FontCatalog = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\nconst GlyphData_1 = __webpack_require__(/*! ./GlyphData */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js\");\nconst GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js\");\nconst TextStyle_1 = __webpack_require__(/*! ./TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst ASSETS_PATH = \"_Assets/\";\nconst BOLD_ASSETS_PATH = \"_BoldAssets/\";\nconst ITALIC_ASSETS_PATH = \"_ItalicAssets/\";\nconst BOLD_ITALIC_ASSETS_PATH = \"_BoldItalicAssets/\";\nconst REPLACEMENT_PATH = \"_Assets/Extra/\";\n/**\n * Collection of font assets used to render glyphs when using a [[TextCanvas]].\n *\n * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed\n * to cover the widest Unicode code point range possible. In order to manage all these assets\n * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and\n * assets for a block are only loaded once a glyph belonging to that block is requested.\n *\n * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture\n * resource, which can be sampled to render all currently loaded glyphs.\n *\n */\nclass FontCatalog {\n    /**\n     * @hidden\n     * Creates a new FontCatalog.\n     *\n     * @param url - FontCatalog's URL.\n     * @param name - FontCatalog's name.\n     * @param type - FontCatalog's type (sdf or msdf).\n     * @param size - FontCatalog's glyph size (pixels).\n     * @param maxWidth - FontCatalog's maximum glyph width (pixels).\n     * @param maxHeight - FontCatalog's maximum glyph height (pixels).\n     * @param distanceRange - Distance range used to generate the SDF bitmaps.\n     * @param fonts - Array of supported fonts.\n     * @param unicodeBlocks - Array of supported Unicode blocks.\n     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     * @param m_replacementGlyph - [[GlyphData]] to be used whenever a Unicode code point is not\n     * supported by this `FontCatalog`.\n     *\n     * @returns New FontCatalog.\n     */\n    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {\n        this.url = url;\n        this.name = name;\n        this.type = type;\n        this.size = size;\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this.distanceRange = distanceRange;\n        this.fonts = fonts;\n        this.unicodeBlocks = unicodeBlocks;\n        this.maxCodePointCount = maxCodePointCount;\n        this.m_replacementGlyph = m_replacementGlyph;\n        /** If `true`, a replacement glyph is returned for every missing glyph. */\n        this.showReplacementGlyphs = false;\n        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);\n        this.m_loadingJson = new Map();\n        this.m_loadingPages = new Map();\n        this.m_loadingGlyphs = new Map();\n        this.m_loadedJson = new Map();\n        this.m_loadedPages = new Map();\n        this.m_loadedGlyphs = new Map();\n    }\n    /**\n     * Loads a `FontCatalog`.\n     *\n     * @param url - Asset url.\n     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     *\n     * @returns `FontCatalog` Promise.\n     */\n    static async load(path, maxCodePointCount) {\n        const url = new URL(path, window.location.href);\n        const fontCatalog = await FontCatalog.loadJSON(url.href);\n        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);\n        const replacementJson = await FontCatalog.loadJSON(replacementDirUrl.href + \"Specials.json\");\n        const replacementTexture = await FontCatalog.loadTexture(replacementDirUrl.href + \"Specials.png\");\n        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;\n        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;\n        replacementTexture.minFilter = THREE.NearestFilter;\n        replacementTexture.needsUpdate = true;\n        const replacementFont = fontCatalog.fonts.find((font) => font.name === \"Extra\");\n        const replacementGlyph = new GlyphData_1.GlyphData(65533, \"Specials\", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont, true);\n        const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf(\"/\")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);\n        return fontCatalogInfo;\n    }\n    static async loadTexture(url) {\n        return await new Promise(resolve => {\n            new THREE.TextureLoader().load(url, resolve);\n        });\n    }\n    static async loadJSON(url) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`${url} Status Text:  ${response.statusText}`);\n        }\n        const rawJSON = await response.text();\n        return JSON.parse(rawJSON);\n    }\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.fonts.length = 0;\n        this.unicodeBlocks.length = 0;\n        this.m_glyphTextureCache.dispose();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n    /**\n     * Removes all loaded (and loading) assets.\n     */\n    clear() {\n        this.m_glyphTextureCache.clear();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer - WebGLRenderer.\n     */\n    update(renderer) {\n        this.m_glyphTextureCache.update(renderer);\n    }\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture() {\n        return this.m_glyphTextureCache.texture;\n    }\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize() {\n        return this.m_glyphTextureCache.textureSize;\n    }\n    /**\n     * Current internal loading state.\n     */\n    get isLoading() {\n        return (this.m_loadingJson.size > 0 ||\n            this.m_loadingPages.size > 0 ||\n            this.m_loadingGlyphs.size > 0);\n    }\n    /**\n     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls\n     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.\n     *\n     * @param block - Requested [[UnicodeBlock]].\n     * @param font - [[Font]] to retrieve this Unicode block from.\n     * @param fontStyle - [[FontStyle]] assets to load.\n     * @param loadPages - If `true`, all pages in this Unicode block will also be loaded.\n     *\n     * @returns Loaded Unicode Block json.\n     */\n    async loadBlock(block, font, fontStyle, loadPages) {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        let json = this.m_loadedJson.get(jsonPath);\n        if (json === undefined) {\n            let jsonPromise = this.m_loadingJson.get(jsonPath);\n            if (jsonPromise === undefined) {\n                try {\n                    jsonPromise = FontCatalog.loadJSON(jsonPath);\n                    this.m_loadingJson.set(jsonPath, jsonPromise);\n                    json = await jsonPromise;\n                    this.m_loadingJson.delete(jsonPath);\n                    this.m_loadedJson.set(jsonPath, json);\n                }\n                catch (e) {\n                    // eslint-disable-next-line no-console\n                    console.error(e);\n                    this.m_loadingJson.delete(jsonPath);\n                }\n            }\n            else {\n                json = await jsonPromise;\n            }\n        }\n        const pagePromises = [];\n        if (loadPages === true) {\n            for (const page of json.pages) {\n                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));\n            }\n        }\n        await Promise.all(pagePromises);\n        return json;\n    }\n    /**\n     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).\n     * Safe to call when no assets for this block have been loaded.\n     *\n     * @param block - Requested [[UnicodeBlock]].\n     * @param font - [[Font]] to remove this Unicode block from.\n     * @param fontStyle - [[FontStyle]] assets to remove.\n     */\n    removeBlock(block, font, fontStyle) {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        const json = this.m_loadedJson.get(jsonPath);\n        if (json !== undefined) {\n            for (const page of json.pages) {\n                const pagePath = `${assetsPath}/${page}`;\n                this.m_loadingPages.delete(pagePath);\n                this.m_loadedPages.delete(pagePath);\n            }\n            this.m_loadingJson.delete(jsonPath);\n            this.m_loadedJson.delete(jsonPath);\n        }\n    }\n    /**\n     * Loads all the required glyphs needed to render the input text. Character repetition will not\n     * be considered, and only styled assets (with applied font selection, style and variants) will\n     * be loaded.\n     *\n     * @param input - Input text.\n     * @param style - Specific [[TextRenderStyle]] for which glyphs will be loaded.\n     *\n     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.\n     */\n    async loadCharset(input, style) {\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||\n            style.fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\\s\\S](?=([\\s\\S]+))/g, (c, s) => {\n            return s.indexOf(c) + 1 ? \"\" : c;\n        });\n        const glyphPromises = [];\n        for (const char of charset) {\n            const codePoint = char.codePointAt(0);\n            const font = this.getFont(codePoint, fontName);\n            const fontHash = `${font.name}_${fontStyle}`;\n            const glyphHash = `${fontHash}_${codePoint}`;\n            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);\n            if (fontGlyphMap === undefined) {\n                fontGlyphMap = new Map();\n                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);\n            }\n            const glyph = fontGlyphMap.get(codePoint);\n            if (glyph === undefined) {\n                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);\n                if (glyphPromise === undefined) {\n                    if (!font.charset.includes(String.fromCodePoint(codePoint))) {\n                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);\n                        fontGlyphMap.set(codePoint, replacementGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);\n                        continue;\n                    }\n                    let charUnicodeBlock;\n                    for (const block of this.unicodeBlocks) {\n                        if (codePoint >= block.min && codePoint <= block.max) {\n                            charUnicodeBlock = block;\n                            break;\n                        }\n                    }\n                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);\n                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);\n                    glyphPromise.then((loadedGlyph) => {\n                        this.m_loadingGlyphs.delete(glyphHash);\n                        fontGlyphMap.set(codePoint, loadedGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);\n                    });\n                }\n                glyphPromises.push(glyphPromise);\n            }\n            else if (!this.m_glyphTextureCache.has(glyphHash)) {\n                glyphPromises.push(Promise.resolve(glyph));\n                this.m_glyphTextureCache.add(glyphHash, glyph);\n            }\n        }\n        return Promise.all(glyphPromises);\n    }\n    /**\n     * Retrieves the loaded [[GlyphData]] for a specific character.\n     * Returns `undefined` if the assets for this glyph haven't been loaded yet.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param font - [[Font]] to get this glyph from.\n     * @param fontStyle - Specific [[FontStyle]] to get glyphs for.\n     *\n     * @returns [[GlyphData]] for this code point.\n     */\n    getGlyph(codePoint, font, fontStyle) {\n        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);\n        if (fontGlyphMap === undefined) {\n            return undefined;\n        }\n        return fontGlyphMap.get(codePoint);\n    }\n    /**\n     * Retrieves the loaded [[GlyphData]] for the specified text.\n     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.\n     *\n     * @param input - Input text.\n     * @param style - Specific [[TextRenderStyle]] to get glyphs for.\n     * @param letterCaseArray - Array containing the original letter case for the requested glyphs.\n     *\n     * @returns Array containing [[GlyphData]] for each character of the input text.\n     */\n    getGlyphs(input, style, letterCaseArray) {\n        const result = [];\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const fontVariant = style.fontVariant;\n        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        for (const character of input) {\n            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;\n            for (const char of transformedCharacter) {\n                const codePoint = char.codePointAt(0);\n                const font = this.getFont(codePoint, fontName);\n                const glyphData = this.getGlyph(codePoint, font, fontStyle);\n                if (glyphData !== undefined &&\n                    (!glyphData.isReplacement || this.showReplacementGlyphs)) {\n                    result.push(glyphData);\n                    if (letterCaseArray !== undefined) {\n                        letterCaseArray.push(char !== character);\n                    }\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets the best matched font for a specific character.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param fontName - Font name suggestion.\n     *\n     * @returns Best matched font.\n     */\n    getFont(codePoint, fontName) {\n        let selectedFontName = this.fonts[0].name;\n        for (const block of this.unicodeBlocks) {\n            if (codePoint >= block.min && codePoint <= block.max) {\n                selectedFontName =\n                    fontName !== undefined &&\n                        block.fonts.find(element => {\n                            return element === fontName;\n                        }) !== undefined\n                        ? fontName\n                        : block.fonts[0];\n                break;\n            }\n        }\n        return this.fonts.find(element => {\n            return element.name === selectedFontName;\n        });\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.\n     *\n     * @param info - The info object to increment with the values from this `FontCatalog`.\n     */\n    updateMemoryUsage(info) {\n        let numBytes = 0;\n        for (const block of this.unicodeBlocks) {\n            numBytes += (block.max - block.min) * 2;\n        }\n        // Always stored in RGBA internally.\n        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;\n        for (const page in this.m_loadedPages.entries) {\n            if (this.m_loadedPages.get(page) !== undefined) {\n                const loadedPage = this.m_loadedPages.get(page);\n                if (loadedPage !== undefined) {\n                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;\n                }\n            }\n        }\n        info.heapSize += numBytes + textureBytes;\n        info.gpuSize += textureBytes;\n    }\n    createReplacementGlyph(codePoint, char, font) {\n        const replacementGlyph = this.m_replacementGlyph.clone();\n        replacementGlyph.codePoint = codePoint;\n        replacementGlyph.character = char;\n        replacementGlyph.font = font;\n        // Glyphs for ASCII control characters and such are not really replacement glyphs.\n        replacementGlyph.isReplacement = UnicodeUtils_1.UnicodeUtils.isPrintable(codePoint);\n        return replacementGlyph;\n    }\n    async loadAssets(codePoint, fontStyle, block, font) {\n        const json = await this.loadBlock(block, font, fontStyle);\n        if (json === undefined) {\n            return this.m_replacementGlyph;\n        }\n        const sourceGlyphData = json.chars.find(char => char.id === codePoint);\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;\n        const texture = await this.loadPage(texturePath);\n        const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);\n        return glyphData;\n    }\n    async loadPage(pagePath) {\n        let page = this.m_loadedPages.get(pagePath);\n        if (page === undefined) {\n            let pagePromise = this.m_loadingPages.get(pagePath);\n            if (pagePromise === undefined) {\n                pagePromise = FontCatalog.loadTexture(pagePath);\n                this.m_loadingPages.set(pagePath, pagePromise);\n                page = await pagePromise;\n                page.wrapS = THREE.ClampToEdgeWrapping;\n                page.wrapT = THREE.ClampToEdgeWrapping;\n                page.minFilter = THREE.NearestFilter;\n                page.needsUpdate = true;\n                if (this.m_loadingPages.delete(pagePath)) {\n                    this.m_loadedPages.set(pagePath, page);\n                }\n                this.m_loadingPages.delete(pagePath);\n            }\n            else {\n                page = await pagePromise;\n            }\n        }\n        return page;\n    }\n    getAssetsPath(fontStyle, font) {\n        let fontStylePath = ASSETS_PATH;\n        switch (fontStyle) {\n            case TextStyle_1.FontStyle.Bold:\n                if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n            case TextStyle_1.FontStyle.Italic:\n                if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                break;\n            case TextStyle_1.FontStyle.BoldItalic:\n                if (font.boldItalic !== undefined) {\n                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;\n                }\n                else if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                else if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n        }\n        return `${this.url}/${this.name}${fontStylePath}${font.name}`;\n    }\n}\nexports.FontCatalog = FontCatalog;\n//# sourceMappingURL=FontCatalog.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GlyphData = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * Structure containing all the required information necessary to render a BMFont glyph using\n * [[TextCanvas]].\n */\nclass GlyphData {\n    /**\n     * Creates a new `GlyphData` object.\n     *\n     * @param codePoint - Unicode code point.\n     * @param block - Unicode block.\n     * @param width - Glyph' width.\n     * @param height - Glyph' height.\n     * @param advanceX - Amount of pixel to move after placing this glyph.\n     * @param offsetX - Horizontal offset from the glyph' origin.\n     * @param offsetY - Vertical offset from the glyph' origin.\n     * @param u0 - Glyph' left texture coordinate.\n     * @param v0 - Glyph' bottom texture coordinate.\n     * @param u1 - Glyph' right texture coordinate.\n     * @param v1 - Glyph' top texture coordinate.\n     * @param texture - Glyph' source texture atlas page.\n     * @param font - Glyph' font.\n     * @param isReplacement - `true` if glyph is a replacement for a missing glyph.\n     *\n     * @returns New `GlyphData`.\n     */\n    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font, isReplacement = false) {\n        this.codePoint = codePoint;\n        this.block = block;\n        this.width = width;\n        this.height = height;\n        this.advanceX = advanceX;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.texture = texture;\n        this.font = font;\n        this.isReplacement = isReplacement;\n        /**\n         * Array containing the positions for all corners of this glyph.\n         */\n        this.positions = [];\n        /**\n         * Array containing the source texture coordinates for all corners of this glyph.\n         * Used to sample the original texture atlas pages.\n         */\n        this.sourceTextureCoordinates = [];\n        /**\n         * Array containing the dynamic texture coordinates for all corners of this glyph.\n         * Used to sample the dynamic texture atlas page.\n         */\n        this.dynamicTextureCoordinates = [];\n        /**\n         * Source texture atlas' page copy index.\n         */\n        this.copyIndex = 0;\n        /**\n         * Flag indicating if glyph can be currently rendered.\n         */\n        this.isInCache = false;\n        this.character = String.fromCodePoint(codePoint);\n        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);\n        const left = this.offsetX;\n        const right = left + this.width;\n        const top = font.metrics.lineHeight - this.offsetY;\n        const bottom = top - this.height;\n        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));\n        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));\n        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));\n    }\n    /**\n     * Clone this `GlyphData`.\n     *\n     * @returns Cloned `GlyphData`.\n     */\n    clone() {\n        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font, this.isReplacement);\n    }\n}\nexports.GlyphData = GlyphData;\n//# sourceMappingURL=GlyphData.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GlyphTextureCache = void 0;\nconst harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ \"./node_modules/@here/harp-lrucache/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GlyphData_1 = __webpack_require__(/*! ./GlyphData */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js\");\nconst TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js\");\n/**\n * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined\n * by the maximum number of texture units available on a pixel shader for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS\n */\nconst MAX_NUM_COPY_PAGES = 8;\n/**\n * Maximum texture size supported. This amount is determined by the maximum texture size supported\n * for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE\n */\nconst MAX_TEXTURE_SIZE = 4096;\n/**\n * @hidden\n * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].\n * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.\n */\nclass GlyphTextureCache {\n    /**\n     * Creates a `GlyphTextureCache` object.\n     *\n     * @param capacity - Cache's maximum glyph capacity.\n     * @param entryWidth - Maximum entry width.\n     * @param entryHeight - Maximum entry height.\n     *\n     * @returns New `GlyphTextureCache`.\n     */\n    constructor(capacity, entryWidth, entryHeight) {\n        this.capacity = capacity;\n        this.entryWidth = entryWidth;\n        this.entryHeight = entryHeight;\n        const nRows = Math.floor(Math.sqrt(capacity));\n        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;\n        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;\n        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);\n        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {\n            // eslint-disable-next-line no-console\n            console.warn(\"GlyphTextureCache texture size (\" +\n                this.m_textureSize.x +\n                \", \" +\n                this.m_textureSize.y +\n                \") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (\" +\n                MAX_TEXTURE_SIZE +\n                \").\\n\" +\n                \"This could result in rendering errors on some devices.\\n\" +\n                \"Please consider reducing its capacity or input assets size.\");\n        }\n        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);\n        this.initCacheEntries();\n        this.m_scene = new THREE.Scene();\n        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);\n        this.m_camera.position.z = 1;\n        this.m_camera.updateMatrixWorld(false);\n        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {\n            wrapS: THREE.ClampToEdgeWrapping,\n            wrapT: THREE.ClampToEdgeWrapping,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n        this.m_copyTextureSet = new Set();\n        this.m_copyTransform = new THREE.Matrix3();\n        this.m_copyPositions = [];\n        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());\n        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);\n        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);\n        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);\n        this.m_copyGeometry = new THREE.BufferGeometry();\n        this.m_copyGeometry.setAttribute(\"position\", this.m_copyPositionAttribute);\n        this.m_copyGeometry.setAttribute(\"uv\", this.m_copyUVAttribute);\n        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyGeometry.setIndex(copyIndexBuffer);\n        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry);\n        this.m_copyMesh.frustumCulled = false;\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);\n        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry = new THREE.BufferGeometry();\n        this.m_clearGeometry.setAttribute(\"position\", this.m_clearPositionAttribute);\n        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry.setIndex(clearIndexBuffer);\n        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry);\n        this.m_clearMesh.frustumCulled = false;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);\n    }\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        var _a, _b;\n        this.m_entryCache.clear();\n        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);\n        this.m_rt.dispose();\n        (_a = this.m_clearMaterial) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this.m_copyMaterial) === null || _b === void 0 ? void 0 : _b.dispose();\n        this.m_copyTextureSet.clear();\n        this.m_clearGeometry.dispose();\n        this.m_copyGeometry.dispose();\n    }\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture() {\n        return this.m_rt.texture;\n    }\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize() {\n        return this.m_textureSize;\n    }\n    /**\n     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested\n     * entry will be replaced.\n     *\n     * @param hash - Entry's hash.\n     * @param glyph - Entry's glyph data.\n     */\n    add(hash, glyph) {\n        const entry = this.m_entryCache.get(hash);\n        if (entry !== undefined) {\n            return;\n        }\n        const oldestEntry = this.m_entryCache.oldest;\n        if (oldestEntry === null) {\n            throw new Error(\"GlyphTextureCache is uninitialized!\");\n        }\n        this.clearCacheEntry(oldestEntry.value);\n        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);\n    }\n    /**\n     * Checks if an entry is in the cache.\n     *\n     * @param hash - Entry's hash.\n     *\n     * @returns Test result.\n     */\n    has(hash) {\n        return this.m_entryCache.has(hash);\n    }\n    /**\n     * Retrieves an entry from the cache.\n     *\n     * @param hash - Entry's hash.\n     *\n     * @returns Retrieval result.\n     */\n    get(hash) {\n        return this.m_entryCache.get(hash);\n    }\n    /**\n     * Clears the internal LRUCache.\n     */\n    clear() {\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_entryCache.clear();\n        this.m_copyTextureSet.clear();\n        this.initCacheEntries();\n    }\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer - WebGLRenderer.\n     */\n    update(renderer) {\n        let oldRenderTarget = null;\n        const willClearGeometry = this.m_clearGeometryDrawCount > 0;\n        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;\n        if (willClearGeometry || willCopyGeometry) {\n            oldRenderTarget = renderer.getRenderTarget();\n            renderer.setRenderTarget(this.m_rt);\n        }\n        if (willClearGeometry) {\n            if (!this.m_clearMaterial) {\n                this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial({\n                    rendererCapabilities: renderer.capabilities\n                });\n                this.m_clearMesh.material = this.m_clearMaterial;\n            }\n            if (this.m_clearGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n            }\n            this.m_clearPositionAttribute.needsUpdate = true;\n            this.m_clearPositionAttribute.updateRange.offset = 0;\n            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;\n            this.m_clearGeometry.index.needsUpdate = true;\n            this.m_clearGeometry.index.updateRange.offset = 0;\n            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;\n            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);\n            this.m_clearMesh.visible = true;\n            this.m_copyMesh.visible = false;\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_clearGeometryDrawCount = 0;\n            this.m_clearMesh.visible = false;\n        }\n        if (willCopyGeometry) {\n            if (!this.m_copyMaterial) {\n                this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial({\n                    rendererCapabilities: renderer.capabilities\n                });\n                this.m_copyMesh.material = this.m_copyMaterial;\n            }\n            if (this.m_copyGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n            }\n            this.m_copyVertexBuffer.needsUpdate = true;\n            this.m_copyVertexBuffer.updateRange.offset = 0;\n            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;\n            this.m_copyGeometry.index.needsUpdate = true;\n            this.m_copyGeometry.index.updateRange.offset = 0;\n            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;\n            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);\n            this.m_copyMesh.visible = true;\n            const srcPages = Array.from(this.m_copyTextureSet);\n            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);\n            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {\n                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;\n                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;\n                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {\n                    const pageIndex = pageOffset + i;\n                    if (pageIndex < this.m_copyTextureSet.size) {\n                        this.m_copyMaterial.uniforms[\"page\" + i].value = srcPages[pageIndex];\n                    }\n                }\n                renderer.render(this.m_scene, this.m_camera);\n            }\n            this.m_copyTextureSet.clear();\n            this.m_copyGeometryDrawCount = 0;\n        }\n        if (willClearGeometry || willCopyGeometry) {\n            renderer.setRenderTarget(oldRenderTarget);\n        }\n    }\n    initCacheEntries() {\n        const dummyMetrics = {\n            size: 0,\n            distanceRange: 0,\n            base: 0,\n            lineHeight: 0,\n            lineGap: 0,\n            capHeight: 0,\n            xHeight: 0\n        };\n        const dummyFont = {\n            name: \"\",\n            metrics: dummyMetrics,\n            charset: \"\"\n        };\n        const dummyGlyphData = new GlyphData_1.GlyphData(0, \"\", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);\n        for (let i = 0; i < this.m_cacheHeight; i++) {\n            for (let j = 0; j < this.m_cacheWidth; j++) {\n                const dummyEntry = {\n                    glyphData: dummyGlyphData,\n                    location: new THREE.Vector2(j, i)\n                };\n                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);\n            }\n        }\n    }\n    copyGlyphToCache(hash, glyph, cacheLocation) {\n        this.m_copyTextureSet.add(glyph.texture);\n        let copyTextureIndex = 0;\n        for (const value of this.m_copyTextureSet.values()) {\n            if (value === glyph.texture) {\n                break;\n            }\n            copyTextureIndex++;\n        }\n        glyph.copyIndex = copyTextureIndex;\n        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);\n            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);\n        }\n        if (this.m_copyGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_copyGeometryDrawCount * 4;\n        const baseIndex = this.m_copyGeometryDrawCount * 6;\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);\n            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);\n        }\n        if (this.m_copyGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n        }\n        this.m_copyGeometry.index.setX(baseIndex, baseVertex);\n        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n        ++this.m_copyGeometryDrawCount;\n        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;\n        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;\n        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;\n        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;\n        glyph.dynamicTextureCoordinates[0].set(u0, v0);\n        glyph.dynamicTextureCoordinates[1].set(u1, v0);\n        glyph.dynamicTextureCoordinates[2].set(u0, v1);\n        glyph.dynamicTextureCoordinates[3].set(u1, v1);\n        glyph.isInCache = true;\n        this.m_entryCache.set(hash, {\n            glyphData: glyph,\n            location: cacheLocation\n        });\n    }\n    clearCacheEntry(entry) {\n        entry.glyphData.isInCache = false;\n        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);\n        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);\n        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);\n        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);\n        if (this.m_clearGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_clearGeometryDrawCount * 4;\n        const baseIndex = this.m_clearGeometryDrawCount * 6;\n        for (let i = 0; i < 4; ++i) {\n            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);\n        }\n        if (this.m_clearGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n        }\n        this.m_clearGeometry.index.setX(baseIndex, baseVertex);\n        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n        ++this.m_clearGeometryDrawCount;\n    }\n}\nexports.GlyphTextureCache = GlyphTextureCache;\n//# sourceMappingURL=GlyphTextureCache.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextBufferObject = void 0;\n/**\n * Object containing vertex buffer data generated by [[TextCanvas]].\n */\nclass TextBufferObject {\n    /**\n     * Constructs a new `TextBufferObject`.\n     *\n     * @param glyphs - Input glyphs.\n     * @param buffer - Buffer containing the data generated by [[TextCanvas]].\n     * @param bounds - Optional text bounds.\n     * @param characterBounds - Optional character bounds.\n     * @param textRenderStyle - [[TextRenderStyle]] applied by [[TextCanvas]].\n     * @param textLayoutStyle - [[TextLayoutStyle]] applied by [[TextCanvas]].\n     *\n     * @returns New `TextBufferObject`.\n     */\n    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {\n        this.glyphs = glyphs;\n        this.buffer = buffer;\n        this.bounds = bounds;\n        this.characterBounds = characterBounds;\n        this.textRenderStyle = textRenderStyle;\n        this.textLayoutStyle = textLayoutStyle;\n    }\n}\nexports.TextBufferObject = TextBufferObject;\n//# sourceMappingURL=TextBufferObject.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextGeometry = exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD = exports.VERTICES_PER_QUAD = exports.INDEX_BUFFER_STRIDE = exports.VERTEX_BUFFER_STRIDE = exports.MAX_CAPACITY = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nexports.MAX_CAPACITY = 65536;\nexports.VERTEX_BUFFER_STRIDE = 16;\nexports.INDEX_BUFFER_STRIDE = 1;\nexports.VERTICES_PER_QUAD = 4;\nexports.INDICES_PER_QUAD = 6;\nexports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;\nexports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n/**\n * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].\n */\nclass TextGeometry {\n    /**\n     * Creates a new `TextGeometry`.\n     *\n     * @param material - Material used to render foreground glyphs.\n     * @param backgroundMaterial - Material used to render background glyphs.\n     * @param initialSize - Initial amount of glyphs that can be stored.\n     * @param capacity - Maximum glyph capacity.\n     *\n     * @returns New `TextGeometry`.\n     */\n    constructor(scene, material, backgroundMaterial, initialSize, capacity) {\n        this.scene = scene;\n        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);\n        this.m_currentCapacity = Math.min(initialSize, capacity);\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n        this.m_pickingDataArray = new Array(this.m_currentCapacity);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n    /**\n     * Count of currently drawn glyphs.\n     */\n    get drawCount() {\n        return this.m_drawCount;\n    }\n    /**\n     * Mesh used to render foreground glyphs.\n     */\n    get mesh() {\n        return this.m_mesh;\n    }\n    /**\n     * Mesh used to render background glyphs.\n     */\n    get backgroundMesh() {\n        return this.m_bgMesh;\n    }\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_geometry.dispose();\n    }\n    /**\n     * Clear the geometry.\n     */\n    clear() {\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n    }\n    /**\n     * Update the GPU resources to reflect the latest additions to the geometry.\n     */\n    update() {\n        if (this.drawCount > this.m_updateOffset) {\n            this.m_vertexBuffer.needsUpdate = true;\n            this.m_vertexBuffer.updateRange.offset =\n                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_vertexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.needsUpdate = true;\n            this.m_indexBuffer.updateRange.offset =\n                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;\n        }\n        this.m_updateOffset = this.m_drawCount;\n        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);\n    }\n    /**\n     * Add a new glyph to the `TextGeometry`.\n     *\n     * @param glyphData - [[GlyphData]] holding the glyph description.\n     * @param corners - Transformed glyph corners.\n     * @param weight - Foreground glyph sampling weight.\n     * @param bgWeight - Foreground glyph sampling weight.\n     * @param mirrored - If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).\n     * @param style - Currently set [[TextRenderStyle]].\n     *\n     * @returns Result of the addition.\n     */\n    add(glyphData, corners, weight, bgWeight, mirrored, style) {\n        if (this.m_drawCount >= this.capacity) {\n            return false;\n        }\n        else if (this.m_drawCount >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;\n        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;\n        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {\n            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);\n            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);\n            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);\n        }\n        this.m_indexBuffer.setX(baseIndex, baseVertex);\n        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);\n        ++this.m_drawCount;\n        return true;\n    }\n    /**\n     * Add a new glyph to a text buffer.\n     *\n     * @param buffer - Target buffer where glyph attributes will be stored.\n     * @param offset - Offset of the target buffer.\n     * @param glyphData - [[GlyphData]] holding the glyph description.\n     * @param corners - Transformed glyph corners.\n     * @param weight - Foreground glyph sampling weight.\n     * @param bgWeight - Foreground glyph sampling weight.\n     * @param mirrored - If `true`, UVs will be mirrored (needed for RTL punctuation).\n     * @param style - Currently set [[TextRenderStyle]].\n     */\n    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {\n        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {\n            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;\n            buffer[vertexOffset] = corners[i].x;\n            buffer[vertexOffset + 1] = corners[i].y;\n            buffer[vertexOffset + 2] = corners[i].z;\n            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;\n            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;\n            buffer[vertexOffset + 6] = weight;\n            buffer[vertexOffset + 7] = bgWeight;\n            buffer[vertexOffset + 8] = style.color.r;\n            buffer[vertexOffset + 9] = style.color.g;\n            buffer[vertexOffset + 10] = style.color.b;\n            buffer[vertexOffset + 11] = style.opacity;\n            buffer[vertexOffset + 12] = style.backgroundColor.r;\n            buffer[vertexOffset + 13] = style.backgroundColor.g;\n            buffer[vertexOffset + 14] = style.backgroundColor.b;\n            buffer[vertexOffset + 15] = style.backgroundOpacity;\n        }\n    }\n    /**\n     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can\n     * be passed to override the passed attribute data.\n     *\n     * @param textBufferObject - [[TextBufferObject]] containing computed glyphs.\n     * @param position - Override position value.\n     * @param scale - Override scale value.\n     * @param rotation - Override rotation value.\n     * @param color - Override color value.\n     * @param opacity - Override opacity value.\n     * @param bgColor - Override background color value.\n     * @param bgOpacity - Override background opacity value.\n     *\n     * @returns Result of the addition.\n     */\n    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {\n        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {\n            return false;\n        }\n        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n        const s = scale !== null && scale !== void 0 ? scale : 1.0;\n        const r = rotation !== null && rotation !== void 0 ? rotation : 0.0;\n        const cosR = Math.cos(r);\n        const sinR = Math.sin(r);\n        const offsetX = position !== undefined ? position.x : 0.0;\n        const offsetY = position !== undefined ? position.y : 0.0;\n        // Ignore z for rendering\n        const offsetZ = 0.0;\n        const buffer = textBufferObject.buffer;\n        const rot = buffer[3];\n        const rotSign = rot < 0 ? -1.0 : 1.0;\n        const red = color !== undefined ? color.r : buffer[8];\n        const green = color !== undefined ? color.g : buffer[9];\n        const blue = color !== undefined ? color.b : buffer[10];\n        const alpha = opacity !== undefined ? opacity : buffer[11];\n        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];\n        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];\n        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];\n        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];\n        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;\n        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {\n            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;\n            const glyph = textBufferObject.glyphs[i];\n            if (!glyph.isInCache) {\n                return false;\n            }\n            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];\n            const w = buffer[srcOffset + 6];\n            const bw = buffer[srcOffset + 7];\n            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {\n                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];\n                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];\n                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);\n                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;\n                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);\n                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);\n                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);\n            }\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);\n        }\n        this.m_drawCount += textBufferObject.glyphs.length;\n        return true;\n    }\n    /**\n     * Adds picking data for glyphs from the specified start until the last glyph added.\n     *\n     * @param startIdx - First glyph index that this picking data is associated to.\n     * @param endIdx - Last glyph index that this picking data is associated to.\n     * @param pickingData - Picking data to be added.\n     */\n    addPickingData(startIdx, endIdx, pickingData) {\n        if (this.m_pickingCount >= this.m_currentCapacity) {\n            return false;\n        }\n        this.m_pickingDataArray[this.m_pickingCount] = {\n            start: Math.min(startIdx, this.capacity),\n            end: Math.min(endIdx, this.capacity),\n            data: pickingData\n        };\n        ++this.m_pickingCount;\n        return true;\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs\n     * are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pick(screenPosition, pickCallback) {\n        for (const pickingData of this.m_pickingDataArray) {\n            if (pickingData === undefined) {\n                return;\n            }\n            for (let i = pickingData.start; i < pickingData.end; ++i) {\n                const positionIndex = i * exports.VERTICES_PER_QUAD;\n                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));\n                if (screenPosition.x < minX) {\n                    continue;\n                }\n                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));\n                if (screenPosition.x > maxX) {\n                    continue;\n                }\n                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));\n                if (screenPosition.y < minY) {\n                    continue;\n                }\n                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));\n                if (screenPosition.y > maxY) {\n                    continue;\n                }\n                pickCallback(pickingData.data);\n                break;\n            }\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.\n     *\n     * @param info - The info object to increment with the values from this `TextGeometry`.\n     */\n    updateMemoryUsage(info) {\n        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +\n            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n    resizeBuffers(size) {\n        this.m_currentCapacity = size;\n        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);\n        newVertexBuffer.set(this.m_vertexBuffer.array);\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);\n        newIndexBuffer.set(this.m_indexBuffer.array);\n        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_geometry.dispose();\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n        this.m_pickingDataArray.length = this.m_currentCapacity;\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n}\nexports.TextGeometry = TextGeometry;\n//# sourceMappingURL=TextGeometry.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SdfTextMaterial = exports.GlyphCopyMaterial = exports.GlyphClearMaterial = void 0;\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst SdfShaderChunks = {\n    sdf_attributes: `\n        attribute vec4 position;\n        attribute vec4 uv;\n        attribute vec4 color;\n        attribute vec4 bgColor;\n        `,\n    sdf_varying: `\n        varying vec4 vColor;\n        varying float vWeight;\n        varying vec2 vUv;\n        varying float vRotation;\n        `,\n    sdf_varying_computation: `\n        #if BG_TEXT\n        vColor = bgColor;\n        vWeight = uv.w;\n        #else\n        vColor = color;\n        vWeight = uv.z;\n        #endif\n        vUv = vec2(uv.xy);\n        vRotation = position.w;\n        `,\n    sdf_frag_uniforms: `\n        uniform sampler2D sdfTexture;\n        uniform vec4 sdfParams;\n        `,\n    sdf_sampling_functions: `\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float getDistance(vec2 uvOffset) {\n            vec3 texSample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;\n            #if MSDF\n            return median(texSample.r, texSample.g, texSample.b);\n            #else\n            return texSample.r;\n            #endif\n        }\n\n        float getOpacity(vec2 uvOffset, float weight) {\n            vec2 uv = vUv + uvOffset;\n            vec2 rotatedUVs = abs(vec2(\n                cos(vRotation) * uv.x - sin(vRotation) * uv.y,\n                sin(vRotation) * uv.x + cos(vRotation) * uv.y));\n\n            float dx = dFdx(rotatedUVs.x) * sdfParams.x;\n            float dy = dFdy(rotatedUVs.y) * sdfParams.y;\n            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );\n\n            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;\n            return clamp(dist * toPixels + 0.5, 0.0, 1.0);\n        }\n        `\n};\nObject.assign(THREE.ShaderChunk, SdfShaderChunks);\nconst clearVertexSource = `\n    attribute vec2 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\nconst clearFragmentSource = `\n    precision highp float;\n    precision highp int;\n\n    void main() {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }`;\nconst copyVertexSource = `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vUv;\n\n    void main() {\n        vUv = vec3(uv.xy, position.z);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\nconst copyFragmentSource = `\n    precision highp float;\n    precision highp int;\n\n    uniform float pageOffset;\n    uniform sampler2D page0;\n    uniform sampler2D page1;\n    uniform sampler2D page2;\n    uniform sampler2D page3;\n    uniform sampler2D page4;\n    uniform sampler2D page5;\n    uniform sampler2D page6;\n    uniform sampler2D page7;\n\n    varying vec3 vUv;\n\n    void main() {\n        vec4 texSample = vec4(0.0);\n        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;\n        else if (vUv.z < pageOffset + 1.0) texSample = texture2D(page0, vUv.xy);\n        else if (vUv.z < pageOffset + 2.0) texSample = texture2D(page1, vUv.xy);\n        else if (vUv.z < pageOffset + 3.0) texSample = texture2D(page2, vUv.xy);\n        else if (vUv.z < pageOffset + 4.0) texSample = texture2D(page3, vUv.xy);\n        else if (vUv.z < pageOffset + 5.0) texSample = texture2D(page4, vUv.xy);\n        else if (vUv.z < pageOffset + 6.0) texSample = texture2D(page5, vUv.xy);\n        else if (vUv.z < pageOffset + 7.0) texSample = texture2D(page6, vUv.xy);\n        else texSample = texture2D(page7, vUv.xy);\n\n        gl_FragColor = texSample;\n    }`;\nconst sdfTextVertexSource = `\n    #include <sdf_attributes>\n    #include <sdf_varying>\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        #include <sdf_varying_computation>\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n    }`;\nconst sdfTextFragmentSource = `\n    precision highp float;\n    precision highp int;\n\n    #include <sdf_varying>\n    #include <sdf_frag_uniforms>\n    #include <sdf_sampling_functions>\n\n    void main() {\n        vec4 color = vColor;\n        color.a *= getOpacity(vec2(0.0), vWeight);\n        if (color.a < 0.05) {\n            discard;\n        }\n        gl_FragColor = color;\n    }`;\nclass RawShaderMaterial extends THREE.RawShaderMaterial {\n    /**\n     * The constructor of `RawShaderMaterial`.\n     *\n     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning\n     * another material.\n     */\n    constructor(params) {\n        const isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;\n        const shaderParams = params\n            ? Object.assign(Object.assign({}, params), { glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1, vertexShader: isWebGL2 && params.vertexShader\n                    ? harp_utils_1.convertVertexShaderToWebGL2(params.vertexShader)\n                    : params.vertexShader, fragmentShader: isWebGL2 && params.fragmentShader\n                    ? harp_utils_1.convertFragmentShaderToWebGL2(params.fragmentShader)\n                    : params.fragmentShader }) : undefined;\n        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js\n        // will log warnings.\n        if (shaderParams) {\n            delete shaderParams.rendererCapabilities;\n        }\n        super(shaderParams);\n    }\n}\n/**\n * @hidden\n * Material used for clearing glyphs from a [[GlyphTextureCache]].\n */\nclass GlyphClearMaterial extends RawShaderMaterial {\n    /**\n     * Creates a new `GlyphClearMaterial`.\n     * @param params - Material parameters. Always required except when cloning another\n     * material.\n     * @returns New `GlyphClearMaterial`.\n     */\n    constructor(params) {\n        const shaderParams = params\n            ? {\n                name: \"GlyphClearMaterial\",\n                vertexShader: clearVertexSource,\n                fragmentShader: clearFragmentSource,\n                uniforms: {},\n                depthTest: false,\n                depthWrite: false,\n                rendererCapabilities: params.rendererCapabilities\n            }\n            : undefined;\n        super(shaderParams);\n    }\n}\nexports.GlyphClearMaterial = GlyphClearMaterial;\n/**\n * @hidden\n * Material used for copying glyphs into a [[GlyphTextureCache]].\n */\nclass GlyphCopyMaterial extends RawShaderMaterial {\n    /**\n     * Creates a new `GlyphCopyMaterial`.\n     * @param params - Material parameters. Always required except when cloning another\n     * material.\n     * @returns New `GlyphCopyMaterial`.\n     */\n    constructor(params) {\n        const shaderParams = params\n            ? {\n                name: \"GlyphCopyMaterial\",\n                vertexShader: copyVertexSource,\n                fragmentShader: copyFragmentSource,\n                uniforms: {\n                    pageOffset: new THREE.Uniform(0.0),\n                    page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                    page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)\n                },\n                depthTest: false,\n                depthWrite: false,\n                rendererCapabilities: params.rendererCapabilities\n            }\n            : undefined;\n        super(shaderParams);\n    }\n}\nexports.GlyphCopyMaterial = GlyphCopyMaterial;\n/**\n * Material designed to render transformable, high quality SDF text.\n */\nclass SdfTextMaterial extends RawShaderMaterial {\n    /**\n     * Creates a new `SdfTextMaterial`.\n     *\n     * @param params - Material parameters. Always required except when cloning another\n     * material.\n     * @returns New `SdfTextMaterial`.\n     */\n    constructor(params) {\n        const shaderParams = params\n            ? {\n                name: \"SdfTextMaterial\",\n                vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,\n                fragmentShader: params.fragmentSource !== undefined\n                    ? params.fragmentSource\n                    : sdfTextFragmentSource,\n                uniforms: {\n                    sdfTexture: new THREE.Uniform(params.texture),\n                    sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))\n                },\n                defines: {\n                    MSDF: params.isMsdf ? 1.0 : 0.0,\n                    BG_TEXT: params.isBackground ? 1.0 : 0.0\n                },\n                depthTest: true,\n                depthWrite: false,\n                side: THREE.DoubleSide,\n                transparent: true,\n                rendererCapabilities: params.rendererCapabilities\n            }\n            : undefined;\n        super(shaderParams);\n        this.extensions.derivatives = true;\n    }\n}\nexports.SdfTextMaterial = SdfTextMaterial;\n//# sourceMappingURL=TextMaterials.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolvePlacementAndAlignment = exports.TextLayoutStyle = exports.TextRenderStyle = exports.DefaultTextStyle = exports.vPlacementFromAlignment = exports.hPlacementFromAlignment = exports.vAlignFromPlacement = exports.hAlignFromPlacement = exports.WrappingMode = exports.HorizontalPlacement = exports.VerticalPlacement = exports.HorizontalAlignment = exports.VerticalAlignment = exports.FontVariant = exports.FontStyle = exports.FontUnit = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Unit of measurement used to specify a font's size.\n */\nvar FontUnit;\n(function (FontUnit) {\n    FontUnit[FontUnit[\"Em\"] = 0] = \"Em\";\n    FontUnit[FontUnit[\"Pixel\"] = 1] = \"Pixel\";\n    FontUnit[FontUnit[\"Point\"] = 2] = \"Point\";\n    FontUnit[FontUnit[\"Percent\"] = 3] = \"Percent\";\n})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));\n/**\n * Style to be used when rendering glyphs.\n */\nvar FontStyle;\n(function (FontStyle) {\n    FontStyle[FontStyle[\"Regular\"] = 0] = \"Regular\";\n    FontStyle[FontStyle[\"Bold\"] = 1] = \"Bold\";\n    FontStyle[FontStyle[\"Italic\"] = 2] = \"Italic\";\n    FontStyle[FontStyle[\"BoldItalic\"] = 3] = \"BoldItalic\";\n})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));\n/**\n * Variant to be used when rendering.\n */\nvar FontVariant;\n(function (FontVariant) {\n    FontVariant[FontVariant[\"Regular\"] = 0] = \"Regular\";\n    FontVariant[FontVariant[\"AllCaps\"] = 1] = \"AllCaps\";\n    FontVariant[FontVariant[\"SmallCaps\"] = 2] = \"SmallCaps\";\n})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));\n/**\n * Vertical alignment to be used when placing text.\n */\nvar VerticalAlignment;\n(function (VerticalAlignment) {\n    VerticalAlignment[VerticalAlignment[\"Above\"] = 0] = \"Above\";\n    VerticalAlignment[VerticalAlignment[\"Center\"] = -0.5] = \"Center\";\n    VerticalAlignment[VerticalAlignment[\"Below\"] = -1] = \"Below\";\n})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));\n/**\n * Horizontal alignment to be used when placing text.\n */\nvar HorizontalAlignment;\n(function (HorizontalAlignment) {\n    HorizontalAlignment[HorizontalAlignment[\"Left\"] = 0] = \"Left\";\n    HorizontalAlignment[HorizontalAlignment[\"Center\"] = -0.5] = \"Center\";\n    HorizontalAlignment[HorizontalAlignment[\"Right\"] = -1] = \"Right\";\n})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));\n/**\n * Vertical position of text area relative to the placement context (point, line).\n */\nvar VerticalPlacement;\n(function (VerticalPlacement) {\n    VerticalPlacement[VerticalPlacement[\"Top\"] = 0] = \"Top\";\n    VerticalPlacement[VerticalPlacement[\"Center\"] = -0.5] = \"Center\";\n    VerticalPlacement[VerticalPlacement[\"Bottom\"] = -1] = \"Bottom\";\n})(VerticalPlacement = exports.VerticalPlacement || (exports.VerticalPlacement = {}));\n/**\n * Horizontal position of text element relative to the placement context (point, line).\n *\n * @note [[HorizontalPlacement]] value is exactly opposite to [[HorizontalAlignment]] value,\n * cause when you place text on the right side of point (or icon) it will be left-aligned.\n */\nvar HorizontalPlacement;\n(function (HorizontalPlacement) {\n    HorizontalPlacement[HorizontalPlacement[\"Left\"] = -1] = \"Left\";\n    HorizontalPlacement[HorizontalPlacement[\"Center\"] = -0.5] = \"Center\";\n    HorizontalPlacement[HorizontalPlacement[\"Right\"] = 0] = \"Right\";\n})(HorizontalPlacement = exports.HorizontalPlacement || (exports.HorizontalPlacement = {}));\n/**\n * Text wrapping rule used when `lineWidth` is reached.\n */\nvar WrappingMode;\n(function (WrappingMode) {\n    WrappingMode[WrappingMode[\"None\"] = 0] = \"None\";\n    WrappingMode[WrappingMode[\"Character\"] = 1] = \"Character\";\n    WrappingMode[WrappingMode[\"Word\"] = 2] = \"Word\";\n})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[HorizontalAlignment]] from [[HorizontalPlacement]].\n * Horizontal alignments are exactly opposite to the placements.\n */\nfunction hAlignFromPlacement(hP) {\n    return hP;\n}\nexports.hAlignFromPlacement = hAlignFromPlacement;\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[VerticalAlignment]] from [[VerticalPlacement]].\n */\nfunction vAlignFromPlacement(vP) {\n    return vP;\n}\nexports.vAlignFromPlacement = vAlignFromPlacement;\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[HorizontalPlacement]] from [[HorizontalAlignment]].\n * Horizontal placements are exactly opposite to the alignment values.\n */\nfunction hPlacementFromAlignment(hA) {\n    return hA;\n}\nexports.hPlacementFromAlignment = hPlacementFromAlignment;\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[VerticalPlacement]] from [[VerticalAlignment]].\n */\nfunction vPlacementFromAlignment(vA) {\n    return vA;\n}\nexports.vPlacementFromAlignment = vPlacementFromAlignment;\n/**\n * Namespace containing default values for all members of [[TextRenderParameters]] and\n * [[TextLayoutParameters]].\n */\nvar DefaultTextStyle;\n(function (DefaultTextStyle) {\n    DefaultTextStyle.DEFAULT_FONT_NAME = \"\";\n    DefaultTextStyle.DEFAULT_FONT_SIZE = {\n        unit: Object.freeze(FontUnit.Pixel),\n        size: Object.freeze(16.0),\n        backgroundSize: Object.freeze(0.0)\n    };\n    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;\n    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;\n    DefaultTextStyle.DEFAULT_ROTATION = 0.0;\n    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);\n    DefaultTextStyle.DEFAULT_OPACITY = 1.0;\n    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);\n    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;\n    DefaultTextStyle.DEFAULT_TRACKING = 0.0;\n    DefaultTextStyle.DEFAULT_LEADING = 0.0;\n    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;\n    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;\n    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;\n    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;\n    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;\n    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;\n    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;\n    DefaultTextStyle.DEFAULT_PLACEMENTS = [];\n})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));\n/**\n * [[TextCanvas]] text rendering style.\n */\nclass TextRenderStyle {\n    /**\n     * Creates a new `TextRenderStyle`.\n     *\n     * @param params - Input [[TextRenderParameters]].\n     *\n     * @returns New `TextRenderStyle`.\n     */\n    constructor(params = {}) {\n        this.m_params = {\n            fontName: params.fontName !== undefined\n                ? params.fontName\n                : DefaultTextStyle.DEFAULT_FONT_NAME,\n            fontSize: params.fontSize !== undefined\n                ? Object.assign({}, params.fontSize) : {\n                unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,\n                size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,\n                backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize\n            },\n            fontStyle: params.fontStyle !== undefined\n                ? params.fontStyle\n                : DefaultTextStyle.DEFAULT_FONT_STYLE,\n            fontVariant: params.fontVariant !== undefined\n                ? params.fontVariant\n                : DefaultTextStyle.DEFAULT_FONT_VARIANT,\n            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,\n            color: params.color !== undefined\n                ? params.color.clone()\n                : DefaultTextStyle.DEFAULT_COLOR.clone(),\n            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,\n            backgroundColor: params.backgroundColor !== undefined\n                ? params.backgroundColor.clone()\n                : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),\n            backgroundOpacity: params.backgroundOpacity !== undefined\n                ? params.backgroundOpacity\n                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY\n        };\n    }\n    /**\n     * Current [[TextRenderParameters]] for this style.\n     */\n    get params() {\n        return this.m_params;\n    }\n    set params(value) {\n        this.m_params = Object.assign(Object.assign({}, this.m_params), value);\n    }\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    get fontName() {\n        return this.m_params.fontName;\n    }\n    set fontName(value) {\n        this.m_params.fontName = value;\n    }\n    /**\n     * Collection of unit and sizes to apply for the currently active [[Font]].\n     */\n    get fontSize() {\n        return this.m_params.fontSize;\n    }\n    set fontSize(value) {\n        this.m_params.fontSize = Object.assign({}, value);\n    }\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    get fontStyle() {\n        return this.m_params.fontStyle;\n    }\n    set fontStyle(value) {\n        this.m_params.fontStyle = value;\n    }\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    get fontVariant() {\n        return this.m_params.fontVariant;\n    }\n    set fontVariant(value) {\n        this.m_params.fontVariant = value;\n    }\n    /**\n     * Glyph local rotation (radians).\n     */\n    get rotation() {\n        return this.m_params.rotation;\n    }\n    set rotation(value) {\n        this.m_params.rotation = value;\n    }\n    /**\n     * Glyph color.\n     */\n    get color() {\n        return this.m_params.color;\n    }\n    set color(value) {\n        this.m_params.color.copy(value);\n    }\n    /**\n     * Glyph background color.\n     */\n    get backgroundColor() {\n        return this.m_params.backgroundColor;\n    }\n    set backgroundColor(value) {\n        this.m_params.backgroundColor.copy(value);\n    }\n    /**\n     * Glyph opacity.\n     */\n    get opacity() {\n        return this.m_params.opacity;\n    }\n    set opacity(value) {\n        this.m_params.opacity = value;\n    }\n    /**\n     * Glyph background opacity.\n     */\n    get backgroundOpacity() {\n        return this.m_params.backgroundOpacity;\n    }\n    set backgroundOpacity(value) {\n        this.m_params.backgroundOpacity = value;\n    }\n    /**\n     * Clone this [[TextRenderStyle]].\n     *\n     * @param params - Input [[TextRenderParameters]].\n     *\n     * @returns Cloned [[TextRenderStyle]].\n     */\n    clone(params = {}) {\n        return new TextRenderStyle(Object.assign(Object.assign({}, this.m_params), params));\n    }\n    /**\n     * Copy other [[TextRenderStyle]] properties into this object instance.\n     *\n     * @param source - The source object to be copied.\n     *\n     * @returns reference to `this` object.\n     */\n    copy(source) {\n        // Given that all source and this params are always defined:\n        this.m_params.fontName = source.fontName;\n        this.m_params.fontSize = Object.assign({}, source.fontSize);\n        this.m_params.fontStyle = source.fontStyle;\n        this.m_params.fontVariant = source.fontVariant;\n        this.m_params.rotation = source.rotation;\n        this.m_params.color.copy(source.color);\n        this.m_params.backgroundColor.copy(source.backgroundColor);\n        this.m_params.opacity = source.opacity;\n        this.m_params.backgroundOpacity = source.backgroundOpacity;\n        return this;\n    }\n}\nexports.TextRenderStyle = TextRenderStyle;\n/**\n * [[TextCanvas]] text rendering style.\n */\nclass TextLayoutStyle {\n    /**\n     * Creates a new `TextLayoutStyle`.\n     *\n     * @param params - Input [[TextLayoutParameters]].\n     *\n     * @returns New `TextLayoutStyle`.\n     */\n    constructor(params = {}) {\n        // Solve alignment and placement dependencies and fallbacks.\n        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(params.horizontalAlignment, params.verticalAlignment, params.placements);\n        this.m_params = {\n            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,\n            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,\n            maxLines: params.maxLines !== undefined\n                ? params.maxLines\n                : DefaultTextStyle.DEFAULT_MAX_LINES,\n            lineWidth: params.lineWidth !== undefined\n                ? params.lineWidth\n                : DefaultTextStyle.DEFAULT_LINE_WIDTH,\n            canvasRotation: params.canvasRotation !== undefined\n                ? params.canvasRotation\n                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,\n            lineRotation: params.lineRotation !== undefined\n                ? params.lineRotation\n                : DefaultTextStyle.DEFAULT_LINE_ROTATION,\n            wrappingMode: params.wrappingMode !== undefined\n                ? params.wrappingMode\n                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,\n            verticalAlignment,\n            horizontalAlignment,\n            placements\n        };\n    }\n    /**\n     * Current [[TextLayoutParameters]] for this style.\n     */\n    get params() {\n        return this.m_params;\n    }\n    set params(value) {\n        this.m_params = Object.assign(Object.assign({}, this.m_params), value);\n    }\n    /**\n     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].\n     */\n    get tracking() {\n        return this.m_params.tracking;\n    }\n    set tracking(value) {\n        this.m_params.tracking = value;\n    }\n    /**\n     * Inter-line spacing (pixels). Scaled by [[FontSize]].\n     */\n    get leading() {\n        return this.m_params.leading;\n    }\n    set leading(value) {\n        this.m_params.leading = value;\n    }\n    /**\n     * Maximum number of lines to be considered when using [[TextCanvas]].\n     */\n    get maxLines() {\n        return this.m_params.maxLines;\n    }\n    set maxLines(value) {\n        this.m_params.maxLines = value;\n    }\n    /**\n     * Maximum line width (pixels).\n     */\n    get lineWidth() {\n        return this.m_params.lineWidth;\n    }\n    set lineWidth(value) {\n        this.m_params.lineWidth = value;\n    }\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    get canvasRotation() {\n        return this.m_params.canvasRotation;\n    }\n    set canvasRotation(value) {\n        this.m_params.canvasRotation = value;\n    }\n    /**\n     * Line typesetting rotation (radians).\n     */\n    get lineRotation() {\n        return this.m_params.lineRotation;\n    }\n    set lineRotation(value) {\n        this.m_params.lineRotation = value;\n    }\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    get wrappingMode() {\n        return this.m_params.wrappingMode;\n    }\n    set wrappingMode(value) {\n        this.m_params.wrappingMode = value;\n    }\n    /**\n     * Text position regarding the baseline.\n     */\n    get verticalAlignment() {\n        return this.m_params.verticalAlignment;\n    }\n    set verticalAlignment(value) {\n        this.m_params.verticalAlignment = value;\n    }\n    /**\n     * Text position inside a line.\n     */\n    get horizontalAlignment() {\n        return this.m_params.horizontalAlignment;\n    }\n    set horizontalAlignment(value) {\n        this.m_params.horizontalAlignment = value;\n    }\n    /**\n     * Text placement options relative to label anchor (origin).\n     *\n     * @note [[TextPlacement]]s options may override alignment settings.\n     */\n    get placements() {\n        return this.m_params.placements;\n    }\n    set placements(value) {\n        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(this.horizontalAlignment, this.verticalAlignment, value);\n        this.m_params.horizontalAlignment = horizontalAlignment;\n        this.m_params.verticalAlignment = verticalAlignment;\n        this.m_params.placements = placements;\n    }\n    /**\n     * Clone this [[TextLayoutStyle]].\n     *\n     * @param params - Input [[TextLayoutParameters]].\n     *\n     * @returns Cloned [[TextLayoutStyle]].\n     */\n    clone(params = {}) {\n        return new TextLayoutStyle(Object.assign(Object.assign({}, this.m_params), params));\n    }\n    /**\n     * Copy other [[TextLayoutStyle]] properties into this object instance.\n     *\n     * @param other - The object to be copied.\n     *\n     * @returns reference to `this` object.\n     */\n    copy(other) {\n        this.params = Object.assign({}, other.params);\n        return this;\n    }\n}\nexports.TextLayoutStyle = TextLayoutStyle;\n/**\n * Deduce alignment and placement attributes depending on the availability.\n *\n * If placement is defined it may override alignment settings, if no attributes are\n * provided they may be retrieved from defaults.\n *\n * @param hAlignment - The optional horizontal alignment.\n * @param vAlignment - The vertical alignment - optional.\n * @param placementsOpt - Possible text placements - optional.\n * @internal\n */\nfunction resolvePlacementAndAlignment(hAlignment, vAlignment, placementsOpt) {\n    var _a;\n    // Make a deep copy or create new array from defaults.\n    const placements = (_a = placementsOpt === null || placementsOpt === void 0 ? void 0 : placementsOpt.map(v => (Object.assign({}, v)))) !== null && _a !== void 0 ? _a : DefaultTextStyle.DEFAULT_PLACEMENTS.map(v => (Object.assign({}, v)));\n    // Ignore alignment attributes when placements attributes are defined or provide default\n    // values if none of them are provided.\n    // NOTE: Alignment override may be removed if we decide to support both attributes.\n    const horizontalAlignment = placements.length > 0\n        ? hAlignFromPlacement(placements[0].h)\n        : hAlignment !== null && hAlignment !== void 0 ? hAlignment : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;\n    const verticalAlignment = placements.length > 0\n        ? vAlignFromPlacement(placements[0].v)\n        : vAlignment !== null && vAlignment !== void 0 ? vAlignment : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;\n    return { horizontalAlignment, verticalAlignment, placements };\n}\nexports.resolvePlacementAndAlignment = resolvePlacementAndAlignment;\n//# sourceMappingURL=TextStyle.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LineTypesetter = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js\");\nconst TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * [[Typesetter]] implementation that handles multi-line complex layout text.\n */\nclass LineTypesetter {\n    /**\n     * Creates a `LineTypesetter` object.\n     *\n     * @returns New `LineTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n    }\n    /**\n     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple\n     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,\n     * such as:\n     * - Maximum line width.\n     * - Word and character wrapping.\n     * - Maximum number of lines.\n     * - Vertical and horizontal alignment.\n     * - Leading (spacing between lines).\n     *\n     * @param params - Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params) {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);\n        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;\n        this.m_currentParams.position.y +=\n            this.m_currentParams.textLayoutStyle.verticalAlignment *\n                this.m_currentParams.glyphs[0].font.metrics.capHeight *\n                this.m_tempScale;\n        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n        // Compute line origin and height.\n        const origin = this.m_currentParams.position.x;\n        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +\n            this.m_currentParams.textLayoutStyle.leading;\n        // Initialize line-breaking and wrapping variables.\n        let lineStartIdx = 0;\n        let glyphWrapIdx = 0;\n        let wordWrapIdx = 0;\n        let lineStartX = 0;\n        let lineCurrX = 0;\n        let glyphWrapX = 0;\n        let wordWrapX = 0;\n        let lineCount = 0;\n        let isBidirectionalLine = false;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {\n                break;\n            }\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);\n            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);\n            // Check if this line should be treated as bidirectional.\n            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectionalLine = true;\n            }\n            // Advance the line's current X offset (only for printable characters).\n            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                lineCurrX +=\n                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                        this.m_tempScale *\n                        (this.m_tempSmallCaps\n                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)\n                            : 1.0);\n            }\n            // If this is the first character in a line, update the line's X offset values (needed\n            // to properly center and wrap).\n            if (i === lineStartIdx) {\n                lineStartX = lineCurrX;\n                glyphWrapX = lineCurrX;\n                wordWrapX = lineCurrX;\n            }\n            // Check if should break the current line.\n            if (isNewLine ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Character &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&\n                    wordWrapX !== lineStartX)) {\n                // Perform wrapping.\n                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {\n                    let wrapPointIdx = glyphWrapIdx;\n                    let wrapPointX = glyphWrapX;\n                    // Only wrap words when more than a single word fits into the current line.\n                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&\n                        wordWrapX !== lineStartX) {\n                        wrapPointIdx = wordWrapIdx;\n                        wrapPointX = wordWrapX;\n                    }\n                    lineCurrX = wrapPointX;\n                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);\n                }\n                // Calculate the correct starting position for the line base on alignment, and place\n                // all glyphs in it.\n                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine\n                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n                this.m_currentParams.position.x =\n                    this.m_currentParams.position.x + lineCurrX * lineAlignment;\n                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {\n                    return false;\n                }\n                // Update the line position.\n                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;\n                this.m_currentParams.position.x = origin;\n                // Find the beginning of a new line (removing trailing white spaces).\n                while (i !== lineStartIdx &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {\n                    ++i;\n                }\n                lineStartIdx = i + 1;\n                if (lineStartIdx === this.m_currentParams.glyphs.length) {\n                    break;\n                }\n                // Only reset the line's direction when a new line character is found (to keep\n                // correct bidirectional behaviour when a bidirectional run is placed between\n                // multiple lines).\n                if (isNewLine) {\n                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);\n                    this.m_tempRunDirection = this.m_tempLineDirection;\n                }\n                // Reset the line placement parameters.\n                lineStartX = 0;\n                lineCurrX = 0;\n                glyphWrapIdx = lineStartIdx;\n                glyphWrapX = 0;\n                wordWrapIdx = lineStartIdx;\n                wordWrapX = 0;\n                isBidirectionalLine = false;\n                lineCount++;\n            }\n            // If not, should if we should record any new wrapping points.\n            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&\n                !isWhiteSpace) {\n                // Update the per-glyph wrapping point.\n                glyphWrapIdx = i;\n                glyphWrapX = lineCurrX;\n                // Update the word wrapping point (only if mode is correctly set and we are\n                // currently placed at the end of a word).\n                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||\n                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {\n                    wordWrapIdx = i;\n                    wordWrapX = lineCurrX;\n                }\n            }\n        }\n        // If we still haven't placed all characters, place a final line.\n        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&\n            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {\n            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine\n                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);\n            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Place characters alongside a line. Text direction is taken into account, and text is broken\n    // into directional runs.\n    placeLine(startIdx, endIdx, direction, isBidirectional) {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(startIdx, endIdx, direction);\n        }\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        const smallCapsArray = this.m_currentParams.smallCapsArray;\n        const textRenderStyle = this.m_currentParams.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams.textLayoutStyle;\n        const position = this.m_currentParams.position;\n        // Initialize line placement parameters.\n        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;\n        const origin = position.x;\n        let offset = 0;\n        let runStart = startIdx;\n        for (let i = startIdx; i <= endIdx; ++i) {\n            const glyphData = glyphDataArray[i];\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (isRTL) {\n                    position.x = origin + offset;\n                }\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                if (!isRTL) {\n                    position.x = origin + offset;\n                }\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction) {\n                let neutralIdx = i;\n                while (neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {\n                    ++neutralIdx;\n                }\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (isRTL) {\n                        position.x = origin + offset;\n                    }\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    if (!isRTL) {\n                        position.x = origin + offset;\n                    }\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n            // Advance the offset position in the line.\n            offset +=\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)\n                        : 1.0) *\n                    direction;\n        }\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart <= endIdx) {\n            if (isRTL) {\n                position.x = origin + offset;\n            }\n            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {\n                return false;\n            }\n            if (!isRTL) {\n                position.x = origin + offset;\n            }\n        }\n        return true;\n    }\n    // Place a directional run of index inside a line.\n    placeRun(startIdx, endIdx, direction) {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        const smallCapsArray = this.m_currentParams.smallCapsArray;\n        const fontCatalog = this.m_currentParams.fontCatalog;\n        const textRenderStyle = this.m_currentParams.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams.textLayoutStyle;\n        const position = this.m_currentParams.position;\n        const geometry = this.m_currentParams.geometry;\n        const globalBounds = this.m_currentParams.globalBounds;\n        const individualBounds = this.m_currentParams.individualBounds;\n        const vertexBuffer = this.m_currentParams.vertexBuffer;\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);\n                i = weakRunStart;\n                continue;\n            }\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight = (0.5 * this.m_tempPixelBgSize) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;\n            const verticalOffset = glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset = isItalicEmulated && j > 1\n                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                    : 0.0;\n                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n            }\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {\n                    return false;\n                }\n            }\n            else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);\n                }\n            }\n            // Advance the current position and proceed to next glyph in the run.\n            position.set(position.x +\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                    glyphScale *\n                    Math.cos(textLayoutStyle.lineRotation), position.y +\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                    glyphScale *\n                    Math.sin(textLayoutStyle.lineRotation), position.z);\n        }\n        return true;\n    }\n}\nexports.LineTypesetter = LineTypesetter;\n//# sourceMappingURL=LineTypesetter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathTypesetter = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js\");\nconst TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * [[Typesetter]] implementation that arranges glyphs alongside a specified path.\n */\nclass PathTypesetter {\n    /**\n     * Creates a `PathTypesetter` object.\n     *\n     * @returns New `PathTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n        this.m_tempPathPosition = new THREE.Vector3();\n        this.m_tempPathLength = 0.0;\n        this.m_tempPathOffset = 0.0;\n    }\n    /**\n     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single\n     * bidirectional line that follows the specified path. Characters will be orientated and placed\n     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and\n     * [[HorizontalAlignment]].\n     *\n     * @param params - Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params) {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);\n        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;\n        this.m_tempPathLength = this.m_currentParams.path.getLength();\n        this.m_tempPathOffset = 0.0;\n        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n        // To be able to properly set the horizontal alignment on a path, we need to first retrieve\n        // how much of the path the input text covers, so we can calculate the correct initial\n        // offset.\n        let isBidirectional = false;\n        let pathWidth = 0.0;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectional = true;\n            }\n            pathWidth +=\n                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)\n                        : 1.0);\n        }\n        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +\n            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /\n                this.m_tempPathLength, 0), 1);\n        // Place the input text as a single path line.\n        return this.placeLine(this.m_tempLineDirection, isBidirectional);\n    }\n    // Place characters alongside a path line. Text direction is taken into account, and text is\n    // broken into directional runs.\n    placeLine(direction, isBidirectional) {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);\n        }\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        // Initialize line placement parameters.\n        let runStart = 0;\n        for (let i = runStart; i < glyphDataArray.length; ++i) {\n            const glyphData = glyphDataArray[i];\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction) {\n                let neutralIdx = i;\n                while (neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {\n                    ++neutralIdx;\n                }\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n        }\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart < glyphDataArray.length) {\n            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Place a directional run of index inside a path line.\n    placeRun(startIdx, endIdx, direction) {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        const smallCapsArray = this.m_currentParams.smallCapsArray;\n        const fontCatalog = this.m_currentParams.fontCatalog;\n        const textRenderStyle = this.m_currentParams.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams.textLayoutStyle;\n        const position = this.m_currentParams.position;\n        const geometry = this.m_currentParams.geometry;\n        const globalBounds = this.m_currentParams.globalBounds;\n        const individualBounds = this.m_currentParams.individualBounds;\n        const vertexBuffer = this.m_currentParams.vertexBuffer;\n        const path = this.m_currentParams.path;\n        const defaultGlyphRotation = textRenderStyle.rotation;\n        const normalDisplacement = textLayoutStyle.verticalAlignment *\n            glyphDataArray[0].font.metrics.capHeight *\n            this.m_tempScale;\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);\n                i = weakRunStart;\n                continue;\n            }\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight = (0.5 * this.m_tempPixelBgSize) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;\n            const verticalOffset = glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n            // Update the current interpolated path position and angle.\n            const textPoint = path.getPoint(this.m_tempPathOffset);\n            if (textPoint === null) {\n                return this.m_currentParams.pathOverflow;\n            }\n            const tangent = path.getTangent(this.m_tempPathOffset);\n            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);\n            const angle = Math.atan2(tangent.y, tangent.x);\n            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);\n            textRenderStyle.rotation = defaultGlyphRotation + angle;\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset = isItalicEmulated && j > 1\n                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                    : 0.0;\n                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n                this.m_tempCorners[j].x -= position.x;\n                this.m_tempCorners[j].y -= position.y;\n            }\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {\n                    return false;\n                }\n            }\n            else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);\n                }\n            }\n            // Restore the original glyph rotation.\n            textRenderStyle.rotation = defaultGlyphRotation;\n            // Advance the current position and proceed to next glyph in the run.\n            this.m_tempPathOffset +=\n                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /\n                    this.m_tempPathLength;\n        }\n        return true;\n    }\n}\nexports.PathTypesetter = PathTypesetter;\n//# sourceMappingURL=PathTypesetter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextualArabicConverter = void 0;\nvar ContextualForm;\n(function (ContextualForm) {\n    ContextualForm[ContextualForm[\"Initial\"] = 0] = \"Initial\";\n    ContextualForm[ContextualForm[\"Medial\"] = 1] = \"Medial\";\n    ContextualForm[ContextualForm[\"Final\"] = 2] = \"Final\";\n})(ContextualForm || (ContextualForm = {}));\nvar CombinedForm;\n(function (CombinedForm) {\n    CombinedForm[CombinedForm[\"Isolated\"] = 0] = \"Isolated\";\n    CombinedForm[CombinedForm[\"Connected\"] = 1] = \"Connected\";\n})(CombinedForm || (CombinedForm = {}));\n/**\n * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms\n * (in Unicode Block 'Arabic Presentation Forms-B').\n */\nclass ContextualArabicConverter {\n    constructor() {\n        this.m_singleCharactersMap = new Map();\n        this.m_combinedCharactersMap = new Map();\n        // Single characters.\n        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA\n        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA\n        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE\n        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA\n        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW\n        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA\n        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF\n        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH\n        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA\n        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH\n        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH\n        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM\n        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH\n        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH\n        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL\n        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL\n        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH\n        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN\n        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN\n        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN\n        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD\n        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD\n        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH\n        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH\n        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN\n        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN\n        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL\n        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH\n        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF\n        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF\n        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM\n        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM\n        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON\n        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH\n        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW\n        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA\n        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH\n        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH\n        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh\n        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh\n        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh\n        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf\n        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh\n        // Combined characters.\n        this.m_combinedCharactersMap.set(0x0644, new Map());\n        // LAM_ALEF_MADDA\n        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);\n        // LAM_ALEF_HAMZA_ABOVE\n        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);\n        // LAM_ALEF_HAMZA_BELOW\n        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);\n        // LAM_ALEF\n        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);\n        // Neutral characters.\n        this.m_neutralCharacters = [\n            0x0610,\n            0x0612,\n            0x0613,\n            0x0614,\n            0x0615,\n            0x064b,\n            0x064c,\n            0x064d,\n            0x064e,\n            0x064f,\n            0x0650,\n            0x0651,\n            0x0652,\n            0x0653,\n            0x0654,\n            0x0655,\n            0x0656,\n            0x0657,\n            0x0658,\n            0x0670,\n            0x06d6,\n            0x06d7,\n            0x06d8,\n            0x06d9,\n            0x06da,\n            0x06db,\n            0x06dc,\n            0x06df,\n            0x06e0,\n            0x06e1,\n            0x06e2,\n            0x06e3,\n            0x06e4,\n            0x06e7,\n            0x06e8,\n            0x06ea,\n            0x06eb,\n            0x06ec,\n            0x06ed // ARABIC SMALL LOW MEEM\n        ];\n    }\n    static get instance() {\n        if (this.m_instance === undefined) {\n            this.m_instance = new ContextualArabicConverter();\n        }\n        return this.m_instance;\n    }\n    /**\n     * Converts isolated arabic characters into their contextual form.\n     *\n     * @param input - String with isolated arabic characters.\n     */\n    convert(input) {\n        let output = \"\";\n        for (let i = 0; i < input.length; ++i) {\n            const currentCodePoint = input.charCodeAt(i);\n            // Only process arabic characters in the map.\n            if (this.isArabicCharacter(currentCodePoint)) {\n                // Find the first previous non-neutral character.\n                let prevIndex = i - 1;\n                for (; prevIndex >= 0; --prevIndex) {\n                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {\n                        break;\n                    }\n                }\n                // Check if the previous character has ligatures with following characters.\n                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;\n                if (prevCodePoint !== undefined) {\n                    const prevMap = this.getCharacterMap(prevCodePoint);\n                    if (prevMap === undefined ||\n                        (prevMap[ContextualForm.Initial] === undefined &&\n                            prevMap[ContextualForm.Medial] === undefined)) {\n                        prevCodePoint = undefined;\n                    }\n                }\n                // Find the first next non-neutral character.\n                let nextIndex = i + 1;\n                for (; nextIndex < input.length; ++nextIndex) {\n                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {\n                        break;\n                    }\n                }\n                // Check if the next character has ligatures with previous characters.\n                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;\n                if (nextCodePoint !== undefined) {\n                    const nextMap = this.getCharacterMap(nextCodePoint);\n                    if (nextMap === undefined ||\n                        (nextMap[ContextualForm.Medial] === undefined &&\n                            nextMap[ContextualForm.Final] === undefined)) {\n                        nextCodePoint = undefined;\n                    }\n                }\n                // Check for Lam Alef combinated forms.\n                if (currentCodePoint === 0x0644 &&\n                    nextCodePoint !== undefined &&\n                    (nextCodePoint === 0x0622 ||\n                        nextCodePoint === 0x0623 ||\n                        nextCodePoint === 0x0625 ||\n                        nextCodePoint === 0x0627)) {\n                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);\n                    if (prevCodePoint !== undefined) {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);\n                    }\n                    else {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);\n                    }\n                    // Skip the next character and continue.\n                    ++i;\n                    continue;\n                }\n                // Check for single character contextual forms.\n                const map = this.getCharacterMap(currentCodePoint);\n                // Intermediate.\n                if (prevCodePoint !== undefined &&\n                    nextCodePoint !== undefined &&\n                    map[ContextualForm.Medial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Medial]);\n                }\n                // Final.\n                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Final]);\n                }\n                // Initial.\n                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Initial]);\n                }\n                // Isolated.\n                else {\n                    output += String.fromCharCode(currentCodePoint);\n                }\n            }\n            else {\n                output += String.fromCharCode(currentCodePoint);\n            }\n        }\n        return output;\n    }\n    isArabicCharacter(codePoint) {\n        return this.m_singleCharactersMap.has(codePoint);\n    }\n    getCharacterMap(codePoint) {\n        return this.m_singleCharactersMap.get(codePoint);\n    }\n    getCombinedCharacterMap(codePoint, nextCodePoint) {\n        const map = this.m_combinedCharactersMap.get(codePoint);\n        if (map !== undefined) {\n            return map.get(nextCodePoint);\n        }\n        return undefined;\n    }\n    isNeutral(codePoint) {\n        for (const character of this.m_neutralCharacters) {\n            if (character === codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.ContextualArabicConverter = ContextualArabicConverter;\n//# sourceMappingURL=ContextualArabicConverter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSdfTextMaterial = void 0;\nconst TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js\");\n/**\n * Helper function designed to create [[SdfTextMaterials]] that can be rendered using\n * [[TextCanvas]].\n *\n * @param params - Material parameters.\n *\n * @returns New `SdfTextMaterial`.\n */\nfunction createSdfTextMaterial(params) {\n    return new TextMaterials_1.SdfTextMaterial({\n        texture: params.fontCatalog.texture,\n        textureSize: params.fontCatalog.textureSize,\n        size: params.fontCatalog.size,\n        distanceRange: params.fontCatalog.distanceRange,\n        isMsdf: params.fontCatalog.type === \"msdf\",\n        isBackground: params.isBackground === true,\n        vertexSource: params.vertexSource,\n        fragmentSource: params.fragmentSource,\n        rendererCapabilities: params.rendererCapabilities\n    });\n}\nexports.createSdfTextMaterial = createSdfTextMaterial;\n//# sourceMappingURL=MaterialUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypesettingUtils = void 0;\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * Collection of different constants and utility functions used by [[Typesetter]]s.\n */\nvar TypesettingUtils;\n(function (TypesettingUtils) {\n    /**\n     * Ratio between EMs and Pixels.\n     */\n    TypesettingUtils.EM_TO_PX = 16.0;\n    /**\n     * Ratio between Points and Pixels.\n     */\n    TypesettingUtils.PT_TO_PX = 1.25;\n    /**\n     * Angle used when emulating italic fonts (oblique).\n     */\n    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;\n    /**\n     * Horizontal offset used when emulating italic fonts (oblique).\n     */\n    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);\n    /**\n     * Convert between any size specified in any [[FontUnit]] to pixels.\n     *\n     * @param size - Font size (specified in `unit`).\n     * @param unit - Size unit.\n     * @param originalSize - Original size (pixels)\n     *\n     * @returns Pixel size.\n     */\n    function getPixelSize(size, unit, originalSize) {\n        let result = size;\n        switch (unit) {\n            case TextStyle_1.FontUnit.Em:\n                result *= TypesettingUtils.EM_TO_PX;\n                break;\n            case TextStyle_1.FontUnit.Point:\n                result *= TypesettingUtils.PT_TO_PX;\n                break;\n            case TextStyle_1.FontUnit.Percent:\n                result *= (1.0 / 100) * originalSize;\n                break;\n        }\n        return result;\n    }\n    TypesettingUtils.getPixelSize = getPixelSize;\n    /**\n     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.\n     *\n     * @param glyphs - Array containing [[TransformedGlyphData]].\n     * @param index - Index to `glyphDataArray`.\n     * @param fontVariant - Currently active [[FontVariant]].\n     *\n     * @returns Glyph `SmallCaps` scale.\n     */\n    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {\n        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        return isSmallCaps\n            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight\n            : 1.0;\n    }\n    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;\n    /**\n     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].\n     *\n     * @param glyphs - Array containing [[GlyphData]].\n     * @param offset - `glyphDataArray` offset.\n     *\n     * @returns Strong direction.\n     */\n    function getDirection(glyphs, offset) {\n        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        let index = offset;\n        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&\n            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&\n            index < glyphs.length - 1) {\n            ++index;\n        }\n        if (Math.abs(glyphs[index].direction) === 1.0) {\n            result = glyphs[index].direction;\n        }\n        return result;\n    }\n    TypesettingUtils.getDirection = getDirection;\n    /**\n     * Computes the transformation matrix for a glyph.\n     *\n     * @param transform - Matrix used to store the results.\n     * @param position - Glyph' position.\n     * @param scale - Glyph' scale.\n     * @param rotation - [[TextCanvas]] rotation.\n     * @param localRotation - Glyph' local rotation.\n     */\n    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {\n        const cosAngle = Math.cos(rotation);\n        const sinAngle = Math.sin(rotation);\n        const localCosAngle = Math.cos(localRotation);\n        const localSinAngle = Math.sin(localRotation);\n        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);\n    }\n    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;\n    /**\n     * Updates the supplied bounds with the computed screen-space corners for a given glyph.\n     *\n     * @param corners - Glyph' corners.\n     * @param globalBounds - Global text bounds.\n     * @param individualBounds - Individual per-character bounds.\n     */\n    function updateBounds(corners, globalBounds, individualBounds) {\n        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        if (individualBounds !== undefined) {\n            if (individualBounds.array[individualBounds.offset] !== undefined) {\n                individualBounds.array[individualBounds.offset].min.set(minX, minY);\n                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);\n            }\n            else {\n                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));\n            }\n            ++individualBounds.offset;\n        }\n        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));\n        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));\n    }\n    TypesettingUtils.updateBounds = updateBounds;\n})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));\n//# sourceMappingURL=TypesettingUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnicodeUtils = void 0;\n/**\n * Namespace containing useful information when dealing with Unicode's code points.\n */\nvar UnicodeUtils;\n(function (UnicodeUtils) {\n    /**\n     * Range of Unicode code points considered as white space.\n     * https://en.wikipedia.org/wiki/Whitespace_character\n     */\n    UnicodeUtils.whiteSpaceRanges = [\n        [0x0009, 0x0009],\n        [0x0020, 0x0020],\n        [0x1680, 0x1680],\n        [0x2000, 0x2006],\n        [0x2008, 0x200a],\n        [0x205f, 0x3000],\n        [0x180e, 0x180e],\n        [0x200b, 0x200d]\n    ];\n    /**\n     * Checks if a character should be considered as a white space.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isWhiteSpace(codePoint) {\n        for (const range of UnicodeUtils.whiteSpaceRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    UnicodeUtils.isWhiteSpace = isWhiteSpace;\n    /**\n     * Range of Unicode code points considered as `NewLine`.\n     * https://en.wikipedia.org/wiki/Newline#Unicode\n     */\n    UnicodeUtils.newLineRanges = [\n        [0x000a, 0x000d],\n        [0x0085, 0x0085],\n        [0x2028, 0x2029]\n    ];\n    /**\n     * Checks if a character should be considered as a new line.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isNewLine(codePoint) {\n        for (const range of UnicodeUtils.newLineRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    UnicodeUtils.isNewLine = isNewLine;\n    /**\n     * Range of Unicode code points considered as non-printable.\n     * https://en.wikipedia.org/wiki/Unicode_control_characters\n     */\n    UnicodeUtils.nonPrintableRanges = [\n        [0x0000, 0x001f],\n        [0x007f, 0x009f]\n    ];\n    /**\n     * Checks if a character's can be printed (rendered).\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isPrintable(codePoint) {\n        for (const range of UnicodeUtils.nonPrintableRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    UnicodeUtils.isPrintable = isPrintable;\n    /**\n     * Unicode code point direction.\n     */\n    let Direction;\n    (function (Direction) {\n        Direction[Direction[\"Neutral\"] = 0] = \"Neutral\";\n        Direction[Direction[\"Weak\"] = 0.5] = \"Weak\";\n        Direction[Direction[\"LTR\"] = 1] = \"LTR\";\n        Direction[Direction[\"RTL\"] = -1] = \"RTL\";\n    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));\n    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).\n    /**\n     * Unicode Blocks which have inherent RTL direction.\n     * These blocks correspond to the scripts described here:\n     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts\n     */\n    UnicodeUtils.rtlBlocks = [\n        \"Hebrew\",\n        \"Alphabetic Presentation Forms\",\n        \"Arabic\",\n        \"Arabic Supplement\",\n        \"Arabic Extended-A\",\n        \"Arabic Presentation Forms-A\",\n        \"Arabic Presentation Forms-B\",\n        \"Arabic Mathematical Alphabetic Symbols\",\n        \"Indic Siyaq Numbers\",\n        \"Rumi Numeral Symbols\",\n        \"Syriac\",\n        \"Syriac Supplement\",\n        \"Samaritan\",\n        \"Mandaic\",\n        \"Thaana\",\n        \"Mende Kikakui\",\n        \"NKo\",\n        \"Adlam\",\n        \"Hanifi Rohingya\"\n    ];\n    /**\n     * ASCII punctuation is considered to have neutral direction:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    UnicodeUtils.neutralBidirectionalRanges = [\n        [0x0020, 0x002f],\n        [0x003a, 0x0040],\n        [0x005b, 0x0060],\n        [0x007b, 0x007e]\n    ];\n    /**\n     * Latin and arabic numerals are considered to have weak directionality:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block\n     */\n    UnicodeUtils.weakBidirectionalRanges = [\n        [0x0030, 0x0039],\n        [0x0660, 0x0669],\n        [0x06f0, 0x06f9]\n    ];\n    /**\n     * Returns the Unicode's character direction.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param block - Character's Unicode block.\n     *\n     * @returns Character's direction.\n     */\n    function getDirection(codePoint, block) {\n        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).\n        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {\n            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {\n                return Direction.Weak;\n            }\n        }\n        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {\n            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {\n                return Direction.Neutral;\n            }\n        }\n        // Check for RTL/LTR.\n        const rtl = UnicodeUtils.rtlBlocks.find(element => {\n            return element === block;\n        });\n        if (rtl !== undefined) {\n            return Direction.RTL;\n        }\n        else {\n            return Direction.LTR;\n        }\n    }\n    UnicodeUtils.getDirection = getDirection;\n    /**\n     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering\n     * a RTL string to preserve their intrinsic meaning.\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    UnicodeUtils.rtlMirroredCodePoints = [\n        0x0028,\n        0x0029,\n        0x003c,\n        0x003e,\n        0x005b,\n        0x005d,\n        0x007b,\n        0x007d\n    ];\n    /**\n     * Checks if a character should be mirrored on an RTL run.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isRtlMirrored(codePoint) {\n        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {\n            return element === codePoint;\n        }) !== undefined);\n    }\n    UnicodeUtils.isRtlMirrored = isRtlMirrored;\n})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));\n//# sourceMappingURL=UnicodeUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Provides a manager that orchestrates downloading URLs, particularly static map resources.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./src/TransferManager */ \"./node_modules/@here/harp-transfer-manager/src/TransferManager.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-transfer-manager/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeferredPromise = void 0;\n/**\n *\n * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.\n * This class allows wrapping other promises or long running functions for later execution.\n * @internal\n * @hidden\n */\nclass DeferredPromise {\n    /**\n     * Constructs a new [[DeferredPromise]]\n     * @param executor - Async function that should be executed at a later point in time.\n     */\n    constructor(executor) {\n        this.executor = executor;\n        this.promise = new Promise((resolve, reject) => {\n            this.resolveFunc = resolve;\n            this.rejectFunc = reject;\n        });\n    }\n    /**\n     * When `exec` is called the deferred executor function is executed.\n     */\n    exec() {\n        this.executor()\n            .then(result => this.resolveFunc(result))\n            .catch(error => this.rejectFunc(error));\n    }\n}\nexports.DeferredPromise = DeferredPromise;\n//# sourceMappingURL=DeferredPromise.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js?");

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/src/TransferManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/src/TransferManager.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransferManager = void 0;\n/** @module\n *\n * This module provides classes to ease downloading URLs. In particular, following redirects,\n * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.\n */\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst DeferredPromise_1 = __webpack_require__(/*! ./DeferredPromise */ \"./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js\");\n/**\n * `TransferManager` for downloading URLs.\n *\n * Features:\n *\n * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded\n *   once.\n * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that\n *   would otherwise stall the browser.\n * * Retries the downloads with an increasing timeout on HTTP 503 replies.\n *\n * The static method [[instance]] can be used to get a default constructed instance.\n */\nclass TransferManager {\n    /**\n     * Constructs a new [[TransferManager]].\n     *\n     * @param fetchFunction - The default fetch function to use.\n     * @param maxRetries - The maximum amount to try to re-fetch a resource.\n     */\n    constructor(fetchFunction = fetch, maxRetries = 5) {\n        this.fetchFunction = fetchFunction;\n        this.maxRetries = maxRetries;\n        this.activeDownloadCount = 0;\n        this.downloadQueue = new Array();\n        this.activeDownloads = new Map();\n    }\n    /**\n     * Returns a default instance of [[TransferManager]].\n     */\n    static instance() {\n        return TransferManager.defaultInstance;\n    }\n    static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {\n        try {\n            if (retryCount < maxRetries) {\n                const response = await fetchFunction(url, init);\n                if (response.status !== 503) {\n                    return response;\n                }\n            }\n            else {\n                throw new Error(\"Max number of retries reached\");\n            }\n        }\n        catch (err) {\n            if (err.hasOwnProperty(\"isCancelled\") ||\n                err.name === \"AbortError\" ||\n                retryCount >= maxRetries) {\n                throw err;\n            }\n        }\n        return await TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, retryCount + 1, maxRetries, url, init));\n    }\n    static waitFor(milliseconds) {\n        return new Promise(resolve => setTimeout(resolve, milliseconds));\n    }\n    /**\n     * Downloads a JSON object. Merges downloads of string URLs if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same string URL to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url - The URL or RequestInfo to download\n     * @param init - Optional extra parameters for the download.\n     */\n    downloadJson(url, init) {\n        return this.downloadAs(response => response.json(), url, init);\n    }\n    /**\n     * Downloads a binary object. Merges downloads of string URLS if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same string URL to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url - The URL or RequestInfo to download\n     * @param init - Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url, init) {\n        return this.download(url, init).then(response => response.arrayBuffer());\n    }\n    /**\n     * Downloads a URL and returns the response.\n     *\n     * Does not merge multiple requests to the same URL.\n     *\n     * @param url - The URL or RequestInfo to download.\n     * @param init - Optional extra parameters for the download.\n     */\n    download(url, init) {\n        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {\n            const deferred = new DeferredPromise_1.DeferredPromise(() => this.doDownload(url, init));\n            this.downloadQueue.push(deferred);\n            return deferred.promise;\n        }\n        return this.doDownload(url, init);\n    }\n    async doDownload(url, init) {\n        try {\n            ++this.activeDownloadCount;\n            const response = await TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init);\n            this.onDownloadDone();\n            return response;\n        }\n        catch (error) {\n            this.onDownloadDone();\n            throw error;\n        }\n    }\n    onDownloadDone() {\n        --this.activeDownloadCount;\n        this.execDeferredDownload();\n    }\n    execDeferredDownload() {\n        const future = this.downloadQueue.pop();\n        if (future === undefined) {\n            return;\n        }\n        future.exec();\n    }\n    downloadAs(converter, url, init) {\n        const cacheKey = url;\n        const pendingFetch = this.activeDownloads.get(cacheKey);\n        if (pendingFetch !== undefined) {\n            return Promise.resolve(pendingFetch);\n        }\n        const newFetch = this.download(url, init)\n            .then(response => {\n            this.activeDownloads.delete(cacheKey);\n            if (response.ok) {\n                return converter(response);\n            }\n            throw new Error(JSON.stringify(response));\n        })\n            .catch(err => {\n            this.activeDownloads.delete(cacheKey);\n            throw err;\n        });\n        this.activeDownloads.set(cacheKey, newFetch);\n        return newFetch;\n    }\n}\nexports.TransferManager = TransferManager;\n/**\n * The timeout in milliseconds to wait between retries. This timeout is multiplied with the\n * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and\n * so on.\n */\nTransferManager.retryTimeout = 500;\n/**\n * The amount of maximum parallel downloads to allow.\n */\nTransferManager.maxParallelDownloads = 16;\nTransferManager.defaultInstance = new TransferManager();\n//# sourceMappingURL=TransferManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-transfer-manager/src/TransferManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/index-common.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/index-common.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lib/GroupedPriorityList */ \"./node_modules/@here/harp-utils/lib/GroupedPriorityList.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Logger */ \"./node_modules/@here/harp-utils/lib/Logger/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Math2D */ \"./node_modules/@here/harp-utils/lib/Math2D.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/MathUtils */ \"./node_modules/@here/harp-utils/lib/MathUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Mixins */ \"./node_modules/@here/harp-utils/lib/Mixins.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/assert */ \"./node_modules/@here/harp-utils/lib/assert.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/CachedResource */ \"./node_modules/@here/harp-utils/lib/CachedResource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ContextLogger */ \"./node_modules/@here/harp-utils/lib/ContextLogger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/PerformanceTimer */ \"./node_modules/@here/harp-utils/lib/PerformanceTimer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/ObjectUtils */ \"./node_modules/@here/harp-utils/lib/ObjectUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/OptionsUtils */ \"./node_modules/@here/harp-utils/lib/OptionsUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/TaskQueue */ \"./node_modules/@here/harp-utils/lib/TaskQueue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/UriResolver */ \"./node_modules/@here/harp-utils/lib/UriResolver.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/Functions */ \"./node_modules/@here/harp-utils/lib/Functions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/SampleBilinear */ \"./node_modules/@here/harp-utils/lib/SampleBilinear.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/AuthenticationUtils */ \"./node_modules/@here/harp-utils/lib/AuthenticationUtils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GlslUtils */ \"./node_modules/@here/harp-utils/lib/GlslUtils.js\"), exports);\n//# sourceMappingURL=index-common.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/index-common.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-utils/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./index-common */ \"./node_modules/@here/harp-utils/index-common.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/UrlPlatformUtils.web */ \"./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js\"), exports);\n//# sourceMappingURL=index.web.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/index.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/AuthenticationUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/AuthenticationUtils.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=AuthenticationUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/AuthenticationUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/CachedResource.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/CachedResource.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=CachedResource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/CachedResource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ContextLogger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ContextLogger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextLogger = void 0;\n/**\n * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`\n * before first actual log message.\n */\nclass ContextLogger {\n    /**\n     * Construct a context-aware logger that logs to `m_logger`.\n     */\n    constructor(m_logger, headerMessage) {\n        this.m_logger = m_logger;\n        this.headerMessage = headerMessage;\n        this.context = [];\n        this.m_headerLogged = false;\n        // They, are public member functions it's just tslint who doesn't understand this.\n        this.warn = this.createLogMethod(\"warn\");\n        this.info = this.createLogMethod(\"info\");\n        this.error = this.createLogMethod(\"error\");\n    }\n    /**\n     * Push \"attribute-like\" context.\n     *\n     * Following log messages will be prefixed with `name` or `.name` depending on current context.\n     */\n    pushAttr(name) {\n        this.context.push(`${this.context.length > 0 ? \".\" : \"\"}${name}`);\n    }\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index) {\n        this.context.push(`[${index}]`);\n    }\n    pop() {\n        this.context.pop();\n    }\n    createLogMethod(severity) {\n        return (message, ...rest) => {\n            if (!this.m_headerLogged) {\n                this.m_logger.info(this.headerMessage);\n                this.m_headerLogged = true;\n            }\n            this.m_logger[severity](`${this.context.join(\"\")}: ${message}`, ...rest);\n        };\n    }\n}\nexports.ContextLogger = ContextLogger;\n//# sourceMappingURL=ContextLogger.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/ContextLogger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Functions.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Functions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chainCallbacks = void 0;\n/**\n * Chains two functions for further assigning as one wrapped callback function\n */\nfunction chainCallbacks(f1, f2) {\n    return function (...args) {\n        if (f1) {\n            f1.apply(this, args);\n        }\n        return f2.apply(this, args);\n    };\n}\nexports.chainCallbacks = chainCallbacks;\n//# sourceMappingURL=Functions.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Functions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GlslUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GlslUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertFragmentShaderToWebGL2 = exports.convertVertexShaderToWebGL2 = void 0;\n/**\n * Converts webgl1-compatible vertex shader glsl code to webgl2.\n *\n * @param vertexShader - String containing the vertex shader glsl code.\n * @returns the converted glsl code.\n */\nfunction convertVertexShaderToWebGL2(vertexShader) {\n    return ([\"#define attribute in\", \"#define varying out\", \"#define texture2D texture\"].join(\"\\n\") +\n        \"\\n\" +\n        vertexShader);\n}\nexports.convertVertexShaderToWebGL2 = convertVertexShaderToWebGL2;\n/**\n * Converts webgl1-compatible fragment shader glsl code to webgl2.\n *\n * @param fragmentShader - String containing the fragment shader glsl code.\n * @returns the converted glsl code.\n */\nfunction convertFragmentShaderToWebGL2(fragmentShader) {\n    return ([\n        \"#define varying in\",\n        \"out highp vec4 pc_fragColor;\",\n        \"#define gl_FragColor pc_fragColor\",\n        \"#define gl_FragDepthEXT gl_FragDepth\",\n        \"#define texture2D texture\",\n        \"#define textureCube texture\",\n        \"#define texture2DProj textureProj\",\n        \"#define texture2DLodEXT textureLod\",\n        \"#define texture2DProjLodEXT textureProjLod\",\n        \"#define textureCubeLodEXT textureLod\",\n        \"#define texture2DGradEXT textureGrad\",\n        \"#define texture2DProjGradEXT textureProjGrad\",\n        \"#define textureCubeGradEXT textureGrad\"\n    ].join(\"\\n\") +\n        \"\\n\" +\n        fragmentShader);\n}\nexports.convertFragmentShaderToWebGL2 = convertFragmentShaderToWebGL2;\n//# sourceMappingURL=GlslUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/GlslUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GroupedPriorityList.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GroupedPriorityList = exports.PriorityListGroup = void 0;\n/**\n * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same\n * (integer) priority.\n */\nclass PriorityListGroup {\n    constructor(priority, elements = new Array()) {\n        this.priority = priority;\n        this.elements = elements;\n    }\n    /**\n     * Create and return a deep copy of the `PriorityListGroup<T>`.\n     *\n     * @returns A clone of the `PriorityListGroup<T>`.\n     */\n    clone() {\n        return new PriorityListGroup(this.priority, this.elements.slice());\n    }\n    /**\n     * Removes an element from the group.\n     * @param element - The element to remove.\n     * @returns true if the element was removed, false if it was not found in the group.\n     */\n    remove(element) {\n        const foundIndex = this.elements.indexOf(element);\n        if (foundIndex === -1) {\n            return false;\n        }\n        this.elements.splice(foundIndex, 1);\n        return true;\n    }\n}\nexports.PriorityListGroup = PriorityListGroup;\n/**\n * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items\n * in priority groups.\n */\nclass GroupedPriorityList {\n    constructor() {\n        this.groups = new Map();\n    }\n    /**\n     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.\n     *\n     * @param element - Element to be added.\n     */\n    add(element) {\n        this.getGroup(element.priority).elements.push(element);\n    }\n    /**\n     * Remove an element from the `GroupedPriorityList`.\n     *\n     * Note: It is required that the priority is the same as it was when the element has been added.\n     * Otherwise, the removal will fail.\n     *\n     * @param element - Element to be removed.\n     * @returns `True` if the element was removed, `false` otherwise.\n     */\n    remove(element) {\n        const group = this.findGroup(element.priority);\n        if (group !== undefined && group.remove(element)) {\n            if (group.elements.length === 0) {\n                this.groups.delete(group.priority);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Remove all internal {@link PriorityListGroup}s.\n     */\n    clear() {\n        this.groups.clear();\n    }\n    /**\n     * Merge another {@link GroupedPriorityList} into this one.\n     *\n     * @param other - Other group to merge.\n     */\n    merge(other) {\n        for (const otherGroup of other.groups) {\n            const group = this.findGroup(otherGroup[1].priority);\n            if (group === undefined) {\n                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());\n                continue;\n            }\n            group.elements = group.elements.concat(otherGroup[1].elements);\n        }\n        return this;\n    }\n    clone() {\n        const clone = new GroupedPriorityList();\n        for (const [priority, group] of this.groups) {\n            clone.groups.set(priority, group.clone());\n        }\n        return clone;\n    }\n    /**\n     * Apply function to all elements in this `GroupedPriorityList`.\n     *\n     * @param {(element: T) => void} fun Function to apply.\n     */\n    forEach(fun) {\n        for (const group of this.groups) {\n            group[1].elements.forEach(fun);\n        }\n    }\n    /**\n     * Count the number of elements in this `GroupedPriorityList`.\n     */\n    count() {\n        let n = 0;\n        for (const group of this.groups) {\n            n += group[1].elements.length;\n        }\n        return n;\n    }\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    findGroup(priority) {\n        const normalizedPriority = Math.floor(priority);\n        const group = this.groups.get(normalizedPriority);\n        return group;\n    }\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    getGroup(priority) {\n        let group = this.findGroup(priority);\n        if (group === undefined) {\n            const normalizedPriority = Math.floor(priority);\n            group = new PriorityListGroup(normalizedPriority);\n            this.groups.set(group.priority, group);\n        }\n        return group;\n    }\n}\nexports.GroupedPriorityList = GroupedPriorityList;\n//# sourceMappingURL=GroupedPriorityList.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/GroupedPriorityList.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConsoleChannel = void 0;\n/**\n * Class for the default console channel.\n */\nclass ConsoleChannel {\n    error(message, ...optionalParams) {\n        console.error(message, ...optionalParams);\n    }\n    debug(message, ...optionalParams) {\n        console.debug(message, ...optionalParams);\n    }\n    info(message, ...optionalParams) {\n        console.info(message, ...optionalParams);\n    }\n    log(message, ...optionalParams) {\n        console.log(message, ...optionalParams);\n    }\n    trace(message, ...optionalParams) {\n        console.trace(message, ...optionalParams);\n    }\n    warn(message, ...optionalParams) {\n        console.warn(message, ...optionalParams);\n    }\n}\nexports.ConsoleChannel = ConsoleChannel;\n//# sourceMappingURL=ConsoleChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/IChannel.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/IChannel.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/IChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ILogger.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggerOptions = exports.LogLevel = void 0;\n/**\n * Enum log levels\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Log\"] = 2] = \"Log\";\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 4] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n/**\n * Logger options to configure logger\n */\nclass LoggerOptions {\n}\nexports.LoggerOptions = LoggerOptions;\n//# sourceMappingURL=ILogger.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/ILogger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/Logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/Logger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Logger = void 0;\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\");\n/**\n * Logger class.\n */\nclass Logger {\n    constructor(name, m_channel, options) {\n        this.name = name;\n        this.m_channel = m_channel;\n        this.enabled = true;\n        this.level = ILogger_1.LogLevel.Trace;\n        if (options !== undefined) {\n            this.update(options);\n        }\n    }\n    error(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {\n            this.m_channel.error(this.prefix, message, ...optionalParams);\n        }\n    }\n    debug(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {\n            this.m_channel.debug(this.prefix, message, ...optionalParams);\n        }\n    }\n    info(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {\n            this.m_channel.info(this.prefix, message, ...optionalParams);\n        }\n    }\n    log(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {\n            this.m_channel.log(this.prefix, message, ...optionalParams);\n        }\n    }\n    trace(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {\n            this.m_channel.trace(this.prefix, message, ...optionalParams);\n        }\n    }\n    warn(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {\n            this.m_channel.warn(this.prefix, message, ...optionalParams);\n        }\n    }\n    update(options) {\n        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;\n        this.level = options.level === undefined ? this.level : options.level;\n    }\n    get prefix() {\n        return this.name + \":\";\n    }\n}\nexports.Logger = Logger;\n//# sourceMappingURL=Logger.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/Logger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggerManager = void 0;\nconst LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ \"./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js\");\n/**\n * The LoggerManager class implements a singleton object that handles logging.\n *\n * Example:\n *\n * ```typescript\n *\n * const logger = LoggerManager.instance.create(\"MyFontLoaderClass\");\n * if (missingFonts.length > 0) {\n *     logger.error(\"These fonts can not be loaded: \", missingFonts);\n * } else {\n *     logger.log(\"All fonts have been loaded.\");\n * }\n * ```\n */\nclass LoggerManager {\n    static get instance() {\n        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());\n    }\n}\nexports.LoggerManager = LoggerManager;\n//# sourceMappingURL=LoggerManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggerManagerImpl = void 0;\nconst ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ \"./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/@here/harp-utils/lib/Logger/Logger.js\");\nconst WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ \"./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js\");\n/**\n * LoggerManagerImpl is the class for the singleton instance of the logger manager.\n * It handles channels and loggers.\n */\nclass LoggerManagerImpl {\n    constructor() {\n        this.m_loggers = [];\n        this.channel =\n            typeof self === \"undefined\" || typeof self.document !== \"undefined\"\n                ? new ConsoleChannel_1.ConsoleChannel()\n                : new WorkerChannel_1.WorkerChannel();\n    }\n    getLoggerNames() {\n        return this.m_loggers.map(logger => logger.name);\n    }\n    getLogger(name) {\n        return this.m_loggers.find(logger => logger.name === name);\n    }\n    create(loggerName, options = {}) {\n        if (this.m_levelSetForAll !== undefined &&\n            (options.level === undefined || options.level < this.m_levelSetForAll)) {\n            options.level = this.m_levelSetForAll;\n        }\n        const logger = new Logger_1.Logger(loggerName, this.channel, options);\n        this.m_loggers.push(logger);\n        return logger;\n    }\n    dispose(logger) {\n        const found = this.m_loggers.indexOf(logger);\n        if (found < 0) {\n            throw new Error(`Cannot unregister \"${logger}\" : no such logger registered.`);\n        }\n        this.m_loggers.splice(found, 1);\n    }\n    updateAll(options) {\n        for (const logger of this.m_loggers) {\n            logger.update(options);\n        }\n    }\n    update(loggerName, config) {\n        for (const logger of this.m_loggers) {\n            if (logger.name === loggerName) {\n                logger.update(config);\n            }\n        }\n    }\n    enableAll(enabled) {\n        for (const logger of this.m_loggers) {\n            logger.enabled = enabled;\n        }\n    }\n    enable(loggerName, value) {\n        this.update(loggerName, { enabled: value });\n    }\n    setLogLevelForAll(level) {\n        this.m_levelSetForAll = level;\n        for (const logger of this.m_loggers) {\n            logger.level = level;\n        }\n    }\n    setLogLevel(loggerName, level) {\n        this.update(loggerName, { level });\n    }\n    setChannel(channel) {\n        this.channel = channel;\n    }\n}\nexports.LoggerManagerImpl = LoggerManagerImpl;\n//# sourceMappingURL=LoggerManagerImpl.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiChannel = void 0;\n/**\n * Class allowing mixing several channels.\n */\nclass MultiChannel {\n    constructor(...channels) {\n        this.channels = [];\n        this.channels = channels;\n    }\n    error(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.error(message, ...optionalParams);\n        }\n    }\n    debug(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.debug(message, ...optionalParams);\n        }\n    }\n    info(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.info(message, ...optionalParams);\n        }\n    }\n    log(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.log(message, ...optionalParams);\n        }\n    }\n    trace(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.trace(message, ...optionalParams);\n        }\n    }\n    warn(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.warn(message, ...optionalParams);\n        }\n    }\n}\nexports.MultiChannel = MultiChannel;\n//# sourceMappingURL=MultiChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerChannel = exports.WORKERCHANNEL_MSG_TYPE = void 0;\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\");\nexports.WORKERCHANNEL_MSG_TYPE = \"worker-channel-message\";\n/**\n * The class for the worker channel.\n */\nclass WorkerChannel {\n    error(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Error\n        };\n        self.postMessage(workerMessage);\n    }\n    debug(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Debug\n        };\n        self.postMessage(workerMessage);\n    }\n    info(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Info\n        };\n        self.postMessage(workerMessage);\n    }\n    log(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Log\n        };\n        self.postMessage(workerMessage);\n    }\n    trace(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Trace\n        };\n        self.postMessage(workerMessage);\n    }\n    warn(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Warn\n        };\n        self.postMessage(workerMessage);\n    }\n}\nexports.WorkerChannel = WorkerChannel;\n//# sourceMappingURL=WorkerChannel.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ConsoleChannel */ \"./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IChannel */ \"./node_modules/@here/harp-utils/lib/Logger/IChannel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Logger */ \"./node_modules/@here/harp-utils/lib/Logger/Logger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./LoggerManager */ \"./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MultiChannel */ \"./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WorkerChannel */ \"./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Math2D.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Math2D.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Math2D = void 0;\nvar Math2D;\n(function (Math2D) {\n    /**\n     * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n     * objects with two numbers each). Should be faster.\n     */\n    class Box {\n        /**\n         * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n         * objects with two numbers each). Should be faster.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        constructor(x = 0, y = 0, w = 0, h = 0) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n        /**\n         * Set new values to all properties of the box.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        set(x, y, w, h) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n        /**\n         * Copy values from another box.\n         *\n         * @param box - Another box.\n         */\n        copy(box) {\n            this.x = box.x;\n            this.y = box.y;\n            this.w = box.w;\n            this.h = box.h;\n        }\n        /**\n         * Test box for inclusion of point.\n         *\n         * @param x - X coordinate of point.\n         * @param y - Y coordinate of point.\n         */\n        contains(x, y) {\n            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;\n        }\n        /**\n         * Test box for inclusion of another box.\n         *\n         * @param other - Box 2 to test for inclusion.\n         */\n        containsBox(other) {\n            const xmax = other.x + other.w;\n            const ymax = other.y + other.h;\n            return (this.contains(other.x, other.y) &&\n                this.contains(xmax, other.y) &&\n                this.contains(other.x, ymax) &&\n                this.contains(xmax, ymax));\n        }\n        /**\n         * Test two boxes for intersection.\n         *\n         * @param other - Box 2 to test for intersection.\n         */\n        intersects(other) {\n            return (this.x <= other.x + other.w &&\n                this.x + this.w >= other.x &&\n                this.y <= other.y + other.h &&\n                this.y + this.h >= other.y);\n        }\n    }\n    Math2D.Box = Box;\n    /**\n     * Compute squared distance between two 2D points `a` and `b`.\n     *\n     * @param ax - Point a.x\n     * @param ay - Point a.y\n     * @param bx - Point b.x\n     * @param by - Point b.y\n     * @returns Squared distance between the two points\n     */\n    function distSquared(ax, ay, bx, by) {\n        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);\n    }\n    Math2D.distSquared = distSquared;\n    /**\n     * Computes the squared length of a line.\n     *\n     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.\n     */\n    function computeSquaredLineLength(line) {\n        let squaredLineLength = 0;\n        const length = line.length - 4;\n        for (let i = 0; i < length; i += 3) {\n            const xDiff = line[i + 3] - line[i];\n            const yDiff = line[i + 4] - line[i + 1];\n            squaredLineLength += xDiff * xDiff + yDiff * yDiff;\n        }\n        return squaredLineLength;\n    }\n    Math2D.computeSquaredLineLength = computeSquaredLineLength;\n    /**\n     * Compute squared distance between a 2D point and a 2D line segment.\n     *\n     * @param px - Test point X\n     * @param py - Test point y\n     * @param l0x - Line segment start X\n     * @param l0y - Line segment start Y\n     * @param l1x - Line segment end X\n     * @param l1y - Line segment end Y\n     * @returns Squared distance between point and line segment\n     */\n    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {\n        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);\n        if (lineLengthSuared === 0) {\n            return distSquared(px, py, l0x, l0y);\n        }\n        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;\n        t = Math.max(0, Math.min(1, t));\n        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));\n    }\n    Math2D.distToSegmentSquared = distToSegmentSquared;\n    /**\n     * Finds the intersections of a line and a circle.\n     *\n     * @param xLine1 - abscissa of first line point.\n     * @param yLine1 - ordinate of second line point.\n     * @param xLine2 - abscissa of second line point.\n     * @param yLine2 - ordinate of second line point.\n     * @param radius - circle radius.\n     * @param xCenter - abscissa of circle center.\n     * @param yCenter - ordinate of circle center.\n     * @returns coordinates of the intersections (1 if the line is tangent to the circle, 2\n     * if it's secant) or undefined if there's no intersection.\n     */\n    function intersectLineAndCircle(xLine1, yLine1, xLine2, yLine2, radius, xCenter = 0, yCenter = 0) {\n        // Line equation: dy*x - dx*y = c, c = dy*x1 - dx*y1 = x1*y2 - x2*y1\n        // Circle equation: (x-xCenter)^2 + (y-yCenter)^2 = r^2\n        // 1. Translate circle center to origin of coordinates:\n        // u = x - xCenter\n        // v = y - yCenter\n        // circle: u^2 + v^2 = r^2\n        // line: dy*u - dx*v = cp, cp = c - dy*xCenter - dx*yCenter\n        // 2. Intersections are solutions of a quadratic equation:\n        // ui = (cp*dy +/- sign(dy)*dx*discriminant / dSq\n        // vi = (-cp*dx +/- |dy|*discriminant / dSq\n        // discriminant = r^2*dSq - cp^2, dSq = dx^2 + dy^2\n        // The sign of the discriminant indicates the number of intersections.\n        // 3. Translate intersection coordinates back to original space:\n        // xi = xCenter + ui\n        // yi = yCenter + yi\n        const epsilon = 1e-10;\n        const dx = xLine2 - xLine1;\n        const dy = yLine2 - yLine1;\n        const dSq = dx * dx + dy * dy;\n        const rSq = radius * radius;\n        const c = xLine1 * yLine2 - xLine2 * yLine1;\n        const cp = c - dy * xCenter + dx * yCenter;\n        const discriminantSquared = rSq * dSq - cp * cp;\n        if (discriminantSquared < -epsilon) {\n            // no intersection\n            return undefined;\n        }\n        const xMid = cp * dy;\n        const yMid = -cp * dx;\n        if (discriminantSquared < epsilon) {\n            // 1 intersection (tangent line)\n            return { x1: xCenter + xMid / dSq, y1: yCenter + yMid / dSq };\n        }\n        const discriminant = Math.sqrt(discriminantSquared);\n        // 2 intersections (secant line)\n        const signDy = dy < 0 ? -1 : 1;\n        const absDy = Math.abs(dy);\n        const xDist = signDy * dx * discriminant;\n        const yDist = absDy * discriminant;\n        return {\n            x1: xCenter + (xMid + xDist) / dSq,\n            y1: yCenter + (yMid + yDist) / dSq,\n            x2: xCenter + (xMid - xDist) / dSq,\n            y2: yCenter + (yMid - yDist) / dSq\n        };\n    }\n    Math2D.intersectLineAndCircle = intersectLineAndCircle;\n    /**\n     * Computes the intersection point between two lines.\n     *\n     * @remarks\n     * This functions computes the\n     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     *    | line-line intersection} of two lines given two points on each line.\n     *\n     * @param x1 - x coordinate of the first point of the first line.\n     * @param y1 - y coordinate of the first point of the first line.\n     * @param x2 - x coordinate of the second point of the first line.\n     * @param y2 - y coordinate of the second point of the first line.\n     * @param x3 - x coordinate of the first point of the second line.\n     * @param y3 - y coordinate of the first point of the second line.\n     * @param x4 - x coordinate of the second point of the second line.\n     * @param y4 - y coordinate of the second point of the second line.\n     * @param result - The resulting point.\n     */\n    function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4, result = { x: 0, y: 0 }) {\n        const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (d === 0) {\n            return undefined;\n        }\n        const px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n        const py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n        result.x = px;\n        result.y = py;\n        return result;\n    }\n    Math2D.intersectLines = intersectLines;\n})(Math2D = exports.Math2D || (exports.Math2D = {}));\n//# sourceMappingURL=Math2D.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Math2D.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/MathUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/MathUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathUtils = void 0;\nvar MathUtils;\n(function (MathUtils) {\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     *\n     * @returns Clamped value.\n     */\n    function clamp(value, min, max) {\n        return value < min ? min : value > max ? max : value;\n    }\n    MathUtils.clamp = clamp;\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    function smoothStep(edge0, edge1, x) {\n        // Scale, bias and saturate x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n    }\n    MathUtils.smoothStep = smoothStep;\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     *\n     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and\n     * `x = 1`:\n     *\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    function smootherStep(edge0, edge1, x) {\n        // Scale, and clamp x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n    MathUtils.smootherStep = smootherStep;\n    /**\n     * Maps a number from one range to another.\n     *\n     * @param val - The incoming value to be converted.\n     * @param inMin - Lower bound of the value's current range.\n     * @param inMax - Upper bound of the value's current range.\n     * @param outMin - Lower bound of the value's target range.\n     * @param outMax - Upper bound of the value's target range.\n     */\n    function map(val, inMin, inMax, outMin, outMax) {\n        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n    }\n    MathUtils.map = map;\n    /**\n     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    function min2(a, b) {\n        let result;\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.min(result, b);\n        }\n        return result;\n    }\n    MathUtils.min2 = min2;\n    /**\n     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    function max2(a, b) {\n        let result;\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.max(result, b);\n        }\n        return result;\n    }\n    MathUtils.max2 = max2;\n    /**\n     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be\n     * undefined, in which case their value is ignored.\n     *\n     * @param value - Value to check.\n     * @param lowerBound - The lower bound to check the value against.\n     * @param upperBound - The upper bound to check the value against.\n     *\n     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`\n     *          otherwise.\n     */\n    function isClamped(value, lowerBound, upperBound) {\n        if (lowerBound !== undefined && value < lowerBound) {\n            return false;\n        }\n        if (upperBound !== undefined && value > upperBound) {\n            return false;\n        }\n        return true;\n    }\n    MathUtils.isClamped = isClamped;\n    /**\n     * Smoothly interpolates between two values using cubic formula\n     *\n     * @param startValue -\n     * @param endValue -\n     * @param time -\n     * @returns Result of the interpolation within the range of `[startValue, endValue]`\n     */\n    function easeInOutCubic(startValue, endValue, time) {\n        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n        return startValue + (endValue - startValue) * timeValue;\n    }\n    MathUtils.easeInOutCubic = easeInOutCubic;\n})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));\n//# sourceMappingURL=MathUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/MathUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Mixins.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Mixins.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyMixinsWithoutProperties = exports.applyMixins = void 0;\n/**\n * Copy methods and properties from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods and properties into.\n * @param baseCtors - Class to take all methods and properties from.\n */\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\nexports.applyMixins = applyMixins;\n/**\n * Copy methods from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods into.\n * @param baseCtors - Class to take all methods from.\n */\nfunction applyMixinsWithoutProperties(derivedCtor, baseCtors) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);\n            if (descriptor !== undefined &&\n                descriptor.get === undefined &&\n                name !== \"constructor\") {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\nexports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;\n//# sourceMappingURL=Mixins.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Mixins.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ObjectUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ObjectUtils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pick = exports.cloneDeep = void 0;\n/**\n * Deep clone of object.\n *\n * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,\n * object), `Date` and `RegExp`s and cycles.\n *\n * Throws error if enounters object with `prototype` assuming that in general class instances\n * cannot be reliably cloned by generic algorithm.\n */\nfunction cloneDeep(obj) {\n    const cache = new Map();\n    function cloneInternal(src) {\n        if (src === null) {\n            return null;\n        }\n        else if (typeof src === \"object\") {\n            const cached = cache.get(src);\n            if (cached !== undefined) {\n                return cached;\n            }\n            if (Array.isArray(src)) {\n                const result = [];\n                cache.set(src, result);\n                result.length = src.length;\n                for (let i = 0; i < result.length; ++i) {\n                    result[i] = cloneInternal(src[i]);\n                }\n                return result;\n            }\n            else if (src instanceof Date) {\n                const result = new Date(src.getTime());\n                cache.set(src, result);\n                return result;\n            }\n            else if (src instanceof RegExp) {\n                const result = new RegExp(src.source, src.flags);\n                cache.set(src, result);\n                return result;\n            }\n            else if (src.constructor !== Object) {\n                throw new Error(\"cloneDeep doesn't support objects with custom prototypes\");\n            }\n            else {\n                const result = {};\n                cache.set(src, result);\n                for (const key in src) {\n                    if (src.hasOwnProperty(key)) {\n                        result[key] = cloneInternal(src[key]);\n                    }\n                }\n                return result;\n            }\n        }\n        else {\n            // string, number, boolean, undefined and functions are returned as is\n            return src;\n        }\n    }\n    const r = cloneInternal(obj);\n    cache.clear();\n    return r;\n}\nexports.cloneDeep = cloneDeep;\n/**\n * Pick `props` from `object.\n *\n * Runtime version of `Pick<T,K>`.\n */\nfunction pick(object, props) {\n    const result = {};\n    for (const propName of props) {\n        if (object.hasOwnProperty(propName)) {\n            result[propName] = object[propName];\n        }\n    }\n    return result;\n}\nexports.pick = pick;\n//# sourceMappingURL=ObjectUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/ObjectUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/OptionsUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/OptionsUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOptionValue = void 0;\nfunction getOptionValue(...values) {\n    for (const candidate of values) {\n        if (candidate !== undefined && candidate !== null) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\nexports.getOptionValue = getOptionValue;\n//# sourceMappingURL=OptionsUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/OptionsUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/PerformanceTimer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceTimer = void 0;\n/**\n * See:\n * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now\n */\nclass PerformanceTimer {\n    /**\n     * Returns timestamp in milliseconds since page load.\n     *\n     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,\n     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two\n     * samples.\n     *\n     * Example:\n     * ```typescript\n     * const now = PerformanceTimer.now();\n     * // call some expensive function for which you want to check the duration.\n     * const end = PerformanceTimer.now();\n     * const elapsedTime = end - now;\n     * ```\n     */\n    static now() {\n        return PerformanceTimer.nowFunc();\n    }\n    static getNowFunc() {\n        if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            return () => performance.now();\n        }\n        // fall back to Date.getTime()\n        return () => {\n            return new Date().getTime();\n        };\n    }\n}\nexports.PerformanceTimer = PerformanceTimer;\nPerformanceTimer.instance = new PerformanceTimer();\nPerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();\n//# sourceMappingURL=PerformanceTimer.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/PerformanceTimer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/SampleBilinear.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/SampleBilinear.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sampleBilinear = void 0;\n/**\n * Returns a bilinear-interpolated texture sample for a given texture.\n * @param texture - Two-dimensional texture to sample.\n * @param width - Texture width.\n * @param height - Texture height.\n * @param u - Number between 0 and 1 representing the location to sample in the width dimension.\n * @param v - Number between 0 and 1 representing the location to sample in the height dimension.\n */\nfunction sampleBilinear(texture, width, height, u, v) {\n    const maxXIndex = width - 1;\n    const maxYIndex = height - 1;\n    // Compute the x and y coordinates relative to the mesh size.\n    const xIndex = u * maxXIndex;\n    const xIndexFloor = Math.floor(xIndex);\n    const yIndex = v * maxYIndex;\n    const yIndexFloor = Math.floor(yIndex);\n    const swIndex = yIndexFloor * width + xIndexFloor;\n    const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;\n    const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;\n    const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;\n    const swElevation = texture[swIndex];\n    const seElevation = texture[seIndex];\n    const nwElevation = texture[nwIndex];\n    const neElevation = texture[neIndex];\n    // Get the fractional components to do bilinear interpolation.\n    const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;\n    const xFracInverse = 1 - xFrac;\n    const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;\n    const yFracInverse = 1 - yFrac;\n    // The interpolation is the sum of the four closest neighbours each\n    // multiplied by the diagonal areas.\n    const result = swElevation * xFracInverse * yFracInverse +\n        seElevation * xFrac * yFracInverse +\n        nwElevation * xFracInverse * yFrac +\n        neElevation * xFrac * yFrac;\n    return result;\n}\nexports.sampleBilinear = sampleBilinear;\n//# sourceMappingURL=SampleBilinear.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/SampleBilinear.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/TaskQueue.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/TaskQueue.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TaskQueue = void 0;\n/**\n * A Pull-TaskQueue sorted by priority and group-able {@link Task}s by {@link Task.group}.\n *\n * @remarks\n *\n * @example\n * Sample Usage\n * ```\n *  const taskQueue = new TaskQueue({\n *      group: [\"group1\"]\n *  })\n *  taskQueue.add({\n *     group: \"group1\",\n *     execute: () => {\n *         console.log(\"task of group1 executed\");\n *     },\n *     getPrio: () => {\n *         return 0;\n *     }\n *   });\n *\n * taskQueue.update();\n * taskQueue.processNext(\"group1\");\n *\n *  ```\n */\nclass TaskQueue {\n    constructor(m_options) {\n        var _a;\n        this.m_options = m_options;\n        this.m_taskLists = new Map();\n        (_a = this.m_options.groups) === null || _a === void 0 ? void 0 : _a.forEach(group => {\n            this.m_taskLists.set(group, []);\n        });\n        if (this.m_options.prioSortFn) {\n            this.sort = this.m_options.prioSortFn;\n        }\n    }\n    /**\n     * Updates the lists in the queue depending on their priority functions and removes\n     * expired Tasks, based on their isExpired functions result.\n     *\n     * @param group The Group to update, if not set all groups will be updated.\n     */\n    update(group) {\n        if (group === undefined) {\n            this.m_taskLists.forEach(taskList => {\n                this.updateTaskList(taskList);\n            });\n        }\n        else {\n            const taskList = this.getTaskList(group);\n            if (taskList) {\n                this.updateTaskList(taskList);\n            }\n        }\n    }\n    /**\n     * Adds a Task to the Queue\n     *\n     * @param task\n     * @returns true if succesfully added, otherwise false\n     */\n    add(task) {\n        var _a;\n        if (this.m_taskLists.has(task.group)) {\n            const taskList = this.m_taskLists.get(task.group);\n            if (!(taskList === null || taskList === void 0 ? void 0 : taskList.includes(task))) {\n                (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.push(task);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes a Task from the Queue\n     *\n     * @param task\n     * @returns true if succesfully removed, otherwise false\n     */\n    remove(task) {\n        var _a, _b;\n        if (this.m_taskLists.has(task.group)) {\n            const index = (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.indexOf(task);\n            if (index !== -1) {\n                (_b = this.m_taskLists.get(task.group)) === null || _b === void 0 ? void 0 : _b.splice(index, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns the number of remaining tasks.\n     *\n     * @param group if group is set, it will return only the remaining tasks for this group,\n     * otherwise it will return the complete amount of tasks left.\n     */\n    numItemsLeft(group) {\n        var _a, _b;\n        let numLeft = 0;\n        if (group === undefined) {\n            this.m_taskLists.forEach(tasklist => {\n                numLeft += tasklist.length;\n            });\n        }\n        else {\n            numLeft += (_b = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n        }\n        return numLeft;\n    }\n    /**\n     * Processes the next Tasks for a group\n     *\n     * @param group The group the Tasks are pulled from.\n     * @param shouldProcess A condition that, if set will be executed before the task is processed,\n     * if returns true, the task will run\n     * @param n The amount of tasks that should be pulled, @defaults to 1\n     * @returns false if thte list was empty\n     */\n    processNext(group, shouldProcess, n = 1) {\n        if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {\n            return false;\n        }\n        for (let i = 0; i < n && this.numItemsLeft(group) > 0; i++) {\n            const nextTask = this.pull(group, true);\n            if (nextTask !== undefined) {\n                //if a condition is set, execute it\n                if (!shouldProcess || (shouldProcess === null || shouldProcess === void 0 ? void 0 : shouldProcess(nextTask))) {\n                    nextTask.execute();\n                }\n                else {\n                    //as the task was not executed but already pulled, add it back\n                    //TODO: dont even pull it if it will not execute, this currently\n                    // interferes with the skipping and removal of expired tasks on this.pull\n                    this.add(nextTask);\n                }\n            }\n        }\n        return true;\n    }\n    clear() {\n        this.m_taskLists.clear();\n    }\n    pull(group, checkIfExpired = false) {\n        var _a, _b;\n        const taskList = this.getTaskList(group);\n        let nextTask;\n        if (taskList) {\n            nextTask = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.pop();\n            if (checkIfExpired && nextTask && ((_b = nextTask.isExpired) === null || _b === void 0 ? void 0 : _b.call(nextTask))) {\n                return this.pull(group, checkIfExpired);\n            }\n        }\n        return nextTask;\n    }\n    sort(a, b) {\n        // the highest number in the beginning as the last in the array with\n        // highest priority which equals 0 will start to be processed\n        return b.getPriority() - a.getPriority();\n    }\n    getTaskList(group) {\n        return this.m_taskLists.get(group);\n    }\n    updateTaskList(taskList) {\n        var _a;\n        for (let i = 0; i < taskList.length; i++) {\n            const task = taskList[i];\n            if ((_a = task === null || task === void 0 ? void 0 : task.isExpired) === null || _a === void 0 ? void 0 : _a.call(task)) {\n                taskList.splice(i, 1);\n                i--;\n            }\n        }\n        taskList.sort(this.sort);\n    }\n}\nexports.TaskQueue = TaskQueue;\n//# sourceMappingURL=TaskQueue.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/TaskQueue.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UriResolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UriResolver.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.composeUriResolvers = exports.RelativeUriResolver = exports.PrefixMapUriResolver = void 0;\nconst UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\");\n/**\n * Basic, import-map like {@link UriResolver}.\n *\n * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.\n *\n * In definitions, `key` is matched against input uri with following strategy:\n *  - `key` without trailing `/` -> `key` and input `uri` must be identical\n *  - `key` with trailing `/`, -> `key` is treated as \"package prefix\", so `uri` must start with\n *    `key`\n *\n * Example:\n * ```\n * {\n *     \"local://poiMasterList\": \"/assets/poiMasterList.json\"\n *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`\n *     \"local://icons/\": \"/assets/icons/\"\n *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to\n *        // `/assets/icons/ANYPATH\n * }\n * ```\n * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).\n */\nclass PrefixMapUriResolver {\n    constructor(definitions) {\n        this.definitions = definitions;\n    }\n    resolveUri(uri) {\n        return Object.keys(this.definitions).reduce((r, key) => {\n            if (key.endsWith(\"/\") && r.startsWith(key)) {\n                const newPrefix = this.definitions[key];\n                return newPrefix + r.substr(key.length);\n            }\n            else if (r === key) {\n                return this.definitions[key];\n            }\n            return r;\n        }, uri);\n    }\n}\nexports.PrefixMapUriResolver = PrefixMapUriResolver;\n/**\n * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.\n */\nclass RelativeUriResolver {\n    constructor(parentUri) {\n        this.parentUri = parentUri;\n    }\n    resolveUri(uri) {\n        return UrlUtils_1.resolveReferenceUri(this.parentUri, uri);\n    }\n}\nexports.RelativeUriResolver = RelativeUriResolver;\n/**\n * Compose URI resolvers.\n *\n * Creates new {@link UriResolver} that applies resolvers in orders or arguments.\n *\n * Example:\n *\n *     const themeUrl = ...; // url of parent object\n *     const childUrlResolver = composeUrlResolvers(\n *           new RelativeUriResolver(themeUrl),\n *           defaultUrlResolver\n *     );\n */\nfunction composeUriResolvers(...resolvers) {\n    return {\n        resolveUri(originalUrl) {\n            return resolvers.reduce((url, resolver) => {\n                if (resolver !== undefined) {\n                    return resolver.resolveUri(url);\n                }\n                else {\n                    return url;\n                }\n            }, originalUrl);\n        }\n    };\n}\nexports.composeUriResolvers = composeUriResolvers;\n//# sourceMappingURL=UriResolver.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UriResolver.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAppBaseUrl = void 0;\nconst UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\");\n/**\n * Get base URL for from where relative URLs will be loaded.\n *\n * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL\n * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n *\n * * In node, it resolves to `file://${process.cwd()}`.\n */\nfunction getAppBaseUrl() {\n    return UrlUtils_1.baseUrl(window.location.href);\n}\nexports.getAppBaseUrl = getAppBaseUrl;\n//# sourceMappingURL=UrlPlatformUtils.web.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlUtils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getUrlHostAndProtocol = exports.getUrlOrigin = exports.baseUrl = exports.resolveReferenceUri = void 0;\n/**\n * Resolve URI of referenced object w.r.t parent URI.\n *\n * Resolves `childUri` as it would be loaded from location specified by `parentUri`.\n *\n * If `childUri` is absolute, then it is returned unchanged.\n * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.\n *\n * See [[baseUri]] for reference how base URL of `parentUri` is determined.\n *\n * Supports `http:`, `https:`, `file:`, `data:` schemes.\n *\n * Examples:\n *\n *     // normal case, child is sibling\n *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent is \"folder\", so child is just located in this folder\n *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent looks like leaf, so last component is stripped\n *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png\n *\n *     // origin-absolute URL, takes only origin from parent\n *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json\n *\n * @param parentUri - URI of parent resource\n * @param childUri - URI of child as referenced from parent resource\n * @return `childUrl` as if anchored in location of `parentUrl`\n */\nfunction resolveReferenceUri(parentUri, childUri) {\n    if (absoluteUrlWithOriginRe.test(childUri)) {\n        return childUri;\n    }\n    else if (childUri.startsWith(\"/\")) {\n        const origin = getUrlOrigin(parentUri);\n        return origin + childUri;\n    }\n    else {\n        if (childUri.startsWith(\"./\")) {\n            childUri = childUri.substr(2);\n        }\n        const parentBaseUrl = baseUrl(parentUri);\n        return parentBaseUrl + childUri;\n    }\n}\nexports.resolveReferenceUri = resolveReferenceUri;\nconst absoluteUrlWithOriginRe = new RegExp(\"^(((?:[a-z]+:)?//)|(file:/)|(data:))\", \"i\");\n/**\n * Returns base URL of given resource URL.\n *\n * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if\n * `url` ends with name component it is treated as \"leaf\", so last path component is removed.\n *\n * Standalone files (without any folder structure) are considered relative to `./`.\n *\n * Examples:\n * ```\n *     https://foo.com/themes/a.json -> https://foo.com/themes/\n *     https://foo.com/themes/ -> https://foo.com/themes/\n *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf\n *     themes/day.json -> themes/\n *     themes -> ./\n * ```\n */\nfunction baseUrl(url) {\n    if (url === undefined) {\n        return \"./\";\n    }\n    let idx = url.indexOf(\"#\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.indexOf(\"?\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.lastIndexOf(\"/\");\n    if (idx === -1) {\n        return \"./\";\n    }\n    else {\n        return url.substring(0, idx + 1);\n    }\n}\nexports.baseUrl = baseUrl;\n/**\n * Get `origin` part of URL.\n *\n * @example\n *    https://example.com/foo -> https://example.com\n *    //example.com:8080/ -> //example.com:8080\n *    file:///etc/hosts ->\n *\n * @param url - input URL\n * @return origin of given URL\n */\nfunction getUrlOrigin(url) {\n    if (url === undefined) {\n        return \"\";\n    }\n    const parsed = getUrlHostAndProtocol(url);\n    if (parsed.protocol === \"file:\") {\n        return \"file://\";\n    }\n    else if (parsed.host && parsed.protocol) {\n        return parsed.protocol + \"//\" + parsed.host;\n    }\n    else if (parsed.host) {\n        return \"//\" + parsed.host;\n    }\n    else if (parsed.protocol) {\n        return parsed.protocol + \"//\";\n    }\n    else {\n        return \"\";\n    }\n}\nexports.getUrlOrigin = getUrlOrigin;\n/**\n * Parse `host` and `protocol` part from URL.\n */\nfunction getUrlHostAndProtocol(url) {\n    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\\/\\/([^\\/]*)/, \"i\");\n    const match = url.match(urlOriginRe);\n    if (!match) {\n        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);\n    }\n    return {\n        protocol: match[1],\n        host: match[2]\n    };\n}\nexports.getUrlHostAndProtocol = getUrlHostAndProtocol;\n//# sourceMappingURL=UrlUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UrlUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/assert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertExists = exports.assert = void 0;\n// cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = \"development\" === \"production\";\n//TODO: Make assertHandler configurable\n/**\n * Implementation of assert as a development help\n *\n * Note - this is deliberately a global function so that minimizers remove the\n * entire call when building for production.\n *\n * @hidden\n * @param condition - Condition to match, if false, throws an Error(message)\n * @param message - Optional message, defaults to \"ASSERTION failed\"\n */\nfunction assert(condition, message) {\n    if (!isProduction) {\n        if (!condition) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed\");\n        }\n    }\n}\nexports.assert = assert;\nfunction assertExists(element, message) {\n    if (!isProduction) {\n        if (element === undefined || element === null) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed: Element is undefined or null\");\n        }\n    }\n    return element;\n}\nexports.assertExists = assertExists;\n//# sourceMappingURL=assert.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/assert.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * HERE OMV Data source.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(__webpack_require__(/*! ./lib/OmvDataFilter */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/VectorTileDataSource */ \"./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataSource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDebugLabelsTile.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/OmvRestClient */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvRestClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataProvider */ \"./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonDataProvider.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonDataProvider.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonDataProvider.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoJsonDataProvider = void 0;\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ \"./node_modules/@here/harp-mapview-decoder/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"GeoJsonDataProvider\");\nconst INVALIDATED = \"invalidated\";\nlet missingTilerServiceInfoEmitted = false;\n/**\n * GeoJson {@link @here/harp-mapview-decoder@DataProvider}.\n *\n * @remarks\n * Automatically handles tiling and simplification of static GeoJson.\n */\nclass GeoJsonDataProvider extends harp_mapview_decoder_1.DataProvider {\n    /**\n     * Constructs a new `GeoJsonDataProvider`.\n     *\n     * @param name - Name to be used to reference this `DataProvider`\n     * @param input - URL of the GeoJSON, or a GeoJSON.\n     * @param options - Optional\n     * @returns New `GeoJsonDataProvider`.\n     */\n    constructor(name, input, options) {\n        var _a;\n        super();\n        this.name = name;\n        this.input = input;\n        this.m_registered = false;\n        this.m_tiler = (_a = options === null || options === void 0 ? void 0 : options.tiler) !== null && _a !== void 0 ? _a : harp_mapview_1.ConcurrentTilerFacade.getTiler(OmvDecoderDefs_1.GEOJSON_TILER_SERVICE_TYPE, options && options.workerTilerUrl);\n    }\n    async connect() {\n        try {\n            await this.m_tiler.connect();\n        }\n        catch (error) {\n            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingTilerServiceInfoEmitted) {\n                logger.info(\"Unable to start GeoJson tiler service in worker. Use \" +\n                    \" 'OmvTilerService.start();' in decoder script.\");\n                missingTilerServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n        await this.m_tiler.registerIndex(this.name, this.input);\n        this.m_registered = true;\n    }\n    updateInput(input) {\n        this.input = input;\n        this.m_tiler.updateIndex(this.name, this.input);\n        this.dispatchEvent({ type: INVALIDATED });\n    }\n    ready() {\n        return this.m_registered;\n    }\n    async getTile(tileKey) {\n        return await this.m_tiler.getTile(this.name, tileKey);\n    }\n    onDidInvalidate(listener) {\n        this.addEventListener(INVALIDATED, listener);\n        return () => this.removeEventListener(INVALIDATED, listener);\n    }\n    /**\n     * Destroys this `GeoJsonDataProvider`.\n     */\n    dispose() {\n        this.m_tiler.dispose();\n    }\n}\nexports.GeoJsonDataProvider = GeoJsonDataProvider;\n//# sourceMappingURL=GeoJsonDataProvider.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/GeoJsonDataProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvGenericFeatureModifier = exports.ComposedDataFilter = exports.OmvGenericFeatureFilter = exports.OmvFeatureFilterDescriptionBuilder = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\n/**\n * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well\n * as an [[OmvFeatureModifier]].\n *\n */\nclass OmvFeatureFilterDescriptionBuilder {\n    /**\n     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as\n     * well as an [[OmvFeatureModifier]].\n     *\n     * @param processLayersDefault - If `true`, all unspecified layers will be processed.\n     * If `false`, all unspecified layers will be ignored.\n     * @param processPointsDefault - If `true`, all unspecified point features will be processed. If\n     * `false`, all unspecified point features will be ignored.\n     * @param processLinesDefault - If `true`, all unspecified line features will be processed. If\n     * `false`, all unspecified line features will be ignored.\n     * @param processPolygonsDefault - If `true`, all unspecified polygon features will be\n     * processed. If `false`, all unspecified polygon features will be ignored.\n     */\n    constructor(options) {\n        this.m_processLayersDefault = true;\n        this.m_processPointsDefault = true;\n        this.m_processLinesDefault = true;\n        this.m_processPolygonsDefault = true;\n        this.m_layersToProcess = new Array();\n        this.m_layersToIgnore = new Array();\n        this.m_pointsToProcess = new Array();\n        this.m_ignoredPoints = new Array();\n        this.m_linesToProcess = new Array();\n        this.m_linesToIgnore = new Array();\n        this.m_polygonsToProcess = new Array();\n        this.m_polygonsToIgnore = new Array();\n        this.m_kindsToProcess = [];\n        this.m_kindsToIgnore = [];\n        if (options) {\n            this.m_processLayersDefault =\n                options.processLayersDefault !== undefined ? options.processLayersDefault : true;\n            this.m_processPointsDefault =\n                options.processPointsDefault !== undefined ? options.processPointsDefault : true;\n            this.m_processLinesDefault =\n                options.processLinesDefault !== undefined ? options.processLinesDefault : true;\n            this.m_processPolygonsDefault =\n                options.processPolygonsDefault !== undefined\n                    ? options.processPolygonsDefault\n                    : true;\n        }\n    }\n    /**\n     * Add a layer that should be processed.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {\n        this.m_layersToProcess.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n    /**\n     * Add a layer that should be ignored.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {\n        this.m_layersToIgnore.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n    /**\n     * Add a valid point feature.\n     *\n     * @param options - Feature options.\n     */\n    processPoint(options) {\n        this.addItem(this.m_pointsToProcess, options);\n    }\n    /**\n     * Add valid point features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPoints(options) {\n        this.addItems(this.m_pointsToProcess, options);\n    }\n    /**\n     * Add a point feature that should be ignored.\n     *\n     * @param options - Feature options.\n     */\n    ignorePoint(options) {\n        this.addItem(this.m_ignoredPoints, options);\n    }\n    /**\n     * Add point features that should be ignored.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePoints(options) {\n        this.addItems(this.m_ignoredPoints, options);\n    }\n    /**\n     * Add a valid line feature.\n     *\n     * @param options - Feature options.\n     */\n    processLine(options) {\n        this.addItem(this.m_linesToProcess, options);\n    }\n    /**\n     * Add valid line features.\n     *\n     * @param options - Multi feature options.\n     */\n    processLines(options) {\n        this.addItems(this.m_linesToProcess, options);\n    }\n    /**\n     * Ignore a line feature.\n     *\n     * @param options - Feature options.\n     */\n    ignoreLine(options) {\n        this.addItem(this.m_linesToIgnore, options);\n    }\n    /**\n     * Ignore line features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignoreLines(options) {\n        this.addItems(this.m_linesToIgnore, options);\n    }\n    /**\n     * Add a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    processPolygon(options) {\n        this.addItem(this.m_polygonsToProcess, options);\n    }\n    /**\n     * Add valid polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPolygons(options) {\n        this.addItems(this.m_polygonsToProcess, options);\n    }\n    /**\n     * Ignore a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    ignorePolygon(options) {\n        this.addItem(this.m_polygonsToIgnore, options);\n    }\n    /**\n     * Ignore polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePolygons(options) {\n        this.addItems(this.m_polygonsToIgnore, options);\n    }\n    /**\n     * Add all the specified strings as \"enabledKinds\".\n     *\n     * @param {string[]} enabledKinds List of kinds that should be generated.\n     */\n    processKinds(enabledKinds) {\n        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);\n    }\n    /**\n     * Add all the specified strings as \"disabledKinds\".\n     *\n     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.\n     */\n    ignoreKinds(disabledKinds) {\n        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);\n    }\n    /**\n     * Create a filter description that can be passed as an option to the [[OmvDataSource]].\n     */\n    createDescription() {\n        return {\n            processLayersDefault: this.m_processLayersDefault,\n            processPointsDefault: this.m_processPointsDefault,\n            processLinesDefault: this.m_processLinesDefault,\n            processPolygonsDefault: this.m_processPolygonsDefault,\n            layersToProcess: this.m_layersToProcess,\n            layersToIgnore: this.m_layersToIgnore,\n            pointsToProcess: this.m_pointsToProcess,\n            pointsToIgnore: this.m_ignoredPoints,\n            linesToProcess: this.m_linesToProcess,\n            linesToIgnore: this.m_linesToIgnore,\n            polygonsToProcess: this.m_polygonsToProcess,\n            polygonsToIgnore: this.m_polygonsToIgnore,\n            kindsToProcess: this.m_kindsToProcess,\n            kindsToIgnore: this.m_kindsToIgnore\n        };\n    }\n    addItem(items, options) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n        const item = {\n            layerName: {\n                value: options.layer,\n                match: options.matchLayer === undefined\n                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                    : options.matchLayer\n            },\n            geometryTypes: options.geomType !== undefined\n                ? Array.isArray(options.geomType)\n                    ? options.geomType\n                    : [options.geomType]\n                : undefined,\n            classes: [\n                {\n                    value: options.featureClass,\n                    match: options.matchClass === undefined\n                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                        : options.matchClass\n                }\n            ],\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n        items.push(item);\n    }\n    addItems(items, options) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n        const item = {\n            layerName: {\n                value: options.layer,\n                match: options.matchLayer === undefined\n                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                    : options.matchLayer\n            },\n            geometryTypes: options.geomTypes !== undefined\n                ? Array.isArray(options.geomTypes)\n                    ? options.geomTypes\n                    : [options.geomTypes]\n                : undefined,\n            classes: options.featureClasses,\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n        items.push(item);\n    }\n}\nexports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;\n/**\n * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`\n * features before they are completely decoded.\n *\n * @internal\n */\nclass OmvGenericFeatureFilter {\n    constructor(description) {\n        this.description = description;\n        if (this.description.kindsToProcess.length > 0) {\n            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToProcess);\n        }\n        if (this.description.kindsToIgnore.length > 0) {\n            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToIgnore);\n        }\n    }\n    static matchLayer(layer, layerItems, level) {\n        for (const layerItem of layerItems) {\n            if (level < layerItem.minLevel || level > layerItem.maxLevel) {\n                continue;\n            }\n            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    wantsLayer(layer, level) {\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {\n            return true;\n        }\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {\n            return false;\n        }\n        return this.description.processLayersDefault;\n    }\n    wantsPointFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);\n    }\n    wantsLineFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);\n    }\n    wantsPolygonFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);\n    }\n    wantsKind(kind) {\n        // undefined -> no way to filter\n        if (kind === undefined) {\n            return true;\n        }\n        return (!(this.disabledKinds !== undefined &&\n            this.disabledKinds.hasOrIntersects(kind)) ||\n            (this.enabledKinds !== undefined &&\n                this.enabledKinds.hasOrIntersects(kind)));\n    }\n    get hasKindFilter() {\n        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;\n    }\n    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {\n        for (const item of itemsToProcess) {\n            if (level < item.minLevel || level > item.maxLevel) {\n                continue;\n            }\n            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {\n                return true;\n            }\n        }\n        for (const item of itemsToIgnore) {\n            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {\n                return false;\n            }\n        }\n        return defaultResult;\n    }\n}\nexports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;\n/**\n * An [[OmvFeatureFilter]] implementation that delegates all filter decision\n * returning `true` for any predicate if all delegates return `true`.\n *\n * @internal\n */\nclass ComposedDataFilter {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    get hasKindFilter() {\n        return this.filters.reduce((result, filter) => result && filter.hasKindFilter, true);\n    }\n    wantsLayer(layer, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsLayer(layer, level), true);\n    }\n    wantsPointFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsPointFeature(layer, geometryType, level), true);\n    }\n    wantsLineFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsLineFeature(layer, geometryType, level), true);\n    }\n    wantsPolygonFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level), true);\n    }\n    wantsKind(kind) {\n        return this.filters.reduce((result, filter) => result && filter.wantsKind(kind), true);\n    }\n}\nexports.ComposedDataFilter = ComposedDataFilter;\n/**\n * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter\n * `TileData` features before they are completely decoded.\n *\n * @internal\n */\nclass OmvGenericFeatureModifier {\n    constructor(description) {\n        this.description = description;\n    }\n    static matchItems(layerName, featureClass, items) {\n        for (const item of items) {\n            if (item.classes !== undefined) {\n                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {\n                    continue;\n                }\n                for (const matchClass of item.classes) {\n                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    static matchAttribute(layerName, env, items) {\n        for (const item of items) {\n            if (item.featureAttribute !== undefined) {\n                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&\n                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    doProcessPointFeature(layer, env) {\n        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);\n    }\n    doProcessLineFeature(layer, env) {\n        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);\n    }\n    doProcessPolygonFeature(layer, env) {\n        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);\n    }\n    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {\n        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {\n            return defaultResult;\n        }\n        let featureClass;\n        const featureClassThing = env.lookup(\"class\");\n        if (featureClassThing !== undefined && featureClassThing !== null) {\n            featureClass = featureClassThing.toString();\n        }\n        if (featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {\n            return true;\n        }\n        if (featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {\n            return false;\n        }\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {\n            return true;\n        }\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {\n            return false;\n        }\n        return defaultResult;\n    }\n}\nexports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;\n//# sourceMappingURL=OmvDataFilter.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvDataFilter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvDebugLabelsTile.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvDebugLabelsTile.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvDebugLabelsTile = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ \"./node_modules/@here/harp-mapview/lib/DebugContext.js\");\nconst TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js\");\nconst TextElementType_1 = __webpack_require__(/*! @here/harp-mapview/lib/text/TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst debugMaterial = new THREE.LineBasicMaterial({\n    color: 0x000000,\n    linewidth: 1,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\nconst debugCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\nconst debugCircleMaterialWF = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterialWF.wireframe = true;\nconst debugCircleMaterial2WF = new THREE.MeshBasicMaterial({\n    color: 0x8080ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterial2WF.wireframe = true;\nconst debugBlackCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x000000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\nconst debugBlueCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x0000ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth,\n    opacity: 0.75,\n    transparent: true\n});\nconst debugOrangeCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xa07000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth,\n    opacity: 0.75,\n    transparent: true\n});\nconst textRenderStyle = new harp_text_canvas_1.TextRenderStyle();\nconst textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();\ntextRenderStyle.fontSize = {\n    unit: harp_text_canvas_1.FontUnit.Point,\n    size: 9,\n    backgroundSize: 0\n};\ntextRenderStyle.opacity = 0.75;\ntextRenderStyle.backgroundOpacity = 0.75;\ntextRenderStyle.color = new THREE.Color(0.8, 0.2, 0.2);\n// Set maximum priority.\nconst PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;\nclass DebugGeometry {\n    constructor() {\n        this.geometry = new THREE.BufferGeometry();\n        this.indices = new Array();\n        this.positions = new Array();\n    }\n}\nfunction addPoint(xPos, yPos, zPos, size, debugGeometry) {\n    debugGeometry.positions.push(xPos, yPos - size, zPos);\n    debugGeometry.positions.push(xPos + size, yPos, zPos);\n    debugGeometry.positions.push(xPos, yPos + size, zPos);\n    debugGeometry.positions.push(xPos - size, yPos, zPos);\n    const index = debugGeometry.positions.length / 3;\n    debugGeometry.indices.push(index - 4);\n    debugGeometry.indices.push(index - 3);\n    debugGeometry.indices.push(index - 2);\n    debugGeometry.indices.push(index - 4);\n    debugGeometry.indices.push(index - 2);\n    debugGeometry.indices.push(index - 1);\n}\nfunction addObject(objects, debugGeometry, priorityOffset = 0, factory) {\n    if (debugGeometry.indices.length > 0) {\n        debugGeometry.geometry.addGroup(0, debugGeometry.indices.length, 0);\n        debugGeometry.geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(debugGeometry.positions), 3));\n        debugGeometry.geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(debugGeometry.indices), 1));\n        const mesh = factory(debugGeometry.geometry);\n        mesh.renderOrder = PRIORITY_ALWAYS - priorityOffset;\n        objects.push(mesh);\n    }\n}\nclass OmvDebugLabelsTile extends harp_mapview_1.Tile {\n    constructor(dataSource, tileKey) {\n        super(dataSource, tileKey);\n    }\n    /**\n     * @override\n     * Create [[TextElement]] objects for label debugging.\n     */\n    loadingFinished() {\n        var _a, _b, _c;\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_TEXT_PATHS\", true)\n        const debugTextPaths = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS\");\n        const debugTextPathsFull = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS_FULL\");\n        const debugTextPoisFull = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_POIS_FULL\");\n        const debugLineMarkers = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_LINE_MARKER\");\n        if (!(debugTextPaths || debugTextPathsFull || debugLineMarkers) ||\n            this.decodedTile === undefined) {\n            return;\n        }\n        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;\n        const decodedTile = this.decodedTile;\n        const colorMap = new Map();\n        // allow limiting to specific names and/or index. There can be many paths with the\n        // same text\n        const textFilter = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.TEXT\");\n        const indexFilter = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.INDEX\");\n        const env = this.mapView.env;\n        if (decodedTile.textPathGeometries !== undefined) {\n            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);\n        }\n        const centerX = this.center.x;\n        const centerY = this.center.y;\n        const centerZ = this.center.z;\n        const pointScale = this.mapView.pixelToWorld;\n        const worldOffsetX = this.computeWorldOffsetX();\n        const zHeight = 10;\n        let pointLabelIndex = 0;\n        if (this.textElementGroups.count() > 0) {\n            const bluePoints = new DebugGeometry();\n            const orangePoints = new DebugGeometry();\n            const addedTextElements = [];\n            this.textElementGroups.forEach((textElement) => {\n                if (textElement.type !== TextElementType_1.TextElementType.LineMarker &&\n                    textElement.type !== TextElementType_1.TextElementType.PoiLabel) {\n                    return;\n                }\n                const isLineMarker = textElement.type === TextElementType_1.TextElementType.LineMarker;\n                const geometry = isLineMarker ? orangePoints : bluePoints;\n                const pointSize = pointScale * 5;\n                const addLabel = (x, y, z) => {\n                    addPoint(x, y, z, pointSize, geometry);\n                    if (debugTextPoisFull || debugLineMarkers) {\n                        const offsetXY = pointSize * 0.5;\n                        const label = `${textElement.text} [${pointLabelIndex}]`;\n                        const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX + centerX + offsetXY, y + centerY + offsetXY, z + centerZ), textRenderStyle, textLayoutStyle, PRIORITY_ALWAYS, 0.0, 0.0);\n                        labelElement.minZoomLevel = 0;\n                        labelElement.mayOverlap = true;\n                        labelElement.reserveSpace = false;\n                        labelElement.alwaysOnTop = true;\n                        labelElement.ignoreDistance = true;\n                        labelElement.priority = harp_mapview_1.TextElement.HIGHEST_PRIORITY;\n                        labelElement._isDebug = true;\n                        addedTextElements.push(labelElement);\n                    }\n                    pointLabelIndex++;\n                };\n                if (textElement.path !== undefined && Array.isArray(textElement.path)) {\n                    for (let i = 0; i < textElement.path.length; i++) {\n                        const pos = textElement.path[i];\n                        const x = pos.x - centerX;\n                        const y = pos.y - centerY;\n                        const z = zHeight + pos.z + i * 5 - centerZ;\n                        addLabel(x, y, z);\n                    }\n                }\n                else if (debugTextPoisFull) {\n                    const x = textElement.position.x - centerX;\n                    const y = textElement.position.y - centerY;\n                    const z = 5 - centerZ;\n                    addLabel(x, y, z);\n                }\n            });\n            for (const labelElement of addedTextElements) {\n                this.addTextElement(labelElement);\n            }\n            addObject(this.objects, bluePoints, 0, (geometry) => {\n                return new THREE.Mesh(geometry, debugBlueCircleMaterial);\n            });\n            addObject(this.objects, orangePoints, 0, (geometry) => {\n                return new THREE.Mesh(geometry, debugOrangeCircleMaterial);\n            });\n        }\n        if (this.preparedTextPaths !== undefined) {\n            const lines = new DebugGeometry();\n            const redPoints = new DebugGeometry();\n            const blackPoints = new DebugGeometry();\n            let baseVertex = 0;\n            for (const textPath of this.preparedTextPaths) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (!harp_datasource_protocol_1.isTextTechnique(technique) || textPath._isDebug !== undefined) {\n                    continue;\n                }\n                if (technique.color !== undefined) {\n                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, env)));\n                }\n                baseVertex = lines.positions.length / 3;\n                const text = textPath.text;\n                const elementIndex = this.preparedTextPaths.indexOf(textPath);\n                const createDebugInfo = (!textFilter || (text && text.includes(textFilter))) &&\n                    (indexFilter === undefined || indexFilter === elementIndex);\n                if (createDebugInfo) {\n                    for (let i = 0; i < textPath.path.length; i += 3) {\n                        const pathIndex = i / 3;\n                        const x = textPath.path[i] - centerX;\n                        const y = textPath.path[i + 1] - centerY;\n                        // raise it a bit, so we get identify connectivity visually by tilting\n                        const z = zHeight + textPath.path[i + 2] + i / 3 - centerZ;\n                        if (debugTextPaths) {\n                            lines.positions.push(x, y, z);\n                        }\n                        const isRedPoint = i === 0 && debugTextPaths;\n                        if (debugTextPathsFull || isRedPoint) {\n                            const pointSize = pointScale * (isRedPoint ? 6 : 4);\n                            const geometry = isRedPoint ? redPoints : blackPoints;\n                            addPoint(x, y, z, pointSize, geometry);\n                            if (debugTextPathsFull) {\n                                const xOffset = (_a = technique.xOffset) !== null && _a !== void 0 ? _a : 0.0;\n                                const yOffset = (_b = technique.yOffset) !== null && _b !== void 0 ? _b : 0.0;\n                                const minZoomLevel = technique.minZoomLevel;\n                                // give point index a label\n                                const label = pathIndex % 5 === 0\n                                    ? text + \":\" + pathIndex\n                                    : Number(pathIndex).toString();\n                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX + centerX, y + centerY, z + centerZ), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue((_c = technique.priority) !== null && _c !== void 0 ? _c : 0, env), xOffset, yOffset);\n                                labelElement.minZoomLevel = harp_datasource_protocol_1.getPropertyValue(minZoomLevel, env);\n                                labelElement.mayOverlap = true;\n                                labelElement.reserveSpace = false;\n                                labelElement.alwaysOnTop = true;\n                                labelElement.ignoreDistance = true;\n                                labelElement.priority = harp_mapview_1.TextElement.HIGHEST_PRIORITY;\n                                this.addTextElement(labelElement);\n                            }\n                        }\n                    }\n                    // the lines of a path share a common geometry\n                    const N = textPath.path.length / 3;\n                    for (let i = 0; i < N; ++i) {\n                        if (i > 0) {\n                            lines.indices.push(baseVertex + i);\n                        }\n                        if (i + 1 < N) {\n                            lines.indices.push(baseVertex + i);\n                        }\n                    }\n                }\n            }\n            addObject(this.objects, lines, -2, (geometry) => {\n                return new THREE.LineSegments(geometry, debugMaterial);\n            });\n            addObject(this.objects, redPoints, 0, (geometry) => {\n                return new THREE.Mesh(geometry, debugCircleMaterial);\n            });\n            addObject(this.objects, blackPoints, -1, (geometry) => {\n                return new THREE.Mesh(geometry, debugBlackCircleMaterial);\n            });\n        }\n    }\n}\nexports.OmvDebugLabelsTile = OmvDebugLabelsTile;\n//# sourceMappingURL=OmvDebugLabelsTile.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvDebugLabelsTile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GEOJSON_TILER_SERVICE_TYPE = exports.VECTOR_TILE_DECODER_SERVICE_TYPE = exports.OmvGeometryType = exports.OmvFilterString = exports.FeatureModifierId = void 0;\n/**\n * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.\n */\nvar FeatureModifierId;\n(function (FeatureModifierId) {\n    /**\n     * Generic feature modifier used when no other modifiers are defined.\n     *\n     * @note You do not need to specify it in [[OmvDataSourceParameters]] as it is added by default\n     * if no other feature modifier is used.\n     */\n    FeatureModifierId[FeatureModifierId[\"default\"] = 0] = \"default\";\n})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));\n/**\n * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.\n */\nvar OmvFilterString;\n(function (OmvFilterString) {\n    /**\n     * Match condition.\n     */\n    let StringMatch;\n    (function (StringMatch) {\n        /** Matches any. */\n        StringMatch[StringMatch[\"Any\"] = 0] = \"Any\";\n        /** Exact match. */\n        StringMatch[StringMatch[\"Match\"] = 1] = \"Match\";\n        /** Matches if a test string starts with a filter string. */\n        StringMatch[StringMatch[\"StartsWith\"] = 2] = \"StartsWith\";\n        /** Matches if a test string contains a filter string. */\n        StringMatch[StringMatch[\"Contains\"] = 3] = \"Contains\";\n        /** Matches if a test string ends with a filter string. */\n        StringMatch[StringMatch[\"EndsWith\"] = 4] = \"EndsWith\";\n    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));\n    /**\n     * Check for a string against a filter.\n     *\n     * @param str - The string to check against a filter.\n     * @param filterString - The filter containing the match condition.\n     * @returns `true` if the match condition is satisfied.\n     *\n     * @internal\n     */\n    function matchString(str, filterString) {\n        switch (filterString.match) {\n            case OmvFilterString.StringMatch.Any:\n                return true;\n            case OmvFilterString.StringMatch.Match:\n                return str === filterString.value;\n            case OmvFilterString.StringMatch.StartsWith:\n                return filterString.value.startsWith(str);\n            case OmvFilterString.StringMatch.EndsWith:\n                return filterString.value.endsWith(str);\n            default:\n                return str.includes(filterString.value);\n        }\n    }\n    OmvFilterString.matchString = matchString;\n})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));\nvar OmvGeometryType;\n(function (OmvGeometryType) {\n    OmvGeometryType[OmvGeometryType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    OmvGeometryType[OmvGeometryType[\"POINT\"] = 1] = \"POINT\";\n    OmvGeometryType[OmvGeometryType[\"LINESTRING\"] = 2] = \"LINESTRING\";\n    OmvGeometryType[OmvGeometryType[\"POLYGON\"] = 3] = \"POLYGON\";\n})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));\n/**\n * Vector tile decoder service type id.\n *\n * @remarks\n * Used for requesting decoder services using `WorkerServiceManager`.\n *\n * @internal\n */\nexports.VECTOR_TILE_DECODER_SERVICE_TYPE = \"vector-tile-decoder\";\n/**\n * GeoJson tiler service type id.\n *\n * @remarks\n * Used for requesting tiler services using `WorkerServiceManager`.\n *\n * @internal\n */\nexports.GEOJSON_TILER_SERVICE_TYPE = \"geojson-tiler\";\n//# sourceMappingURL=OmvDecoderDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/OmvRestClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/OmvRestClient.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OmvRestClient = exports.AuthenticationTypeAccessToken = exports.AuthenticationTypeTomTomV1 = exports.AuthenticationTypeBearer = exports.AuthenticationMethod = exports.APIFormat = void 0;\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ \"./node_modules/@here/harp-mapview-decoder/index.js\");\nconst harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ \"./node_modules/@here/harp-transfer-manager/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"OmvRestClient\");\nvar APIFormat;\n(function (APIFormat) {\n    /**\n     * Use the REST API format of HERE Vector Tiles Server component version 1.\n     *\n     * @remarks\n     * Documentation:\n     *  https://developer.here.com/documentation/vector-tiles-api/dev_guide/index.html\n     *\n     * Usage:\n     *\n     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv\n     *\n     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:\n     *\n     *     Authorization: Bearer $authenticationToken\n     *\n     * Format definition:\n     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`\n     *\n     * Default authentication method used: [[AuthenticationTypeBearer]].\n     */\n    APIFormat[APIFormat[\"HereV1\"] = 0] = \"HereV1\";\n    /**\n     * Use the REST API format of Mapbox Vector Tile API v4.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`\n     *\n     * Sample URL:\n     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"MapboxV4\"] = 1] = \"MapboxV4\";\n    /**\n     * Use the REST API format of XYZ Vector Tile API in MVT format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZMVT\"] = 2] = \"XYZMVT\";\n    /**\n     * Use the REST API format of XYZ Vector Tile API in JSON format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZJson\"] = 3] = \"XYZJson\";\n    /**\n     * Use the REST API format of XYZ Vector Tile API in OMV format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZOMV\"] = 4] = \"XYZOMV\";\n    /**\n     * Use the REST API format of Tomtoms Vector Tile API v1.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`\n     *\n     * Sample URL:\n     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`\n     *\n     * Default authentication method used: [[AuthenticationTypeTomTomV1]].\n     */\n    APIFormat[APIFormat[\"TomtomV1\"] = 5] = \"TomtomV1\";\n    /**\n     * Use the REST API format of XYZ Space Vector Tile API in OMV format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZSpace\"] = 6] = \"XYZSpace\";\n})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));\nvar AuthenticationMethod;\n(function (AuthenticationMethod) {\n    AuthenticationMethod[AuthenticationMethod[\"QueryString\"] = 0] = \"QueryString\";\n    AuthenticationMethod[AuthenticationMethod[\"AuthorizationHeader\"] = 1] = \"AuthorizationHeader\";\n})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));\n/**\n * Authentication method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexports.AuthenticationTypeBearer = {\n    method: AuthenticationMethod.AuthorizationHeader,\n    name: \"Bearer\"\n};\n/**\n * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexports.AuthenticationTypeTomTomV1 = {\n    method: AuthenticationMethod.QueryString,\n    name: \"key\"\n};\nexports.AuthenticationTypeAccessToken = {\n    method: AuthenticationMethod.QueryString,\n    name: \"access_token\"\n};\n/**\n * REST client supporting getting protobuf OMV Tile from REST-based servers.\n */\nclass OmvRestClient extends harp_mapview_decoder_1.DataProvider {\n    constructor(params) {\n        super();\n        this.params = params;\n        this.downloadManager =\n            params.downloadManager === undefined\n                ? harp_transfer_manager_1.TransferManager.instance()\n                : params.downloadManager;\n        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;\n    }\n    /** Overriding abstract method, in this case doing nothing. */\n    async connect() {\n        // not needed\n    }\n    /** Overriding abstract method, in this case always returning `true`. */\n    ready() {\n        return true;\n    }\n    /**\n     * Asynchronously fetches a tile from this restful server.\n     *\n     * @remarks\n     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is\n     * returned.\n     *\n     * @example\n     * ```typescript\n     * const response = layer.getTile(tileKey);\n     * if (!response.ok) {\n     *     // a network error happened\n     *     console.error(\"Unable to download tile\", response.statusText);\n     *     return;\n     * }\n     * if (response.status === 404) {\n     *     // 404 -, no data exists at the given tile. Do nothing.\n     *     return;\n     * }\n     *\n     * // the response is ok and contains data, access it e.g. as arrayBuffer:\n     * const payload = await response.arrayBuffer();\n     * ```\n     *\n     * @param tileKey - The tile key of the tile.\n     * @param tileRequestInit - Optional request options to be passed to fetch when downloading a\n     * tile.\n     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.\n     */\n    async getTile(tileKey, abortSignal) {\n        const init = { signal: abortSignal };\n        let tileUrl = this.dataUrl(tileKey);\n        const authenticationCode = await this.getActualAuthenticationCode();\n        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);\n        tileUrl = this.addQueryParams(tileUrl, this.urlParams);\n        if (this.params.apiFormat === APIFormat.XYZJson) {\n            return await this.downloadManager.downloadJson(tileUrl, init);\n        }\n        return await this.downloadManager.downloadArrayBuffer(tileUrl, init);\n    }\n    /**\n     * Destroys this `OmvRestClient`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Get actual authentication code/token for this request according to configuration.\n     */\n    async getActualAuthenticationCode() {\n        if (typeof this.params.authenticationCode === \"string\") {\n            return this.params.authenticationCode;\n        }\n        else if (this.params.authenticationCode !== undefined) {\n            return await this.params.authenticationCode();\n        }\n        else if (this.params.getBearerToken !== undefined) {\n            return await this.params.getBearerToken();\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Get default authentication method basing on apiFormat and other params.\n     */\n    getDefaultAuthMethod() {\n        if (this.params.getBearerToken !== undefined) {\n            return exports.AuthenticationTypeBearer;\n        }\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n                return exports.AuthenticationTypeBearer;\n            case APIFormat.MapboxV4:\n            case APIFormat.XYZOMV:\n            case APIFormat.XYZMVT:\n            case APIFormat.XYZSpace:\n            case APIFormat.XYZJson:\n                return exports.AuthenticationTypeAccessToken;\n            case APIFormat.TomtomV1:\n                return exports.AuthenticationTypeTomTomV1;\n            default:\n                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);\n                return undefined;\n        }\n    }\n    /**\n     * Apply authentication code/token using configured (or default) authentication method.\n     *\n     * @param url -\n     * @param init - request extra data\n     * @param authenticationCode - authentication/token to be applied\n     * @return new url to be used\n     */\n    applyAuthCode(url, init, authenticationCode) {\n        var _a, _b, _c;\n        if (authenticationCode === undefined) {\n            return url;\n        }\n        const authMethod = (_a = this.params.authenticationMethod) !== null && _a !== void 0 ? _a : this.getDefaultAuthMethod();\n        if (authMethod === undefined) {\n            return url;\n        }\n        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {\n            if (init.headers === undefined) {\n                init.headers = new Headers();\n            }\n            const authType = (_b = authMethod.name) !== null && _b !== void 0 ? _b : \"Bearer\";\n            init.headers.append(\"Authorization\", `${authType} ${authenticationCode}`);\n        }\n        else if (authMethod.method === AuthenticationMethod.QueryString) {\n            const attrName = (_c = authMethod.name) !== null && _c !== void 0 ? _c : \"access_token\";\n            const authParams = {};\n            authParams[attrName] = authenticationCode;\n            url = this.addQueryParams(url, authParams);\n        }\n        return url;\n    }\n    /**\n     * Get actual tile URL depending on configured API format.\n     */\n    dataUrl(tileKey) {\n        if (this.params.url !== undefined) {\n            return this.params.url\n                .replace(\"{x}\", String(tileKey.column))\n                .replace(\"{y}\", String(tileKey.row))\n                .replace(\"{z}\", String(tileKey.level));\n        }\n        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ||\n            this.params.apiFormat === APIFormat.XYZJson\n            ? \"_\"\n            : \"/\");\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n            case APIFormat.XYZOMV:\n                path += \"/omv\";\n                break;\n            case APIFormat.MapboxV4:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZMVT:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZJson:\n                break;\n            case APIFormat.XYZSpace:\n                path += \".mvt\";\n                break;\n            case APIFormat.TomtomV1:\n                path += \".pbf\";\n                break;\n            default:\n                logger.warn(`Not supported API format: ${this.params.apiFormat}`);\n                break;\n        }\n        return this.params.baseUrl + path;\n    }\n    addQueryParams(url, queryParams) {\n        let queryString = \"\";\n        let sep = url.includes(\"?\") ? \"&\" : \"?\";\n        for (const prop in queryParams) {\n            if (!queryParams.hasOwnProperty(prop)) {\n                continue;\n            }\n            queryString += `${sep}${encodeURIComponent(prop)}=${encodeURIComponent(queryParams[prop])}`;\n            if (sep === \"?\") {\n                sep = \"&\";\n            }\n        }\n        return url + queryString;\n    }\n}\nexports.OmvRestClient = OmvRestClient;\n//# sourceMappingURL=OmvRestClient.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/OmvRestClient.js?");

/***/ }),

/***/ "./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataSource.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataSource.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorTileDataSource = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ \"./node_modules/@here/harp-mapview-decoder/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvDecoderDefs.js\");\nconst OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ \"./node_modules/@here/harp-vectortile-datasource/lib/OmvRestClient.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"VectorTileDataSource\");\n/**\n * A helper function to retrieve the [[DataProvider]] from the\n * {@link VectorTileDataSource}s parameters.\n *\n * @param params - The parameters passed into the OmvDataSource.\n */\nfunction getDataProvider(params) {\n    var _a;\n    if (params.dataProvider) {\n        return params.dataProvider;\n    }\n    else if ((_a = params.baseUrl) !== null && _a !== void 0 ? _a : params.url) {\n        return new OmvRestClient_1.OmvRestClient(params);\n    }\n    else {\n        throw new Error(\"OmvDataSource: missing url, baseUrl or dataProvider params\");\n    }\n}\nlet missingOmvDecoderServiceInfoEmitted = false;\n/**\n * The default vector tile service.\n */\nconst hereVectorTileBaseUrl = \"https://vector.hereapi.com/v2/vectortiles/base/mc\";\n/**\n * Default options for the HERE Vector Tile service.\n */\nconst hereVectorTileDefaultOptions = {\n    baseUrl: hereVectorTileBaseUrl,\n    apiFormat: OmvRestClient_1.APIFormat.XYZOMV,\n    styleSetName: \"tilezen\",\n    authenticationMethod: {\n        method: OmvRestClient_1.AuthenticationMethod.QueryString,\n        name: \"apikey\"\n    },\n    copyrightInfo: [\n        {\n            id: \"here.com\",\n            year: new Date().getFullYear(),\n            label: \"HERE\",\n            link: \"https://legal.here.com/terms\"\n        }\n    ]\n};\nconst defaultOptions = new Map([\n    [hereVectorTileBaseUrl, hereVectorTileDefaultOptions]\n]);\n/**\n * Tests if the given object has custom data provider.\n * @param object -\n */\nfunction hasCustomDataProvider(object) {\n    return object.dataProvider !== undefined;\n}\n/**\n * Add service specific default values.\n *\n * @param params - The configuration settings of the data source.\n */\nfunction completeDataSourceParameters(params) {\n    var _a;\n    if (!hasCustomDataProvider(params) && params.url === undefined) {\n        const baseUrl = (_a = params.baseUrl) !== null && _a !== void 0 ? _a : hereVectorTileBaseUrl;\n        const completedParams = Object.assign(Object.assign({}, defaultOptions.get(baseUrl)), params);\n        return Object.assign(Object.assign({}, completedParams), { tilingScheme: harp_geoutils_1.webMercatorTilingScheme, dataProvider: new OmvRestClient_1.OmvRestClient(completedParams) });\n    }\n    return Object.assign(Object.assign({}, params), { tilingScheme: harp_geoutils_1.webMercatorTilingScheme, dataProvider: getDataProvider(params) });\n}\n/**\n * `VectorTileDataSource` is used for the visualization of vector tiles.\n *\n * @example\n * ```typescript\n *    const dataSource = new VectorTileDataSource({\n *        baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n *        authenticationCode: apikey\n *    });\n *    mapView.addDataSource(dataSource);\n *   ```\n */\nclass VectorTileDataSource extends harp_mapview_decoder_1.TileDataSource {\n    constructor(m_params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        super((_a = m_params.tileFactory) !== null && _a !== void 0 ? _a : new harp_mapview_decoder_1.TileFactory(harp_mapview_1.Tile), Object.assign({ styleSetName: (_b = m_params.styleSetName) !== null && _b !== void 0 ? _b : \"omv\", concurrentDecoderServiceName: OmvDecoderDefs_1.VECTOR_TILE_DECODER_SERVICE_TYPE, minDataLevel: (_c = m_params.minDataLevel) !== null && _c !== void 0 ? _c : 1, maxDataLevel: (_d = m_params.maxDataLevel) !== null && _d !== void 0 ? _d : 17, storageLevelOffset: (_e = m_params.storageLevelOffset) !== null && _e !== void 0 ? _e : -1 }, completeDataSourceParameters(m_params)));\n        this.m_params = m_params;\n        this.cacheable = true;\n        this.addGroundPlane =\n            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;\n        let roundUpCoordinatesIfNeeded = m_params.roundUpCoordinatesIfNeeded;\n        if (roundUpCoordinatesIfNeeded === undefined &&\n            ((_f = m_params) === null || _f === void 0 ? void 0 : _f.baseUrl) === hereVectorTileBaseUrl) {\n            roundUpCoordinatesIfNeeded = true;\n        }\n        this.m_decoderOptions = {\n            showMissingTechniques: this.m_params.showMissingTechniques === true,\n            filterDescription: this.m_params.filterDescr,\n            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,\n            featureModifiers: this.m_params.featureModifierId\n                ? [this.m_params.featureModifierId]\n                : undefined,\n            politicalView: this.m_params.politicalView,\n            skipShortLabels: this.m_params.skipShortLabels,\n            storageLevelOffset: (_g = m_params.storageLevelOffset) !== null && _g !== void 0 ? _g : -1,\n            enableElevationOverlay: this.m_params.enableElevationOverlay === true,\n            roundUpCoordinatesIfNeeded\n        };\n        this.maxGeometryHeight = harp_utils_1.getOptionValue(m_params.maxGeometryHeight, harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT);\n        this.minGeometryHeight = harp_utils_1.getOptionValue(m_params.minGeometryHeight, 0);\n    }\n    /** @override */\n    async connect() {\n        try {\n            await super.connect();\n        }\n        catch (error) {\n            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingOmvDecoderServiceInfoEmitted) {\n                logger.info(\"Unable to create decoder service in worker. Use \" +\n                    \" 'OmvTileDecoderService.start();' in decoder script.\");\n                missingOmvDecoderServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n        this.configureDecoder(undefined, this.m_decoderOptions);\n    }\n    /**\n     * Remove the current data filter.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     */\n    removeDataFilter() {\n        this.configureDecoder(undefined, {\n            filterDescription: null\n        });\n    }\n    /**\n     * Set a new data filter. Can also be done during\n     * the creation of an {@link VectorTileDataSource}.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     *\n     * @param filterDescription - Data filter description created with\n     * [[OmvFeatureFilterDescriptionBuilder]].\n     */\n    setDataFilter(filterDescription) {\n        this.m_decoderOptions.filterDescription =\n            filterDescription !== null ? filterDescription : undefined;\n        this.configureDecoder(undefined, {\n            filterDescription,\n            featureModifiers: this.m_decoderOptions.featureModifiers,\n            politicalView: this.m_decoderOptions.politicalView\n        });\n    }\n    /** @override */\n    shouldPreloadTiles() {\n        return true;\n    }\n    /** @override */\n    setPoliticalView(politicalView) {\n        // Just in case users mess with letters' casing.\n        politicalView = politicalView === null || politicalView === void 0 ? void 0 : politicalView.toLowerCase();\n        if (this.m_decoderOptions.politicalView !== politicalView) {\n            this.m_decoderOptions.politicalView = politicalView;\n            this.configureDecoder(undefined, {\n                filterDescription: this.m_decoderOptions.filterDescription,\n                featureModifiers: this.m_decoderOptions.featureModifiers,\n                politicalView: politicalView !== undefined ? politicalView : \"\"\n            });\n        }\n    }\n    /** @override */\n    get storageLevelOffset() {\n        return super.storageLevelOffset;\n    }\n    /** @override */\n    set storageLevelOffset(levelOffset) {\n        super.storageLevelOffset = levelOffset;\n        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;\n        this.configureDecoder(undefined, {\n            storageLevelOffset: this.storageLevelOffset\n        });\n    }\n    /** @override */\n    setEnableElevationOverlay(enable) {\n        if (this.m_decoderOptions.enableElevationOverlay !== enable) {\n            this.m_decoderOptions.enableElevationOverlay = enable;\n            this.configureDecoder(undefined, {\n                enableElevationOverlay: enable\n            });\n        }\n    }\n    configureDecoder(options, customOptions) {\n        this.clearCache();\n        this.decoder.configure(options, customOptions);\n        this.mapView.markTilesDirty(this);\n    }\n}\nexports.VectorTileDataSource = VectorTileDataSource;\n//# sourceMappingURL=VectorTileDataSource.js.map\n\n//# sourceURL=webpack:///./node_modules/@here/harp-vectortile-datasource/lib/VectorTileDataSource.js?");

/***/ }),

/***/ "./node_modules/csscolorparser/csscolorparser.js":
/*!*******************************************************!*\
  !*** ./node_modules/csscolorparser/csscolorparser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  \"transparent\": [0,0,0,0], \"aliceblue\": [240,248,255,1],\n  \"antiquewhite\": [250,235,215,1], \"aqua\": [0,255,255,1],\n  \"aquamarine\": [127,255,212,1], \"azure\": [240,255,255,1],\n  \"beige\": [245,245,220,1], \"bisque\": [255,228,196,1],\n  \"black\": [0,0,0,1], \"blanchedalmond\": [255,235,205,1],\n  \"blue\": [0,0,255,1], \"blueviolet\": [138,43,226,1],\n  \"brown\": [165,42,42,1], \"burlywood\": [222,184,135,1],\n  \"cadetblue\": [95,158,160,1], \"chartreuse\": [127,255,0,1],\n  \"chocolate\": [210,105,30,1], \"coral\": [255,127,80,1],\n  \"cornflowerblue\": [100,149,237,1], \"cornsilk\": [255,248,220,1],\n  \"crimson\": [220,20,60,1], \"cyan\": [0,255,255,1],\n  \"darkblue\": [0,0,139,1], \"darkcyan\": [0,139,139,1],\n  \"darkgoldenrod\": [184,134,11,1], \"darkgray\": [169,169,169,1],\n  \"darkgreen\": [0,100,0,1], \"darkgrey\": [169,169,169,1],\n  \"darkkhaki\": [189,183,107,1], \"darkmagenta\": [139,0,139,1],\n  \"darkolivegreen\": [85,107,47,1], \"darkorange\": [255,140,0,1],\n  \"darkorchid\": [153,50,204,1], \"darkred\": [139,0,0,1],\n  \"darksalmon\": [233,150,122,1], \"darkseagreen\": [143,188,143,1],\n  \"darkslateblue\": [72,61,139,1], \"darkslategray\": [47,79,79,1],\n  \"darkslategrey\": [47,79,79,1], \"darkturquoise\": [0,206,209,1],\n  \"darkviolet\": [148,0,211,1], \"deeppink\": [255,20,147,1],\n  \"deepskyblue\": [0,191,255,1], \"dimgray\": [105,105,105,1],\n  \"dimgrey\": [105,105,105,1], \"dodgerblue\": [30,144,255,1],\n  \"firebrick\": [178,34,34,1], \"floralwhite\": [255,250,240,1],\n  \"forestgreen\": [34,139,34,1], \"fuchsia\": [255,0,255,1],\n  \"gainsboro\": [220,220,220,1], \"ghostwhite\": [248,248,255,1],\n  \"gold\": [255,215,0,1], \"goldenrod\": [218,165,32,1],\n  \"gray\": [128,128,128,1], \"green\": [0,128,0,1],\n  \"greenyellow\": [173,255,47,1], \"grey\": [128,128,128,1],\n  \"honeydew\": [240,255,240,1], \"hotpink\": [255,105,180,1],\n  \"indianred\": [205,92,92,1], \"indigo\": [75,0,130,1],\n  \"ivory\": [255,255,240,1], \"khaki\": [240,230,140,1],\n  \"lavender\": [230,230,250,1], \"lavenderblush\": [255,240,245,1],\n  \"lawngreen\": [124,252,0,1], \"lemonchiffon\": [255,250,205,1],\n  \"lightblue\": [173,216,230,1], \"lightcoral\": [240,128,128,1],\n  \"lightcyan\": [224,255,255,1], \"lightgoldenrodyellow\": [250,250,210,1],\n  \"lightgray\": [211,211,211,1], \"lightgreen\": [144,238,144,1],\n  \"lightgrey\": [211,211,211,1], \"lightpink\": [255,182,193,1],\n  \"lightsalmon\": [255,160,122,1], \"lightseagreen\": [32,178,170,1],\n  \"lightskyblue\": [135,206,250,1], \"lightslategray\": [119,136,153,1],\n  \"lightslategrey\": [119,136,153,1], \"lightsteelblue\": [176,196,222,1],\n  \"lightyellow\": [255,255,224,1], \"lime\": [0,255,0,1],\n  \"limegreen\": [50,205,50,1], \"linen\": [250,240,230,1],\n  \"magenta\": [255,0,255,1], \"maroon\": [128,0,0,1],\n  \"mediumaquamarine\": [102,205,170,1], \"mediumblue\": [0,0,205,1],\n  \"mediumorchid\": [186,85,211,1], \"mediumpurple\": [147,112,219,1],\n  \"mediumseagreen\": [60,179,113,1], \"mediumslateblue\": [123,104,238,1],\n  \"mediumspringgreen\": [0,250,154,1], \"mediumturquoise\": [72,209,204,1],\n  \"mediumvioletred\": [199,21,133,1], \"midnightblue\": [25,25,112,1],\n  \"mintcream\": [245,255,250,1], \"mistyrose\": [255,228,225,1],\n  \"moccasin\": [255,228,181,1], \"navajowhite\": [255,222,173,1],\n  \"navy\": [0,0,128,1], \"oldlace\": [253,245,230,1],\n  \"olive\": [128,128,0,1], \"olivedrab\": [107,142,35,1],\n  \"orange\": [255,165,0,1], \"orangered\": [255,69,0,1],\n  \"orchid\": [218,112,214,1], \"palegoldenrod\": [238,232,170,1],\n  \"palegreen\": [152,251,152,1], \"paleturquoise\": [175,238,238,1],\n  \"palevioletred\": [219,112,147,1], \"papayawhip\": [255,239,213,1],\n  \"peachpuff\": [255,218,185,1], \"peru\": [205,133,63,1],\n  \"pink\": [255,192,203,1], \"plum\": [221,160,221,1],\n  \"powderblue\": [176,224,230,1], \"purple\": [128,0,128,1],\n  \"rebeccapurple\": [102,51,153,1],\n  \"red\": [255,0,0,1], \"rosybrown\": [188,143,143,1],\n  \"royalblue\": [65,105,225,1], \"saddlebrown\": [139,69,19,1],\n  \"salmon\": [250,128,114,1], \"sandybrown\": [244,164,96,1],\n  \"seagreen\": [46,139,87,1], \"seashell\": [255,245,238,1],\n  \"sienna\": [160,82,45,1], \"silver\": [192,192,192,1],\n  \"skyblue\": [135,206,235,1], \"slateblue\": [106,90,205,1],\n  \"slategray\": [112,128,144,1], \"slategrey\": [112,128,144,1],\n  \"snow\": [255,250,250,1], \"springgreen\": [0,255,127,1],\n  \"steelblue\": [70,130,180,1], \"tan\": [210,180,140,1],\n  \"teal\": [0,128,128,1], \"thistle\": [216,191,216,1],\n  \"tomato\": [255,99,71,1], \"turquoise\": [64,224,208,1],\n  \"violet\": [238,130,238,1], \"wheat\": [245,222,179,1],\n  \"white\": [255,255,255,1], \"whitesmoke\": [245,245,245,1],\n  \"yellow\": [255,255,0,1], \"yellowgreen\": [154,205,50,1]}\n\nfunction clamp_css_byte(i) {  // Clamp to integer 0 .. 255.\n  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parse_css_int(str) {  // int or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_byte(parseFloat(str) / 100 * 255);\n  return clamp_css_byte(parseInt(str));\n}\n\nfunction parse_css_float(str) {  // float or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_float(parseFloat(str) / 100);\n  return clamp_css_float(parseFloat(str));\n}\n\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) h += 1;\n  else if (h > 1) h -= 1;\n\n  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n  if (h * 2 < 1) return m2;\n  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n  return m1;\n}\n\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.\n\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.\n      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n              (iv & 0xf0) | ((iv & 0xf0) >> 4),\n              (iv & 0xf) | ((iv & 0xf) << 4),\n              1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.\n      return [(iv & 0xff0000) >> 16,\n              (iv & 0xff00) >> 8,\n              iv & 0xff,\n              1];\n    }\n\n    return null;\n  }\n\n  var op = str.indexOf('('), ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op+1, ep-(op+1)).split(',');\n    var alpha = 1;  // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'rgb':\n        if (params.length !== 3) return null;\n        return [parse_css_int(params[0]),\n                parse_css_int(params[1]),\n                parse_css_int(params[2]),\n                alpha];\n      case 'hsla':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'hsl':\n        if (params.length !== 3) return null;\n        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),\n                alpha];\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\ntry { exports.parseCSSColor = parseCSSColor } catch(e) { }\n\n\n//# sourceURL=webpack:///./node_modules/csscolorparser/csscolorparser.js?");

/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(t,i){ true?module.exports=i():undefined}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n\n\n//# sourceURL=webpack:///./node_modules/rbush/rbush.min.js?");

/***/ }),

/***/ "./src/draggable-patch.ts":
/*!********************************!*\
  !*** ./src/draggable-patch.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2019-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * This patch is used to increase syncronization between Leaflat layer &\n * harp.gl. It delays position update (panning) for the time until frame is rendered.\n * Making a JS queue:\n * [1. Render frame (synchronous, takes time)] - [2. Update position (immediately)]\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst leaflet_1 = __webpack_require__(/*! leaflet */ \"leaflet\");\n// @ts-ignore\nconst oldUpdatePostition = leaflet_1.Draggable.prototype._updatePosition;\n// @ts-ignore\nleaflet_1.Draggable.prototype._updatePosition = function (...args) {\n    setTimeout(() => {\n        oldUpdatePostition.apply(this, args);\n    }, 0);\n};\n\n\n//# sourceURL=webpack:///./src/draggable-patch.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HarpGL = void 0;\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst leaflet_1 = __webpack_require__(/*! leaflet */ \"leaflet\");\n__webpack_require__(/*! ./draggable-patch */ \"./src/draggable-patch.ts\");\nconst GEO_COORD = new harp_geoutils_1.GeoCoordinates(0, 0);\nclass HarpGL extends leaflet_1.Layer {\n    constructor(m_options) {\n        super(m_options);\n        this.m_options = m_options;\n        this.onResize = () => {\n            const size = this._map.getSize();\n            this.m_glContainer.style.width = size.x + \"px\";\n            this.m_glContainer.style.height = size.y + \"px\";\n            this.m_mapView.resize(size.x, size.y);\n            this.resetTransform();\n        };\n    }\n    initialize() {\n        this.update();\n        this.resetTransform = this.resetTransform.bind(this);\n    }\n    getEvents() {\n        return {\n            move: this.resetTransform,\n            zoom: this.resetTransform,\n            zoomanim: (event) => {\n                const evt = event;\n                this.setTransform(evt.zoom, evt.center);\n            },\n        };\n    }\n    onAdd(map) {\n        if (!this.m_glContainer) {\n            this.initContainer();\n        }\n        this.getPane(\"mapPane\").appendChild(this.m_glContainer);\n        if (this.m_mapView === undefined) {\n            this.initMapView();\n        }\n        // ...\n        this.onResize();\n        map.on(\"resize\", this.onResize);\n        return this;\n    }\n    onRemove(map) {\n        map.off(\"resize\", this.onResize);\n        if (this.m_mapView !== undefined) {\n            this.m_mapView.dispose();\n            this.m_mapView = undefined;\n        }\n        if (this.m_glContainer !== undefined) {\n            this.m_glContainer.remove();\n            this.m_glContainer = undefined;\n        }\n        return this;\n    }\n    resetTransform() {\n        this.update();\n        this.setTransform(this._map.getZoom(), this._map.getCenter());\n    }\n    setTransform(toZoom, toCenter) {\n        const map = this._map;\n        const fromZoom = map.getZoom();\n        const scale = map.getZoomScale(toZoom, fromZoom);\n        const mapPanePos = leaflet_1.DomUtil.getPosition(this.getPane(\"mapPane\"));\n        const origin = map.getPixelOrigin().subtract(mapPanePos);\n        const newOrigin = map.project(toCenter, toZoom);\n        newOrigin.x -= this.m_glContainer.clientWidth / 2 || 0;\n        newOrigin.y -= this.m_glContainer.clientHeight / 2 || 0;\n        newOrigin.x = newOrigin.x + mapPanePos.x;\n        newOrigin.y = newOrigin.y + mapPanePos.y;\n        const translate = new leaflet_1.Point(Math.round(origin.x * scale - newOrigin.x), Math.round(origin.y * scale - newOrigin.y));\n        leaflet_1.DomUtil.setTransform(this.m_glContainer, translate, scale);\n    }\n    initContainer() {\n        const container = this._map.createPane(\"harpgl\");\n        container.style.zIndex = \"190\"; // put it under tilePane\n        const size = this._map.getSize();\n        container.style.width = size.x + \"px\";\n        container.style.height = size.y + \"px\";\n        leaflet_1.DomUtil.addClass(container, \"leaflet-zoom-animated\");\n        this.m_glContainer = container;\n    }\n    initMapView() {\n        const canvas = document.createElement(\"canvas\");\n        // this styles are needed to sync movement and zoom deltas with leaflet.\n        Object.assign(canvas.style, {\n            width: \"100%\",\n            height: \"100%\",\n        });\n        this.m_glContainer.appendChild(canvas);\n        this.m_mapView = new harp_mapview_1.MapView(Object.assign({ canvas }, this.m_options));\n    }\n    update() {\n        if (!this._map) {\n            return;\n        }\n        const zoom = this._map.getZoom();\n        const center = this._map.getCenter();\n        const cameraDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.m_mapView, zoom);\n        GEO_COORD.latitude = center.lat;\n        GEO_COORD.longitude = center.lng;\n        GEO_COORD.altitude = cameraDistance;\n        if (!geoCoordsSame(this.m_mapView.geoCenter, GEO_COORD)) {\n            // Triggers update of mapview.worldCenter\n            this.m_mapView.geoCenter = GEO_COORD;\n        }\n    }\n    get mapView() {\n        return this.m_mapView;\n    }\n}\nexports.HarpGL = HarpGL;\nfunction geoCoordsSame(a, b) {\n    return (equalsWithEpsilon(a.latitude, b.latitude) &&\n        equalsWithEpsilon(a.longitude, b.longitude) &&\n        ((typeof a.altitude === \"number\" &&\n            typeof b.altitude === \"number\" &&\n            equalsWithEpsilon(a.altitude, b.altitude)) ||\n            (a.altitude === undefined && typeof a.altitude === typeof b.altitude)));\n}\nfunction equalsWithEpsilon(a, b) {\n    return Math.abs(a - b) < 0.000000001;\n}\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "leaflet":
/*!********************!*\
  !*** external "L" ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = L;\n\n//# sourceURL=webpack:///external_%22L%22?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = THREE;\n\n//# sourceURL=webpack:///external_%22THREE%22?");

/***/ })

/******/ });