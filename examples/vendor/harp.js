var harp =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/rtree/lib/geojson.js":
/*!*******************************************************************************!*\
  !*** /Users/alex2401/vislib/mapsdk/coresdk/node_modules/rtree/lib/geojson.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var rectangle = __webpack_require__(/*! ./rectangle */ "../../node_modules/rtree/lib/rectangle.js");
var bbox = function (ar, obj) {
  if (obj && obj.bbox) {
    return {
      leaf: obj,
      x: obj.bbox[0],
      y: obj.bbox[1],
      w: obj.bbox[2] - obj.bbox[0],
      h: obj.bbox[3] - obj.bbox[1]
    };
  }
  var len = ar.length;
  var i = 0;
  var a = new Array(len);
  while (i < len) {
    a[i] = [ar[i][0], ar[i][1]];
    i++;
  }
  var first = a[0];
  len = a.length;
  i = 1;
  var temp = {
    min: [].concat(first),
    max: [].concat(first)
  };
  while (i < len) {
    if (a[i][0] < temp.min[0]) {
      temp.min[0] = a[i][0];
    }
    else if (a[i][0] > temp.max[0]) {
      temp.max[0] = a[i][0];
    }
    if (a[i][1] < temp.min[1]) {
      temp.min[1] = a[i][1];
    }
    else if (a[i][1] > temp.max[1]) {
      temp.max[1] = a[i][1];
    }
    i++;
  }
  var out = {
    x: temp.min[0],
    y: temp.min[1],
    w: (temp.max[0] - temp.min[0]),
    h: (temp.max[1] - temp.min[1])
  };
  if (obj) {
    out.leaf = obj;
  }
  return out;
};
var geoJSON = {};
geoJSON.point = function (obj, self) {
  return (self.insertSubtree({
    x: obj.geometry.coordinates[0],
    y: obj.geometry.coordinates[1],
    w: 0,
    h: 0,
    leaf: obj
  }, self.root));
};
geoJSON.multiPointLineString = function (obj, self) {
  return (self.insertSubtree(bbox(obj.geometry.coordinates, obj), self.root));
};
geoJSON.multiLineStringPolygon = function (obj, self) {
  return (self.insertSubtree(bbox(Array.prototype.concat.apply([], obj.geometry.coordinates), obj), self.root));
};
geoJSON.multiPolygon = function (obj, self) {
  return (self.insertSubtree(bbox(Array.prototype.concat.apply([], Array.prototype.concat.apply([], obj.geometry.coordinates)), obj), self.root));
};
geoJSON.makeRec = function (obj) {
  return rectangle(obj.x, obj.y, obj.w, obj.h);
};
geoJSON.geometryCollection = function (obj, self) {
  if (obj.bbox) {
    return (self.insertSubtree({
      leaf: obj,
      x: obj.bbox[0],
      y: obj.bbox[1],
      w: obj.bbox[2] - obj.bbox[0],
      h: obj.bbox[3] - obj.bbox[1]
    }, self.root));
  }
  var geos = obj.geometry.geometries;
  var i = 0;
  var len = geos.length;
  var temp = [];
  var g;
  while (i < len) {
    g = geos[i];
    switch (g.type) {
    case 'Point':
      temp.push(geoJSON.makeRec({
        x: g.coordinates[0],
        y: g.coordinates[1],
        w: 0,
        h: 0
      }));
      break;
    case 'MultiPoint':
      temp.push(geoJSON.makeRec(bbox(g.coordinates)));
      break;
    case 'LineString':
      temp.push(geoJSON.makeRec(bbox(g.coordinates)));
      break;
    case 'MultiLineString':
      temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], g.coordinates))));
      break;
    case 'Polygon':
      temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], g.coordinates))));
      break;
    case 'MultiPolygon':
      temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], Array.prototype.concat.apply([], g.coordinates)))));
      break;
    case 'GeometryCollection':
      geos = geos.concat(g.geometries);
      len = geos.length;
      break;
    }
    i++;
  }
  var first = temp[0];
  i = 1;
  len = temp.length;
  while (i < len) {
    first.expand(temp[i]);
    i++;
  }
  return self.insertSubtree({
    leaf: obj,
    x: first.x(),
    y: first.y(),
    h: first.h(),
    w: first.w()
  }, self.root);
};
exports.geoJSON = function (prelim) {
  var that = this;
  var features, feature;
  if (Array.isArray(prelim)) {
    features = prelim.slice();
  }
  else if (prelim.features && Array.isArray(prelim.features)) {
    features = prelim.features.slice();
  }
  else if (prelim instanceof Object) {
    features = [prelim];
  } else {
    throw ('this isn\'t what we\'re looking for');
  }
  var len = features.length;
  var i = 0;
  while (i < len) {
    feature = features[i];
    if (feature.type === 'Feature') {
      switch (feature.geometry.type) {
      case 'Point':
        geoJSON.point(feature, that);
        break;
      case 'MultiPoint':
        geoJSON.multiPointLineString(feature, that);
        break;
      case 'LineString':
        geoJSON.multiPointLineString(feature, that);
        break;
      case 'MultiLineString':
        geoJSON.multiLineStringPolygon(feature, that);
        break;
      case 'Polygon':
        geoJSON.multiLineStringPolygon(feature, that);
        break;
      case 'MultiPolygon':
        geoJSON.multiPolygon(feature, that);
        break;
      case 'GeometryCollection':
        geoJSON.geometryCollection(feature, that);
        break;
      }
    }
    i++;
  }
};
exports.bbox = function () {
  var x1, y1, x2, y2;
  switch (arguments.length) {
  case 1:
    x1 = arguments[0][0][0];
    y1 = arguments[0][0][1];
    x2 = arguments[0][1][0];
    y2 = arguments[0][1][1];
    break;
  case 2:
    x1 = arguments[0][0];
    y1 = arguments[0][1];
    x2 = arguments[1][0];
    y2 = arguments[1][1];
    break;
  case 4:
    x1 = arguments[0];
    y1 = arguments[1];
    x2 = arguments[2];
    y2 = arguments[3];
    break;
  }

  return this.search({
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1
  });
};


/***/ }),

/***/ "../../node_modules/rtree/lib/index.js":
/*!*****************************************************************************!*\
  !*** /Users/alex2401/vislib/mapsdk/coresdk/node_modules/rtree/lib/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RTree = __webpack_require__(/*! ./rtree */ "../../node_modules/rtree/lib/rtree.js");
var geojson = __webpack_require__(/*! ./geojson */ "../../node_modules/rtree/lib/geojson.js");
RTree.prototype.bbox = geojson.bbox;
RTree.prototype.geoJSON = geojson.geoJSON;
RTree.Rectangle = __webpack_require__(/*! ./rectangle */ "../../node_modules/rtree/lib/rectangle.js");
module.exports = RTree;

/***/ }),

/***/ "../../node_modules/rtree/lib/rectangle.js":
/*!*********************************************************************************!*\
  !*** /Users/alex2401/vislib/mapsdk/coresdk/node_modules/rtree/lib/rectangle.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function Rectangle(x, y, w, h) { // new Rectangle(bounds) or new Rectangle(x, y, w, h)
  if (!(this instanceof Rectangle)) {
    return new Rectangle(x, y, w, h);
  }
  var x2, y2, p;

  if (x.x) {
    w = x.w;
    h = x.h;
    y = x.y;
    if (x.w !== 0 && !x.w && x.x2) {
      w = x.x2 - x.x;
      h = x.y2 - x.y;
    }
    else {
      w = x.w;
      h = x.h;
    }
    x = x.x;
    // For extra fastitude
    x2 = x + w;
    y2 = y + h;
    p = (h + w) ? false : true;
  }
  else {
    // For extra fastitude
    x2 = x + w;
    y2 = y + h;
    p = (h + w) ? false : true;
  }

  this.x1 = this.x = function () {
    return x;
  };
  this.y1 = this.y = function () {
    return y;
  };
  this.x2 = function () {
    return x2;
  };
  this.y2 = function () {
    return y2;
  };
  this.w = function () {
    return w;
  };
  this.h = function () {
    return h;
  };
  this.p = function () {
    return p;
  };

  this.overlap = function (a) {
    if (p || a.p()) {
      return x <= a.x2() && x2 >= a.x() && y <= a.y2() && y2 >= a.y();
    }
    return x < a.x2() && x2 > a.x() && y < a.y2() && y2 > a.y();
  };

  this.expand = function (a) {
    var nx, ny;
    var ax = a.x();
    var ay = a.y();
    var ax2 = a.x2();
    var ay2 = a.y2();
    if (x > ax) {
      nx = ax;
    }
    else {
      nx = x;
    }
    if (y > ay) {
      ny = ay;
    }
    else {
      ny = y;
    }
    if (x2 > ax2) {
      w = x2 - nx;
    }
    else {
      w = ax2 - nx;
    }
    if (y2 > ay2) {
      h = y2 - ny;
    }
    else {
      h = ay2 - ny;
    }
    x = nx;
    y = ny;
    return this;
  };

  //End of RTree.Rectangle
}


/* returns true if rectangle 1 overlaps rectangle 2
 * [ boolean ] = overlapRectangle(rectangle a, rectangle b)
 * @static function
 */
Rectangle.overlapRectangle = function (a, b) {
  //if(!((a.h||a.w)&&(b.h||b.w))){ not faster resist the urge!
  if ((a.h === 0 && a.w === 0) || (b.h === 0 && b.w === 0)) {
    return a.x <= (b.x + b.w) && (a.x + a.w) >= b.x && a.y <= (b.y + b.h) && (a.y + a.h) >= b.y;
  }
  else {
    return a.x < (b.x + b.w) && (a.x + a.w) > b.x && a.y < (b.y + b.h) && (a.y + a.h) > b.y;
  }
};

/* returns true if rectangle a is contained in rectangle b
 * [ boolean ] = containsRectangle(rectangle a, rectangle b)
 * @static function
 */
Rectangle.containsRectangle = function (a, b) {
  return (a.x + a.w) <= (b.x + b.w) && a.x >= b.x && (a.y + a.h) <= (b.y + b.h) && a.y >= b.y;
};

/* expands rectangle A to include rectangle B, rectangle B is untouched
 * [ rectangle a ] = expandRectangle(rectangle a, rectangle b)
 * @static function
 */
Rectangle.expandRectangle = function (a, b) {
  var nx, ny;
  var axw = a.x + a.w;
  var bxw = b.x + b.w;
  var ayh = a.y + a.h;
  var byh = b.y + b.h;
  if (a.x > b.x) {
    nx = b.x;
  }
  else {
    nx = a.x;
  }
  if (a.y > b.y) {
    ny = b.y;
  }
  else {
    ny = a.y;
  }
  if (axw > bxw) {
    a.w = axw - nx;
  }
  else {
    a.w = bxw - nx;
  }
  if (ayh > byh) {
    a.h = ayh - ny;
  }
  else {
    a.h = byh - ny;
  }
  a.x = nx;
  a.y = ny;
  return a;
};

/* generates a minimally bounding rectangle for all rectangles in
 * array 'nodes'. If rect is set, it is modified into the MBR. Otherwise,
 * a new rectangle is generated and returned.
 * [ rectangle a ] = makeMBR(rectangle array nodes, rectangle rect)
 * @static function
 */
Rectangle.makeMBR = function (nodes, rect) {
  if (!nodes.length) {
    return {
      x: 0,
      y: 0,
      w: 0,
      h: 0
    };
  }
  rect = rect || {};
  rect.x = nodes[0].x;
  rect.y = nodes[0].y;
  rect.w = nodes[0].w;
  rect.h = nodes[0].h;

  for (var i = 1, len = nodes.length; i < len; i++) {
    Rectangle.expandRectangle(rect, nodes[i]);
  }

  return rect;
};
Rectangle.squarifiedRatio = function (l, w, fill) {
  // Area of new enlarged rectangle
  var lperi = (l + w) / 2.0; // Average size of a side of the new rectangle
  var larea = l * w; // Area of new rectangle
  // return the ratio of the perimeter to the area - the closer to 1 we are,
  // the more 'square' a rectangle is. conversly, when approaching zero the
  // more elongated a rectangle is
  var lgeo = larea / (lperi * lperi);
  return larea * fill / lgeo;
};
module.exports = Rectangle;

/***/ }),

/***/ "../../node_modules/rtree/lib/rtree.js":
/*!*****************************************************************************!*\
  !*** /Users/alex2401/vislib/mapsdk/coresdk/node_modules/rtree/lib/rtree.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var rectangle = __webpack_require__(/*! ./rectangle */ "../../node_modules/rtree/lib/rectangle.js");
function RTree(width) {
  if (!(this instanceof RTree)) {
    return new RTree(width);
  }
  // Variables to control tree-dimensions
  var minWidth = 3;  // Minimum width of any node before a merge
  var maxWidth = 6;  // Maximum width of any node before a split
  if (!isNaN(width)) {
    minWidth = Math.floor(width / 2.0);
    maxWidth = width;
  }
  // Start with an empty root-tree
  var rootTree = {x: 0, y: 0, w: 0, h: 0, id: 'root', nodes: [] };
  this.root = rootTree;


  // This is my special addition to the world of r-trees
  // every other (simple) method I found produced crap trees
  // this skews insertions to prefering squarer and emptier nodes
  var flatten = function (tree) {
    var todo = tree.slice();
    var done = [];
    var current;
    while (todo.length) {
      current = todo.pop();
      if (current.nodes) {
        todo = todo.concat(current.nodes);
      } else if (current.leaf) {
        done.push(current);
      }
    }
    return done;
  };
  /* find the best specific node(s) for object to be deleted from
   * [ leaf node parent ] = removeSubtree(rectangle, object, root)
   * @private
   */
  var removeSubtree = function (rect, obj, root) {
    var hitStack = []; // Contains the elements that overlap
    var countStack = []; // Contains the elements that overlap
    var retArray = [];
    var currentDepth = 1;
    var tree, i, ltree;
    if (!rect || !rectangle.overlapRectangle(rect, root)) {
      return retArray;
    }
    var retObj = {x: rect.x, y: rect.y, w: rect.w, h: rect.h, target: obj};

    countStack.push(root.nodes.length);
    hitStack.push(root);
    while (hitStack.length > 0) {
      tree = hitStack.pop();
      i = countStack.pop() - 1;
      if ('target' in retObj) { // will this ever be false?
        while (i >= 0) {
          ltree = tree.nodes[i];
          if (rectangle.overlapRectangle(retObj, ltree)) {
            if ((retObj.target && 'leaf' in ltree && ltree.leaf === retObj.target) || (!retObj.target && ('leaf' in ltree || rectangle.containsRectangle(ltree, retObj)))) {
              // A Match !!
            // Yup we found a match...
            // we can cancel search and start walking up the list
              if ('nodes' in ltree) {// If we are deleting a node not a leaf...
                retArray = flatten(tree.nodes.splice(i, 1));
              } else {
                retArray = tree.nodes.splice(i, 1);
              }
              // Resize MBR down...
              rectangle.makeMBR(tree.nodes, tree);
              delete retObj.target;
              //if (tree.nodes.length < minWidth) { // Underflow
              //  retObj.nodes = searchSubtree(tree, true, [], tree);
              //}
              break;
            } else if ('nodes' in ltree) { // Not a Leaf
              currentDepth++;
              countStack.push(i);
              hitStack.push(tree);
              tree = ltree;
              i = ltree.nodes.length;
            }
          }
          i--;
        }

      } else if ('nodes' in retObj) { // We are unsplitting

        tree.nodes.splice(i + 1, 1); // Remove unsplit node
        if (tree.nodes.length > 0) {
          rectangle.makeMBR(tree.nodes, tree);
        }
        for (var t = 0;t < retObj.nodes.length;t++) {
          insertSubtree(retObj.nodes[t], tree);
        }
        retObj.nodes = [];
        if (hitStack.length === 0 && tree.nodes.length <= 1) { // Underflow..on root!
          retObj.nodes = searchSubtree(tree, true, retObj.nodes, tree);
          tree.nodes = [];
          hitStack.push(tree);
          countStack.push(1);
        } else if (hitStack.length > 0 && tree.nodes.length < minWidth) { // Underflow..AGAIN!
          retObj.nodes = searchSubtree(tree, true, retObj.nodes, tree);
          tree.nodes = [];
        } else {
          delete retObj.nodes; // Just start resizing
        }
      } else { // we are just resizing
        rectangle.makeMBR(tree.nodes, tree);
      }
      currentDepth -= 1;
    }
    return retArray;
  };

  /* choose the best damn node for rectangle to be inserted into
   * [ leaf node parent ] = chooseLeafSubtree(rectangle, root to start search at)
   * @private
   */
  var chooseLeafSubtree = function (rect, root) {
    var bestChoiceIndex = -1;
    var bestChoiceStack = [];
    var bestChoiceArea;
    var first = true;
    bestChoiceStack.push(root);
    var nodes = root.nodes;

    while (first || bestChoiceIndex !== -1) {
      if (first) {
        first = false;
      } else {
        bestChoiceStack.push(nodes[bestChoiceIndex]);
        nodes = nodes[bestChoiceIndex].nodes;
        bestChoiceIndex = -1;
      }

      for (var i = nodes.length - 1; i >= 0; i--) {
        var ltree = nodes[i];
        if ('leaf' in ltree) {
          // Bail out of everything and start inserting
          bestChoiceIndex = -1;
          break;
        }
        // Area of new enlarged rectangle
        var oldLRatio = rectangle.squarifiedRatio(ltree.w, ltree.h, ltree.nodes.length + 1);

        // Enlarge rectangle to fit new rectangle
        var nw = Math.max(ltree.x + ltree.w, rect.x + rect.w) - Math.min(ltree.x, rect.x);
        var nh = Math.max(ltree.y + ltree.h, rect.y + rect.h) - Math.min(ltree.y, rect.y);

        // Area of new enlarged rectangle
        var lratio = rectangle.squarifiedRatio(nw, nh, ltree.nodes.length + 2);

        if (bestChoiceIndex < 0 || Math.abs(lratio - oldLRatio) < bestChoiceArea) {
          bestChoiceArea = Math.abs(lratio - oldLRatio);
          bestChoiceIndex = i;
        }
      }
    }

    return bestChoiceStack;
  };

  /* split a set of nodes into two roughly equally-filled nodes
   * [ an array of two new arrays of nodes ] = linearSplit(array of nodes)
   * @private
   */
  var linearSplit = function (nodes) {
    var n = pickLinear(nodes);
    while (nodes.length > 0) {
      pickNext(nodes, n[0], n[1]);
    }
    return n;
  };

  /* insert the best source rectangle into the best fitting parent node: a or b
   * [] = pickNext(array of source nodes, target node array a, target node array b)
   * @private
   */
  var pickNext = function (nodes, a, b) {
  // Area of new enlarged rectangle
    var areaA = rectangle.squarifiedRatio(a.w, a.h, a.nodes.length + 1);
    var areaB = rectangle.squarifiedRatio(b.w, b.h, b.nodes.length + 1);
    var highAreaDelta;
    var highAreaNode;
    var lowestGrowthGroup;

    for (var i = nodes.length - 1; i >= 0;i--) {
      var l = nodes[i];
      var newAreaA = {};
      newAreaA.x = Math.min(a.x, l.x);
      newAreaA.y = Math.min(a.y, l.y);
      newAreaA.w = Math.max(a.x + a.w, l.x + l.w) - newAreaA.x;
      newAreaA.h = Math.max(a.y + a.h, l.y + l.h) - newAreaA.y;
      var changeNewAreaA = Math.abs(rectangle.squarifiedRatio(newAreaA.w, newAreaA.h, a.nodes.length + 2) - areaA);

      var newAreaB = {};
      newAreaB.x = Math.min(b.x, l.x);
      newAreaB.y = Math.min(b.y, l.y);
      newAreaB.w = Math.max(b.x + b.w, l.x + l.w) - newAreaB.x;
      newAreaB.h = Math.max(b.y + b.h, l.y + l.h) - newAreaB.y;
      var changeNewAreaB = Math.abs(rectangle.squarifiedRatio(newAreaB.w, newAreaB.h, b.nodes.length + 2) - areaB);

      if (!highAreaNode || !highAreaDelta || Math.abs(changeNewAreaB - changeNewAreaA) < highAreaDelta) {
        highAreaNode = i;
        highAreaDelta = Math.abs(changeNewAreaB - changeNewAreaA);
        lowestGrowthGroup = changeNewAreaB < changeNewAreaA ? b : a;
      }
    }
    var tempNode = nodes.splice(highAreaNode, 1)[0];
    if (a.nodes.length + nodes.length + 1 <= minWidth) {
      a.nodes.push(tempNode);
      rectangle.expandRectangle(a, tempNode);
    }  else if (b.nodes.length + nodes.length + 1 <= minWidth) {
      b.nodes.push(tempNode);
      rectangle.expandRectangle(b, tempNode);
    }
    else {
      lowestGrowthGroup.nodes.push(tempNode);
      rectangle.expandRectangle(lowestGrowthGroup, tempNode);
    }
  };

  /* pick the 'best' two starter nodes to use as seeds using the 'linear' criteria
   * [ an array of two new arrays of nodes ] = pickLinear(array of source nodes)
   * @private
   */
  var pickLinear = function (nodes) {
    var lowestHighX = nodes.length - 1;
    var highestLowX = 0;
    var lowestHighY = nodes.length - 1;
    var highestLowY = 0;
    var t1, t2;

    for (var i = nodes.length - 2; i >= 0;i--) {
      var l = nodes[i];
      if (l.x > nodes[highestLowX].x) {
        highestLowX = i;
      } else if (l.x + l.w < nodes[lowestHighX].x + nodes[lowestHighX].w) {
        lowestHighX = i;
      }
      if (l.y > nodes[highestLowY].y) {
        highestLowY = i;
      } else if (l.y + l.h < nodes[lowestHighY].y + nodes[lowestHighY].h) {
        lowestHighY = i;
      }
    }
    var dx = Math.abs((nodes[lowestHighX].x + nodes[lowestHighX].w) - nodes[highestLowX].x);
    var dy = Math.abs((nodes[lowestHighY].y + nodes[lowestHighY].h) - nodes[highestLowY].y);
    if (dx > dy)  {
      if (lowestHighX > highestLowX)  {
        t1 = nodes.splice(lowestHighX, 1)[0];
        t2 = nodes.splice(highestLowX, 1)[0];
      }  else {
        t2 = nodes.splice(highestLowX, 1)[0];
        t1 = nodes.splice(lowestHighX, 1)[0];
      }
    }  else {
      if (lowestHighY > highestLowY)  {
        t1 = nodes.splice(lowestHighY, 1)[0];
        t2 = nodes.splice(highestLowY, 1)[0];
      }  else {
        t2 = nodes.splice(highestLowY, 1)[0];
        t1 = nodes.splice(lowestHighY, 1)[0];
      }
    }
    return [
      {x: t1.x, y: t1.y, w: t1.w, h: t1.h, nodes: [t1]},
      {x: t2.x, y: t2.y, w: t2.w, h: t2.h, nodes: [t2]}
    ];
  };

  var attachData = function (node, moreTree) {
    node.nodes = moreTree.nodes;
    node.x = moreTree.x;
    node.y = moreTree.y;
    node.w = moreTree.w;
    node.h = moreTree.h;
    return node;
  };

  /* non-recursive internal search function
  * [ nodes | objects ] = searchSubtree(rectangle, [return node data], [array to fill], root to begin search at)
   * @private
   */
  var searchSubtree = function (rect, returnNode, returnArray, root) {
    var hitStack = []; // Contains the elements that overlap

    if (!rectangle.overlapRectangle(rect, root)) {
      return returnArray;
    }


    hitStack.push(root.nodes);

    while (hitStack.length > 0) {
      var nodes = hitStack.pop();

      for (var i = nodes.length - 1; i >= 0; i--) {
        var ltree = nodes[i];
        if (rectangle.overlapRectangle(rect, ltree)) {
          if ('nodes' in ltree) { // Not a Leaf
            hitStack.push(ltree.nodes);
          } else if ('leaf' in ltree) { // A Leaf !!
            if (!returnNode) {
              returnArray.push(ltree.leaf);
            } else {
              returnArray.push(ltree);
            }
          }
        }
      }
    }

    return returnArray;
  };

  /* non-recursive internal insert function
   * [] = insertSubtree(rectangle, object to insert, root to begin insertion at)
   * @private
   */
  var insertSubtree = function (node, root) {
    var bc; // Best Current node
    // Initial insertion is special because we resize the Tree and we don't
    // care about any overflow (seriously, how can the first object overflow?)
    if (root.nodes.length === 0) {
      root.x = node.x;
      root.y = node.y;
      root.w = node.w;
      root.h = node.h;
      root.nodes.push(node);
      return;
    }

    // Find the best fitting leaf node
    // chooseLeaf returns an array of all tree levels (including root)
    // that were traversed while trying to find the leaf
    var treeStack = chooseLeafSubtree(node, root);
    var retObj = node;//{x:rect.x,y:rect.y,w:rect.w,h:rect.h, leaf:obj};
    var pbc;
    // Walk back up the tree resizing and inserting as needed
    while (treeStack.length > 0) {
      //handle the case of an empty node (from a split)
      if (bc && 'nodes' in bc && bc.nodes.length === 0) {
        pbc = bc; // Past bc
        bc = treeStack.pop();
        for (var t = 0;t < bc.nodes.length;t++) {
          if (bc.nodes[t] === pbc || bc.nodes[t].nodes.length === 0) {
            bc.nodes.splice(t, 1);
            break;
          }
        }
      } else {
        bc = treeStack.pop();
      }

      // If there is data attached to this retObj
      if ('leaf' in retObj || 'nodes' in retObj || Array.isArray(retObj)) {
        // Do Insert
        if (Array.isArray(retObj)) {
          for (var ai = 0; ai < retObj.length; ai++) {
            rectangle.expandRectangle(bc, retObj[ai]);
          }
          bc.nodes = bc.nodes.concat(retObj);
        } else {
          rectangle.expandRectangle(bc, retObj);
          bc.nodes.push(retObj); // Do Insert
        }

        if (bc.nodes.length <= maxWidth)  { // Start Resizeing Up the Tree
          retObj = {x: bc.x, y: bc.y, w: bc.w, h: bc.h};
        }  else { // Otherwise Split this Node
          // linearSplit() returns an array containing two new nodes
          // formed from the split of the previous node's overflow
          var a = linearSplit(bc.nodes);
          retObj = a;//[1];

          if (treeStack.length < 1)  { // If are splitting the root..
            bc.nodes.push(a[0]);
            treeStack.push(bc);  // Reconsider the root element
            retObj = a[1];
          } /*else {
            delete bc;
          }*/
        }
      } else { // Otherwise Do Resize
        //Just keep applying the new bounding rectangle to the parents..
        rectangle.expandRectangle(bc, retObj);
        retObj = {x: bc.x, y: bc.y, w: bc.w, h: bc.h};
      }
    }
  };

  this.insertSubtree = insertSubtree;
  /* quick 'n' dirty function for plugins or manually drawing the tree
   * [ tree ] = RTree.getTree(): returns the raw tree data. useful for adding
   * @public
   * !! DEPRECATED !!
   */
  this.getTree = function () {
    return rootTree;
  };

  /* quick 'n' dirty function for plugins or manually loading the tree
   * [ tree ] = RTree.setTree(sub-tree, where to attach): returns the raw tree data. useful for adding
   * @public
   * !! DEPRECATED !!
   */
  this.setTree = function (newTree, where) {
    if (!where) {
      where = rootTree;
    }
    return attachData(where, newTree);
  };

  /* non-recursive search function
  * [ nodes | objects ] = RTree.search(rectangle, [return node data], [array to fill])
   * @public
   */
  this.search = function (rect, returnNode, returnArray) {
    returnArray = returnArray || [];
    return searchSubtree(rect, returnNode, returnArray, rootTree);
  };


  var removeArea = function (rect) {
    var numberDeleted = 1,
    retArray = [],
    deleted;
    while (numberDeleted > 0) {
      deleted = removeSubtree(rect, false, rootTree);
      numberDeleted = deleted.length;
      retArray = retArray.concat(deleted);
    }
    return retArray;
  };

  var removeObj = function (rect, obj) {
    var retArray = removeSubtree(rect, obj, rootTree);
    return retArray;
  };
    /* non-recursive delete function
   * [deleted object] = RTree.remove(rectangle, [object to delete])
   */
  this.remove = function (rect, obj) {
    if (!obj || typeof obj === 'function') {
      return removeArea(rect, obj);
    } else {
      return removeObj(rect, obj);
    }
  };

  /* non-recursive insert function
   * [] = RTree.insert(rectangle, object to insert)
   */
  this.insert = function (rect, obj) {
    var retArray = insertSubtree({x: rect.x, y: rect.y, w: rect.w, h: rect.h, leaf: obj}, rootTree);
    return retArray;
  };
}
RTree.prototype.toJSON = function (printing) {
  return JSON.stringify(this.root, false, printing);
};

RTree.fromJSON = function (json) {
  var rt = new RTree();
  rt.setTree(JSON.parse(json));
  return rt;
};

module.exports = RTree;


/**
 * Polyfill for the Array.isArray function
 * todo: Test on IE7 and IE8
 * Taken from https://github.com/geraintluff/tv4/issues/20
 */
if (typeof Array.isArray !== 'function') {
  Array.isArray = function (a) {
    return typeof a === 'object' && {}.toString.call(a) === '[object Array]';
  };
}


/***/ }),

/***/ "../harp-datasource-protocol/index-decoder.ts":
/*!****************************************************!*\
  !*** ../harp-datasource-protocol/index-decoder.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/StyleSetEvaluator */ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts"));
__export(__webpack_require__(/*! ./lib/Extruder */ "../harp-datasource-protocol/lib/Extruder.ts"));
__export(__webpack_require__(/*! ./lib/Outliner */ "../harp-datasource-protocol/lib/Outliner.ts"));
__export(__webpack_require__(/*! ./lib/Expr */ "../harp-datasource-protocol/lib/Expr.ts"));


/***/ }),

/***/ "../harp-datasource-protocol/index.ts":
/*!********************************************!*\
  !*** ../harp-datasource-protocol/index.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Techniques */ "../harp-datasource-protocol/lib/Techniques.ts"));
__export(__webpack_require__(/*! ./lib/TechniqueParams */ "../harp-datasource-protocol/lib/TechniqueParams.ts"));
__export(__webpack_require__(/*! ./lib/Theme */ "../harp-datasource-protocol/lib/Theme.ts"));
__export(__webpack_require__(/*! ./lib/InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts"));
__export(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts"));
__export(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ "../harp-datasource-protocol/lib/WorkerServiceProtocol.ts"));
__export(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ "../harp-datasource-protocol/lib/WorkerTilerProtocol.ts"));
__export(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ "../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts"));
__export(__webpack_require__(/*! ./lib/DecodedTile */ "../harp-datasource-protocol/lib/DecodedTile.ts"));
__export(__webpack_require__(/*! ./lib/TileInfo */ "../harp-datasource-protocol/lib/TileInfo.ts"));
__export(__webpack_require__(/*! ./lib/ThemeVisitor */ "../harp-datasource-protocol/lib/ThemeVisitor.ts"));
__export(__webpack_require__(/*! ./lib/StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts"));


/***/ }),

/***/ "../harp-datasource-protocol/lib/DecodedTile.ts":
/*!******************************************************!*\
  !*** ../harp-datasource-protocol/lib/DecodedTile.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
/**
 * Returns an array with the data type specified as parameter.
 *
 * @param attr specifies which type of data is being stored in the array
 */
function getArrayConstructor(attr) {
    switch (attr) {
        case "float":
            return Float32Array;
        case "uint8":
            return Uint8Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
        case "int8":
            return Int8Array;
        case "int16":
            return Int16Array;
        case "int32":
            return Int32Array;
    }
}
exports.getArrayConstructor = getArrayConstructor;
/**
 * Geometry types supported by [[Geometry]] objects.
 */
var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["Unspecified"] = 0] = "Unspecified";
    GeometryType[GeometryType["Point"] = 1] = "Point";
    GeometryType[GeometryType["Line"] = 2] = "Line";
    GeometryType[GeometryType["SolidLine"] = 3] = "SolidLine";
    GeometryType[GeometryType["Text"] = 4] = "Text";
    GeometryType[GeometryType["TextPath"] = 5] = "TextPath";
    GeometryType[GeometryType["ExtrudedLine"] = 6] = "ExtrudedLine";
    GeometryType[GeometryType["Polygon"] = 7] = "Polygon";
    GeometryType[GeometryType["ExtrudedPolygon"] = 8] = "ExtrudedPolygon";
    GeometryType[GeometryType["Object3D"] = 9] = "Object3D";
    GeometryType[GeometryType["Other"] = 1000] = "Other";
})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));
/**
 * Returns the projection object specified in the parameter.
 *
 * @param projectionName string describing projection to be used
 */
function getProjection(projectionName) {
    switch (projectionName) {
        case "mercator":
            return harp_geoutils_1.mercatorProjection;
        case "webMercator":
            return harp_geoutils_1.webMercatorProjection;
        case "sphere":
            return harp_geoutils_1.sphereProjection;
        case "normalizedEquirectangular":
            return harp_geoutils_1.normalizedEquirectangularProjection;
        case "equirectangular":
            return harp_geoutils_1.equirectangularProjection;
        default:
            throw new Error(`Unknown projection ${projectionName}`);
    } // switch
}
exports.getProjection = getProjection;
/**
 * String with the projection's name.
 *
 * @param projection `Projection` object containing the name of the projection to retrieve
 */
function getProjectionName(projection) {
    if (projection === harp_geoutils_1.mercatorProjection) {
        return "mercator";
    }
    else if (projection === harp_geoutils_1.webMercatorProjection) {
        return "webMercator";
    }
    else if (projection === harp_geoutils_1.sphereProjection) {
        return "sphere";
    }
    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    }
    else if (projection === harp_geoutils_1.equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
exports.getProjectionName = getProjectionName;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExponentialInterpolant.ts":
/*!*****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExponentialInterpolant.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
class ExponentialInterpolant extends three_1.Interpolant {
    constructor() {
        super(...arguments);
        /**
         * Exponent value. Defaults to `2.0`.
         */
        this.exponent = 2.0;
    }
    // Note: We need to disable linting here as tslint thinks this function is never used, though it
    // indeed is called by ``Interpolant.evaluate(level)``.
    // tslint:disable-next-line
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer;
        // TODO: Remove when Interpolant types are fixed.
        const values = this.sampleValues;
        const stride = this.valueSize;
        const offset1 = i1 * stride;
        const offset0 = offset1 - stride;
        const weight1 = Math.pow((t - t0) / (t1 - t0), this.exponent);
        const weight0 = 1 - weight1;
        for (let i = 0; i !== stride; ++i) {
            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        }
        return result;
    }
}
exports.ExponentialInterpolant = ExponentialInterpolant;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Expr.ts":
/*!***********************************************!*\
  !*** ../harp-datasource-protocol/lib/Expr.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ "../harp-datasource-protocol/lib/ExprEvaluator.ts");
const ExprParser_1 = __webpack_require__(/*! ./ExprParser */ "../harp-datasource-protocol/lib/ExprParser.ts");
const exprEvaluator = new ExprEvaluator_1.ExprEvaluator();
/**
 * Abstract class defining a shape of a [[Theme]]'s expression
 */
class Expr {
    /**
     * Creates an expression from the given `code`.
     *
     * @param code The code to parse.
     * @returns The parsed [[Expr]].
     */
    static parse(code) {
        const parser = new ExprParser_1.ExprParser(code);
        const expr = parser.parse();
        return expr;
    }
    static fromJSON(node) {
        if (Array.isArray(node)) {
            return Expr.parseCall(node);
        }
        else if (node === null) {
            return NullLiteralExpr.instance;
        }
        else if (typeof node === "boolean") {
            return new BooleanLiteralExpr(node);
        }
        else if (typeof node === "number") {
            return new NumberLiteralExpr(node);
        }
        else if (typeof node === "string") {
            return new StringLiteralExpr(node);
        }
        throw new Error("failed to create expression");
    }
    static parseCall(node) {
        const op = node[0];
        if (typeof op !== "string") {
            throw new Error("expected a builtin function name");
        }
        switch (op) {
            case "get":
                if (typeof node[1] !== "string") {
                    throw new Error(`expected the name of an attribute`);
                }
                return new VarExpr(node[1]);
            case "has":
                if (typeof node[1] !== "string") {
                    throw new Error(`expected the name of an attribute`);
                }
                return new HasAttributeExpr(node[1]);
            case "in":
                const elements = node[2];
                if (!Array.isArray(elements)) {
                    // tslint:disable-next-line: max-line-length
                    throw new Error(`'${op}' expects an expression followed by an array of literals`);
                }
                elements.forEach(element => {
                    if (typeof element === "object" || typeof element === "function") {
                        throw new Error("expected an array of constant values");
                    }
                });
                return new ContainsExpr(this.fromJSON(node[1]), elements);
            default:
                return new CallExpr(op, node.slice(1).map(childExpr => this.fromJSON(childExpr)));
        } // switch
    }
    /**
     * Evaluate an expression returning a [[Value]] object.
     *
     * @param env The [[Env]] used to lookup symbols.
     * @param cache A cache of previously computed results.
     */
    evaluate(env, cache) {
        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, cache));
    }
    /**
     * Create a unique object that is structurally equivalent to this [[Expr]].
     *
     * @param pool The [[ExprPool]] used to create a unique
     * equivalent object of this [[Expr]].
     */
    intern(pool) {
        return pool.add(this);
    }
    toJSON() {
        return new ExprSerializer().serialize(this);
    }
}
exports.Expr = Expr;
/**
 * @hidden
 */
class Env {
    /**
     * Returns property in [[Env]] by name.
     *
     * @param name Name of property.
     */
    lookup(_name) {
        return undefined;
    }
    /**
     * Return an object containing all properties of this environment. (Here: empty object).
     */
    unmap() {
        return {};
    }
}
exports.Env = Env;
/**
 * Adds access to map specific environment properties.
 */
class MapEnv extends Env {
    constructor(entries, parent) {
        super();
        this.entries = entries;
        this.parent = parent;
    }
    /**
     * Returns property in [[Env]] by name.
     *
     * @param name Name of property.
     */
    lookup(name) {
        if (this.entries.hasOwnProperty(name)) {
            const value = this.entries[name];
            if (value !== undefined) {
                return value;
            }
        }
        return this.parent ? this.parent.lookup(name) : undefined;
    }
    /**
     * Return an object containing all properties of this environment, takes care of the parent
     * object.
     */
    unmap() {
        const obj = this.parent ? this.parent.unmap() : {};
        for (const key in this.entries) {
            if (this.entries.hasOwnProperty(key)) {
                obj[key] = this.entries[key];
            }
        }
        return obj;
    }
}
exports.MapEnv = MapEnv;
/**
 * Var expression.
 * @hidden
 */
class VarExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    accept(visitor, context) {
        return visitor.visitVarExpr(this, context);
    }
}
exports.VarExpr = VarExpr;
/**
 * Null literal expression.
 * @hidden
 */
class NullLiteralExpr extends Expr {
    constructor() {
        super();
    }
    accept(visitor, context) {
        return visitor.visitNullLiteralExpr(this, context);
    }
}
NullLiteralExpr.instance = new NullLiteralExpr();
exports.NullLiteralExpr = NullLiteralExpr;
/**
 * Boolean literal expression.
 * @hidden
 */
class BooleanLiteralExpr extends Expr {
    constructor(value) {
        super();
        this.value = value;
    }
    accept(visitor, context) {
        return visitor.visitBooleanLiteralExpr(this, context);
    }
}
exports.BooleanLiteralExpr = BooleanLiteralExpr;
/**
 * Number literal expression.
 * @hidden
 */
class NumberLiteralExpr extends Expr {
    constructor(value) {
        super();
        this.value = value;
    }
    accept(visitor, context) {
        return visitor.visitNumberLiteralExpr(this, context);
    }
}
exports.NumberLiteralExpr = NumberLiteralExpr;
/**
 * String literal expression.
 * @hidden
 */
class StringLiteralExpr extends Expr {
    constructor(value) {
        super();
        this.value = value;
    }
    accept(visitor, context) {
        return visitor.visitStringLiteralExpr(this, context);
    }
}
exports.StringLiteralExpr = StringLiteralExpr;
/**
 * A has expression with an attribute, for example `has(ref)`.
 * @hidden
 */
class HasAttributeExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    accept(visitor, context) {
        return visitor.visitHasAttributeExpr(this, context);
    }
}
exports.HasAttributeExpr = HasAttributeExpr;
/**
 * A contains expression.
 * @hidden
 */
class ContainsExpr extends Expr {
    constructor(value, elements) {
        super();
        this.value = value;
        this.elements = elements;
    }
    accept(visitor, context) {
        return visitor.visitContainsExpr(this, context);
    }
}
exports.ContainsExpr = ContainsExpr;
/**
 * @hidden
 */
class CallExpr extends Expr {
    constructor(op, children) {
        super();
        this.op = op;
        this.children = children;
    }
    accept(visitor, context) {
        return visitor.visitCallExpr(this, context);
    }
}
exports.CallExpr = CallExpr;
/**
 * @hidden
 */
class ExprSerializer {
    serialize(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitVarExpr(expr, context) {
        return ["get", expr.name];
    }
    visitHasAttributeExpr(expr, context) {
        return ["has", expr.name];
    }
    visitContainsExpr(expr, context) {
        return ["in", this.serialize(expr.value), expr.elements];
    }
    visitCallExpr(expr, context) {
        return [expr.op, ...expr.children.map(childExpr => this.serialize(childExpr))];
    }
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprEvaluator.ts":
/*!********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprEvaluator.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ "../harp-datasource-protocol/lib/operators/CastOperators.ts");
const ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ "../harp-datasource-protocol/lib/operators/ComparisonOperators.ts");
const FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ "../harp-datasource-protocol/lib/operators/FlowOperators.ts");
const MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ "../harp-datasource-protocol/lib/operators/MathOperators.ts");
const MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ "../harp-datasource-protocol/lib/operators/MiscOperators.ts");
const StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ "../harp-datasource-protocol/lib/operators/StringOperators.ts");
const TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ "../harp-datasource-protocol/lib/operators/TypeOperators.ts");
const operatorDescriptors = new Map();
/*
 * @hidden
 */
class ExprEvaluatorContext {
    constructor(evaluator, env, cache) {
        this.evaluator = evaluator;
        this.env = env;
        this.cache = cache;
    }
    evaluate(expr) {
        if (expr !== undefined) {
            return expr.accept(this.evaluator, this);
        }
        throw new Error("Failed to evaluate expression");
    }
}
exports.ExprEvaluatorContext = ExprEvaluatorContext;
/**
 * [[ExprEvaluator]] is used to evaluate [[Expr]] in a given environment.
 *
 * @hidden
 */
class ExprEvaluator {
    static defineOperator(op, builtin) {
        operatorDescriptors.set(op, builtin);
    }
    static defineOperators(builtins) {
        Object.getOwnPropertyNames(builtins).forEach(p => {
            this.defineOperator(p, builtins[p]);
        });
    }
    visitVarExpr(expr, context) {
        const value = context.env.lookup(expr.name);
        return value !== undefined ? value : null;
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitHasAttributeExpr(expr, context) {
        return context.env.lookup(expr.name) !== undefined;
    }
    visitContainsExpr(expr, context) {
        const value = expr.value.accept(this, context);
        const result = expr.elements.includes(value);
        if (context.cache !== undefined) {
            context.cache.set(expr, result);
        }
        return result;
    }
    visitCallExpr(expr, context) {
        switch (expr.op) {
            case "all":
                for (const childExpr of expr.children) {
                    if (!childExpr.accept(this, context)) {
                        return false;
                    }
                }
                return true;
            case "any":
                for (const childExpr of expr.children) {
                    if (childExpr.accept(this, context)) {
                        return true;
                    }
                }
                return false;
            case "none":
                for (const childExpr of expr.children) {
                    if (childExpr.accept(this, context)) {
                        return false;
                    }
                }
                return true;
            default: {
                if (context.cache !== undefined) {
                    const v = context.cache.get(expr);
                    if (v !== undefined) {
                        return v;
                    }
                }
                const descriptor = expr.descriptor || operatorDescriptors.get(expr.op);
                if (descriptor) {
                    expr.descriptor = descriptor;
                    const result = descriptor.call(context, expr.children);
                    if (context.cache) {
                        context.cache.set(expr, result);
                    }
                    return result;
                }
                throw new Error(`undefined operator '${expr.op}`);
            }
        } // switch
    }
}
exports.ExprEvaluator = ExprEvaluator;
ExprEvaluator.defineOperators(CastOperators_1.CastOperators);
ExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);
ExprEvaluator.defineOperators(MathOperators_1.MathOperators);
ExprEvaluator.defineOperators(StringOperators_1.StringOperators);
ExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);
ExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);
ExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprParser.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprParser.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * Character value
 */
var Character;
(function (Character) {
    Character[Character["Tab"] = 9] = "Tab";
    Character[Character["Lf"] = 10] = "Lf";
    Character[Character["Cr"] = 13] = "Cr";
    Character[Character["Space"] = 32] = "Space";
    Character[Character["LParen"] = 40] = "LParen";
    Character[Character["RParen"] = 41] = "RParen";
    Character[Character["Comma"] = 44] = "Comma";
    Character[Character["Dot"] = 46] = "Dot";
    Character[Character["LBracket"] = 91] = "LBracket";
    Character[Character["Backslash"] = 92] = "Backslash";
    Character[Character["RBracket"] = 93] = "RBracket";
    Character[Character["_0"] = 48] = "_0";
    Character[Character["_9"] = 57] = "_9";
    Character[Character["_"] = 95] = "_";
    Character[Character["A"] = 64] = "A";
    Character[Character["Z"] = 90] = "Z";
    Character[Character["a"] = 97] = "a";
    Character[Character["z"] = 122] = "z";
    Character[Character["DoubleQuote"] = 34] = "DoubleQuote";
    Character[Character["SingleQuote"] = 39] = "SingleQuote";
    Character[Character["Exclaim"] = 33] = "Exclaim";
    Character[Character["Equal"] = 61] = "Equal";
    Character[Character["Caret"] = 94] = "Caret";
    Character[Character["Tilde"] = 126] = "Tilde";
    Character[Character["Dollar"] = 36] = "Dollar";
    Character[Character["Less"] = 60] = "Less";
    Character[Character["Greater"] = 62] = "Greater";
    Character[Character["Bar"] = 124] = "Bar";
    Character[Character["Amp"] = 38] = "Amp";
})(Character || (Character = {}));
/**
 * Check if a codepoint is a whitespace character.
 */
function isSpace(codepoint) {
    switch (codepoint) {
        case Character.Tab:
        case Character.Lf:
        case Character.Cr:
        case Character.Space:
            return true;
        default:
            return false;
    } // switch
}
/**
 * Check if codepoint is a digit character.
 */
function isNumber(codepoint) {
    return codepoint >= Character._0 && codepoint <= Character._9;
}
/**
 * Check if codepoint is a letter character.
 */
function isLetter(codepoint) {
    return ((codepoint >= Character.a && codepoint <= Character.z) ||
        (codepoint >= Character.A && codepoint <= Character.Z));
}
/**
 * Check if codepoint is either a digit or a letter character.
 */
function isLetterOrNumber(codepoint) {
    return isLetter(codepoint) || isNumber(codepoint);
}
/**
 * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.
 */
function isIdentChar(codepoint) {
    return (isLetterOrNumber(codepoint) ||
        codepoint === Character._ ||
        codepoint === Character.Dollar ||
        codepoint === Character.Dot ||
        codepoint === Character.LBracket ||
        codepoint === Character.RBracket);
}
/**
 * Tokens used in theme grammar.
 */
var Token;
(function (Token) {
    Token[Token["Eof"] = 0] = "Eof";
    Token[Token["Error"] = 1] = "Error";
    Token[Token["Identifier"] = 2] = "Identifier";
    Token[Token["Number"] = 3] = "Number";
    Token[Token["String"] = 4] = "String";
    Token[Token["Comma"] = 5] = "Comma";
    Token[Token["LParen"] = 6] = "LParen";
    Token[Token["RParen"] = 7] = "RParen";
    Token[Token["LBracket"] = 8] = "LBracket";
    Token[Token["RBracket"] = 9] = "RBracket";
    Token[Token["Exclaim"] = 10] = "Exclaim";
    Token[Token["TildeEqual"] = 11] = "TildeEqual";
    Token[Token["CaretEqual"] = 12] = "CaretEqual";
    Token[Token["DollarEqual"] = 13] = "DollarEqual";
    Token[Token["EqualEqual"] = 14] = "EqualEqual";
    Token[Token["ExclaimEqual"] = 15] = "ExclaimEqual";
    Token[Token["Less"] = 16] = "Less";
    Token[Token["Greater"] = 17] = "Greater";
    Token[Token["LessEqual"] = 18] = "LessEqual";
    Token[Token["GreaterEqual"] = 19] = "GreaterEqual";
    Token[Token["BarBar"] = 20] = "BarBar";
    Token[Token["AmpAmp"] = 21] = "AmpAmp";
})(Token || (Token = {}));
/**
 * Maps a token to its string name.
 */
function tokenSpell(token) {
    switch (token) {
        case Token.Eof:
            return "eof";
        case Token.Error:
            return "error";
        case Token.Identifier:
            return "identifier";
        case Token.Number:
            return "number";
        case Token.String:
            return "string";
        case Token.Comma:
            return ",";
        case Token.LParen:
            return "(";
        case Token.RParen:
            return ")";
        case Token.LBracket:
            return "[";
        case Token.RBracket:
            return "]";
        case Token.Exclaim:
            return "!";
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        case Token.BarBar:
            return "||";
        case Token.AmpAmp:
            return "&&";
        default:
            throw new Error(`invalid token ${token}`);
    }
}
/**
 * Lexer class implementation.
 */
class Lexer {
    constructor(code) {
        this.code = code;
        this.m_token = Token.Error;
        this.m_index = 0;
        this.m_char = Character.Lf;
    }
    /**
     * Single lexer token.
     */
    token() {
        return this.m_token;
    }
    /**
     * Parsed text.
     */
    text() {
        return this.m_text || "";
    }
    /**
     * Go to the next token.
     */
    next() {
        this.m_token = this.yylex();
        if (this.m_token === Token.Error) {
            throw new Error(`unexpected character ${this.m_char}`);
        }
        return this.m_token;
    }
    yyinp() {
        this.m_char = this.code.codePointAt(this.m_index++) || 0;
    }
    yylex() {
        this.m_text = undefined;
        while (isSpace(this.m_char)) {
            this.yyinp();
        }
        if (this.m_char === 0) {
            return Token.Eof;
        }
        const ch = this.m_char;
        this.yyinp();
        switch (ch) {
            case Character.LParen:
                return Token.LParen;
            case Character.RParen:
                return Token.RParen;
            case Character.LBracket:
                return Token.LBracket;
            case Character.RBracket:
                return Token.RBracket;
            case Character.Comma:
                return Token.Comma;
            case Character.SingleQuote:
            case Character.DoubleQuote: {
                const start = this.m_index - 1;
                while (this.m_char && this.m_char !== ch) {
                    // ### TODO handle escape sequences
                    this.yyinp();
                }
                if (this.m_char !== ch) {
                    throw new Error("Unfinished string literal");
                }
                this.yyinp();
                this.m_text = this.code.substring(start, this.m_index - 2);
                return Token.String;
            }
            case Character.Exclaim:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.ExclaimEqual;
                }
                return Token.Exclaim;
            case Character.Caret:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.CaretEqual;
                }
                return Token.Error;
            case Character.Tilde:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.TildeEqual;
                }
                return Token.Error;
            case Character.Equal:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.EqualEqual;
                }
                return Token.Error;
            case Character.Less:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.LessEqual;
                }
                return Token.Less;
            case Character.Greater:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.GreaterEqual;
                }
                return Token.Greater;
            case Character.Bar:
                if (this.m_char === Character.Bar) {
                    this.yyinp();
                    return Token.BarBar;
                }
                return Token.Error;
            case Character.Amp:
                if (this.m_char === Character.Amp) {
                    this.yyinp();
                    return Token.AmpAmp;
                }
                return Token.Error;
            default: {
                const start = this.m_index - 2;
                if (isLetter(ch) ||
                    ch === Character._ ||
                    (ch === Character.Dollar && isIdentChar(this.m_char))) {
                    while (isIdentChar(this.m_char)) {
                        this.yyinp();
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Identifier;
                }
                else if (isNumber(ch)) {
                    while (isNumber(this.m_char)) {
                        this.yyinp();
                    }
                    if (this.m_char === Character.Dot) {
                        this.yyinp();
                        while (isNumber(this.m_char)) {
                            this.yyinp();
                        }
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Number;
                }
                else if (ch === Character.Dollar) {
                    if (this.m_char === Character.Equal) {
                        this.yyinp();
                        return Token.DollarEqual;
                    }
                    return Token.Error;
                }
            }
        }
        return Token.Error;
    }
}
function getEqualityOp(token) {
    switch (token) {
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        default:
            return undefined;
    } // switch
}
function getRelationalOp(token) {
    switch (token) {
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        default:
            return undefined;
    } // switch
}
class ExprParser {
    constructor(code) {
        this.lex = new Lexer(code);
        this.lex.next();
    }
    parse() {
        return this.parseLogicalOr();
    }
    yyexpect(token) {
        if (this.lex.token() !== token) {
            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +
                `found '${tokenSpell(this.lex.token())}'`);
        }
        this.lex.next();
    }
    parsePrimary() {
        switch (this.lex.token()) {
            case Token.Identifier: {
                const text = this.lex.text();
                switch (text) {
                    case "has":
                        this.lex.next(); // skip has keyword
                        this.yyexpect(Token.LParen);
                        const hasAttribute = this.lex.text();
                        this.yyexpect(Token.Identifier);
                        this.yyexpect(Token.RParen);
                        return new Expr_1.HasAttributeExpr(hasAttribute);
                    case "length":
                        this.lex.next(); // skip length keyword
                        this.yyexpect(Token.LParen);
                        const value = this.parseLogicalOr();
                        this.yyexpect(Token.RParen);
                        return new Expr_1.CallExpr("length", [value]);
                    default:
                        const expr = new Expr_1.VarExpr(text);
                        this.lex.next();
                        return expr;
                }
            }
            case Token.LParen: {
                this.lex.next();
                const expr = this.parseLogicalOr();
                this.yyexpect(Token.RParen);
                return expr;
            }
            default:
                return this.parseLiteral();
        } // switch
    }
    parseLiteral() {
        switch (this.lex.token()) {
            case Token.Number: {
                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));
                this.lex.next();
                return expr;
            }
            case Token.String: {
                const expr = new Expr_1.StringLiteralExpr(this.lex.text());
                this.lex.next();
                return expr;
            }
            default:
                throw new Error("Syntax error");
        } // switch
    }
    parseUnary() {
        if (this.lex.token() === Token.Exclaim) {
            this.lex.next();
            return new Expr_1.CallExpr("!", [this.parseUnary()]);
        }
        return this.parsePrimary();
    }
    parseRelational() {
        let expr = this.parseUnary();
        while (true) {
            if (this.lex.token() === Token.Identifier && this.lex.text() === "in") {
                this.lex.next();
                this.yyexpect(Token.LBracket);
                const elements = [this.parseLiteral()];
                while (this.lex.token() === Token.Comma) {
                    this.lex.next();
                    elements.push(this.parseLiteral());
                }
                this.yyexpect(Token.RBracket);
                expr = new Expr_1.ContainsExpr(expr, elements.map(literal => literal.value));
            }
            else {
                const op = getRelationalOp(this.lex.token());
                if (op === undefined) {
                    break;
                }
                this.lex.next();
                const right = this.parseUnary();
                expr = new Expr_1.CallExpr(op, [expr, right]);
            }
        }
        return expr;
    }
    parseEquality() {
        let expr = this.parseRelational();
        while (true) {
            const op = getEqualityOp(this.lex.token());
            if (op === undefined) {
                break;
            }
            this.lex.next();
            const right = this.parseRelational();
            expr = new Expr_1.CallExpr(op, [expr, right]);
        }
        return expr;
    }
    parseLogicalAnd() {
        const expr = this.parseEquality();
        if (this.lex.token() !== Token.AmpAmp) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseEquality());
        } while (this.lex.token() === Token.AmpAmp);
        return new Expr_1.CallExpr("all", expressions);
    }
    parseLogicalOr() {
        const expr = this.parseLogicalAnd();
        if (this.lex.token() !== Token.BarBar) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseLogicalAnd());
        } while (this.lex.token() === Token.BarBar);
        return new Expr_1.CallExpr("any", expressions);
    }
}
exports.ExprParser = ExprParser;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprPool.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprPool.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * [[ExprPool]] maintains a set of unique interned [[Expr]] objects.
 *
 * @hidden
 */
class ExprPool {
    constructor() {
        this.m_booleanLiterals = new Map();
        this.m_numberLiterals = new Map();
        this.m_stringLiterals = new Map();
        this.m_varExprs = new Map();
        this.m_hasAttributeExprs = new Map();
        this.m_inExprs = new Map();
        this.m_callExprs = new Map();
    }
    /**
     * Add `expr` to this [[ExprPool]] and return a unique [[Expr]]
     * object that is structurally equivalent to `expr`.
     *
     * @param expr The [[Expr]] to add to this [[ExprPool]].
     * @returns A unique [[Expr]] that is structurally equivalent to `expr`.
     */
    add(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return Expr_1.NullLiteralExpr.instance;
    }
    visitBooleanLiteralExpr(expr, context) {
        const e = this.m_booleanLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_booleanLiterals.set(expr.value, expr);
        return expr;
    }
    visitNumberLiteralExpr(expr, context) {
        const e = this.m_numberLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_numberLiterals.set(expr.value, expr);
        return expr;
    }
    visitStringLiteralExpr(expr, context) {
        const e = this.m_stringLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_stringLiterals.set(expr.value, expr);
        return expr;
    }
    visitVarExpr(expr, context) {
        const e = this.m_varExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_varExprs.set(expr.name, expr);
        return expr;
    }
    visitHasAttributeExpr(expr, context) {
        const e = this.m_hasAttributeExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_hasAttributeExprs.set(expr.name, expr);
        return expr;
    }
    visitContainsExpr(expr, context) {
        const value = expr.value.accept(this, context);
        if (!this.m_inExprs.has(value)) {
            this.m_inExprs.set(value, []);
        }
        const inExprs = this.m_inExprs.get(value);
        for (const inExpr of inExprs) {
            if (inExpr.elements.length !== expr.elements.length) {
                continue;
            }
            // find the index of the first element in the cached 'in' expr
            // that is not contained in 'expr.elements'.
            const i = inExpr.elements.findIndex(x => !expr.elements.includes(x));
            if (i === -1) {
                return inExpr;
            }
        }
        const e = new Expr_1.ContainsExpr(value, expr.elements);
        this.m_inExprs.set(value, [e]);
        return e;
    }
    visitCallExpr(expr, context) {
        // rewrite the actual arguments
        const expressions = expr.children.map(childExpr => childExpr.accept(this, context));
        // ensure we have a valid set of interned expressions for the calls
        if (!this.m_callExprs.has(expr.op)) {
            this.m_callExprs.set(expr.op, []);
        }
        // get the calls for the given operator.
        const calls = this.m_callExprs.get(expr.op);
        for (const call of calls) {
            // check the number of arguments
            if (call.children.length !== expressions.length) {
                continue;
            }
            // find the index of the first mismatch.
            let index = 0;
            for (; index < call.children.length; ++index) {
                if (call.children[index] !== expressions[index]) {
                    break;
                }
            }
            if (index === call.children.length) {
                // no mismatch found, return the 'interned' call.
                return call;
            }
        }
        const e = new Expr_1.CallExpr(expr.op, expressions);
        calls.push(e);
        return e;
    }
}
exports.ExprPool = ExprPool;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Extruder.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/Extruder.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Fills an index buffer with the indices for the extruded walls for a polygon contour.
 *
 * @param indexBuffer Index buffer to be filled.
 * @param vertexOffset Starting offset of the vertices composing the contour.
 * @param vertexStride Number of elements per contour vertex.
 * @param contour Vertices that compose the contour.
 * @param contourEdges Collection of booleans indicating if contour edges should be added.
 * @param boundaryWalls If `false`, walls in tile boundaries will not be created.
 *
 */
function addExtrudedWalls(indexBuffer, vertexOffset, vertexStride, contour, contourEdges, boundaryWalls) {
    // Infer the index buffer's position of the vertices that form the extruded-polygons' walls
    // by stepping through the contour segment by segment.
    const nSegments = contour.length / vertexStride;
    for (let i = 0; i < nSegments; ++i) {
        const vFootprint0 = vertexOffset + i * 2;
        const vRoof0 = vFootprint0 + 1;
        const vFootprint1 = vertexOffset + ((i + 1) % nSegments) * 2;
        const vRoof1 = vFootprint1 + 1;
        if (boundaryWalls !== false || contourEdges === undefined) {
            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);
        }
        else if (contourEdges[i]) {
            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);
        }
    }
}
exports.addExtrudedWalls = addExtrudedWalls;


/***/ }),

/***/ "../harp-datasource-protocol/lib/InterpolatedProperty.ts":
/*!***************************************************************!*\
  !*** ../harp-datasource-protocol/lib/InterpolatedProperty.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const three_1 = __webpack_require__(/*! three */ "three");
const ExponentialInterpolant_1 = __webpack_require__(/*! ./ExponentialInterpolant */ "../harp-datasource-protocol/lib/ExponentialInterpolant.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const interpolants = [
    three_1.DiscreteInterpolant,
    three_1.LinearInterpolant,
    three_1.CubicInterpolant,
    ExponentialInterpolant_1.ExponentialInterpolant
];
const tmpColor = new three_1.Color();
/**
 * Checks if a property is interpolated.
 * @param p property to be checked
 */
function isInterpolatedPropertyDefinition(p) {
    if (p !== undefined &&
        p.values instanceof Array &&
        p.values.length > 0 &&
        p.values[0] !== undefined &&
        p.zoomLevels instanceof Array &&
        p.zoomLevels.length > 0 &&
        p.zoomLevels[0] !== undefined &&
        p.values.length === p.zoomLevels.length) {
        return true;
    }
    return false;
}
exports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;
/**
 * Type guard to check if an object is an instance of `InterpolatedProperty`.
 */
function isInterpolatedProperty(p) {
    if (p !== undefined &&
        p.interpolationMode !== undefined &&
        p.zoomLevels !== undefined &&
        p.values !== undefined &&
        p.values.length > 0 &&
        (p.zoomLevels.length === p.values.length / 3 || p.zoomLevels.length === p.values.length)) {
        return true;
    }
    return false;
}
exports.isInterpolatedProperty = isInterpolatedProperty;
/**
 * Get the value of the specified property at the given zoom level, represented as a `number` value.
 *
 * @param property Property of a technique.
 * @param level Display level the property should be rendered at.
 * @param pixelToMeters Optional pixels to meters conversion factor (needed for proper
 * interpolation of `length` values).
 *
 */
function getPropertyValue(property, level, pixelToMeters = 1.0) {
    if (isInterpolatedPropertyDefinition(property)) {
        throw new Error("Cannot interpolate a InterpolatedPropertyDefinition.");
    }
    else if (!isInterpolatedProperty(property)) {
        if (typeof property !== "string") {
            return property;
        }
        else {
            const matchedFormat = StringEncodedNumeral_1.StringEncodedNumeralFormats.find(format => format.regExp.test(property));
            if (matchedFormat === undefined) {
                throw new Error(`No StringEncodedNumeralFormat matched ${property}.`);
            }
            switch (matchedFormat.type) {
                case StringEncodedNumeral_1.StringEncodedNumeralType.Meters:
                    return matchedFormat.decoder(property)[0];
                case StringEncodedNumeral_1.StringEncodedNumeralType.Pixels:
                    return matchedFormat.decoder(property)[0] * pixelToMeters;
                case StringEncodedNumeral_1.StringEncodedNumeralType.Hex:
                case StringEncodedNumeral_1.StringEncodedNumeralType.RGB:
                case StringEncodedNumeral_1.StringEncodedNumeralType.HSL:
                    const hslValues = matchedFormat.decoder(property);
                    return tmpColor.setHSL(hslValues[0], hslValues[1], hslValues[2]).getHex();
                default:
                    return matchedFormat.decoder(property)[0];
            }
        }
    }
    else if (property._stringEncodedNumeralType !== undefined) {
        switch (property._stringEncodedNumeralType) {
            case StringEncodedNumeral_1.StringEncodedNumeralType.Meters:
            case StringEncodedNumeral_1.StringEncodedNumeralType.Pixels:
                return getInterpolatedLength(property, level, pixelToMeters);
            case StringEncodedNumeral_1.StringEncodedNumeralType.Hex:
            case StringEncodedNumeral_1.StringEncodedNumeralType.RGB:
            case StringEncodedNumeral_1.StringEncodedNumeralType.HSL:
                return getInterpolatedColor(property, level);
        }
    }
    return getInterpolatedLength(property, level, pixelToMeters);
}
exports.getPropertyValue = getPropertyValue;
function getInterpolatedLength(property, level, pixelToMeters) {
    const nChannels = property.values.length / property.zoomLevels.length;
    const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);
    if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
        property.exponent !== undefined) {
        interpolant.exponent = property.exponent;
    }
    interpolant.evaluate(level);
    if (property._stringEncodedNumeralDynamicMask === undefined) {
        return interpolant.resultBuffer[0];
    }
    else {
        const maskInterpolant = new interpolants[property.interpolationMode](property.zoomLevels, property._stringEncodedNumeralDynamicMask, 1);
        if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
            property.exponent !== undefined) {
            maskInterpolant.exponent = property.exponent;
        }
        maskInterpolant.evaluate(level);
        return (interpolant.resultBuffer[0] *
            (1 + maskInterpolant.resultBuffer[0] * (pixelToMeters - 1)));
    }
}
function getInterpolatedColor(property, level) {
    const nChannels = property.values.length / property.zoomLevels.length;
    const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);
    if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
        property.exponent !== undefined) {
        interpolant.exponent = property.exponent;
    }
    interpolant.evaluate(level);
    return tmpColor
        .setHSL(interpolant.resultBuffer[0], interpolant.resultBuffer[1], interpolant.resultBuffer[2])
        .getHex();
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.
 */
var InterpolationMode;
(function (InterpolationMode) {
    InterpolationMode[InterpolationMode["Discrete"] = 0] = "Discrete";
    InterpolationMode[InterpolationMode["Linear"] = 1] = "Linear";
    InterpolationMode[InterpolationMode["Cubic"] = 2] = "Cubic";
    InterpolationMode[InterpolationMode["Exponential"] = 3] = "Exponential";
})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/Outliner.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/Outliner.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const currEdgeStart = new THREE.Vector2();
const currEdgeGoal = new THREE.Vector2();
const prevEdgeStart = new THREE.Vector2();
const prevEdgeGoal = new THREE.Vector2();
/**
 * Fills an index buffer with the indices for the edges of a polygon contour.
 *
 * @param indexBuffer Edge index buffer to be filled.
 * @param vertexOffset Starting offset of the vertices composing the contour.
 * @param vertexStride Number of elements per contour vertex.
 * @param polygonContour Vertices that compose the contour.
 * @param polygonContourEdges Collection of booleans indicating if contour edges should be added.
 */
function addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {
    for (let i = 0; i < polygonContourEdges.length; ++i) {
        if (polygonContourEdges[i]) {
            if (isExtruded === true) {
                const vFootprint0 = vertexOffset + i * 2;
                const vRoof0 = vFootprint0 + 1;
                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;
                const vRoof1 = vFootprint1 + 1;
                if (addFootprintEdges === true) {
                    indexBuffer.push(vFootprint0, vFootprint1);
                }
                indexBuffer.push(vRoof0, vRoof1);
                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;
                if (polygonContourEdges[prevEdgeIdx]) {
                    if (wallEdgeSlope !== undefined) {
                        const v0x = polygonContour[i * vertexStride];
                        const v0y = polygonContour[i * vertexStride + 1];
                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];
                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];
                        currEdgeStart.set(v0x, v0y);
                        currEdgeGoal.set(v1x, v1y);
                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);
                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);
                        if (prevEdgeGoal
                            .sub(prevEdgeStart)
                            .normalize()
                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {
                            indexBuffer.push(vFootprint0, vRoof0);
                        }
                    }
                    else {
                        indexBuffer.push(vFootprint0, vRoof0);
                    }
                }
            }
            else {
                const vFoot0 = vertexOffset + i;
                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);
                indexBuffer.push(vFoot0, vRoof0);
            }
        }
    }
}
exports.addPolygonEdges = addPolygonEdges;


/***/ }),

/***/ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts":
/*!***************************************************************!*\
  !*** ../harp-datasource-protocol/lib/StringEncodedNumeral.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const three_1 = __webpack_require__(/*! three */ "three");
const tmpColor = new three_1.Color();
const tmpHSL = { h: 0, s: 0, l: 0 };
/**
 * Enumeration of supported string encoded numerals.
 */
var StringEncodedNumeralType;
(function (StringEncodedNumeralType) {
    StringEncodedNumeralType[StringEncodedNumeralType["Meters"] = 0] = "Meters";
    StringEncodedNumeralType[StringEncodedNumeralType["Pixels"] = 1] = "Pixels";
    StringEncodedNumeralType[StringEncodedNumeralType["Hex"] = 2] = "Hex";
    StringEncodedNumeralType[StringEncodedNumeralType["RGB"] = 3] = "RGB";
    StringEncodedNumeralType[StringEncodedNumeralType["HSL"] = 4] = "HSL";
})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));
exports.StringEncodedMeters = {
    type: StringEncodedNumeralType.Meters,
    size: 1,
    regExp: /((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m/,
    decoder: (encodedValue) => {
        return [Number(exports.StringEncodedMeters.regExp.exec(encodedValue)[1])];
    }
};
exports.StringEncodedPixels = {
    type: StringEncodedNumeralType.Pixels,
    size: 1,
    mask: 1.0,
    regExp: /((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px/,
    decoder: (encodedValue) => {
        return [Number(exports.StringEncodedPixels.regExp.exec(encodedValue)[1])];
    }
};
exports.StringEncodedHex = {
    type: StringEncodedNumeralType.Hex,
    size: 3,
    regExp: /#([0-9A-Fa-f]{1,2})([0-9A-Fa-f]{1,2})([0-9A-Fa-f]{1,2})/,
    decoder: (encodedValue) => {
        tmpColor.set(encodedValue).getHSL(tmpHSL);
        return [tmpHSL.h, tmpHSL.s, tmpHSL.l];
    }
};
exports.StringEncodedRGB = {
    type: StringEncodedNumeralType.RGB,
    size: 3,
    // tslint:disable-next-line:max-line-length
    regExp: /rgb\((?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]))\)/,
    decoder: (encodedValue) => {
        const channels = exports.StringEncodedRGB.regExp.exec(encodedValue);
        tmpColor
            .setRGB(parseInt(channels[1], 10) / 255, parseInt(channels[2], 10) / 255, parseInt(channels[3], 10) / 255)
            .getHSL(tmpHSL);
        return [tmpHSL.h, tmpHSL.s, tmpHSL.l];
    }
};
exports.StringEncodedHSL = {
    type: StringEncodedNumeralType.HSL,
    size: 3,
    // tslint:disable-next-line:max-line-length
    regExp: /hsl\(((?:[0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-9]{1,2}|3[0-5][0-9]|360)), ?(?:([0-9]|[1-9][0-9]|100)%), ?(?:([0-9]|[1-9][0-9]|100)%)\)/,
    decoder: (encodedValue) => {
        const channels = exports.StringEncodedHSL.regExp.exec(encodedValue);
        return [
            parseInt(channels[1], 10) / 360,
            parseInt(channels[2], 10) / 100,
            parseInt(channels[3], 10) / 100
        ];
    }
};
/**
 * Array of supported [[StringEncodedNumeralFormat]]s (inteded to be indexed with
 * [[StringEncodedNumeralType]] enum).
 */
exports.StringEncodedNumeralFormats = [
    exports.StringEncodedMeters,
    exports.StringEncodedPixels,
    exports.StringEncodedHex,
    exports.StringEncodedRGB,
    exports.StringEncodedHSL
];


/***/ }),

/***/ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts":
/*!************************************************************!*\
  !*** ../harp-datasource-protocol/lib/StyleSetEvaluator.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const ExprPool_1 = __webpack_require__(/*! ./ExprPool */ "../harp-datasource-protocol/lib/ExprPool.ts");
const InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
const Theme_1 = __webpack_require__(/*! ./Theme */ "../harp-datasource-protocol/lib/Theme.ts");
exports.logger = harp_utils_1.LoggerManager.instance.create("StyleSetEvaluator");
/**
 * [[ExprClassifier]] searches for usages of `$layer` in `when` conditions
 * associated with styling rules.
 *
 * @hidden
 */
class StyleConditionClassifier {
    classify(style) {
        if (style._whenExpr) {
            const savedStyle = this.switchStyle(style);
            style._whenExpr = style._whenExpr.accept(this, undefined);
            this._style = savedStyle;
        }
    }
    visitNullLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitNumberLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitStringLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitVarExpr(expr, enclosingExpr) {
        return expr;
    }
    visitHasAttributeExpr(expr, enclosingExpr) {
        return expr;
    }
    visitContainsExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCallExpr(call, enclosingExpr) {
        if (call.op === "all") {
            // processing of an `["all", e1, e2, ... eN]` expression. In this case
            // search for expressions matching comparison of `$layer` and string literals
            // in the sub expressions.
            const children = call.children
                .map(childExpr => childExpr.accept(this, call))
                .filter(childExpr => childExpr !== undefined);
            return new Expr_1.CallExpr(call.op, children);
        }
        else if (enclosingExpr) {
            // `call` is a direct child expression of an `"all"` operator.
            const matched = this.matchVarStringComparison(call);
            if (matched && this._style._layer === undefined && matched.name === "$layer") {
                // found a subexpression `["==", ["get", "$layer"], "some layer name"]`
                // enclosed in an `["all", e1...eN]` expression. Remove it from
                // its parent expression and store the value of the expected $layer in
                // [[StyleInternalParams]].
                this._style._layer = matched.value;
                // return `undefined` to remove this sub expression from its parent.
                return undefined;
            }
        }
        return call;
    }
    /**
     * Tests if the given `call` matches the structure ["==", ["get", name], value].
     * If a match is found returns an object containing the `name` and the `value`;
     *
     * @param call The expression to match.
     */
    matchVarStringComparison(call) {
        if (call.op === "==") {
            const left = call.children[0];
            const right = call.children[1];
            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {
                return { name: left.name, value: right.value };
            }
            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {
                return { name: right.name, value: left.value };
            }
        }
        return undefined;
    }
    /**
     * Sets the given `style` as current.
     *
     * @returns The previous `style`.
     */
    switchStyle(style) {
        const saved = this._style;
        this._style = style;
        return saved;
    }
}
/**
 * Combine data from datasource and apply the rules from a specified theme to show it on the map.
 */
class StyleSetEvaluator {
    constructor(styleSet) {
        this.m_renderOrderBiasGroups = new Map();
        this.m_techniques = [];
        this.m_exprPool = new ExprPool_1.ExprPool();
        this.m_cachedResults = new Map();
        this.m_styleConditionClassifier = new StyleConditionClassifier();
        let techniqueRenderOrder = 0;
        let styleSetIndex = 0;
        const cloneStyle = (style) => {
            if (Theme_1.isReference(style)) {
                return undefined;
            }
            return Object.assign({}, style, { styles: style.styles !== undefined
                    ? style.styles
                        .map(subStyle => cloneStyle(subStyle))
                        .filter(subStyle => subStyle !== undefined)
                    : undefined });
        };
        this.styleSet = styleSet
            .map(style => cloneStyle(style))
            .filter(subStyle => subStyle !== undefined);
        const computeDefaultRenderOrder = (style) => {
            if (style.renderOrderBiasGroup !== undefined) {
                const renderOrderBiasGroupOrder = style.renderOrderBiasGroup
                    ? this.m_renderOrderBiasGroups.get(style.renderOrderBiasGroup)
                    : undefined;
                if (style.renderOrderBiasRange !== undefined &&
                    renderOrderBiasGroupOrder === undefined) {
                    if (style.renderOrder !== undefined) {
                        exports.logger.warn("WARN: style.renderOrder will be overridden if " +
                            "renderOrderBiasGroup is set:", style);
                    }
                    const [minRange, maxRange] = style.renderOrderBiasRange;
                    style.renderOrder =
                        minRange < 0
                            ? techniqueRenderOrder + Math.abs(minRange)
                            : techniqueRenderOrder;
                    techniqueRenderOrder += Math.abs(minRange) + maxRange;
                    if (style.renderOrderBiasGroup) {
                        this.m_renderOrderBiasGroups.set(style.renderOrderBiasGroup, style.renderOrder);
                    }
                    techniqueRenderOrder++;
                }
                else if (renderOrderBiasGroupOrder) {
                    if (style.renderOrder !== undefined) {
                        exports.logger.warn("WARN: style.renderOrder will be overridden if " +
                            "renderOrderBiasGroup is set:", style);
                    }
                    style.renderOrder = renderOrderBiasGroupOrder;
                }
            }
            // search through child styles
            if (style.styles !== undefined) {
                for (const currStyle of style.styles) {
                    computeDefaultRenderOrder(currStyle);
                }
            }
            else {
                style._styleSetIndex = styleSetIndex++;
                if (style.technique !== undefined && style.renderOrder === undefined) {
                    style.renderOrder = techniqueRenderOrder++;
                }
            }
        };
        for (const style of this.styleSet) {
            computeDefaultRenderOrder(style);
        }
        this.compileStyleSet();
    }
    /**
     * Find all techniques that fit the current objects' environment.
     * *The techniques in the resulting array may not be modified* since they are being reused for
     * identical objects.
     *
     * @param env The objects environment, i.e. the attributes that are relevant for its
     * representation.
     */
    getMatchingTechniques(env) {
        const result = [];
        const styleStack = new Array();
        this.m_cachedResults.clear();
        // get the requested $layer, if any.
        const layer = env.lookup("$layer");
        // set the requested $layer as the current layer.
        const previousLayer = this.changeLayer(typeof layer === "string" ? layer : undefined);
        for (const currStyle of this.styleSet) {
            if (styleStack.length !== 0) {
                this.changeLayer(previousLayer); // restore the layer
                throw new Error("Internal error: style stack cleanup failed");
            }
            if (this.processStyle(env, styleStack, currStyle, result)) {
                break;
            }
        }
        this.changeLayer(previousLayer); // restore the layer
        return result;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get techniques() {
        return this.m_techniques;
    }
    changeLayer(layer) {
        const savedLayer = this.m_layer;
        this.m_layer = layer;
        return savedLayer;
    }
    /**
     * Shorten the style object for debug log. Remove special strings (starting with "_") as well
     * as the sub-styles of style groups.
     *
     * @param key Key in object
     * @param value value in object
     */
    cleanupStyle(key, value) {
        // Filtering out properties
        if (key === "styles") {
            return "[...]";
        }
        if (key.startsWith("_")) {
            return undefined;
        }
        return value;
    }
    /**
     * Compile the `when` conditions found when traversting the styling rules.
     */
    compileStyleSet() {
        this.styleSet.forEach(style => this.compileStyle(style));
    }
    /**
     * Compile the `when` conditions reachable from the given `style`.
     *
     * @param style The current style.
     */
    compileStyle(style) {
        if (style.when !== undefined) {
            try {
                style._whenExpr = Array.isArray(style.when)
                    ? Expr_1.Expr.fromJSON(style.when)
                    : Expr_1.Expr.parse(style.when);
                // search for usages of '$layer' and any other
                // special symbol that can be used to speed up the evaluation
                // of the `when` conditions associated to this `style`.
                this.m_styleConditionClassifier.classify(style);
                if (style._whenExpr !== undefined) {
                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);
                }
            }
            catch (err) {
                exports.logger.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
            }
        }
        if (Array.isArray(style.styles)) {
            style.styles.forEach(nestedStyle => this.compileStyle(nestedStyle));
        }
    }
    /**
     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the
     * current objects' environment. The attributes of the styles are assembled to create a unique
     * technique for every object.
     *
     * @param env The objects environment, i.e. the attributes that are relevant for its
     *            representation.
     * @param styleStack Stack of styles containing the hierarchy of styles up to this point.
     * @param style Current style (could also be top of stack).
     * @param result The array of resulting techniques. There may be more than one technique per
     *               object, resulting in multiple graphical objects for representation.
     * @returns `true` if style has been found and processing is finished. `false` if not found, or
     *          more than one technique should be applied.
     */
    processStyle(env, styleStack, style, result) {
        if (style._whenExpr) {
            if (this.m_layer !== undefined &&
                style._layer !== undefined &&
                this.m_layer !== style._layer) {
                // skip this rule because its requested layer is different than the
                // layer defined in $layer variable.
                return false;
            }
            if (!style._whenExpr.evaluate(env, this.m_cachedResults)) {
                // Stop processing this styling rule. The `when` condition
                // associated with the current `style` evaluates to false so
                // no techinque defined by this style should be applied.
                return false;
            }
        }
        if (style.styles !== undefined) {
            if (style.debug) {
                exports.logger.log("\n======== style group =========\nenv:", JSON.stringify(env.unmap(), undefined, 2), "\nstyle group:", JSON.stringify(style, this.cleanupStyle, 2));
            }
            styleStack.push(style);
            for (const currStyle of style.styles) {
                if (this.processStyle(env, styleStack, currStyle, result)) {
                    styleStack.pop();
                    return true;
                }
            }
            styleStack.pop();
        }
        else {
            // we found a technique!
            if (style.technique !== undefined) {
                if (style.technique !== "none") {
                    // Check if we already assembled the technique for exactly this style. If we
                    // have, we return the preassembled technique object. Otherwise we assemble the
                    // technique from all parent styles' attributes and the current stales'
                    // attributes, and add it to the cached techniques.
                    if (style._index === undefined) {
                        const technique = this.createTechnique(style, styleStack);
                        result.push(technique);
                        if (style.debug) {
                            exports.logger.log("\n======== style w/ technique =========\nenv:", JSON.stringify(env.unmap(), undefined, 2), "\nstyle:", JSON.stringify(style, this.cleanupStyle, 2), "\ntechnique:", JSON.stringify(technique, this.cleanupStyle, 2));
                        }
                    }
                    else {
                        result.push(this.m_techniques[style._index]);
                    }
                }
                // stop processing if "final" is set
                return style.final === true;
            }
        }
        return false;
    }
    createTechnique(style, styleStack) {
        const technique = {};
        technique.name = style.technique;
        const addAttributes = (currStyle) => {
            if (currStyle.renderOrder !== undefined) {
                technique.renderOrder = currStyle.renderOrder;
            }
            if (currStyle.transient !== undefined) {
                technique.transient = currStyle.transient;
            }
            if (currStyle.renderOrderBiasProperty !== undefined) {
                technique.renderOrderBiasProperty = currStyle.renderOrderBiasProperty;
            }
            if (currStyle.labelProperty !== undefined) {
                technique.label = currStyle.labelProperty;
            }
            if (currStyle.renderOrderBiasRange !== undefined) {
                technique.renderOrderBiasRange = currStyle.renderOrderBiasRange;
            }
            if (currStyle.renderOrderBiasGroup !== undefined) {
                technique.renderOrderBiasGroup = currStyle.renderOrderBiasGroup;
            }
            if (currStyle.secondaryRenderOrder !== undefined) {
                technique.secondaryRenderOrder = currStyle.secondaryRenderOrder;
            }
            if (currStyle.attr !== undefined) {
                Object.getOwnPropertyNames(currStyle.attr).forEach(property => {
                    const prop = currStyle.attr[property];
                    if (InterpolatedProperty_1.isInterpolatedPropertyDefinition(prop)) {
                        removeDuplicatePropertyValues(prop);
                        const propKeys = new Float32Array(prop.zoomLevels);
                        let propValues;
                        let maskValues;
                        switch (typeof prop.values[0]) {
                            default:
                            case "number":
                                propValues = new Float32Array(prop.values);
                                technique[property] = {
                                    interpolationMode: prop.interpolation !== undefined
                                        ? InterpolatedPropertyDefs_1.InterpolationMode[prop.interpolation]
                                        : InterpolatedPropertyDefs_1.InterpolationMode.Discrete,
                                    zoomLevels: propKeys,
                                    values: propValues,
                                    exponent: prop.exponent
                                };
                                break;
                            case "boolean":
                                propValues = new Float32Array(prop.values.length);
                                for (let i = 0; i < prop.values.length; ++i) {
                                    propValues[i] = prop.values[i]
                                        ? 1
                                        : 0;
                                }
                                technique[property] = {
                                    interpolationMode: InterpolatedPropertyDefs_1.InterpolationMode.Discrete,
                                    zoomLevels: propKeys,
                                    values: propValues,
                                    exponent: prop.exponent
                                };
                                break;
                            case "string":
                                let needsMask = false;
                                const matchedFormat = StringEncodedNumeral_1.StringEncodedNumeralFormats.find(format => format.regExp.test(prop.values[0]));
                                if (matchedFormat === undefined) {
                                    exports.logger.error(`No StringEncodedNumeralFormat matched ${property}.`);
                                    break;
                                }
                                propValues = new Float32Array(prop.values.length * matchedFormat.size);
                                maskValues = new Float32Array(prop.values.length);
                                needsMask = procesStringEnocodedNumeralInterpolatedProperty(matchedFormat, prop, propValues, maskValues);
                                technique[property] = {
                                    interpolationMode: prop.interpolation !== undefined
                                        ? InterpolatedPropertyDefs_1.InterpolationMode[prop.interpolation]
                                        : InterpolatedPropertyDefs_1.InterpolationMode.Discrete,
                                    zoomLevels: propKeys,
                                    values: propValues,
                                    exponent: prop.exponent,
                                    _stringEncodedNumeralType: matchedFormat.type,
                                    _stringEncodedNumeralDynamicMask: needsMask
                                        ? maskValues
                                        : undefined
                                };
                                break;
                        }
                    }
                    else {
                        technique[property] = prop;
                    }
                });
            }
        };
        for (const currStyle of styleStack) {
            addAttributes(currStyle);
        }
        addAttributes(style);
        style._index = this.m_techniques.length;
        technique._index = style._index;
        technique._styleSetIndex = style._styleSetIndex;
        this.m_techniques.push(technique);
        return technique;
    }
}
exports.StyleSetEvaluator = StyleSetEvaluator;
function removeDuplicatePropertyValues(p) {
    for (let i = 0; i < p.values.length; ++i) {
        const firstIdx = p.zoomLevels.findIndex((a) => {
            return a === p.zoomLevels[i];
        });
        if (firstIdx !== i) {
            p.zoomLevels.splice(--i, 1);
            p.values.splice(--i, 1);
        }
    }
}
const colorFormats = [StringEncodedNumeral_1.StringEncodedHSL, StringEncodedNumeral_1.StringEncodedHex, StringEncodedNumeral_1.StringEncodedRGB];
const worldSizeFormats = [StringEncodedNumeral_1.StringEncodedMeters, StringEncodedNumeral_1.StringEncodedPixels];
function procesStringEnocodedNumeralInterpolatedProperty(baseFormat, prop, propValues, maskValues) {
    let needsMask = false;
    const allowedValueFormats = baseFormat.type === StringEncodedNumeral_1.StringEncodedNumeralType.Meters ||
        baseFormat.type === StringEncodedNumeral_1.StringEncodedNumeralType.Pixels
        ? worldSizeFormats
        : colorFormats;
    for (let valueIdx = 0; valueIdx < prop.values.length; ++valueIdx) {
        for (const valueFormat of allowedValueFormats) {
            const value = prop.values[valueIdx];
            if (!valueFormat.regExp.test(value)) {
                continue;
            }
            if (valueFormat.mask !== undefined) {
                maskValues[valueIdx] = valueFormat.mask;
                needsMask = true;
            }
            const result = valueFormat.decoder(value);
            for (let i = 0; i < result.length; ++i) {
                propValues[valueIdx * valueFormat.size + i] = result[i];
            }
            break;
        }
    }
    return needsMask;
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueParams.ts":
/*!**********************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueParams.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The kind of geometry is used to
 *
 * a) Group objects together, allowing the group to be hidden or displayed.
 *
 * b) Assigning the objects a loading phase. If a [[PhasedTileGeometryManager]] is used, techniques
 *      without a `GeometryKind` may not be processed (at the desired phase).
 *
 * Any string can be used to specify the kind of the technique in a style in the theme file. Is is
 * suggested to specify multiple kinds for specific types of data. For a highway, the following list
 * of kinds is suggested:
 *
 *    ["line", "road", "road:highway"]
 *
 * If it is a tunnel for a highway:
 *
 *    ["line", "road", "road:highway", "tunnel", "road:tunnel", "road:highway:tunnel"]
 *
 * If specified in this way, specific types of data (here: highway roads) can be enabled and/or
 * disabled.
 */
var GeometryKind;
(function (GeometryKind) {
    /**
     * Used in the enabledKinds/disabledKinds filter to match any kind.
     */
    GeometryKind["All"] = "_all_";
    /**
     * Background geometry.
     */
    GeometryKind["Background"] = "background";
    /**
     * Terrain geometry.
     */
    GeometryKind["Terrain"] = "terrain";
    /**
     * Default value for the FillTechnique.
     */
    GeometryKind["Area"] = "area";
    /**
     * Default value for all line techniques.
     */
    GeometryKind["Line"] = "line";
    /**
     * Default value for the FillTechnique.
     */
    GeometryKind["Water"] = "water";
    /**
     * Political borders.
     */
    GeometryKind["Border"] = "border";
    /**
     * Basis for all roads.
     */
    GeometryKind["Road"] = "road";
    /**
     * Default value for the ExtrudedPolygonTechnique.
     */
    GeometryKind["Building"] = "building";
    /**
     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.
     */
    GeometryKind["Label"] = "label";
    /**
     * Anything that may show up last.
     */
    GeometryKind["Detail"] = "detail";
})(GeometryKind = exports.GeometryKind || (exports.GeometryKind = {}));
/**
 * A set of [[GeometryKind]]s.
 */
class GeometryKindSet extends Set {
    /**
     * Return `true` if the Set is a superset of the set 'subset'.
     */
    isSuperset(subset) {
        for (const elem of subset) {
            if (!this.has(elem)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return `true` if the Set intersects Set 'set'.
     */
    hasIntersection(set) {
        for (const elem of set) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'
     * if set is not a Set.
     */
    hasOrIntersects(set) {
        if (set instanceof Set) {
            return this.hasIntersection(set);
        }
        return this.has(set);
    }
    /**
     * Return `true` if this set and the array of elements share at least a single element.
     */
    hasOrIntersectsArray(subset) {
        for (const elem of subset) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
}
exports.GeometryKindSet = GeometryKindSet;
var TextureCoordinateType;
(function (TextureCoordinateType) {
    /**
     * Texture coordinates are in tile space.
     * SW of the tile will have (0,0) and NE will have (1,1).
     */
    TextureCoordinateType["TileSpace"] = "tile-space";
    /**
     * Texture coordinates are in equirectangular space.
     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).
     */
    TextureCoordinateType["EquirectangularSpace"] = "equirectangular-space";
})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));
/**
 * Define the stacking option. Enum values for theme file are in "kebab-case".
 */
var PoiStackMode;
(function (PoiStackMode) {
    /**
     * Show in a stack.
     */
    PoiStackMode["Show"] = "show-in-stack";
    /**
     * Do not show in a stack.
     */
    PoiStackMode["Hide"] = "hide-in-stack";
    /**
     * Show category parent in the stack.
     */
    PoiStackMode["ShowParent"] = "show-parent";
})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));
/**
 * Type guard to check if an object is an instance of `TextureBuffer`.
 */
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
exports.isTextureBuffer = isTextureBuffer;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Techniques.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/Techniques.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ "../harp-datasource-protocol/lib/TechniqueParams.ts");
/**
 * Names of the supported texture properties.
 */
exports.TEXTURE_PROPERTY_KEYS = [
    "map",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "emissiveMap",
    "alphaMap",
    "metalnessMap",
    "bumpMap"
];
/**
 * Type guard to check if an object is an instance of [[CirclesTechnique]].
 */
function isCirclesTechnique(technique) {
    return technique.name === "circles";
}
exports.isCirclesTechnique = isCirclesTechnique;
/**
 * Type guard to check if an object is an instance of [[SquaresTechnique]].
 */
function isSquaresTechnique(technique) {
    return technique.name === "squares";
}
exports.isSquaresTechnique = isSquaresTechnique;
/**
 * Type guard to check if an object is an instance of [[PoiTechnique]].
 */
function isPoiTechnique(technique) {
    return technique.name === "labeled-icon";
}
exports.isPoiTechnique = isPoiTechnique;
/**
 * Type guard to check if an object is an instance of [[LineMarkerTechnique]].
 */
function isLineMarkerTechnique(technique) {
    return technique.name === "line-marker";
}
exports.isLineMarkerTechnique = isLineMarkerTechnique;
/**
 * Type guard to check if an object is an instance of [[DashedLineTechnique]].
 */
function isDashedLineTechnique(technique) {
    return technique.name === "dashed-line";
}
exports.isDashedLineTechnique = isDashedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[LineTechnique]].
 */
function isLineTechnique(technique) {
    return technique.name === "line";
}
exports.isLineTechnique = isLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SolidLineTechnique]].
 */
function isSolidLineTechnique(technique) {
    return technique.name === "solid-line";
}
exports.isSolidLineTechnique = isSolidLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SegmentsTechnique]].
 */
function isSegmentsTechnique(technique) {
    return technique.name === "segments";
}
exports.isSegmentsTechnique = isSegmentsTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]
 * or [[StandardExtrudedLineTechnique]].
 */
function isExtrudedLineTechnique(technique) {
    return technique.name === "extruded-line";
}
exports.isExtrudedLineTechnique = isExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].
 */
function isBasicExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "basic";
}
exports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].
 */
function isStandardExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
exports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[FillTechnique]].
 */
function isFillTechnique(technique) {
    return technique.name === "fill";
}
exports.isFillTechnique = isFillTechnique;
/**
 * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].
 */
function isExtrudedPolygonTechnique(technique) {
    return technique.name === "extruded-polygon";
}
exports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardTechnique]].
 */
function isStandardTechnique(technique) {
    return technique.name === "standard";
}
exports.isStandardTechnique = isStandardTechnique;
/**
 * Type guard to check if an object is an instance of [[TerrainTechnique]].
 */
function isTerrainTechnique(technique) {
    return technique.name === "terrain";
}
exports.isTerrainTechnique = isTerrainTechnique;
/**
 * Type guard to check if an object is an instance of [[TextTechnique]].
 */
function isTextTechnique(technique) {
    return technique.name === "text";
}
exports.isTextTechnique = isTextTechnique;
/**
 * Type guard to check if an object is an instance of [[ShaderTechnique]].
 */
function isShaderTechnique(technique) {
    return technique.name === "shader";
}
exports.isShaderTechnique = isShaderTechnique;
/**
 * Check if vertex normals should be generated for this technique (if no normals are in the data).
 * @param technique Technique to check.
 */
function needsVertexNormals(technique) {
    return (isFillTechnique(technique) ||
        isStandardTechnique(technique) ||
        isTerrainTechnique(technique) ||
        isStandardExtrudedLineTechnique(technique));
}
exports.needsVertexNormals = needsVertexNormals;
/**
 * Get the texture coordinate type if the technique supports it.
 */
function textureCoordinateType(technique) {
    if (isStandardTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isExtrudedPolygonTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isTerrainTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else {
        return undefined;
    }
}
exports.textureCoordinateType = textureCoordinateType;
/**
 * Add all the buffers of the technique to the transfer list.
 */
function addBuffersToTransferList(technique, transferList) {
    if (isStandardTechnique(technique) ||
        isExtrudedPolygonTechnique(technique) ||
        isTerrainTechnique(technique)) {
        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {
            const textureProperty = technique[texturePropertyKey];
            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.buffer instanceof ArrayBuffer) {
                    transferList.push(textureProperty.buffer);
                }
            }
        }
    }
}
exports.addBuffersToTransferList = addBuffersToTransferList;
/**
 * Compose full texture name for given image name with technique specified.
 * Some techniques allows to add prefix/postfix to icons names specified, this
 * function uses technique information to create fully qualified texture name.
 * @param imageName base name of the marker icon.
 * @param technique the technique describing POI or line marker.
 * @returns fully qualified texture name for loading from atlas (without extension).
 */
function composeTechniqueTextureName(imageName, technique) {
    let textureName = imageName;
    if (typeof technique.imageTexturePrefix === "string") {
        textureName = technique.imageTexturePrefix + textureName;
    }
    if (typeof technique.imageTexturePostfix === "string") {
        textureName = textureName + technique.imageTexturePostfix;
    }
    return textureName;
}
exports.composeTechniqueTextureName = composeTechniqueTextureName;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Theme.ts":
/*!************************************************!*\
  !*** ../harp-datasource-protocol/lib/Theme.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Checks if the given definition implements the [[ValueDefinition]] interface.
 */
function isValueDefinition(def) {
    const valueDef = def;
    return (typeof valueDef === "object" &&
        valueDef !== null &&
        typeof valueDef.type === "string" &&
        valueDef.value !== undefined);
}
exports.isValueDefinition = isValueDefinition;
function isSelectorDefinition(def) {
    const valueDef = def;
    return (typeof valueDef === "object" &&
        valueDef !== null &&
        valueDef.type === "selector" &&
        (typeof valueDef.value === "string" || Array.isArray(valueDef.value)));
}
exports.isSelectorDefinition = isSelectorDefinition;
function isActualSelectorDefinition(def) {
    const styleDef = def;
    return (typeof styleDef === "object" &&
        styleDef !== null &&
        !Array.isArray(styleDef) &&
        typeof styleDef.technique === "string");
}
exports.isActualSelectorDefinition = isActualSelectorDefinition;
/**
 * Checks if the given value is a reference to a definition.
 *
 * @param value The value of a technique property.
 */
function isReference(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        value[0] === "ref" &&
        typeof value[1] === "string");
}
exports.isReference = isReference;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ThemeVisitor.ts":
/*!*******************************************************!*\
  !*** ../harp-datasource-protocol/lib/ThemeVisitor.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Theme_1 = __webpack_require__(/*! ./Theme */ "../harp-datasource-protocol/lib/Theme.ts");
/**
 * The ThemeVisitor visits every style in the theme in a depth-first fashion.
 */
class ThemeVisitor {
    constructor(theme) {
        this.theme = theme;
    }
    /**
     * Applies a function to every style in the theme.
     *
     * @param visitFunc Function to be called with `style` as an argument. Function should return
     *                  `true` to cancel visitation.
     * @returns `true` if function has finished prematurely.
     */
    visitStyles(visitFunc) {
        const visit = (style) => {
            if (Theme_1.isReference(style)) {
                return false;
            }
            if (visitFunc(style)) {
                return true;
            }
            if (style.styles !== undefined) {
                for (const currStyle of style.styles) {
                    if (visit(currStyle)) {
                        return true;
                    }
                }
            }
            return false;
        };
        if (this.theme.styles !== undefined) {
            for (const styleSetName in this.theme.styles) {
                if (this.theme.styles[styleSetName] !== undefined) {
                    for (const style of this.theme.styles[styleSetName]) {
                        if (visit(style)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.ThemeVisitor = ThemeVisitor;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TileInfo.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/TileInfo.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Represents a feature group type for tile info.
 */
var FeatureGroupType;
(function (FeatureGroupType) {
    FeatureGroupType[FeatureGroupType["Point"] = 0] = "Point";
    FeatureGroupType[FeatureGroupType["Line"] = 1] = "Line";
    FeatureGroupType[FeatureGroupType["Polygon"] = 2] = "Polygon";
})(FeatureGroupType = exports.FeatureGroupType || (exports.FeatureGroupType = {}));
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * Structure of arrays containing data for all features of this group. No methods, since the object
 * is being passed as part of ExtendedTileInfo across "process boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 */
class FeatureGroup {
    /**
     * Construct featureGroup.
     *
     * @param storeExtendedTags Pass `true` to create fields for more OMV tags (`layer`, `class`
     * and `type`).
     */
    constructor(storeExtendedTags, startSize = 5000) {
        /** featureIds */
        this.featureIds = new Array();
        /** number of features */
        this.numFeatures = 0;
        /** number of positions of elements (2 per point) */
        this.numPositions = 0;
        this.featureIds = new Array(startSize);
        this.featureIds.length = startSize;
        this.techniqueIndex = new Array(startSize);
        this.techniqueIndex.length = startSize;
        this.textIndex = new Array(startSize);
        this.textIndex.length = startSize;
        this.positionIndex = new Array(startSize);
        this.positionIndex.length = startSize;
        this.positions = new Array(10 * startSize);
        this.positions.length = 10 * startSize;
        if (storeExtendedTags) {
            this.layerIndex = new Array(startSize);
            this.layerIndex.length = startSize;
            this.classIndex = new Array(startSize);
            this.classIndex.length = startSize;
            this.typeIndex = new Array(startSize);
            this.typeIndex.length = startSize;
        }
    }
    /**
     * Compute size in bytes.
     */
    getNumBytes() {
        return ((this.featureIds.length +
            this.techniqueIndex.length +
            this.textIndex.length +
            this.positionIndex.length +
            this.positions.length +
            (this.layerIndex !== undefined ? this.layerIndex.length : 0) +
            (this.classIndex !== undefined ? this.classIndex.length : 0) +
            (this.typeIndex !== undefined ? this.typeIndex.length : 0)) *
            8);
    }
}
exports.FeatureGroup = FeatureGroup;
/**
 * Structure of arrays containing data for roads. No methods, since the object is being passed as
 * part of [[ExtendedTileInfo]] across "process boundaries" to the web worker.
 */
class LineFeatureGroup extends FeatureGroup {
    constructor() {
        super(...arguments);
        /**
         * An array of object defined by the user. Certain elements may be `undefined` (if this line
         * feature is not a road, or if the object for that feature is undefined).
         */
        this.userData = [];
    }
    getNumBytes() {
        return (super.getNumBytes() +
            ((this.segmentIds !== undefined ? this.segmentIds.length : 0) +
                (this.segmentStartOffsets !== undefined ? this.segmentStartOffsets.length : 0) +
                (this.segmentEndOffsets !== undefined ? this.segmentEndOffsets.length : 0)) *
                8);
    }
}
exports.LineFeatureGroup = LineFeatureGroup;
/**
 * Structure of arrays containing data for polygons. No methods, since the object is being passed as
 * part of ExtendedTileInfo across "process boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 *
 * Due to the complexity of the access, there are supporting classes to store and access data in
 * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].
 */
class PolygonFeatureGroup extends FeatureGroup {
    constructor(storeExtendedTags, startSize = 5000) {
        super(storeExtendedTags, startSize);
        /**
         * Number of rings stored in all polygons in tis group. Used to keep size of the
         * arrays.
         */
        this.groupNumRings = 0;
        this.outerRingStartIndex = new Array(startSize);
        this.outerRingStartIndex.length = startSize;
        this.innerRingIsOuterContour = new Array(startSize);
        this.innerRingIsOuterContour.length = startSize;
        this.innerRingStartIndex = new Array(startSize);
        this.innerRingStartIndex.length = startSize;
    }
    getNumBytes() {
        return (super.getNumBytes() +
            ((this.outerRingStartIndex !== undefined ? this.outerRingStartIndex.length : 0) +
                (this.innerRingIsOuterContour !== undefined
                    ? this.innerRingIsOuterContour.length
                    : 0) +
                (this.innerRingStartIndex !== undefined ? this.innerRingStartIndex.length : 0)) *
                8);
    }
}
exports.PolygonFeatureGroup = PolygonFeatureGroup;
/**
 * Class to hold infos from [[OmvTile]]s. Optimized for fast serialization when being passed from
 * webworker to main thread. No methods, since the object is being passed across "process
 * boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 *
 * Due to the complexity of the access, there are supporting classes to store and access data in
 * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].
 */
class ExtendedTileInfo {
    constructor(tileKey, storeExtendedTags) {
        this.tileKey = tileKey;
        /**
         * Catalog of strings. Addressed by every features stringIndex.
         */
        this.textCatalog = new Array();
        /**
         * Catalog of techniques. Addressed by every features featureIndex.
         */
        this.techniqueCatalog = new Array();
        /**
         * Used for performance diagnostics.
         */
        this.setupTime = 0;
        /**
         * Size in bytes.
         */
        this.numBytes = 0;
        this.pointGroup = new FeatureGroup(storeExtendedTags);
        this.lineGroup = new LineFeatureGroup(storeExtendedTags);
        this.polygonGroup = new PolygonFeatureGroup(storeExtendedTags);
        if (storeExtendedTags) {
            this.layerCatalog = new Array();
            this.classCatalog = new Array();
            this.typeCatalog = new Array();
        }
    }
    /**
     * Compute the memory footprint caused by objects owned by the `ExtendedTileInfo`.
     */
    getNumBytes() {
        let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
        for (const str of this.textCatalog) {
            numBytes += 2 * str.length;
        }
        numBytes += this.techniqueCatalog.length * MINIMUM_OBJECT_SIZE_ESTIMATION;
        numBytes += this.pointGroup.getNumBytes();
        numBytes += this.lineGroup.getNumBytes();
        numBytes += this.polygonGroup.getNumBytes();
        if (this.layerCatalog !== undefined) {
            for (const str of this.layerCatalog) {
                numBytes += 2 * str.length;
            }
            for (const str of this.classCatalog) {
                numBytes += 2 * str.length;
            }
            for (const str of this.typeCatalog) {
                numBytes += 2 * str.length;
            }
        }
        return numBytes;
    }
}
exports.ExtendedTileInfo = ExtendedTileInfo;
(function (ExtendedTileInfo) {
    function finishFeatureGroup(featureGroup) {
        featureGroup.featureIds.length = featureGroup.numFeatures;
        featureGroup.techniqueIndex.length = featureGroup.numFeatures;
        featureGroup.textIndex.length = featureGroup.numFeatures;
        featureGroup.positionIndex.length = featureGroup.numFeatures;
        featureGroup.positions.length = featureGroup.numPositions;
        if (featureGroup.layerIndex !== undefined) {
            featureGroup.layerIndex.length = featureGroup.numFeatures;
        }
        if (featureGroup.classIndex !== undefined) {
            featureGroup.classIndex.length = featureGroup.numFeatures;
        }
        if (featureGroup.typeIndex !== undefined) {
            featureGroup.typeIndex.length = featureGroup.numFeatures;
        }
    }
    function finishPolygonFeatureGroup(polygonGroup) {
        finishFeatureGroup(polygonGroup);
        polygonGroup.outerRingStartIndex.length = polygonGroup.numFeatures;
        polygonGroup.innerRingIsOuterContour.length = polygonGroup.groupNumRings;
        polygonGroup.innerRingStartIndex.length = polygonGroup.groupNumRings;
    }
    function finishLineFeatureGroup(lineGroup) {
        finishFeatureGroup(lineGroup);
        if (lineGroup.segmentIds !== undefined) {
            lineGroup.segmentIds.length = lineGroup.numFeatures;
            lineGroup.segmentStartOffsets.length = lineGroup.numFeatures;
            lineGroup.segmentEndOffsets.length = lineGroup.numFeatures;
        }
    }
    /**
     * Finalize the tile's features groups.
     */
    function finish(tileInfo) {
        finishFeatureGroup(tileInfo.pointGroup);
        finishLineFeatureGroup(tileInfo.lineGroup);
        finishPolygonFeatureGroup(tileInfo.polygonGroup);
        tileInfo.numBytes = tileInfo.getNumBytes();
    }
    ExtendedTileInfo.finish = finish;
    /**
     * Returns the number of features in this feature group.
     */
    function featureGroupSize(featureGroup) {
        return featureGroup.numFeatures;
    }
    ExtendedTileInfo.featureGroupSize = featureGroupSize;
    /**
     * Check if the feature group is finalized.
     */
    function featureGroupFinished(featureGroup) {
        return featureGroup.numPositions === featureGroup.positions.length;
    }
    ExtendedTileInfo.featureGroupFinished = featureGroupFinished;
    /**
     * Check if the tileInfo is finalized.
     */
    function tileInfoFinished(tileInfo) {
        return (featureGroupFinished(tileInfo.pointGroup) &&
            featureGroupFinished(tileInfo.lineGroup) &&
            featureGroupFinished(tileInfo.polygonGroup));
    }
    ExtendedTileInfo.tileInfoFinished = tileInfoFinished;
    /**
     * Determine the text string of the (OMV) feature. It implements the special handling required
     * to determine the text content of a feature from its tags, which are passed in as the `env`.
     *
     * @param env Environment containing the tags from the (OMV) feature.
     * @param useAbbreviation `true` to use the abbreviation if available.
     * @param useIsoCode `true` to use the tag "iso_code".
     * @param languages List of languages to use, for example: Specify "en" to use the tag "name_en"
     *                  as the text of the string. Order reflects priority.
     */
    function getFeatureName(env, useAbbreviation, useIsoCode, languages) {
        let name;
        if (useAbbreviation) {
            const abbreviation = env.lookup(`name:short`);
            if (typeof abbreviation === "string" && abbreviation.length > 0) {
                return abbreviation;
            }
        }
        if (useIsoCode) {
            const isoCode = env.lookup(`iso_code`);
            if (typeof isoCode === "string" && isoCode.length > 0) {
                return isoCode;
            }
        }
        if (languages !== undefined) {
            for (const lang of languages) {
                name = env.lookup(`name:${lang}`) || env.lookup(`name_${lang}`);
                if (typeof name === "string" && name.length > 0) {
                    return name;
                }
            }
        }
        name = env.lookup("name");
        if (typeof name === "string") {
            return name;
        }
        return undefined;
    }
    ExtendedTileInfo.getFeatureName = getFeatureName;
})(ExtendedTileInfo = exports.ExtendedTileInfo || (exports.ExtendedTileInfo = {}));
/**
 * Support class for [[ExtendedTileInfo]]. Assist in filling it with data.
 */
class ExtendedTileInfoWriter {
    /**
     * Create an [[ExtendedTileInfoWriter]] for an [[ExtendedTileInfo]]. Assist in filling the
     * [[ExtendedTileInfo]] with data.
     *
     * @param tileInfo [[ExtendedTileInfo]] to write data to.
     * @param storeExtendedTags Pass `true` if feature data like `layer`, `class`or `type` should
     *          be stored for every feature.
     */
    constructor(tileInfo, storeExtendedTags, languages) {
        this.tileInfo = tileInfo;
        this.storeExtendedTags = storeExtendedTags;
        this.languages = languages;
        /** Map to identify which techniques already have been added to the [[ExtendedTileInfo]]. */
        this.techniqueIndexMap = new Map();
        /** Map to identify which strings already have been added to the [[ExtendedTileInfo]]. */
        this.stringMap = new Map();
        /** Map to identify which `layer` names already have been added to the [[ExtendedTileInfo]]. */
        this.layerMap = new Map();
        /** Map to identify which `class` names already have been added to the [[ExtendedTileInfo]]. */
        this.classMap = new Map();
        /** Map to identify which `type` names already have been added to the [[ExtendedTileInfo]]. */
        this.typeMap = new Map();
    }
    /**
     * Adds a [[Technique]] to the catalog of techniques. Individual techniques have a `_index` file
     * which has been created in the [[StyleSetEvaluator]]. This index is required to identify a
     * technique. The `Map` is used to map techniques to already added techniques, or store the
     * technique as new, and add it to the map.
     *
     * @param technique The [[Technique]] to add.
     */
    addTechnique(technique) {
        let infoTileTechniqueIndex = this.techniqueIndexMap.get(technique._index);
        if (infoTileTechniqueIndex !== undefined) {
            return infoTileTechniqueIndex;
        }
        infoTileTechniqueIndex = this.tileInfo.techniqueCatalog.length;
        // add a new technique. Select the subset of features that should be stored (e.g., _index is
        // not)
        const storedTechnique = {};
        Object.getOwnPropertyNames(technique).forEach(property => {
            if (!property.startsWith("_")) {
                storedTechnique[property] = technique[property];
            }
        });
        // Keep the index to identify the original technique later.
        storedTechnique._index = technique._index;
        storedTechnique._styleSetIndex = technique._styleSetIndex;
        this.techniqueIndexMap.set(technique._index, infoTileTechniqueIndex);
        this.tileInfo.techniqueCatalog.push(storedTechnique);
        return infoTileTechniqueIndex;
    }
    /**
     * Add a feature.
     *
     * @param featureGroup The feature group to add to.
     * @param technique The technique to add.
     * @param env The `env` which is a mix of original OMV feature tags and fields added by the
     *      [[StyleSetEvaluator]]
     * @param featureId The featureId, a number unique for many features (but not all).
     * @param infoTileTechniqueIndex The previously computed index of the technique. Must have been
     *      computed by `addTechnique(technique)`.
     * @param isPolygonGroup `true`for polygons.
     */
    addFeature(featureGroup, technique, env, featureId, infoTileTechniqueIndex, featureGroupType) {
        // compute name/label of feature
        const textTechnique = technique;
        const textLabel = textTechnique.label;
        const useAbbreviation = textTechnique.useAbbreviation;
        const useIsoCode = textTechnique.useIsoCode;
        const name = typeof textLabel === "string"
            ? env.lookup(textLabel)
            : ExtendedTileInfo.getFeatureName(env, useAbbreviation, useIsoCode, this.languages);
        let stringIndex = -1;
        if (name && typeof name === "string") {
            stringIndex = this.addText(name);
        }
        // add indices into the arrays.
        featureGroup.featureIds[featureGroup.numFeatures] = featureId;
        featureGroup.techniqueIndex[featureGroup.numFeatures] = infoTileTechniqueIndex;
        featureGroup.textIndex[featureGroup.numFeatures] = stringIndex;
        featureGroup.positionIndex[featureGroup.numFeatures] = featureGroup.numPositions;
        switch (featureGroupType) {
            case FeatureGroupType.Polygon:
                // polygons need the extra fields for polygon rings
                const polygonGroup = featureGroup;
                harp_utils_1.assert(polygonGroup.outerRingStartIndex !== undefined);
                harp_utils_1.assert(polygonGroup.innerRingStartIndex !== undefined);
                harp_utils_1.assert(polygonGroup.innerRingIsOuterContour !== undefined);
                polygonGroup.outerRingStartIndex[featureGroup.numFeatures] =
                    polygonGroup.groupNumRings;
                break;
            case FeatureGroupType.Line:
                featureGroup.userData[featureGroup.numFeatures] = env.entries;
                break;
        }
        // store the extra feature fields
        if (this.storeExtendedTags) {
            featureGroup.layerIndex[featureGroup.numFeatures] = this.addLayer(env.lookup("$layer"));
            featureGroup.classIndex[featureGroup.numFeatures] = this.addClass(env.lookup("class"));
            featureGroup.typeIndex[featureGroup.numFeatures] = this.addType(env.lookup("type"));
        }
        featureGroup.numFeatures++;
    }
    /**
     * Add the X/Y coordinate of the point. Only for point feature groups.
     *
     * @param featureGroup The feature group to add it to.
     * @param x X Position of point.
     * @param y Y Position of point.
     */
    addFeaturePoint(featureGroup, x, y) {
        featureGroup.positions[featureGroup.numPositions++] = x;
        featureGroup.positions[featureGroup.numPositions++] = y;
    }
    /**
     * Add the line points as X/Y coordinates to the line feature.
     *
     * If a line feature has more than one line (rare for HERE data), it should define multiple
     * line features for it.
     *
     * @param featureGroup The feature group to add to. Must be line feature group.
     * @param points The X/Y coordinates of the points.
     */
    addFeaturePoints(featureGroup, points) {
        const n = featureGroup.numPositions;
        const l = points.length;
        const p = featureGroup.positions;
        for (let i = 0; i < l; i++) {
            p[n + i] = points[i];
        }
        featureGroup.numPositions += points.length;
    }
    /**
     * Add the information about road segments to the line feature. Performs lazy initialization of
     * `segmentIds`, `segmentStartOffsets`, and `segmentEndOffsets` members of a
     * [[LineFeatureGroup]] instance.
     *
     * @param featureGroup The line feature group to add information to.
     * @param segmentId Segment id of a feature.
     * @param startOffset Start offset of a feature.
     * @param endOffset End offset of a feature.
     */
    addRoadSegments(featureGroup, segmentId, startOffset, endOffset) {
        if (featureGroup.segmentIds === undefined) {
            featureGroup.segmentIds = new Array();
            featureGroup.segmentStartOffsets = new Array();
            featureGroup.segmentEndOffsets = new Array();
        }
        featureGroup.segmentIds[featureGroup.numFeatures - 1] = segmentId;
        featureGroup.segmentStartOffsets[featureGroup.numFeatures - 1] = startOffset;
        featureGroup.segmentEndOffsets[featureGroup.numFeatures - 1] = endOffset;
    }
    /**
     * Add a single ring to the polygon. Can be called multiple times to add multiple rings to the
     * polygon.
     *
     * @param featureGroup Polygon feature group to add polygon ring to.
     * @param contour The X/Y coordinates of the ring.
     * @param isOuterRing Pass `true`if it is a outer ring, otherwise `false`.
     */
    addRingPoints(featureGroup, contour, isOuterRing) {
        featureGroup.innerRingStartIndex[featureGroup.groupNumRings] = featureGroup.numPositions;
        featureGroup.innerRingIsOuterContour[featureGroup.groupNumRings] = isOuterRing ? 1 : 0;
        featureGroup.groupNumRings++;
        const n = featureGroup.numPositions;
        const l = contour.length;
        const p = featureGroup.positions;
        for (let i = 0; i < l; i++) {
            p[n + i] = contour[i];
        }
        featureGroup.numPositions += contour.length;
    }
    /**
     * Finalize the tile info's feature group.
     */
    finish() {
        ExtendedTileInfo.finish(this.tileInfo);
    }
    addText(name) {
        return this.addStringValue(name, this.tileInfo.textCatalog, this.stringMap);
    }
    addLayer(name) {
        return this.addStringValue(name, this.tileInfo.layerCatalog, this.layerMap);
    }
    addClass(name) {
        return this.addStringValue(name, this.tileInfo.classCatalog, this.classMap);
    }
    addType(name) {
        return this.addStringValue(name, this.tileInfo.typeCatalog, this.typeMap);
    }
    // Add a string to the strings catalog. Returns index into the catalog.
    addStringValue(str, catalog, map) {
        if (str === undefined || str === null) {
            return -1;
        }
        const name = str.toString();
        let i = map.get(name);
        if (i !== undefined) {
            return i;
        }
        i = catalog.length;
        catalog.push(name);
        map.set(name, i);
        return i;
    }
}
exports.ExtendedTileInfoWriter = ExtendedTileInfoWriter;
/**
 * Implementation of [[ExtendedTileInfoPolygonAccessor]].
 */
class ExtendedTileInfoPolygonAccessorImpl {
    constructor() {
        /**
         * Feature's index in the group.
         */
        this.featureIndex = 0;
        /**
         * Indicates where the ring starts.
         */
        this.ringStart = 0;
        /**
         * Number of rings.
         */
        this.numRings = 0;
    }
    /**
     * Setup the accessor for extended [[TileInfo]].
     *
     * @param polygons polygons feature group.
     * @param featureIndex feature's index in the group.
     * @param ringStart where the ring starts.
     * @param numRings number of rings.
     */
    setup(polygons, featureIndex, ringStart, numRings) {
        this.polygons = polygons;
        this.featureIndex = featureIndex;
        this.ringStart = ringStart;
        this.numRings = numRings;
    }
    /**
     * Shut down the accessor and free all references.
     */
    reset() {
        this.polygons = undefined;
        this.featureIndex = 0;
        this.ringStart = 0;
        this.numRings = 0;
    }
    isOuterRing(ringIndex) {
        harp_utils_1.assert(ringIndex >= 0);
        harp_utils_1.assert(ringIndex < this.numRings);
        harp_utils_1.assert(this.polygons !== undefined);
        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {
            throw new Error("ExtendedTileInfoPolygonAccessor: Invalid ring index");
        }
        return this.polygons.innerRingIsOuterContour[this.ringStart + ringIndex] !== 0;
    }
    getPoints(ringIndex) {
        harp_utils_1.assert(ringIndex >= 0);
        harp_utils_1.assert(ringIndex < this.numRings);
        harp_utils_1.assert(this.polygons !== undefined);
        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {
            throw new Error("ExtendedTileInfoPolygonAccessor: Invalid ring index");
        }
        // compute the start/size of the points in this ring. All `points` are actually just the
        // indices of a single X/Y coordinate.
        const pointsStart = this.polygons.innerRingStartIndex[this.ringStart + ringIndex];
        let numPointValues;
        if (ringIndex < this.numRings - 1) {
            numPointValues =
                this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;
        }
        else {
            if (this.ringStart + ringIndex < this.polygons.innerRingStartIndex.length - 1) {
                numPointValues =
                    this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;
            }
            else {
                numPointValues = this.polygons.positions.length - pointsStart;
            }
        }
        return {
            points: this.polygons.positions,
            pointsStart,
            numPointValues
        };
    }
}
/**
 * Supporting class for [[ExtendedTileInfo]]. Takes an [[ExtendedTileInfoHandler]] and calls an
 * `accept` for every feature of the [[ExtendedTileInfo]], or just all features of a specified
 * `featureId`.
 */
class ExtendedTileInfoVisitor {
    constructor(tileInfo) {
        this.tileInfo = tileInfo;
    }
    /**
     * Visit all feature in the [[ExtendedTileInfo]]
     *
     * @param handler Let the `handler` visit all features.
     */
    visitAll(handler) {
        this.visitAllPointFeatures(handler);
        this.visitAllLineFeatures(handler);
        this.visitAllPolygonFeatures(handler);
    }
    /**
     * Visit all features of a specified featureId.
     *
     * @param featureId The featureId to visit.
     * @param handler The `handler` to use.
     */
    visitFeature(featureId, handler) {
        let numFeaturesFound = 0;
        const numPointFeatures = this.tileInfo.pointGroup.numFeatures;
        const pointFeatures = this.tileInfo.pointGroup.featureIds;
        for (let i = 0; i < numPointFeatures; i++) {
            if (pointFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitPointFeature(i, handler);
            }
        }
        const numLineFeatures = this.tileInfo.lineGroup.numFeatures;
        const lineFeatures = this.tileInfo.lineGroup.featureIds;
        for (let i = 0; i < numLineFeatures; i++) {
            if (lineFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitLineFeature(i, handler);
            }
        }
        const numPolygonFeatures = this.tileInfo.polygonGroup.numFeatures;
        const polygonsFeatures = this.tileInfo.polygonGroup.featureIds;
        for (let i = 0; i < numPolygonFeatures; i++) {
            if (polygonsFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitPolygonFeature(i, handler);
            }
        }
        return numFeaturesFound;
    }
    /**
     * Visit all `POINT` features.
     *
     * @param handler The `handler` to use.
     */
    visitAllPointFeatures(handler) {
        const numFeatures = this.tileInfo.pointGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitPointFeature(i, handler);
        }
    }
    /**
     * Visit all `LINESTRING` features.
     *
     * @param handler The handler to use.
     */
    visitAllLineFeatures(handler) {
        const numFeatures = this.tileInfo.lineGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitLineFeature(i, handler);
        }
    }
    /**
     * Visit all `POLYGON` features.
     *
     * @param handler The `handler` to use.
     */
    visitAllPolygonFeatures(handler) {
        const numFeatures = this.tileInfo.polygonGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitPolygonFeature(i, handler);
        }
    }
    getTag(featureIndex, index) {
        return index !== undefined && index[featureIndex] >= 0 ? index[featureIndex] : -1;
    }
    /**
     * Call the `handler` on a point feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitPointFeature(featureIndex, handler) {
        const tileInfo = this.tileInfo;
        const points = tileInfo.pointGroup;
        const start = points.positionIndex[featureIndex];
        const x = points.positions[start];
        const y = points.positions[start + 1];
        if (!!handler.acceptPoint) {
            handler.acceptPoint(points.featureIds[featureIndex], points.techniqueIndex[featureIndex], x, y, points.textIndex[featureIndex], this.getTag(featureIndex, points.layerIndex), this.getTag(featureIndex, points.classIndex), this.getTag(featureIndex, points.typeIndex));
        }
    }
    /**
     * Call the `handler` on a line feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitLineFeature(featureIndex, handler) {
        const tileInfo = this.tileInfo;
        const lines = tileInfo.lineGroup;
        const numFeatures = lines.numFeatures;
        const positionsStart = lines.positionIndex[featureIndex];
        const numPointValues = featureIndex === numFeatures - 1
            ? lines.positions.length - positionsStart
            : lines.positionIndex[featureIndex + 1] - positionsStart;
        let segmentId;
        let startOffset;
        let endOffset;
        if (lines.segmentIds !== undefined) {
            segmentId = lines.segmentIds[featureIndex];
            startOffset = lines.segmentStartOffsets[featureIndex];
            endOffset = lines.segmentEndOffsets[featureIndex];
        }
        if (!!handler.acceptLine) {
            handler.acceptLine(lines.featureIds[featureIndex], lines.techniqueIndex[featureIndex], lines.textIndex[featureIndex], this.getTag(featureIndex, lines.layerIndex), this.getTag(featureIndex, lines.classIndex), this.getTag(featureIndex, lines.typeIndex), tileInfo.lineGroup.positions, positionsStart, numPointValues, segmentId, startOffset, endOffset);
        }
    }
    /**
     * Call the `handler` on a polygon feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitPolygonFeature(featureIndex, handler) {
        if (handler.acceptPolygon === undefined) {
            return;
        }
        const tileInfo = this.tileInfo;
        const polygons = tileInfo.polygonGroup;
        const numFeatures = polygons.numFeatures;
        const ringStart = polygons.outerRingStartIndex[featureIndex];
        const numRings = featureIndex === numFeatures - 1
            ? polygons.innerRingStartIndex.length - ringStart
            : polygons.outerRingStartIndex[featureIndex + 1] - ringStart;
        // Use a static instance, so we do not allocate anything here
        ExtendedTileInfoVisitor.polygonAccessor.setup(polygons, featureIndex, ringStart, numRings);
        handler.acceptPolygon(polygons.featureIds[featureIndex], polygons.techniqueIndex[featureIndex], polygons.textIndex[featureIndex], this.getTag(featureIndex, polygons.layerIndex), this.getTag(featureIndex, polygons.classIndex), this.getTag(featureIndex, polygons.typeIndex), ExtendedTileInfoVisitor.polygonAccessor);
        // Free all data references.
        ExtendedTileInfoVisitor.polygonAccessor.reset();
    }
}
// static instance to work without allocations.
ExtendedTileInfoVisitor.polygonAccessor = new ExtendedTileInfoPolygonAccessorImpl();
exports.ExtendedTileInfoVisitor = ExtendedTileInfoVisitor;


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts":
/*!****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Allows to cancel and prioritize requests inside the requestQueue. Useful to optimize the order of
 * decoding tiles during animations and camera movements.
 *
 * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.
 */
class RequestController {
    /**
     * Creates an instance of `RequestController`.
     *
     * @param {number} priority
     * @param {AbortController} abortController Optional [[AbortController]] used internally, since
     *      [[AbortController]]s should not be subclassed.
     */
    constructor(priority = 0, abortController = new AbortController()) {
        this.priority = priority;
        this.abortController = abortController;
    }
    get signal() {
        return this.abortController.signal;
    }
    /**
     * Invoking this method will set this object's AbortSignal's aborted flag and
     * signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        this.abortController.abort();
    }
}
exports.RequestController = RequestController;
/**
 * Communication protocol with [[ITileDecoder]].
 */
var WorkerDecoderProtocol;
(function (WorkerDecoderProtocol) {
    /**
     * Define possible names of messages exchanged with decoder services within `WebWorker`.
     */
    let DecoderMessageName;
    (function (DecoderMessageName) {
        DecoderMessageName["Configuration"] = "configuration";
    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));
    /**
     * Type guard to check if an object is an instance of `ConfigurationMessage`.
     */
    function isConfigurationMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === DecoderMessageName.Configuration);
    }
    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;
    /**
     * Define possible names of requests called on decoder services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["DecodeTileRequest"] = "decode-tile-request";
        Requests["TileInfoRequest"] = "tile-info-request";
    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a decoded tile object sent to a worker.
     */
    function isDecodeTileRequest(message) {
        return (message &&
            typeof message.type === "string" &&
            message.type === Requests.DecodeTileRequest);
    }
    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;
    /**
     * Type guard to check if an object is an info tile object sent to a worker.
     */
    function isTileInfoRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.TileInfoRequest);
    }
    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerServiceProtocol.ts":
/*!****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerServiceProtocol.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Common communication protocol for [[WorkerService]].
 */
var WorkerServiceProtocol;
(function (WorkerServiceProtocol) {
    /**
     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service
     * instances in workers.
     */
    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    /**
     * Define possible names of messages exchanged with services within `WebWorker`.
     */
    let ServiceMessageName;
    (function (ServiceMessageName) {
        ServiceMessageName["Initialized"] = "initialized";
        ServiceMessageName["Request"] = "request";
        ServiceMessageName["Response"] = "response";
    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));
    /**
     * Type guard to check if an object is a signal message from worker.
     */
    function isInitializedMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Initialized);
    }
    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;
    /**
     * Define possible names of requests called on services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["CreateService"] = "create-service";
        Requests["DestroyService"] = "destroy-service";
    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isRequestMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Request);
    }
    WorkerServiceProtocol.isRequestMessage = isRequestMessage;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isResponseMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Response);
    }
    WorkerServiceProtocol.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerTilerProtocol.ts":
/*!**************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerTilerProtocol.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Communication protocol with [[ITiler]].
 */
var WorkerTilerProtocol;
(function (WorkerTilerProtocol) {
    /**
     * Define possible names of requests called on tiler services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["RegisterIndex"] = "register-index";
        Requests["UpdateIndex"] = "update-index";
        Requests["TileRequest"] = "tile-request";
    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));
    /**
     * Type guard to check if an object is an index registration request sent to a worker.
     */
    function isRegisterIndexRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.RegisterIndex);
    }
    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;
    /**
     * Type guard to check if an object is an update request for the index registration.
     */
    function isUpdateIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.UpdateIndex;
    }
    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;
    /**
     * Type guard to check if an object is a tile request sent to a worker.
     */
    function isTileRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.TileRequest;
    }
    WorkerTilerProtocol.isTileRequest = isTileRequest;
})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/CastOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/CastOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    "to-boolean": {
        call: (context, args) => {
            return Boolean(context.evaluate(args[0]));
        }
    },
    "to-string": {
        call: (context, args) => {
            return String(context.evaluate(args[0]));
        }
    },
    "to-number": {
        call: (context, args) => {
            for (const arg of args) {
                const value = Number(context.evaluate(arg));
                if (!isNaN(value)) {
                    return value;
                }
            }
            throw new Error("cannot convert the value to a number");
        }
    }
};
exports.CastOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ComparisonOperators.ts":
/*!************************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ComparisonOperators.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function compare(context, op, actuals, strict = false) {
    const left = context.evaluate(actuals[0]);
    const right = context.evaluate(actuals[1]);
    if (!((typeof left === "number" && typeof right === "number") ||
        (typeof left === "string" && typeof right === "string"))) {
        if (strict) {
            throw new Error(`invalid operands '${left}' and '${right}' for operator '${op}'`);
        }
    }
    switch (op) {
        case "<":
            return left < right;
        case ">":
            return left > right;
        case "<=":
            return left <= right;
        case ">=":
            return left >= right;
        default:
            throw new Error(`invalid comparison operator '${op}'`);
    }
}
const operators = {
    "!": {
        call: (context, args) => {
            return !context.evaluate(args[0]);
        }
    },
    "==": {
        call: (context, args) => {
            const left = context.evaluate(args[0]);
            const right = context.evaluate(args[1]);
            return left === right;
        }
    },
    "!=": {
        call: (context, args) => {
            const left = context.evaluate(args[0]);
            const right = context.evaluate(args[1]);
            return left !== right;
        }
    },
    "<": { call: (context, args) => compare(context, "<", args) },
    ">": { call: (context, args) => compare(context, ">", args) },
    "<=": { call: (context, args) => compare(context, "<=", args) },
    ">=": { call: (context, args) => compare(context, ">=", args) }
};
exports.ComparisonOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/FlowOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/FlowOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function conditionalCast(context, type, args) {
    switch (type) {
        case "boolean":
        case "number":
        case "string":
            for (const childExpr of args) {
                const value = context.evaluate(childExpr);
                if (typeof value === type) {
                    return value;
                }
            }
            throw new Error(`expected a '${type}'`);
        default:
            throw new Error(`invalid type '${type}'`);
    } // switch
}
const operators = {
    boolean: {
        call: (context, args) => {
            return conditionalCast(context, "boolean", args);
        }
    },
    number: {
        call: (context, args) => {
            return conditionalCast(context, "number", args);
        }
    },
    string: {
        call: (context, args) => {
            return conditionalCast(context, "string", args);
        }
    }
};
exports.FlowOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MathOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MathOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    "^": {
        call: (context, args) => {
            const a = context.evaluate(args[0]);
            const b = context.evaluate(args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);
            }
            return Math.pow(a, b);
        }
    },
    "-": {
        call: (context, args) => {
            const a = context.evaluate(args[0]);
            const b = context.evaluate(args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);
            }
            return a - b;
        }
    },
    "/": {
        call: (context, args) => {
            const a = context.evaluate(args[0]);
            const b = context.evaluate(args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);
            }
            return a / b;
        }
    },
    "%": {
        call: (context, args) => {
            const a = context.evaluate(args[0]);
            const b = context.evaluate(args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);
            }
            return a % b;
        }
    },
    "+": {
        call: (context, args) => {
            return args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);
        }
    },
    "*": {
        call: (context, args) => {
            return args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);
        }
    },
    abs: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'abs'`);
            }
            return Math.abs(value);
        }
    },
    acos: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'acos'`);
            }
            return Math.acos(value);
        }
    },
    asin: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'asin'`);
            }
            return Math.asin(value);
        }
    },
    atan: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'atan'`);
            }
            return Math.atan(value);
        }
    },
    ceil: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ceil'`);
            }
            return Math.ceil(value);
        }
    },
    cos: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'cos'`);
            }
            return Math.cos(value);
        }
    },
    e: {
        call: () => {
            return Math.E;
        }
    },
    floor: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'floor'`);
            }
            return Math.floor(value);
        }
    },
    ln: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln'`);
            }
            return Math.log(value);
        }
    },
    ln2: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln2'`);
            }
            return Math.log2(value);
        }
    },
    log10: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'log10'`);
            }
            return Math.log10(value);
        }
    },
    max: {
        call: (context, args) => {
            return Math.max(...args.map(v => Number(context.evaluate(v))));
        }
    },
    min: {
        call: (context, args) => {
            return Math.min(...args.map(v => Number(context.evaluate(v))));
        }
    },
    pi: {
        call: () => {
            return Math.PI;
        }
    },
    round: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'round'`);
            }
            return Math.round(value);
        }
    },
    sin: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sin'`);
            }
            return Math.sin(value);
        }
    },
    sqrt: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);
            }
            return Math.sqrt(value);
        }
    },
    tan: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'tan'`);
            }
            return Math.tan(value);
        }
    }
};
exports.MathOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MiscOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MiscOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    length: {
        call: (context, args) => {
            const value = context.evaluate(args[0]);
            if (Array.isArray(value) || typeof value === "string") {
                return value.length;
            }
            throw new Error(`invalid operand '${value}' for operator 'length'`);
        }
    }
};
exports.MiscOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/StringOperators.ts":
/*!********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/StringOperators.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    concat: {
        call: (context, args) => {
            return "".concat(...args.map(a => String(context.evaluate(a))));
        }
    },
    downcase: {
        call: (context, args) => {
            return String(context.evaluate(args[0])).toLocaleLowerCase();
        }
    },
    upcase: {
        call: (context, args) => {
            return String(context.evaluate(args[0])).toLocaleUpperCase();
        }
    },
    "~=": {
        call: (context, args) => {
            const left = context.evaluate(args[0]);
            const right = context.evaluate(args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.indexOf(right) !== -1;
            }
            return false;
        }
    },
    "^=": {
        call: (context, args) => {
            const left = context.evaluate(args[0]);
            const right = context.evaluate(args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.startsWith(right);
            }
            return false;
        }
    },
    "$=": {
        call: (context, args) => {
            const left = context.evaluate(args[0]);
            const right = context.evaluate(args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.endsWith(right);
            }
            return false;
        }
    }
};
exports.StringOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/TypeOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/TypeOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    typeof: {
        call: (context, args) => {
            return typeof context.evaluate(args[0]);
        }
    }
};
exports.TypeOperators = operators;


/***/ }),

/***/ "../harp-features-datasource/index.ts":
/*!********************************************!*\
  !*** ../harp-features-datasource/index.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Features */ "../harp-features-datasource/lib/Features.ts"));
__export(__webpack_require__(/*! ./lib/FeaturesDataSource */ "../harp-features-datasource/lib/FeaturesDataSource.ts"));


/***/ }),

/***/ "../harp-features-datasource/lib/Features.ts":
/*!***************************************************!*\
  !*** ../harp-features-datasource/lib/Features.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Base class to create features.
 */
class MapViewFeature {
    /**
     * Builds a new `MapViewFeature`.
     *
     * @param coordinates The GeoJson geometry.
     * @param style The style to render the geometry.
     */
    constructor(coordinates, properties) {
        this.coordinates = coordinates;
        this.properties = properties;
        /**
         * The type of the feature. The extended class should initialize this value. It defaults to
         * "Point" in order to avoid allowing `null` or `undefined`.
         */
        this.type = "Point";
        /**
         * A string identifying this feature.
         */
        this.uuid = THREE.Math.generateUUID();
    }
}
exports.MapViewFeature = MapViewFeature;
class MapViewLineFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        this.type = "LineString";
    }
}
exports.MapViewLineFeature = MapViewLineFeature;
class MapViewMultiLineFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        this.type = "MultiLineString";
    }
}
exports.MapViewMultiLineFeature = MapViewMultiLineFeature;
class MapViewPolygonFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        this.type = "Polygon";
    }
}
exports.MapViewPolygonFeature = MapViewPolygonFeature;
class MapViewMultiPolygonFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        this.type = "MultiPolygon";
    }
}
exports.MapViewMultiPolygonFeature = MapViewMultiPolygonFeature;
class MapViewPointFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        this.type = "Point";
    }
}
exports.MapViewPointFeature = MapViewPointFeature;
class MapViewMultiPointFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        this.type = "MultiPoint";
    }
}
exports.MapViewMultiPointFeature = MapViewMultiPointFeature;


/***/ }),

/***/ "../harp-features-datasource/lib/FeaturesDataSource.ts":
/*!*************************************************************!*\
  !*** ../harp-features-datasource/lib/FeaturesDataSource.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geojson_datasource_1 = __webpack_require__(/*! @here/harp-geojson-datasource */ "../harp-geojson-datasource/index.ts");
const harp_omv_datasource_1 = __webpack_require__(/*! @here/harp-omv-datasource */ "../harp-omv-datasource/index.ts");
const NAME = "user-features-datasource";
const DEFAULT_GEOJSON = {
    type: "FeatureCollection",
    features: []
};
/**
 * [[DataSource]] implementation to use for the addition of custom features.
 */
class FeaturesDataSource extends harp_omv_datasource_1.OmvDataSource {
    /**
     * Builds a `FeaturesDataSource`.
     *
     * @param workerTilerUrl Worker tiler URL. Defaults to `./decoder.bundle.ts` in the
     * [[ConcurrentTilerFacade]].
     */
    constructor(workerTilerUrl) {
        super({
            dataProvider: new harp_geojson_datasource_1.GeoJsonDataProvider(NAME, DEFAULT_GEOJSON, { workerTilerUrl })
        });
        this.m_featureCollection = this.emptyGeojson();
    }
    /**
     * This method allows to directly add a GeoJSON without using [[MapViewFeature]] instances. It
     * also overwrites existing features in this data source. To add a GeoJSON without overwriting
     * the data source, one should loop through it to create [[MapViewFeature]] and add them with
     * the `add` method.
     *
     * @param geojson A javascript object matching the GeoJSON specification.
     */
    setFromGeojson(geojson) {
        if (geojson.type === "FeatureCollection") {
            this.m_featureCollection = geojson;
        }
        else if (geojson.type === "Feature") {
            this.m_featureCollection = this.emptyGeojson();
            this.m_featureCollection.features.push(geojson);
        }
        else if (geojson.type === "GeometryCollection") {
            this.m_featureCollection = this.emptyGeojson();
            for (const geometry of geojson.geometries) {
                this.m_featureCollection.features.push({
                    type: "Feature",
                    geometry
                });
            }
        }
        else {
            throw new TypeError("The provided object is not a valid GeoJSON object.");
        }
        this.update();
        return this;
    }
    /**
     * Adds a custom feature in the datasource.
     *
     * @param features The features to add in the datasource.
     */
    add(...features) {
        for (const feature of features) {
            this.addFeature(feature);
        }
        this.update();
        return this;
    }
    /**
     * Removes a custom feature in the datasource.
     *
     * @param features The features to add in the datasource.
     */
    remove(...features) {
        for (const feature of features) {
            this.removeFeature(feature);
        }
        this.update();
        return this;
    }
    /**
     * Removes all the custom features in this `FeaturesDataSource`.
     */
    clear() {
        this.m_featureCollection = this.emptyGeojson();
        this.update();
    }
    addFeature(feature) {
        // Check if the feature is not already in there.
        const hasFeature = this.m_featureCollection.features.some(_feature => _feature.properties.__mapViewUuid === feature.uuid);
        if (hasFeature) {
            return;
        }
        // Create a GeoJson feature from the feature coordinates and push it.
        const geometry = {
            type: feature.type,
            coordinates: feature.coordinates
        };
        const geojsonFeature = {
            type: "Feature",
            geometry,
            properties: Object.assign({}, feature.properties, { __mapViewUuid: feature.uuid })
        };
        this.m_featureCollection.features.push(geojsonFeature);
    }
    removeFeature(feature) {
        // Remove geojson feature from the root FeatureCollection.
        const index = this.m_featureCollection.features.findIndex(_feature => _feature.properties.__mapViewUuid === feature.uuid);
        if (index === -1) {
            return;
        }
        this.m_featureCollection.features.splice(index, 1);
    }
    update() {
        this.dataProvider().updateInput(this.m_featureCollection);
        this.mapView.markTilesDirty(this);
        this.mapView.clearTileCache(this.name);
    }
    emptyGeojson() {
        return {
            features: [],
            type: "FeatureCollection"
        };
    }
}
exports.FeaturesDataSource = FeaturesDataSource;


/***/ }),

/***/ "../harp-fetch/index.web.ts":
/*!**********************************!*\
  !*** ../harp-fetch/index.web.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "../harp-geojson-datasource/index.ts":
/*!*******************************************!*\
  !*** ../harp-geojson-datasource/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/GeoJsonDataSource */ "../harp-geojson-datasource/lib/GeoJsonDataSource.ts"));
__export(__webpack_require__(/*! ./lib/GeoJsonDataProvider */ "../harp-geojson-datasource/lib/GeoJsonDataProvider.ts"));


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonDataProvider.ts":
/*!*************************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonDataProvider.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
/**
 * GeoJson [[DataProvider]]. Automatically handles tiling and simplification of static GeoJson.
 */
class GeoJsonDataProvider {
    /**
     * Constructs a new `GeoJsonDataProvider`.
     *
     * @param name Name to be used to reference this `DataProvider`
     * @param input URL of the GeoJSON, or a GeoJSON.
     * @param options Optional
     * @returns New `GeoJsonDataProvider`.
     */
    constructor(name, input, options) {
        this.name = name;
        this.input = input;
        this.m_registered = false;
        this.m_tiler =
            (options && options.tiler) ||
                harp_mapview_1.ConcurrentTilerFacade.getTiler("omv-tiler", options && options.workerTilerUrl);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.m_tiler.connect();
            this.m_tiler.registerIndex(this.name, this.input).then(() => {
                this.m_registered = true;
            });
        });
    }
    updateInput(input) {
        this.input = input;
        this.m_tiler.updateIndex(this.name, this.input);
    }
    ready() {
        return this.m_registered;
    }
    getTile(tileKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.m_tiler.getTile(this.name, tileKey);
        });
    }
}
exports.GeoJsonDataProvider = GeoJsonDataProvider;


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonDataSource.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const GeoJsonTile_1 = __webpack_require__(/*! ./GeoJsonTile */ "../harp-geojson-datasource/lib/GeoJsonTile.ts");
/**
 * `GeoJsonDataSource` is used for the visualization of geometric objects provided in the GeoJSON
 * format. To be able to render GeoJSON data, a `GeoJsonDataSource` instance must be added to the
 * [[MapView]] instance.
 *
 * @example <caption><b>Example usage of GeoJsonDataSource:</b></caption>
 * <pre>
 * const geoJsonDataSource = new GeoJsonDataSource({
 *    dataStore: {
 *       dataProvider: new XYZDataProvider({baseUrl, spaceId, token})
 *    }
 * });
 *
 * mapView.addDataSource(geoJsonDataSource);
 * // Show geoJSON data on specific tile
 * geoJsonDataSource.selectTile(geoJsonDataTile, mapView.projection);
 * </pre>
 */
class GeoJsonDataSource extends harp_mapview_decoder_1.TileDataSource {
    /**
     * Default constructor.
     *
     * @param params Data source configuration's parameters.
     */
    constructor(params) {
        super(new harp_mapview_decoder_1.TileFactory(GeoJsonTile_1.GeoJsonTile), {
            styleSetName: params.styleSetName || "geojson",
            name: params.name,
            tilingScheme: harp_geoutils_1.webMercatorTilingScheme,
            dataProvider: params.dataProvider,
            concurrentDecoderServiceName: "geojson-tile-decoder",
            storageLevelOffset: -1
        });
        this.params = params;
    }
    connect() {
        const _super = Object.create(null, {
            connect: { get: () => super.connect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.connect.call(this);
            yield this.decoder.connect();
        });
    }
}
exports.GeoJsonDataSource = GeoJsonDataSource;


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonTile.ts":
/*!*****************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonTile.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * It contains default values for the labeled icons
 */
const DEFAULT_LABELED_ICON = {
    priority: 1000,
    size: 16,
    xOffset: 0.0,
    yOffset: 0.0,
    mayOverlap: false,
    reserveSpace: true,
    alwaysOnTop: true,
    textIsOptional: true,
    iconIsOptional: false,
    iconMayOverlap: false,
    renderTextDuringMovements: true,
    textReserveSpace: true,
    imageTextureName: "location",
    label: "",
    featureId: 0
};
/**
 * The `GeoJsonTile` class is used to create objects from decoded GeoJSON data. Instances of
 * `GeoJsonTile` are created by [[GeoJsonDataSource.getTile]] and used by [[MapView]] to add tile
 * objects to the scene.
 */
class GeoJsonTile extends harp_mapview_1.Tile {
    /**
     * Tiles render at all zoom levels. This method stores the zoom level in order to know how to
     * scale the lines's width.
     *
     * @param zoomLevel zoom level.
     * @returns always returns `true`
     */
    willRender(zoomLevel) {
        if (this.m_currentZoomLevel !== zoomLevel) {
            this.m_currentZoomLevel = zoomLevel;
        }
        return true;
    }
    /**
     * For unit testing.
     * TODO: find a better solution and/or get rid of window in this class at all.
     */
    getWindow() {
        return window;
    }
    /**
     * Given a decode tile, it adds labeled icons to it. This method overrides the
     * `createTextElements` in the [[Tile]] class.
     *
     * @param decodedTile The decoded tile received by the [[GeoJsonDecoder]].
     */
    createTextElements(decodedTile) {
        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        if (decodedTile.poiGeometries !== undefined) {
            for (const geometry of decodedTile.poiGeometries) {
                const techniqueIndex = geometry.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (harp_datasource_protocol_1.isPoiTechnique(technique)) {
                    this.addPois(tileGeometryCreator, geometry, technique);
                }
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const geometry of decodedTile.textGeometries) {
                const techniqueIndex = geometry.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (harp_datasource_protocol_1.isTextTechnique(technique)) {
                    this.addTexts(tileGeometryCreator, geometry, technique);
                }
            }
        }
        if (decodedTile.textPathGeometries !== undefined) {
            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);
            for (const textPath of this.preparedTextPaths) {
                const techniqueIndex = textPath.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (harp_datasource_protocol_1.isTextTechnique(technique)) {
                    this.addTextPaths(tileGeometryCreator, textPath, technique);
                }
            }
        }
    }
    /**
     * Calls `addTextPath` for each TextPath.
     *
     * @param tileGeometryCreator [[TileGeometryCreator]] to help with the text path.
     * @param geometry The TextPath geometry.
     * @param technique Text technique.
     */
    addTextPaths(tileGeometryCreator, geometry, technique) {
        const path = [];
        for (let i = 0; i < geometry.path.length; i += 3) {
            path.push(new THREE.Vector3(geometry.path[i], geometry.path[i + 1], geometry.path[i + 2]));
        }
        const properties = geometry.objInfos !== undefined ? geometry.objInfos : undefined;
        this.addTextPath(tileGeometryCreator, path, geometry.text, technique, properties);
    }
    /**
     * Add a label available for mouse picking at the given path.
     *
     * @param tileGeometryCreator [[TileGeometryCreator]] to help with the text path.
     * @param path Path of the text path.
     * @param text Text of the path.
     * @param technique Technique in use.
     * @param geojsonProperties Properties defined by the user.
     */
    addTextPath(tileGeometryCreator, path, text, technique, geojsonProperties) {
        const priority = technique.priority === undefined ? DEFAULT_LABELED_ICON.priority : technique.priority;
        const xOffset = technique.xOffset === undefined ? DEFAULT_LABELED_ICON.xOffset : technique.xOffset;
        const yOffset = technique.yOffset === undefined ? DEFAULT_LABELED_ICON.yOffset : technique.yOffset;
        const featureId = DEFAULT_LABELED_ICON.featureId;
        const textElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), path, tileGeometryCreator.getRenderStyle(this, technique), tileGeometryCreator.getLayoutStyle(this, technique), harp_datasource_protocol_1.getPropertyValue(priority, this.mapView.zoomLevel), xOffset, yOffset, featureId);
        // Set the userData of the TextElement to the geojsonProperties, then it will be available
        // for picking.
        if (geojsonProperties !== undefined) {
            textElement.userData = geojsonProperties;
        }
        const mayOverlap = technique.mayOverlap === undefined
            ? DEFAULT_LABELED_ICON.iconMayOverlap
            : technique.mayOverlap;
        const reserveSpace = technique.reserveSpace === undefined
            ? DEFAULT_LABELED_ICON.textReserveSpace
            : technique.reserveSpace;
        const distanceScale = harp_mapview_1.DEFAULT_TEXT_DISTANCE_SCALE;
        textElement.mayOverlap = mayOverlap;
        textElement.reserveSpace = reserveSpace;
        textElement.distanceScale = distanceScale;
        this.addUserTextElement(textElement);
    }
    /**
     * Calls `addText` on each vertex of the geometry.
     *
     * @param tileGeometryCreator [[TileGeometryCreator]] to help with the text path.
     * @param geometry The Text geometry.
     * @param technique Text technique.
     */
    addTexts(tileGeometryCreator, geometry, technique) {
        const attribute = harp_mapview_1.getBufferAttribute(geometry.positions);
        for (let index = 0; index < attribute.count; index++) {
            const currentVertexCache = new THREE.Vector3(attribute.getX(index), attribute.getY(index), attribute.getZ(index));
            const properties = geometry.objInfos !== undefined ? geometry.objInfos[index] : undefined;
            const text = geometry.stringCatalog[index];
            this.addText(tileGeometryCreator, currentVertexCache, text, technique, properties);
        }
    }
    /**
     * Add a label available for mouse picking at the given position.
     *
     * @param tileGeometryCreator [[TileGeometryCreator]] to help with the text path.
     * @param position position of the labeled Icon, in world coordinate.
     * @param text Text of the path.
     * @param technique Technique in use.
     * @param geojsonProperties Properties defined by the user.
     */
    addText(tileGeometryCreator, position, text, technique, geojsonProperties) {
        const priority = technique.priority === undefined ? DEFAULT_LABELED_ICON.priority : technique.priority;
        const xOffset = technique.xOffset === undefined ? DEFAULT_LABELED_ICON.xOffset : technique.xOffset;
        const yOffset = technique.yOffset === undefined ? DEFAULT_LABELED_ICON.yOffset : technique.yOffset;
        const featureId = DEFAULT_LABELED_ICON.featureId;
        const textElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), position, tileGeometryCreator.getRenderStyle(this, technique), tileGeometryCreator.getLayoutStyle(this, technique), harp_datasource_protocol_1.getPropertyValue(priority, this.mapView.zoomLevel), xOffset, yOffset, featureId);
        // Set the userData of the TextElement to the geojsonProperties, then it will be available
        // for picking.
        if (geojsonProperties !== undefined) {
            textElement.userData = geojsonProperties;
        }
        const mayOverlap = technique.mayOverlap === undefined
            ? DEFAULT_LABELED_ICON.iconMayOverlap
            : technique.mayOverlap;
        const distanceScale = harp_mapview_1.DEFAULT_TEXT_DISTANCE_SCALE;
        textElement.mayOverlap = mayOverlap;
        textElement.reserveSpace = false;
        textElement.distanceScale = distanceScale;
        this.addUserTextElement(textElement);
    }
    /**
     * Calls `addPoi` on each vertex of the geometry.
     *
     * @param tileGeometryCreator [[TileGeometryCreator]] to help with the text path.
     * @param geometry The POI geometry.
     * @param technique POI technique.
     */
    addPois(tileGeometryCreator, geometry, technique) {
        const attribute = harp_mapview_1.getBufferAttribute(geometry.positions);
        const currentVertexCache = new THREE.Vector3();
        for (let index = 0; index < attribute.count; index++) {
            currentVertexCache.set(attribute.getX(index), attribute.getY(index), attribute.getZ(index));
            const properties = geometry.objInfos !== undefined ? geometry.objInfos[index] : undefined;
            this.addPoi(tileGeometryCreator, currentVertexCache, technique, properties);
        }
    }
    /**
     * Add a POI available for mouse picking at the given position.
     *
     * @param tileGeometryCreator [[TileGeometryCreator]] to help with the text path.
     * @param position position of the labeled Icon, in world coordinate.
     * @param technique Technique in use.
     * @param geojsonProperties Properties defined by the user.
     */
    addPoi(tileGeometryCreator, position, technique, geojsonProperties) {
        const label = DEFAULT_LABELED_ICON.label;
        const priority = technique.priority === undefined ? DEFAULT_LABELED_ICON.priority : technique.priority;
        const xOffset = technique.xOffset === undefined ? DEFAULT_LABELED_ICON.xOffset : technique.xOffset;
        const yOffset = technique.yOffset === undefined ? DEFAULT_LABELED_ICON.yOffset : technique.yOffset;
        const featureId = DEFAULT_LABELED_ICON.featureId;
        const textElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), position, tileGeometryCreator.getRenderStyle(this, technique), tileGeometryCreator.getLayoutStyle(this, technique), harp_datasource_protocol_1.getPropertyValue(priority, this.mapView.zoomLevel), xOffset, yOffset, featureId);
        // Set the userData of the TextElement to the geojsonProperties, then it will be available
        // for picking.
        if (geojsonProperties !== undefined) {
            textElement.userData = geojsonProperties;
        }
        const mayOverlap = technique.iconMayOverlap === undefined
            ? DEFAULT_LABELED_ICON.iconMayOverlap
            : technique.iconMayOverlap;
        const reserveSpace = technique.iconReserveSpace === undefined
            ? DEFAULT_LABELED_ICON.textReserveSpace
            : technique.iconReserveSpace;
        const distanceScale = harp_mapview_1.DEFAULT_TEXT_DISTANCE_SCALE;
        const alwaysOnTop = technique.alwaysOnTop === undefined
            ? DEFAULT_LABELED_ICON.alwaysOnTop
            : technique.alwaysOnTop;
        textElement.mayOverlap = mayOverlap;
        textElement.reserveSpace = reserveSpace;
        textElement.distanceScale = distanceScale;
        textElement.alwaysOnTop = alwaysOnTop;
        const textIsOptional = technique.textIsOptional === undefined
            ? DEFAULT_LABELED_ICON.textIsOptional
            : technique.textIsOptional;
        const iconIsOptional = technique.iconIsOptional === undefined
            ? DEFAULT_LABELED_ICON.iconIsOptional
            : technique.iconIsOptional;
        const renderTextDuringMovements = technique.renderTextDuringMovements === undefined
            ? DEFAULT_LABELED_ICON.renderTextDuringMovements
            : technique.renderTextDuringMovements;
        const imageTextureName = technique.imageTexture !== undefined
            ? technique.imageTexture
            : DEFAULT_LABELED_ICON.imageTextureName;
        textElement.poiInfo = {
            technique,
            imageTextureName,
            textElement,
            textIsOptional,
            iconIsOptional,
            renderTextDuringMovements,
            mayOverlap,
            reserveSpace,
            featureId
        };
        this.addUserTextElement(textElement);
    }
}
GeoJsonTile.POINT_MARKER_SIZE = 128;
exports.GeoJsonTile = GeoJsonTile;


/***/ }),

/***/ "../harp-geometry/index.ts":
/*!*********************************!*\
  !*** ../harp-geometry/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/OrientedBox3 */ "../harp-geometry/lib/OrientedBox3.ts"));


/***/ }),

/***/ "../harp-geometry/lib/OrientedBox3.ts":
/*!********************************************!*\
  !*** ../harp-geometry/lib/OrientedBox3.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
class OrientedBox3 {
    /**
     * Creates a new `OrientedBox3`.
     *
     * @hideconstructor
     */
    constructor(position, rotationMatrix, extents) {
        /**
         * The position of the center of this `OrientedBox3`.
         */
        this.position = new three_1.Vector3();
        /**
         * The x-axis of this `OrientedBox3`.
         */
        this.xAxis = new three_1.Vector3(1, 0, 0);
        /**
         * The y-axis of this `OrientedBox3`.
         */
        this.yAxis = new three_1.Vector3(0, 1, 0);
        /**
         * The z-axis of this `OrientedBox3`.
         */
        this.zAxis = new three_1.Vector3(0, 0, 1);
        /**
         * The extents of this `OrientedBox3`.
         */
        this.extents = new three_1.Vector3();
        if (position !== undefined) {
            this.position.copy(position);
        }
        if (rotationMatrix !== undefined) {
            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
        }
        if (extents !== undefined) {
            this.extents.copy(extents);
        }
    }
    /**
     * Create a copy of this [[OrientedBoundingBox]].
     */
    clone() {
        const newBox = new OrientedBox3();
        newBox.copy(this);
        return newBox;
    }
    /**
     * Copies the values of `other` to this [[OrientedBox3]].
     * @param other The other [[OrientedBox3]] to copy.
     */
    copy(other) {
        this.position.copy(other.position);
        this.xAxis.copy(other.xAxis);
        this.yAxis.copy(other.yAxis);
        this.zAxis.copy(other.zAxis);
        this.extents.copy(other.extents);
    }
    /**
     * Gets the center position of this [[OrientedBox3]].
     *
     * @param center The returned center position.
     */
    getCenter(center = new three_1.Vector3()) {
        return center.copy(this.position);
    }
    /**
     * Gets the size of this [[OrientedBox3]].
     *
     * @param size The returned size.
     */
    getSize(size = new three_1.Vector3()) {
        return size.copy(this.extents).multiplyScalar(2);
    }
    /**
     * Gets the orientation matrix of this `OrientedBox3`.
     * @param matrix The output orientation matrix.
     */
    getRotationMatrix(matrix = new three_1.Matrix4()) {
        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
    }
    /**
     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.
     *
     * @param frustumOrPlanes Frustum or array of planes.
     */
    intersects(frustumOrPlanes) {
        const planes = Array.isArray(frustumOrPlanes)
            ? frustumOrPlanes
            : frustumOrPlanes.planes;
        for (const plane of planes) {
            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +
                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +
                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
            const d = plane.distanceToPoint(this.position);
            if (d + r < 0) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns the distance from this [[OrientedBox3]] and the given `point`.
     *
     * @param point A point.
     */
    distanceToPoint(point) {
        return Math.sqrt(this.distanceToPointSquared(point));
    }
    /**
     * Returns the squared distance from this [[OrientedBox3]] and the given `point`.
     *
     * @param point A point.
     */
    distanceToPointSquared(point) {
        const d = new three_1.Vector3();
        d.subVectors(point, this.position);
        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];
        let result = 0;
        for (let i = 0; i < 3; ++i) {
            const length = lengths[i];
            const extent = this.extents.getComponent(i);
            if (length < -extent) {
                const dd = extent + length;
                result += dd * dd;
            }
            else if (length > extent) {
                const dd = length - extent;
                result += dd * dd;
            }
        }
        return result;
    }
}
exports.OrientedBox3 = OrientedBox3;


/***/ }),

/***/ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts":
/*!********************************************************************!*\
  !*** ../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "../harp-geometry/lib/SubdivisionModifier.ts");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];
/**
 * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned
 * on the surface of a sphere centered at `(0, 0, 0)`.
 */
class SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[SphericalGeometrySubdivisionModifier]].
     *
     * @param angle The maximum angle in radians between two vertices and the origin.
     * @param projection The projection that defines the world space of this geometry.
     */
    constructor(angle, projection = harp_geoutils_1.sphereProjection) {
        super();
        this.angle = angle;
        this.projection = projection;
    }
    shouldSplitTriangle(a, b, c) {
        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);
        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);
        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);
        const alpha = aa.angleTo(bb);
        const beta = bb.angleTo(cc);
        const gamma = cc.angleTo(aa);
        // find the maximum angle
        const m = Math.max(alpha, Math.max(beta, gamma));
        // split the triangle if needed.
        if (m < this.angle) {
            return undefined;
        }
        if (m === alpha) {
            return 0;
        }
        else if (m === beta) {
            return 1;
        }
        else if (m === gamma) {
            return 2;
        }
        throw new Error("failed to split triangle");
    }
}
exports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;


/***/ }),

/***/ "../harp-geometry/lib/SubdivisionModifier.ts":
/*!***************************************************!*\
  !*** ../harp-geometry/lib/SubdivisionModifier.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
const tmpVectorA = new three_1.Vector3();
const tmpVectorB = new three_1.Vector3();
const tmpVectorC = new three_1.Vector3();
/**
 * The [[SubdivisionModifier]] subdivides triangle mesh geometries.
 */
class SubdivisionModifier {
    /**
     * Constructs a new [[SubdivisionModifier]].
     */
    constructor() {
        // nothing to do
    }
    /**
     * Subdivides the faces of the given [[THREE.BufferGeometry]].
     *
     * This method modifies (in-place) the vertices and the faces of the geometry.
     * Please note that only the vertex position and their UV coordinates are subdivided.
     * Normals, vertex colors and other attributes are left unmodified.
     *
     * @param geometry The [[THREE.BufferGeometry]] to subdivide.
     */
    modify(geometry) {
        const positionAttr = geometry.getAttribute("position");
        const position = Array.from(positionAttr.array);
        const uvAttr = geometry.getAttribute("uv");
        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;
        const edgeAttr = geometry.getAttribute("edge");
        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;
        const wallAttr = geometry.getAttribute("wall");
        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;
        const indexAttr = geometry.getIndex();
        const indices = Array.from(indexAttr.array);
        // A cache containing the indices of the vertices added
        // when subdiving the faces of the geometry.
        const cache = new Map();
        /**
         * Returns the index of the vertex positioned in the middle of the given vertices.
         */
        function middleVertex(i, j) {
            // Build a unique `key` for the pair of indices `(i, j)`.
            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;
            const h = cache.get(key);
            if (h !== undefined) {
                // Nothing to do, a vertex in the middle of (i, j) was already created.
                return h;
            }
            // The position of the new vertex.
            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);
            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
            // The index of the new vertex.
            const index = position.length / 3;
            position.push(...tmpVectorC.toArray());
            // Cache the position of the new vertex.
            cache.set(key, index);
            // The uvs of the new vertex.
            if (uv !== undefined) {
                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);
                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);
                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
                uv.push(tmpVectorC.x, tmpVectorC.y);
            }
            // The edge and wall attributes of the new vertex.
            // If a new vertex has been introduced between i and j, connect the elements
            // accordingly.
            if (edge !== undefined) {
                if (edge[i] === j) {
                    edge.push(j);
                    edge[i] = index;
                }
                else if (edge[j] === i) {
                    edge.push(i);
                    edge[j] = index;
                }
                else {
                    edge.push(-1);
                }
            }
            if (wall !== undefined) {
                if (wall[i] === j) {
                    wall.push(j);
                    wall[i] = index;
                }
                else if (wall[j] === i) {
                    wall.push(i);
                    wall[j] = index;
                }
                else {
                    wall.push(-1);
                }
            }
            return index;
        }
        const newIndices = [];
        while (indices.length >= 3) {
            const v0 = indices.shift();
            const v1 = indices.shift();
            const v2 = indices.shift();
            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);
            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);
            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);
            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);
            switch (edgeToSplit) {
                case 0: {
                    const v3 = middleVertex(v0, v1);
                    indices.push(v0, v3, v2, v3, v1, v2);
                    break;
                }
                case 1: {
                    const v3 = middleVertex(v1, v2);
                    indices.push(v0, v1, v3, v0, v3, v2);
                    break;
                }
                case 2: {
                    const v3 = middleVertex(v2, v0);
                    indices.push(v0, v1, v3, v3, v1, v2);
                    break;
                }
                case undefined: {
                    newIndices.push(v0, v1, v2);
                    break;
                }
                default:
                    throw new Error("failed to subdivide the given geometry");
            }
        }
        positionAttr.setArray(new Float32Array(position));
        positionAttr.needsUpdate = true;
        geometry.setIndex(newIndices);
        if (uv !== undefined) {
            uvAttr.setArray(new Float32Array(uv));
            uvAttr.needsUpdate = true;
        }
        if (edge !== undefined) {
            edgeAttr.setArray(new Float32Array(edge));
            edgeAttr.needsUpdate = true;
        }
        return geometry;
    }
}
exports.SubdivisionModifier = SubdivisionModifier;


/***/ }),

/***/ "../harp-geoutils/index.ts":
/*!*********************************!*\
  !*** ../harp-geoutils/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts"));
__export(__webpack_require__(/*! ./lib/projection/EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts"));
__export(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ "../harp-geoutils/lib/projection/EquirectangularProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/IdentityProjection */ "../harp-geoutils/lib/projection/IdentityProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/Projection */ "../harp-geoutils/lib/projection/Projection.ts"));
__export(__webpack_require__(/*! ./lib/projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/SphereProjection */ "../harp-geoutils/lib/projection/SphereProjection.ts"));
__export(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts"));
__export(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/QuadTree */ "../harp-geoutils/lib/tiling/QuadTree.ts"));
__export(__webpack_require__(/*! ./lib/tiling/SubTiles */ "../harp-geoutils/lib/tiling/SubTiles.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ "../harp-geoutils/lib/tiling/TileKeyUtils.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ "../harp-geoutils/lib/tiling/HereTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ "../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ "../harp-geoutils/lib/tiling/MercatorTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/math/Vector3Like */ "../harp-geoutils/lib/math/Vector3Like.ts"));
__export(__webpack_require__(/*! ./lib/math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts"));
__export(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts"));
__export(__webpack_require__(/*! ./lib/math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts"));
__export(__webpack_require__(/*! ./lib/math/TransformLike */ "../harp-geoutils/lib/math/TransformLike.ts"));


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoBox.ts":
/*!**************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoBox.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const DEG2RAD = Math.PI / 180;
/**
 * `GeoBox` is used to represent a bounding box in geo coordinates.
 */
class GeoBox {
    /**
     * Constructs a new `GeoBox` with the given geo coordinates.
     *
     * @param southWest The south west position in geo coordinates.
     * @param northEast The north east position in geo coordinates.
     */
    constructor(southWest, northEast) {
        this.southWest = southWest;
        this.northEast = northEast;
    }
    /**
     * Returns a `GeoBox` with the given geo coordinates.
     *
     * @param southWest The south west position in geo coordinates.
     * @param northEast The north east position in geo coordinates.
     */
    static fromCoordinates(southWest, northEast) {
        return new GeoBox(southWest, northEast);
    }
    /**
     * Returns the minimum altitude or `undefined`.
     */
    get minAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.min(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the maximum altitude or `undefined`.
     */
    get maxAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.max(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the south latitude in degrees of this `GeoBox`.
     */
    get south() {
        return this.southWest.latitude;
    }
    /**
     * Returns the north altitude in degrees of this `GeoBox`.
     */
    get north() {
        return this.northEast.latitude;
    }
    /**
     * Returns the west longitude in degrees of this `GeoBox`.
     */
    get west() {
        return this.southWest.longitude;
    }
    /**
     * Returns the east longitude in degrees of this `GeoBox`.
     */
    get east() {
        return this.northEast.longitude;
    }
    /**
     * Returns the center of this `GeoBox`.
     */
    get center() {
        const latitude = (this.south + this.north) * 0.5;
        const { west, east } = this;
        const { minAltitude, altitudeSpan } = this;
        let altitude;
        if (minAltitude !== undefined && altitudeSpan !== undefined) {
            altitude = minAltitude + altitudeSpan * 0.5;
        }
        if (west < east) {
            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);
        }
        let longitude = (360 + east + west) * 0.5;
        if (longitude > 360) {
            longitude -= 360;
        }
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns the latitude span in radians.
     */
    get latitudeSpanInRadians() {
        return this.latitudeSpan * DEG2RAD;
    }
    /**
     * Returns the longitude span in radians.
     */
    get longitudeSpanInRadians() {
        return this.longitudeSpan * DEG2RAD;
    }
    /**
     * Returns the latitude span in degrees.
     */
    get latitudeSpan() {
        return this.north - this.south;
    }
    get altitudeSpan() {
        if (this.maxAltitude === undefined || this.minAltitude === undefined) {
            return undefined;
        }
        return this.maxAltitude - this.minAltitude;
    }
    /**
     * Returns the longitude span in degrees.
     */
    get longitudeSpan() {
        let width = this.northEast.longitude - this.southWest.longitude;
        if (width < 0) {
            width += 360;
        }
        return width;
    }
    /**
     * Returns the latitude span in degrees.
     * @deprecated Use [[latitudeSpan]] instead.
     */
    get latitudeSpanInDegrees() {
        return this.latitudeSpan;
    }
    /**
     * Returns the longitude span in degrees.
     * @deprecated Use [[longitudeSpan]] instead.
     */
    get longitudeSpanInDegrees() {
        return this.longitudeSpan;
    }
    /**
     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.
     *
     * @param point The geo coordinates.
     */
    contains(point) {
        if (point.altitude === undefined ||
            this.minAltitude === undefined ||
            this.maxAltitude === undefined) {
            return this.containsHelper(point);
        }
        const isFlat = this.minAltitude === this.maxAltitude;
        const isSameAltitude = this.minAltitude === point.altitude;
        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
        // If box is flat, we should check the altitude and containment,
        // otherwise we should check also altitude difference where we consider
        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!
        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
            return this.containsHelper(point);
        }
        return false;
    }
    /**
     * Clones this `GeoBox` instance.
     */
    clone() {
        return new GeoBox(this.southWest, this.northEast);
    }
    /**
     * Update the bounding box by considering a given point.
     *
     * @param point The point that may expand the bounding box.
     */
    growToContain(point) {
        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
        this.southWest.altitude =
            this.southWest.altitude !== undefined && point.altitude !== undefined
                ? Math.min(this.southWest.altitude, point.altitude)
                : this.southWest.altitude !== undefined
                    ? this.southWest.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
        this.northEast.altitude =
            this.northEast.altitude !== undefined && point.altitude !== undefined
                ? Math.max(this.northEast.altitude, point.altitude)
                : this.northEast.altitude !== undefined
                    ? this.northEast.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
    }
    containsHelper(point) {
        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
            return false;
        }
        const { west, east } = this;
        if (east > west) {
            return point.longitude >= west && point.longitude < east;
        }
        return point.longitude > east || point.longitude <= west;
    }
}
exports.GeoBox = GeoBox;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts":
/*!**********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordinates.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const RAD2DEG = 180.0 / Math.PI;
const DEG2RAD = Math.PI / 180.0;
/**
 * `GeoCoordinates` is used to represent geo positions.
 */
class GeoCoordinates {
    /**
     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in degrees.
     * @param longitude Longitude in degrees.
     * @param altitude Altitude in meters.
     */
    constructor(latitude, longitude, altitude) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.altitude = altitude;
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in degrees.
     * @param longitude Longitude in degrees.
     * @param altitude Altitude in meters.
     */
    static fromDegrees(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in radians.
     * @param longitude Longitude in radians.
     * @param altitude Altitude in meters.
     */
    static fromRadians(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude * RAD2DEG, longitude * RAD2DEG, altitude);
    }
    /**
     * Returns the latitude in radians.
     */
    get latitudeInRadians() {
        return this.latitude * DEG2RAD;
    }
    /**
     * Returns the longitude in radians.
     */
    get longitudeInRadians() {
        return this.longitude * DEG2RAD;
    }
    /**
     * Returns the latitude in degrees.
     * @deprecated Use the [[latitude]] property instead.
     */
    get latitudeInDegrees() {
        return this.latitude;
    } // compat api
    /**
     * Returns the longitude in degrees.
     * @deprecated Use the [[longitude]] property instead.
     */
    get longitudeInDegrees() {
        return this.longitude;
    } // compat api
    /**
     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.
     */
    isValid() {
        return !isNaN(this.latitude) && !isNaN(this.longitude);
    }
    /**
     * Returns the normalized `GeoCoordinates`.
     */
    normalized() {
        let { latitude, longitude } = this;
        if (isNaN(latitude) || isNaN(longitude)) {
            return this;
        }
        if (latitude > 90) {
            let wrapped = (latitude + 90) % 360;
            if (wrapped >= 180) {
                longitude += 180;
                wrapped = 360 - wrapped;
            }
            latitude = wrapped - 90;
        }
        if (latitude < -90) {
            let wrapped = (latitude - 90) % 360;
            if (wrapped <= -180) {
                longitude += 180;
                wrapped = -360 - wrapped;
            }
            latitude = wrapped + 90;
        }
        if (longitude < -180 || longitude > 180) {
            const sign = Math.sign(longitude);
            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;
        }
        if (latitude === this.latitude && longitude === this.longitude) {
            return this;
        }
        return new GeoCoordinates(latitude, longitude, this.altitude);
    }
    /**
     * Returns `true` if this `GeoCoordinates` is equal to the other.
     *
     * @param other GeoCoordinatesLike to compare to.
     */
    equals(other) {
        return (this.latitude === other.latitude &&
            this.longitude === other.longitude &&
            this.altitude === other.altitude);
    }
    /**
     * Copy values from the other.
     *
     * @param other GeoCoordinatesLike to copy all values from.
     */
    copy(other) {
        this.latitude = other.latitude;
        this.longitude = other.longitude;
        this.altitude = other.altitude;
        return this;
    }
    /**
     * Clones this `GeoCoordinates`.
     * @deprecated
     */
    clone() {
        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
    }
}
exports.GeoCoordinates = GeoCoordinates;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts":
/*!**************************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard to assert that `object` conforms to [[GeoCoordinatesLike]] data interface.
 */
function isGeoCoordinatesLike(object) {
    return (object &&
        typeof object.latitude === "number" &&
        typeof object.longitude === "number" &&
        (typeof object.altitude === "number" || typeof object.altitude === "undefined"));
}
exports.isGeoCoordinatesLike = isGeoCoordinatesLike;


/***/ }),

/***/ "../harp-geoutils/lib/math/Box3Like.ts":
/*!*********************************************!*\
  !*** ../harp-geoutils/lib/math/Box3Like.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the [[Box3Like]] interface.
 *
 * @param object A valid object.
 */
function isBox3Like(object) {
    const box3 = object;
    return box3.min !== undefined && box3.max !== undefined;
}
exports.isBox3Like = isBox3Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/MathUtils.ts":
/*!**********************************************!*\
  !*** ../harp-geoutils/lib/math/MathUtils.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
var MathUtils;
(function (MathUtils) {
    /**
     * Creates a new empty bounding box.
     */
    function newEmptyBox3() {
        return {
            min: { x: Infinity, y: Infinity, z: Infinity },
            max: { x: -Infinity, y: -Infinity, z: -Infinity }
        };
    }
    MathUtils.newEmptyBox3 = newEmptyBox3;
    /**
     * Set the components of the given [Vector3Like] instance.
     *
     * @param x The x component.
     * @param y The y component.
     * @param z The z component.
     * @param v The [Vector3Like]
     */
    function newVector3(x, y, z, v) {
        if (v === undefined) {
            return { x, y, z };
        }
        v.x = x;
        v.y = y;
        v.z = z;
        return v;
    }
    MathUtils.newVector3 = newVector3;
    /**
     * Converts an angle measured in degrees to an equivalent value in radians.
     *
     * @param degrees Value in degrees.
     * @returns Value in radians.
     */
    function degToRad(degrees) {
        return degrees * DEG2RAD;
    }
    MathUtils.degToRad = degToRad;
    /**
     * Converts an angle measured in radians to an equivalent value in degrees.
     *
     * @param degrees Value in radians.
     * @returns Value in degrees.
     */
    function radToDeg(radians) {
        return radians * RAD2DEG;
    }
    MathUtils.radToDeg = radToDeg;
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value The value to be clamped.
     * @param min Minimum value.
     * @param max Maximum value.
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Normalize angle in degrees to range `[0, 360)`.
     *
     * @param a Angle in degrees.
     * @returns Angle in degrees in range `[0, 360)`.
     */
    function normalizeAngleDeg(a) {
        a = a % 360;
        if (a < 0) {
            a = a + 360;
        }
        return a;
    }
    MathUtils.normalizeAngleDeg = normalizeAngleDeg;
    /**
     * Return the minimal delta between angles `a` and `b` given in degrees.
     *
     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed
     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.
     *
     * Useful when interpolating between `b` and `a` in angle space.
     *
     * @param a Start angle in degrees.
     * @param b End angle in degrees.
     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.
     */
    function angleDistanceDeg(a, b) {
        a = normalizeAngleDeg(a);
        b = normalizeAngleDeg(b);
        const d = a - b;
        if (d > 180) {
            return d - 360;
        }
        else if (d <= -180) {
            return d + 360;
        }
        else {
            return d;
        }
    }
    MathUtils.angleDistanceDeg = angleDistanceDeg;
    /**
     * Interpolate linearly between two angles given in degrees.
     *
     * @param p0 Angle from in degrees
     * @param p1 Angle to in degrees
     * @param t Interpolation factor (alpha), in range `0-1`.
     */
    function interpolateAnglesDeg(p0, p1, t) {
        // hand crafted version,
        // see stack for maybe better versions:
        //    https://stackoverflow.com/questions/2708476/rotation-interpolation
        const d = angleDistanceDeg(p1, p0);
        const r = (p0 + d * t) % 360;
        return r;
    }
    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "../harp-geoutils/lib/math/OrientedBox3Like.ts":
/*!*****************************************************!*\
  !*** ../harp-geoutils/lib/math/OrientedBox3Like.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the interface [[OrientedBox3Like]].
 *
 * @param object The object.
 */
function isOrientedBox3Like(object) {
    const obb = object;
    return (obb.position !== undefined &&
        obb.xAxis !== undefined &&
        obb.yAxis !== undefined &&
        obb.zAxis !== undefined &&
        obb.extents !== undefined);
}
exports.isOrientedBox3Like = isOrientedBox3Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/TransformLike.ts":
/*!**************************************************!*\
  !*** ../harp-geoutils/lib/math/TransformLike.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the interface [[TransformLike]].
 *
 * @param object The object.
 */
function isTransformLike(object) {
    const transform = object;
    return (transform.position !== undefined &&
        transform.xAxis !== undefined &&
        transform.yAxis !== undefined &&
        transform.zAxis !== undefined);
}
exports.isTransformLike = isTransformLike;


/***/ }),

/***/ "../harp-geoutils/lib/math/Vector3Like.ts":
/*!************************************************!*\
  !*** ../harp-geoutils/lib/math/Vector3Like.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isVector3Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
exports.isVector3Like = isVector3Like;


/***/ }),

/***/ "../harp-geoutils/lib/projection/EarthConstants.ts":
/*!*********************************************************!*\
  !*** ../harp-geoutils/lib/projection/EarthConstants.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class EarthConstants {
}
/** The equatorial circumference in meters. */
EarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;
/** The equatorial radius in meters. */
EarthConstants.EQUATORIAL_RADIUS = 6378137.0;
/** The lowest point on earth (Dead Sea) in meters. */
EarthConstants.MIN_ELEVATION = -433.0;
/** The highest point on earth (Mt. Everest) in meters. */
EarthConstants.MAX_ELEVATION = 8848.0;
exports.EarthConstants = EarthConstants;


/***/ }),

/***/ "../harp-geoutils/lib/projection/EquirectangularProjection.ts":
/*!********************************************************************!*\
  !*** ../harp-geoutils/lib/projection/EquirectangularProjection.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
const DEG2RAD = Math.PI / 180;
class EquirectangularProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Planar;
    }
    getScaleFactor(_worldPoint) {
        return 1;
    }
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0.0;
        result.min.y = 0.0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale / 2;
        result.max.z = maxAltitude;
        return result;
    }
    projectPoint(geoPoint, result) {
        if (result === undefined) {
            /*
             * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
             * might be a concrete class which is not available at runtime.
             * Consider the following example:
             *
             *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
             *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
             *
             * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
             */
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x =
            (geoPoint.longitude * DEG2RAD + Math.PI) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.y =
            (geoPoint.latitude * DEG2RAD + Math.PI * 0.5) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -
            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);
        return geoPoint;
    }
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;
        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = sizeX * 0.5 * this.unitScale;
            result.extents.y = sizeY * 0.5 * this.unitScale;
            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);
        }
        return result;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
EquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);
EquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;
/**
 * Equirectangular [[Projection]] used to convert geo coordinates to unit coordinates and vice
 * versa.
 */
exports.normalizedEquirectangularProjection = new EquirectangularProjection(1);
/**
 * Equirectangular [[Projection]] used to convert geo coordinates to world coordinates and vice
 * versa.
 */
exports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/projection/IdentityProjection.ts":
/*!*************************************************************!*\
  !*** ../harp-geoutils/lib/projection/IdentityProjection.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
const DEG2RAD = Math.PI / 180;
class IdentityProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Planar;
    }
    getScaleFactor(_worldPoint) {
        return 1;
    }
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = -Math.PI;
        result.min.y = -Math.PI * 0.5;
        result.min.z = minAltitude;
        result.max.x = Math.PI;
        result.max.y = Math.PI * 0.5;
        result.max.z = maxAltitude;
        return result;
    }
    projectPoint(geoPoint, result) {
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = geoPoint.longitude * DEG2RAD;
        result.y = geoPoint.latitude * DEG2RAD;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);
        return geoPoint;
    }
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    projectBox(geoBox, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));
        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = min.x;
            result.min.y = min.y;
            result.min.z = min.z;
            result.max.x = max.x;
            result.max.y = max.y;
            result.max.z = max.z;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (min.x + max.x) * 0.5;
            result.position.y = (min.y + max.y) * 0.5;
            result.position.z = (min.z + max.z) * 0.5;
            result.extents.x = (max.x - min.x) * 0.5;
            result.extents.y = (max.y - min.y) * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);
        }
        return result;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
/**
 * Identity [[Projection]] used to convert geo coordinates to unit coordinates and vice versa.
 */
exports.identityProjection = new IdentityProjection(1);


/***/ }),

/***/ "../harp-geoutils/lib/projection/MercatorProjection.ts":
/*!*************************************************************!*\
  !*** ../harp-geoutils/lib/projection/MercatorProjection.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
class MercatorProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Planar;
    }
    static clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    static latitudeClamp(latitude) {
        return MercatorProjection.clamp(latitude, -MercatorProjection.MAXIMUM_LATITUDE, MercatorProjection.MAXIMUM_LATITUDE);
    }
    static latitudeProject(latitude) {
        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
    }
    static latitudeClampProject(latitude) {
        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
    }
    static unprojectLatitude(y) {
        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
    }
    getScaleFactor(worldPoint) {
        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
    }
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        result.y =
            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);
        return geoPoint;
    }
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(geoBox.center);
        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldYCenter = (worldNorth + worldSouth) * 0.5;
        worldCenter.y = worldYCenter;
        const latitudeSpan = worldNorth - worldSouth;
        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - longitudeSpan * 0.5;
            result.min.y = worldCenter.y - latitudeSpan * 0.5;
            result.max.x = worldCenter.x + longitudeSpan * 0.5;
            result.max.y = worldCenter.y + latitudeSpan * 0.5;
            const altitudeSpan = geoBox.altitudeSpan;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = longitudeSpan * 0.5;
            result.extents.y = latitudeSpan * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
    reprojectPoint(sourceProjection, worldPos, result) {
        // this implementation of [[reprojectPoint]] supports both
        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only
        // difference betweeen these two variants of WEB Mercator
        // is in the orientation of the Y axis, so we just flip Y coordinates
        // when reprojecting between them.
        if (sourceProjection !== this &&
            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = worldPos.x;
            result.y = this.unitScale - worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
}
MercatorProjection.MAXIMUM_LATITUDE = 1.4844222297453323;
class WebMercatorProjection extends MercatorProjection {
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        /*
         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
         * might be a concrete class which is not available at runtime.
         * Consider the following example:
         *
         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
         *
         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
         */
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    unprojectPoint(worldPoint) {
        const x = worldPoint.x / this.unitScale - 0.5;
        const y = 0.5 - worldPoint.y / this.unitScale;
        const longitude = 360 * x;
        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);
    }
    projectBox(geoBox, result) {
        const r = super.projectBox(geoBox, result);
        if (Box3Like_1.isBox3Like(r)) {
            // Invert the y axis for web mercator, this means that max => min & min => max
            const maxY = r.max.y;
            r.max.y = this.unitScale - r.min.y;
            r.min.y = this.unitScale - maxY;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);
            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);
            r.position.y = this.unitScale - r.position.y;
        }
        return r;
    }
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
        return geoBox;
    }
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
    localTangentSpace(geoPoint, result) {
        this.projectPoint(geoPoint, result.position);
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);
        return result;
    }
}
WebMercatorProjection.MAXIMUM_LATITUDE = 1.4844222297453323;
/**
 * Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.
 */
exports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
/**
 * Web Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.
 */
exports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/projection/Projection.ts":
/*!*****************************************************!*\
  !*** ../harp-geoutils/lib/projection/Projection.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
/**
 * The type of projection.
 */
var ProjectionType;
(function (ProjectionType) {
    /**
     * A type of [Projection] with zero curvature.
     */
    ProjectionType[ProjectionType["Planar"] = 0] = "Planar";
    /**
     * A spherical [Projection].
     */
    ProjectionType[ProjectionType["Spherical"] = 1] = "Spherical";
})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));
/**
 * `Projection` is used to convert positions from geo coordinates to world coordinates and vice
 * versa.
 */
class Projection {
    /**
     * Constructs the Projection
     *
     * @param unitScale How to transform the projected coordinates to world units.
     */
    constructor(unitScale) {
        this.unitScale = unitScale;
        //Prevent empty constructor error.
    }
    /**
     * Gets the [[TransformLike]] of the local tangent space at the given geo coordinates.
     *
     * @param geoPoint The geo coordinates.
     * @param result The [[TransformLike]].
     */
    localTangentSpace(geoPoint, result) {
        this.projectPoint(geoPoint, result.position);
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
        return result;
    }
    /**
     * Reproject a world position from the given source [[Projection]].
     *
     * @param sourceProjection The source projection.
     * @param worldPos A valid position in the world space defined by the source projection.
     * @param result The resulting position reprojected using this [[Projection]].
     * @hidden
     */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === this) {
            if (result === undefined) {
                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };
            }
            result.x = worldPos.x;
            result.y = worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
    }
}
exports.Projection = Projection;


/***/ }),

/***/ "../harp-geoutils/lib/projection/SphereProjection.ts":
/*!***********************************************************!*\
  !*** ../harp-geoutils/lib/projection/SphereProjection.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
/**
 * Transforms the given vector using the provided basis.
 */
function apply(xAxis, yAxis, zAxis, v) {
    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
/**
 * Returns the quadrants for the given longitude. The quadrant is defined as:
 *  - quadrant(+Math.PI * -1.0) = 0
 *  - quadrant(+Math.PI * -0.5) = 1
 *  - quadrant(+Math.PI *  0.0) = 2
 *  - quadrant(+Math.PI *  0.5) = 3
 *  - quadrant(+Math.PI *  1.0) = 4
 *
 * @param longitude The longitude in radians.
 */
function getLongitudeQuadrant(longitude) {
    const oneOverPI = 1 / Math.PI;
    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
    return MathUtils_1.MathUtils.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
    return d;
}
/**
 * Creates a Box3 enclosing the geobox.
 *
 * @param geoBox Ghe given geobox
 * @param worldBox The resulting axis aligned bounding box.
 */
function makeBox3(geoBox, worldBox, unitScale) {
    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;
    const minLongitude = MathUtils_1.MathUtils.degToRad(geoBox.west);
    const maxLongitude = MathUtils_1.MathUtils.degToRad(geoBox.east);
    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
    let xMin = Math.cos(minLongitude);
    let xMax = xMin;
    let yMin = Math.sin(minLongitude);
    let yMax = yMin;
    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {
        // tslint:disable-next-line: no-bitwise
        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);
        xMin = Math.min(x, xMin);
        xMax = Math.max(x, xMax);
        // tslint:disable-next-line: no-bitwise
        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
        yMin = Math.min(y, yMin);
        yMax = Math.max(y, yMax);
    }
    const cosMaxLongitude = Math.cos(maxLongitude);
    xMin = Math.min(cosMaxLongitude, xMin);
    xMax = Math.max(cosMaxLongitude, xMax);
    const sinMaxLongitude = Math.sin(maxLongitude);
    yMin = Math.min(sinMaxLongitude, yMin);
    yMax = Math.max(sinMaxLongitude, yMax);
    const xCenter = (xMax + xMin) * halfEquatorialRadius;
    const xExtent = (xMax - xMin) * halfEquatorialRadius;
    const yCenter = (yMax + yMin) * halfEquatorialRadius;
    const yExtent = (yMax - yMin) * halfEquatorialRadius;
    // Calculate Z boundaries.
    const minLatitude = MathUtils_1.MathUtils.degToRad(geoBox.south);
    const maxLatutide = MathUtils_1.MathUtils.degToRad(geoBox.north);
    const zMax = Math.sin(maxLatutide);
    const zMin = Math.sin(minLatitude);
    const zCenter = (zMax + zMin) * halfEquatorialRadius;
    const zExtent = (zMax - zMin) * halfEquatorialRadius;
    worldBox.min.x = xCenter - xExtent;
    worldBox.min.y = yCenter - yExtent;
    worldBox.min.z = zCenter - zExtent;
    worldBox.max.x = xCenter + xExtent;
    worldBox.max.y = yCenter + yExtent;
    worldBox.max.z = zCenter + zExtent;
    return worldBox;
}
/**
 * Computes the spherical projection of the given geo coordinates.
 *
 * @param geoPoint The geo coordinates.
 * @param worldpoint The resulting world coordinates.
 */
function project(geoPoint, worldpoint, unitScale) {
    const radius = unitScale + (geoPoint.altitude || 0);
    const latitude = MathUtils_1.MathUtils.degToRad(geoPoint.latitude);
    const longitude = MathUtils_1.MathUtils.degToRad(geoPoint.longitude);
    const cosLatitude = Math.cos(latitude);
    worldpoint.x = radius * cosLatitude * Math.cos(longitude);
    worldpoint.y = radius * cosLatitude * Math.sin(longitude);
    worldpoint.z = radius * Math.sin(latitude);
    return worldpoint;
}
class SphereProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        this.type = Projection_1.ProjectionType.Spherical;
    }
    worldExtent(_minElevation, maxElevation, result = MathUtils_1.MathUtils.newEmptyBox3()) {
        const radius = this.unitScale + maxElevation;
        result.min.x = -radius;
        result.min.y = -radius;
        result.min.z = -radius;
        result.max.x = radius;
        result.max.y = radius;
        result.max.z = radius;
        return result;
    }
    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {
        return project(geoPoint, result, this.unitScale);
    }
    unprojectPoint(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y;
        const parallelRadius = Math.sqrt(parallelRadiusSq);
        const v = point.z / parallelRadius;
        if (isNaN(v)) {
            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);
        }
        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
    }
    unprojectAltitude(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
    }
    projectBox(geoBox, result = MathUtils_1.MathUtils.newEmptyBox3()) {
        if (Box3Like_1.isBox3Like(result)) {
            return makeBox3(geoBox, result, this.unitScale);
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            if (geoBox.longitudeSpan >= 90) {
                const bounds = makeBox3(geoBox, MathUtils_1.MathUtils.newEmptyBox3(), this.unitScale);
                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
                return result;
            }
            const { south, west, north, east, center: mid } = geoBox;
            const midX = mid.longitude;
            const midY = mid.latitude;
            const cosSouth = Math.cos(MathUtils_1.MathUtils.degToRad(south));
            const sinSouth = Math.sin(MathUtils_1.MathUtils.degToRad(south));
            const cosWest = Math.cos(MathUtils_1.MathUtils.degToRad(west));
            const sinWest = Math.sin(MathUtils_1.MathUtils.degToRad(west));
            const cosNorth = Math.cos(MathUtils_1.MathUtils.degToRad(north));
            const sinNorth = Math.sin(MathUtils_1.MathUtils.degToRad(north));
            const cosEast = Math.cos(MathUtils_1.MathUtils.degToRad(east));
            const sinEast = Math.sin(MathUtils_1.MathUtils.degToRad(east));
            const cosMidX = Math.cos(MathUtils_1.MathUtils.degToRad(midX));
            const sinMidX = Math.sin(MathUtils_1.MathUtils.degToRad(midX));
            const cosMidY = Math.cos(MathUtils_1.MathUtils.degToRad(midY));
            const sinMidY = Math.sin(MathUtils_1.MathUtils.degToRad(midY));
            // Build the orientation of the OBB using the normal vector and its partial derivates.
            // the sperical coordinates of the mid point of the geobox.
            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
            // the partial derivates of the normal vector.
            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
            let width;
            let minY;
            let maxY;
            if (south >= 0) {
                // abs(dot(southWest - southEast, xAxis))
                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                // dot(south, yAxis)
                minY = cosMidY * sinSouth - sinMidY * cosSouth;
                // dot(northEast, zAxis)
                maxY =
                    cosMidY * sinNorth -
                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            else {
                if (north <= 0) {
                    // abs(dot(northWest - northEast, xAxis))
                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                    // dot(north, yAxis)
                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;
                }
                else {
                    // abs(dot(west - east, xAxis))
                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
                    // dot(northEast, yAxis)
                    maxY =
                        cosMidY * sinNorth -
                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
                }
                // dot(southEast, yAxis)
                minY =
                    cosMidY * sinSouth -
                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;
            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;
            // min(dot(southEast, zAxis), dot(northEast, zAxis))
            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
            apply(result.xAxis, result.yAxis, result.zAxis, result.position);
            result.position.x = result.position.x - result.zAxis.x * result.extents.z;
            result.position.y = result.position.y - result.zAxis.y * result.extents.z;
            result.position.z = result.position.z - result.zAxis.z * result.extents.z;
            return result;
        }
        throw new Error("Invalid bounding box");
    }
    unprojectBox(_worldBox) {
        throw new Error("Method not implemented.");
    }
    getScaleFactor(_worldPoint) {
        return 1;
    }
    groundDistance(worldPoint) {
        return lengthOfVector3(worldPoint) - this.unitScale;
    }
    scalePointToSurface(worldPoint) {
        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
        worldPoint.x *= scale;
        worldPoint.y *= scale;
        worldPoint.z *= scale;
        return worldPoint;
    }
    surfaceNormal(worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 0 };
        }
        const scale = 1 / (lengthOfVector3(worldPoint) || 1);
        normal.x = worldPoint.x * scale;
        normal.y = worldPoint.y * scale;
        normal.z = worldPoint.z * scale;
        return normal;
    }
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {
            const { x, y, z } = worldPos;
            const r = this.unitScale;
            const mx = x / r - Math.PI;
            const my = y / r - Math.PI;
            const w = Math.exp(my);
            const d = w * w;
            const gx = (2 * w) / (d + 1);
            const gy = (d - 1) / (d + 1);
            const scale = r + z;
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = Math.cos(mx) * gx * scale;
            result.y = Math.sin(mx) * gx * scale;
            result.z = gy * scale;
            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {
                result.z = -result.z;
            }
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
    localTangentSpace(geoPoint, result) {
        const latitude = MathUtils_1.MathUtils.degToRad(geoPoint.latitude);
        const longitude = MathUtils_1.MathUtils.degToRad(geoPoint.longitude);
        const cosLongitude = Math.cos(longitude);
        const sinLongitude = Math.sin(longitude);
        const cosLatitude = Math.cos(latitude);
        const sinLatitude = Math.sin(latitude);
        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);
        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);
        this.projectPoint(geoPoint, result.position);
        return result;
    }
}
exports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts":
/*!*******************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
/**
 * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given
 * TilingScheme.
 */
class FlatTileBoundingBoxGenerator {
    /**
     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given
     * TilingScheme.
     *
     * @param tilingScheme The [[TilingScheme]] used to compute bounding boxes.
     * @param minElevation The minimum elevation in meters.
     * @param maxElevation The maximum elevation in meters.
     */
    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {
        this.tilingScheme = tilingScheme;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.m_tilingScheme = tilingScheme;
        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
        const { min, max } = this.m_worldBox;
        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };
    }
    /**
     * Returns the [[Projection]] of the [[TilingScheme]].
     */
    get projection() {
        return this.m_tilingScheme.projection;
    }
    /**
     * Returns the [[SubdivisionScheme]] of the [[TilingScheme]].
     */
    get subdivisionScheme() {
        return this.m_tilingScheme.subdivisionScheme;
    }
    /**
     * Returns the bounding box in world coordinates of the given [[TileKey]].
     *
     * Example:
     * ```typescript
     * const worldBounds = new THREE.Box3();
     * generator.getWorldBox(geoBox, worldBounds);
     * console.log(worldBounds.getCenter());
     * ```
     *
     * @param tileKey The TileKey.
     * @param result The optional object used to store the resulting bounding box in world
     * coordinates.
     */
    getWorldBox(tileKey, result) {
        const level = tileKey.level;
        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
        const sizeX = this.m_worldDimensions.x / levelDimensionX;
        const sizeY = this.m_worldDimensions.y / levelDimensionY;
        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;
        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = originX;
        result.min.y = originY;
        result.min.z = this.m_worldBox.min.z;
        result.max.x = originX + sizeX;
        result.max.y = originY + sizeY;
        result.max.z = this.m_worldBox.max.z;
        return result;
    }
    /**
     * Returns the bounding box in geo coordinates for the given [[TileKey]].
     *
     * Example:
     * ```typescript
     * const geoBox = generator.getGeoBox(worldBounds);
     * console.log(geoBox.center);
     * ```
     *
     * @param tileKey The [[TileKey]].
     */
    getGeoBox(tileKey) {
        const worldBox = this.getWorldBox(tileKey);
        return this.projection.unprojectBox(worldBox);
    }
}
exports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts":
/*!********************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class HalfQuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY(level) {
        return level === 0 ? 1 : 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return level !== 0 ? 1 << (level - 1) : 1;
    }
}
/**
 * A [[SubdivisionScheme]] used to represent half quadtrees. This particular subdivision scheme is
 * used by the HERE tiling scheme.
 */
exports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();


/***/ }),

/***/ "../harp-geoutils/lib/tiling/HereTilingScheme.ts":
/*!*******************************************************!*\
  !*** ../harp-geoutils/lib/tiling/HereTilingScheme.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ "../harp-geoutils/lib/projection/EquirectangularProjection.ts");
const HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * [[TilingScheme]] used by most of the data published by HERE.
 *
 * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular
 * projection.
 */
exports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/MercatorTilingScheme.ts":
/*!***********************************************************!*\
  !*** ../harp-geoutils/lib/tiling/MercatorTilingScheme.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * The [[TilingScheme]] used by the HERE web tiles.
 *
 * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.
 */
exports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/QuadTree.ts":
/*!***********************************************!*\
  !*** ../harp-geoutils/lib/tiling/QuadTree.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
/**
 * A class used to represent a quadtree.
 */
class QuadTree {
    /**
     * Constructs a new `QuadTree` for the given [[TilingScheme]].
     *
     * Example:
     * ```typescript
     * const quadTree = new QuadTree(hereTilingScheme);
     * const geoBox = quadTree.getGeoBox(tileKey);
     * console.log(geoBox.center);
     * ```
     *
     * @param tilingScheme The TilingScheme used by this `QuadTree`.
     */
    constructor(tilingScheme) {
        this.tilingScheme = tilingScheme;
    }
    /**
     * Visits this `QuadTree` and invoke the given accept method with the current [[TileKey]] and
     * its bounding box in geo coordinates.
     *
     * Example:
     * ```typescript
     * const geoPos = new GeoCoordinates(latitude, longitude);
     * const quadTree = new QuadTree(hereTilingScheme);
     * quadTree.visit((tileKey, geoBox) => {
     *     if (geoBox.contains(geoPos)) {
     *         console.log("tile", tileKey, "contains", geoPos);
     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.
     *     }
     *     return false; // stop visiting the quadtree,
     *                   // the tile's geoBox doesn't contain the given coordinates.
     * });
     * ```
     *
     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and
     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.
     */
    visit(accept) {
        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);
    }
    /**
     * Visits the subtree starting from the given tile.
     *
     * @param tileKey The root of the subtree that should be visited.
     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and
     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.
     */
    visitTileKey(tileKey, accept) {
        const geoBox = this.tilingScheme.getGeoBox(tileKey);
        if (!accept(tileKey, geoBox)) {
            return;
        }
        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {
            this.visitTileKey(subTileKey, accept);
        }
    }
}
exports.QuadTree = QuadTree;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts":
/*!****************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class QuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY() {
        return 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
}
/**
 * [[SubdivisionScheme]] representing a quadtree.
 */
exports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();


/***/ }),

/***/ "../harp-geoutils/lib/tiling/SubTiles.ts":
/*!***********************************************!*\
  !*** ../harp-geoutils/lib/tiling/SubTiles.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
class SubTiles {
    constructor(tileKey, sizeX, sizeY) {
        this.tileKey = tileKey;
        this.sizeX = sizeX;
        this.sizeY = sizeY;
    }
    [Symbol.iterator]() {
        return this.sizeX === 2 && this.sizeY === 2
            ? SubTiles.ZCurveIterator(this.tileKey)
            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);
    }
}
exports.SubTiles = SubTiles;
(function (SubTiles) {
    function* RowColumnIterator(parentKey, sizeX, sizeY) {
        for (let y = 0; y < sizeY; y++) {
            for (let x = 0; x < sizeX; x++) {
                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);
            }
        }
    }
    SubTiles.RowColumnIterator = RowColumnIterator;
    function* ZCurveIterator(parentKey) {
        // tslint:disable:no-bitwise
        for (let i = 0; i < 4; i++) {
            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);
        }
        // tslint:enableno-bitwise
    }
    SubTiles.ZCurveIterator = ZCurveIterator;
})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileKey.ts":
/*!**********************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileKey.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.
];
/**
 * The `TileKey` instances are used to address a tile in a quadtree.
 *
 * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one
 * single tile. On every level, each tile is divided into four children (therefore the name
 * quadtree).
 *
 * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number
 * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only
 * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles
 * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.
 *
 * A tile key is usually created using [[fromRowColumnLevel]]() method.
 *
 * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not
 * modify the original object.
 *
 * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for
 * easy vertical navigation of the tree. The number of available rows and columns in the tile's
 * level is given with [[rowCount]]() and [[columnCount]]().
 *
 * Tile keys can be created from and converted into various alternative formats:
 *
 *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based
 *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based
 *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation
 *
 * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be
 * represented in the number representation returned by [[mortonCode]]().
 */
class TileKey {
    /**
     * Constructs a new immutable instance of a `TileKey`.
     *
     * For the better readability, [[TileKey.fromRowColumnLevel]] should be preferred.
     *
     * Note - row and column must not be greater than the maximum rows/columns for the given level.
     *
     * @param row Represents the row in the quadtree.
     * @param column Represents the column in the quadtree.
     * @param level Represents the level in the quadtree.
     */
    constructor(row, column, level) {
        this.row = row;
        this.column = column;
        this.level = level;
    }
    /**
     * Creates a tile key.
     *
     * @param row The requested row. Must be less than 2 to the power of level.
     * @param column The requested column. Must be less than 2 to the power of level.
     * @param level The requested level.
     */
    static fromRowColumnLevel(row, column, level) {
        return new TileKey(row, column, level);
    }
    /**
     * Creates a tile key from a quad string.
     *
     * The quad string can be created with [[toQuadKey]].
     *
     * @param quadkey The quadkey to convert.
     * @returns A new instance of `TileKey`.
     */
    static fromQuadKey(quadkey) {
        const level = quadkey.length;
        let row = 0;
        let column = 0;
        // tslint:disable:no-bitwise
        for (let i = 0; i < quadkey.length; ++i) {
            const mask = 1 << i;
            const d = parseInt(quadkey.charAt(level - i - 1), 10);
            if (d & 0x1) {
                column |= mask;
            }
            if (d & 0x2) {
                row |= mask;
            }
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Creates a tile key from a numeric Morton code representation.
     *
     * You can convert a tile key into a numeric Morton code with [[mortonCode]].
     *
     * @param quadKey64 The Morton code to be converted.
     * @returns A new instance of [[TileKey]].
     */
    static fromMortonCode(quadKey64) {
        let level = 0;
        let row = 0;
        let column = 0;
        let quadKey = quadKey64;
        // tslint:disable:no-bitwise
        while (quadKey > 1) {
            const mask = 1 << level;
            if (quadKey & 0x1) {
                column |= mask;
            }
            if (quadKey & 0x2) {
                row |= mask;
            }
            level++;
            quadKey = (quadKey - (quadKey & 0x3)) / 4;
        }
        // tslint:enable:no-bitwise
        const result = TileKey.fromRowColumnLevel(row, column, level);
        result.m_mortonCode = quadKey64;
        return result;
    }
    /**
     * Creates a tile key from a heretile code string.
     *
     * The string can be created with [[toHereTile]].
     *
     * @param quadkey64 The string representation of the HERE tile key.
     * @returns A new instance of `TileKey`.
     */
    static fromHereTile(quadkey64) {
        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
        result.m_hereTile = quadkey64;
        return result;
    }
    /**
     * Returns the number of available columns at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level The level for which to return the number of columns.
     * @returns The available columns at the given level.
     */
    static columnsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the number of available rows at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level The level for which to return the number of rows.
     * @returns The available rows at the given level.
     */
    static rowsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the closest matching `TileKey` in a cartesian coordinate system.
     *
     * @param level The level for the tile key.
     * @param coordX The X coordinate.
     * @param coordY The Y coordinate.
     * @param totalWidth The maximum X coordinate.
     * @param totalHeight The maximum Y coordinate.
     * @returns A new tile key at the given level that includes the given coordinates.
     */
    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {
        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
    }
    /**
     * Computes the Morton code of the parent tile key of the given Morton code.
     *
     * Note: The parent key of the root key is the root key itself.
     *
     * @param mortonCode A Morton code, for example, obtained from [[mortonCode]].
     * @returns The Morton code of the parent tile.
     */
    static parentMortonCode(mortonCode) {
        return Math.floor(mortonCode / 4);
    }
    /**
     * Returns a tile key representing the parent of the tile addressed by this tile key.
     *
     * Throws an exception is this tile is already the root.
     */
    parent() {
        if (this.level === 0) {
            throw new Error("Cannot get the parent of the root tile key");
        }
        // tslint:disable-next-line:no-bitwise
        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
    }
    /**
     * Returns a new tile key at a level that differs from this tile's level by delta.
     *
     * Equivalent to `changedLevelTo(level() + delta)`.
     *
     * Note - root key is returned if `delta` is smaller than the level of this tile key.
     *
     * @param delta The numeric difference between the current level and the requested level.
     */
    changedLevelBy(delta) {
        const level = Math.max(0, this.level + delta);
        let row = this.row;
        let column = this.column;
        // tslint:disable:no-bitwise
        if (delta >= 0) {
            row <<= delta;
            column <<= delta;
        }
        else {
            row >>>= -delta;
            column >>>= -delta;
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Returns a new tile key at the requested level.
     *
     * If the requested level is smaller than the tile's level, then the key of an ancestor of this
     * tile is returned. If the requested level is larger than the tile's level, then the key of
     * first child or grandchild of this tile is returned, for example, the child with the lowest
     * row and column number. If the requested level equals this tile's level, then the tile key
     * itself is returned. If the requested level is negative, the root tile key is returned.
     *
     * @param level The requested level.
     */
    changedLevelTo(level) {
        return this.changedLevelBy(level - this.level);
    }
    /**
     * Converts the tile key to a numeric code representation.
     *
     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].
     *
     * Note - only levels <= 26 are supported.
     */
    mortonCode() {
        if (this.m_mortonCode === undefined) {
            let column = this.column;
            let row = this.row;
            // tslint:disable:no-bitwise
            let result = powerOfTwo[this.level << 1];
            for (let i = 0; i < this.level; ++i) {
                if (column & 0x1) {
                    result += powerOfTwo[2 * i];
                }
                if (row & 0x1) {
                    result += powerOfTwo[2 * i + 1];
                }
                column >>>= 1;
                row >>>= 1;
            }
            // tslint:enable:no-bitwise
            this.m_mortonCode = result;
        }
        return this.m_mortonCode;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * The string is a quadkey Morton code representation as a string.
     *
     * You can convert back from a quadkey string with [[fromHereTile]].
     */
    toHereTile() {
        if (this.m_hereTile === undefined) {
            this.m_hereTile = this.mortonCode().toString();
        }
        return this.m_hereTile;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the
     * base of 4, but without the leading 1, with the following properties:
     *  1. the number of digits equals the level.
     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3
     *     to a quadkey string gives the tiles's children.
     *
     * You can convert back from a quadkey string with [[fromQuadKey]].
     */
    toQuadKey() {
        let result = "";
        // tslint:disable:no-bitwise
        for (let i = this.level; i > 0; --i) {
            const mask = 1 << (i - 1);
            const col = (this.column & mask) !== 0;
            const row = (this.row & mask) !== 0;
            if (col && row) {
                result += "3";
            }
            else if (row) {
                result += "2";
            }
            else if (col) {
                result += "1";
            }
            else {
                result += "0";
            }
        }
        // tslint:enable:no-bitwise
        return result;
    }
    /**
     * Equality operator.
     *
     * @param qnr The tile key to compare to.
     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.
     */
    equals(qnr) {
        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub quadkey.
     *
     * @param sub The sub key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubKey(sub) {
        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub HERE tile key.
     *
     * @param sub The sub HERE key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubHereTile(sub) {
        const subQuad = TileKey.fromHereTile(sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns a sub quadkey that is relative to its parent.
     *
     * This function can be used to generate sub keys that are relative to a parent that is delta
     * levels up in the quadtree.
     *
     * This function can be used to create shortened keys for quads on lower levels if the parent is
     * known.
     *
     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If
     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.
     *
     * Deltas larger than 16 are not supported.
     *
     * @param delta The number of levels relative to its parent quadkey. Must be greater or equal to
     * 0 and smaller than 16.
     * @returns The quadkey relative to its parent that is `delta` levels up the tree.
     */
    getSubHereTile(delta) {
        const key = this.mortonCode();
        // tslint:disable-next-line:no-bitwise
        const msb = 1 << (delta * 2);
        const mask = msb - 1;
        // tslint:disable-next-line:no-bitwise
        const result = (key & mask) | msb;
        return result.toString();
    }
    /**
     * Returns the number of available rows in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    rowCount() {
        return TileKey.rowsAtLevel(this.level);
    }
    /**
     * Returns the number of available columns in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    columnCount() {
        return TileKey.columnsAtLevel(this.level);
    }
}
exports.TileKey = TileKey;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileKeyUtils.ts":
/*!***************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileKeyUtils.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
class TileKeyUtils {
    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
        const projection = tilingScheme.projection;
        const subdivisionScheme = tilingScheme.subdivisionScheme;
        const worldPoint = projection.projectPoint(geoPoint);
        const cx = subdivisionScheme.getLevelDimensionX(level);
        const cy = subdivisionScheme.getLevelDimensionY(level);
        const { min, max } = projection.worldExtent(0, 0);
        const worldSizeX = max.x - min.x;
        const worldSizeY = max.y - min.y;
        if (worldPoint.x < min.x || worldPoint.x > max.x) {
            return null;
        }
        if (worldPoint.y < min.y || worldPoint.y > max.y) {
            return null;
        }
        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));
        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));
        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);
    }
    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {
        const wrap = (value, lower, upper) => {
            if (value < lower) {
                return upper - ((lower - value) % (upper - lower));
            }
            return lower + ((value - lower) % (upper - lower));
        };
        const clamp = (x, minVal, maxVal) => {
            return Math.min(Math.max(x, minVal), maxVal);
        };
        // Clamp at the poles and wrap around the international date line.
        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
        if (!minTileKey || !maxTileKey) {
            throw new Error("Invalid coordinates");
        }
        const minColumn = minTileKey.column;
        let maxColumn = maxTileKey.column;
        // wrap around case
        if (southWestLongitude > northEastLongitude) {
            if (maxColumn !== minColumn) {
                maxColumn += columnCount;
            }
            else {
                // do not duplicate
                maxColumn += columnCount - 1;
            }
        }
        const minRow = Math.min(minTileKey.row, maxTileKey.row);
        const maxRow = Math.max(minTileKey.row, maxTileKey.row);
        const keys = new Array();
        for (let row = minRow; row <= maxRow; ++row) {
            for (let column = minColumn; column <= maxColumn; ++column) {
                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));
            }
        }
        return keys;
    }
}
exports.TileKeyUtils = TileKeyUtils;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts":
/*!*******************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileTreeTraverse.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SubTiles_1 = __webpack_require__(/*! ./SubTiles */ "../harp-geoutils/lib/tiling/SubTiles.ts");
class TileTreeTraverse {
    constructor(subdivisionScheme) {
        this.m_subdivisionScheme = subdivisionScheme;
    }
    subTiles(tileKey) {
        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);
        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
        return new SubTiles_1.SubTiles(tileKey, divX, divY);
    }
}
exports.TileTreeTraverse = TileTreeTraverse;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TilingScheme.ts":
/*!***************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TilingScheme.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts");
const TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ "../harp-geoutils/lib/tiling/TileKeyUtils.ts");
const TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts");
/**
 * The `TilingScheme` represents how the data is tiled.
 */
class TilingScheme {
    /**
     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.
     *
     * @param subdivisionScheme The subdivision scheme used by this `TilingScheme`.
     * @param projection The projection used by this `TilingScheme`.
     */
    constructor(subdivisionScheme, projection) {
        this.subdivisionScheme = subdivisionScheme;
        this.projection = projection;
        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);
        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);
    }
    /**
     * Returns the sub tile keys of the given tile.
     *
     * @param tileKey The [[TileKey]].
     * @returns The list of the sub tile keys.
     */
    getSubTileKeys(tileKey) {
        return this.tileTreeTraverse.subTiles(tileKey);
    }
    /**
     * Gets the [[TileKey]] from the given geo position and level.
     *
     * @param geoPoint The position in geo coordinates.
     * @param level The level of the resulting `TileKey`.
     */
    getTileKey(geoPoint, level) {
        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
    }
    /**
     * Gets the list of [[TileKey]]s contained in the given [[GeoBox]].
     *
     * @param geoBox The bounding box in geo coordinates.
     * @param level The level of the resulting `TileKey`.
     */
    getTileKeys(geoBox, level) {
        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
    }
    /**
     * Returns the bounding box in geo coordinates for the given [[TileKey]].
     *
     * @param tileKey The `TileKey`.
     */
    getGeoBox(tileKey) {
        return this.boundingBoxGenerator.getGeoBox(tileKey);
    }
    /**
     * Returns the bounding box in world coordinates.
     *
     * @param tileKey The `TileKey`.
     * @param result The optional object that will contain the resulting bounding box.
     */
    getWorldBox(tileKey, result) {
        return this.boundingBoxGenerator.getWorldBox(tileKey, result);
    }
}
exports.TilingScheme = TilingScheme;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts":
/*!**************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * A [[TilingScheme]] featuring quadtree subdivision scheme and web Mercator projection.
 */
exports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);


/***/ }),

/***/ "../harp-lines/index.ts":
/*!******************************!*\
  !*** ../harp-lines/index.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Lines */ "../harp-lines/lib/Lines.ts"));
__export(__webpack_require__(/*! ./lib/TriangulateLines */ "../harp-lines/lib/TriangulateLines.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionLines */ "../harp-lines/lib/HighPrecisionLines.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts"));


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionLines.ts":
/*!***********************************************!*\
  !*** ../harp-lines/lib/HighPrecisionLines.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts");
/**
 * Class used to render high-precision wireframe lines.
 */
class HighPrecisionWireFrameLine extends THREE.Line {
    /**
     * Creates a `HighPrecisionWireFrameLine` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered line.
     * @param opacity Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;
/**
 * Class used to render high-precision lines.
 */
class HighPrecisionLine extends THREE.Mesh {
    /**
     * Creates a `HighPrecisionLine` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered line.
     * @param opacity Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionLine = HighPrecisionLine;


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionPoints.ts":
/*!************************************************!*\
  !*** ../harp-lines/lib/HighPrecisionPoints.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts");
/**
 * Class used to render high-precision points.
 */
class HighPrecisionPoints extends THREE.Points {
    /**
     * Creates a `HighPrecisionPoints` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered point.
     * @param opacity Opacity of the rendered point.
     */
    constructor(geometry, material, positions, color, opacity) {
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionPointMaterial({
                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : 1
            });
        }
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    /**
     * Clears the [[BufferGeometry]] used to render this point.
     */
    clearGeometry() {
        return (this.geometry = new THREE.BufferGeometry());
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        if (this.material.isHighPrecisionPointsMaterial &&
            this.dimensionality !== undefined) {
            this.material.setDimensionality(this.dimensionality);
        }
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionPoints = HighPrecisionPoints;


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionUtils.ts":
/*!***********************************************!*\
  !*** ../harp-lines/lib/HighPrecisionUtils.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const HPL = __webpack_require__(/*! ./HighPrecisionLines */ "../harp-lines/lib/HighPrecisionLines.ts");
const HPP = __webpack_require__(/*! ./HighPrecisionPoints */ "../harp-lines/lib/HighPrecisionPoints.ts");
const TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ "../harp-lines/lib/TriangulateLines.ts");
var HighPrecisionUtils;
(function (HighPrecisionUtils) {
    /**
     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.
     * precision.
     *
     * @param v
     */
    function doubleToFloatVec(v) {
        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
    }
    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;
    /**
     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the
     * difference of the double elements and their float counterparts.
     *
     * @param v Vector3 to convert to float IN-PLACE!
     */
    function makeFloatVec(v) {
        const majorX = Math.fround(v.x);
        const majorY = Math.fround(v.y);
        const majorZ = Math.fround(v.z);
        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
        v.x = Math.fround(majorX);
        v.y = Math.fround(majorY);
        v.z = Math.fround(majorZ);
        return minorVec;
    }
    HighPrecisionUtils.makeFloatVec = makeFloatVec;
    /**
     * Calculate high-precision camera position used in vertex shader of high-precision materials.
     *
     * @param camera Camera used to get the high-precision position.
     * @param objectInverseWorldMatrix Inverse World Matrix of the rendered [[HighPrecisionObject]].
     */
    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);
        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
        // split the double float vector into hi and lo parts
        const eyePosFloat = doubleToFloatVec(eyePos);
        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
        return {
            viewProjection: mvp,
            eyePosHi: eyePosFloat,
            eyePosLo
        };
    }
    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
    /**
     * Updates the high-precision uniform data of a material used to render a
     * [[HighPrecisionObject]].
     *
     * @param object [[HighPrecisionObject]] used for rendering.
     * @param camera Camera used to get the high-precision position.
     * @param shaderMaterial Material which uniforms will be updated.
     */
    function updateHpUniforms(object, camera, shaderMaterial) {
        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
        const mvp = highPrecisionCameraInfo.viewProjection;
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_mvp &&
                shaderMaterial.uniforms.u_eyepos &&
                shaderMaterial.uniforms.u_eyepos_lowpart) {
                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
            }
            else {
                throw Error("High pecision material has missing uniforms");
            }
        }
        else {
            throw Error("High pecision line has no high precision material");
        }
    }
    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;
    /**
     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].
     *
     * @param positions Array of positions.
     */
    function createAttributes(positions) {
        if (positions.length > 0) {
            const v = positions[0];
            if (v === undefined || v === null) {
                throw Error("Empty element in positions");
            }
            const positionVec = new Array();
            const positionVecLow = new Array();
            const addHPValue = (...values) => {
                for (const value of values) {
                    const major = Math.fround(value);
                    positionVecLow.push(value - major);
                    positionVec.push(major);
                }
            };
            const addHPVector = (vec) => {
                addHPValue(vec.x, vec.y, vec.z);
            };
            const vAny = v;
            if (vAny.z !== undefined) {
                positions.forEach(vec => {
                    addHPVector(vec);
                });
            }
            else {
                if (positionVec.length % 3 !== 0) {
                    throw Error("Positions must be 3D, not 2D");
                }
                positions.forEach((n) => {
                    addHPValue(n);
                });
            }
            return {
                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),
                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)
            };
        }
        else {
            return {
                positionHigh: new three_1.Float32BufferAttribute([], 3),
                positionLow: new three_1.Float32BufferAttribute([], 3)
            };
        }
    }
    HighPrecisionUtils.createAttributes = createAttributes;
    /**
     * Assembles an interleaved buffer containing the position attribute data for a
     * [[HighPrecisionObject]].
     *
     * @param positions Array of positions.
     * @param stride Stride of the elements in the `positions` array.
     * @param positionOffset Offset into the `positions` array.
     */
    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {
        const newPositions = new Array();
        const end = positions.length;
        for (let i = 0; i < end; i += stride) {
            for (let j = 0; j < positionOffset; j++) {
                newPositions.push(positions[i + j]);
            }
            const x = positions[i + positionOffset];
            const y = positions[i + positionOffset + 1];
            const z = positions[i + positionOffset + 2];
            const majorX = Math.fround(x);
            const minorX = x - majorX;
            const majorY = Math.fround(y);
            const minorY = y - majorY;
            const majorZ = Math.fround(z);
            const minorZ = z - majorZ;
            // insert values in interleaved buffer
            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
            for (let j = positionOffset + 3; j < stride; j++) {
                newPositions.push(positions[i + j]);
            }
        }
        return newPositions;
    }
    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;
    /**
     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].
     *
     * @param object [[HighPrecisionObject]] which position attribute will be set.
     * @param positions Array of positions.
     */
    function setPositions(object, positions) {
        const attributes = createAttributes(positions);
        object.bufferGeometry.addAttribute("position", attributes.positionHigh);
        object.bufferGeometry.addAttribute("positionLow", attributes.positionLow);
        return attributes.positionHigh.itemSize;
    }
    HighPrecisionUtils.setPositions = setPositions;
    /**
     * Convert positions from `Array<Vector3>` to `Array<number>`.
     *
     * @param positions Array of positions.
     */
    function convertPositions(positions) {
        if (positions.length <= 0) {
            return { positions: [] };
        }
        const v = positions[0];
        if (v === undefined || v === null) {
            throw Error("Empty element in positions");
        }
        const vAny = v;
        if (vAny.y === undefined && vAny.z === undefined) {
            return { positions: positions };
        }
        const returnPositions = new Array();
        positions.forEach(vec => {
            returnPositions.push(vec.x, vec.y, vec.z);
        });
        return { positions: returnPositions };
    }
    HighPrecisionUtils.convertPositions = convertPositions;
    /**
     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.
     *
     * @param linePositions Array of 2D/3D positions.
     * @param params Parameters used to configure the created [[HighPrecisionObject]].
     */
    function createLine(linePositions, params) {
        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;
        const addCircles = params.addCircles !== undefined ? params.addCircles : false;
        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;
        const positions = [];
        const indices = [];
        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
        const hpLineGeometry = new three_1.BufferGeometry();
        const hpPositions = addInterleavedAttributes3(positions, 3);
        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);
        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);
        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);
        hpLineGeometry.addAttribute("position", positionAttribute);
        hpLineGeometry.addAttribute("positionLow", positionLowAttribute);
        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));
        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);
        const lineObject = wireFrame
            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)
            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
        lineObject.setupForRendering();
        return lineObject;
    }
    HighPrecisionUtils.createLine = createLine;
    /**
     * Creates a group of [[HighPrecisionPoints]].
     *
     * @param pointPositions Array of 2D/3D positions.
     * @param materialParameters Parameters used to configure the material used to render the
     * created [[HighPrecisionPoints]].
     */
    function createPoints(pointPositions, materialParameters) {
        const indices = [];
        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface
        for (let i = 0; i < pointPositions.length; i++) {
            indices.push(indices.length / 3);
        }
        const hpPointsGeometry = new three_1.BufferGeometry();
        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)
            ? materialParameters
            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);
        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
        setPositions(pointsObject, pointPositions);
        pointsObject.setupForRendering();
        return pointsObject;
    }
    HighPrecisionUtils.createPoints = createPoints;
})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));


/***/ }),

/***/ "../harp-lines/lib/Lines.ts":
/*!**********************************!*\
  !*** ../harp-lines/lib/Lines.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
// Preallocate temp variables used during line generation.
const tmpV = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpTangent0 = new THREE.Vector3();
const tmpTangent1 = new THREE.Vector3();
const tmpBitangent = new THREE.Vector3();
const SEGMENT_OFFSET = 0.1;
/**
 * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].
 */
/** Optional normal and uv coordinates. */
const NORMAL_UV_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "uv", itemSize: 2, offset: 12 },
        { name: "normal", itemSize: 3, offset: 14 }
    ],
    stride: 5
};
/** Base line vertex attributes. */
const LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "extrusionCoord", itemSize: 2, offset: 0 },
        { name: "position", itemSize: 3, offset: 2 },
        { name: "tangent", itemSize: 3, offset: 5 },
        { name: "bitangent", itemSize: 4, offset: 8 }
    ],
    stride: 12
};
/** Base line vertex attributes plus normals and uv coordinates. */
const LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],
    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Declares all the vertex attributes used for rendering a line using the
 * [[HighPrecisionLineMaterial]].
 */
const HP_LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "extrusionCoord", itemSize: 2, offset: 0 },
        { name: "position", itemSize: 3, offset: 2 },
        { name: "positionLow", itemSize: 3, offset: 5 },
        { name: "tangent", itemSize: 3, offset: 8 },
        { name: "bitangent", itemSize: 4, offset: 11 }
    ],
    stride: 15
};
/** High precision line vertex attributes plus normals and uv coordinates. */
const HP_LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [
        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,
        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes
    ],
    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Class that holds the vertex and index attributes for a [[Lines]] object.
 */
class LineGeometry {
    constructor() {
        this.vertices = [];
        this.vertexColors = [];
        this.indices = [];
    }
}
exports.LineGeometry = LineGeometry;
function getVertexDescriptor(hasNormalsAndUvs, highPrecision) {
    if (highPrecision) {
        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;
    }
    else {
        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;
    }
}
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param center Center of the polyline.
 * @param polyline Array of `numbers` describing a polyline.
 * @param uvs Array of `numbers` representing texture coordinates.
 * @param colors Array of `numbers` describing a polyline's colors.
 * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.
 * @param highPrecision If `true` will create high-precision vertex information.
 */
function createLineGeometry(center, polyline, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {
    if (polyline.length === 0) {
        return geometry;
    }
    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;
    const pointCount = polyline.length / 3;
    const segments = new Array(pointCount);
    const tangents = new Array(polyline.length - 3);
    const baseVertex = geometry.vertices.length / stride;
    const hasTexCoords = uvs !== undefined && uvs.length > 0;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);
    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);
    // Compute segments and tangents.
    let sum = SEGMENT_OFFSET;
    segments[0] = sum;
    let isFlat = true;
    for (let i = 0; i < pointCount - 1; ++i) {
        let sqrLength = 0;
        for (let j = 0; j < 3; ++j) {
            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];
            tangents[i * 3 + j] = d;
            sqrLength += d * d;
            isFlat = j === 2 ? isFlat && polyline[(i + 1) * 3 + j] === 0.0 : isFlat;
        }
        const len = Math.sqrt(sqrLength);
        sum = sum + len;
        segments[i + 1] = sum;
    }
    // Check if we're working with a closed line.
    let isClosed = true;
    for (let j = 0; j < 3; ++j) {
        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];
    }
    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {
        for (let v = -1; v <= 1; v += 2) {
            // Store the segment and extrusionCoord attributes.
            geometry.vertices.push(segment, extrusionCoord * v);
            // Store the position attribute (component-dependant).
            for (let j = 0; j < 3; ++j) {
                if (!highPrecision) {
                    geometry.vertices.push(polyline[i * 3 + j]);
                }
                else {
                    const highComp = Math.fround(polyline[i * 3 + j]);
                    const lowComp = polyline[i * 3 + j] - highComp;
                    geometry.vertices.push(highComp, lowComp);
                }
                tmpNormal.setComponent(j, polyline[i * 3 + j]);
            }
            // Store the bitangent attribute (component-dependant).
            for (let j = 0; j < 3; ++j) {
                tmpTangent0.setComponent(j, tangents[T1 + j]);
                tmpTangent1.setComponent(j, tangents[T2 + j]);
            }
            geometry.vertices.push(...tmpTangent0.normalize().toArray());
            const angle = computeBitangent(isFlat ? tmpNormal.set(0, 0, 1) : tmpNormal.add(center).normalize(), tmpTangent0, tmpTangent1.normalize(), tmpBitangent);
            geometry.vertices.push(...tmpBitangent.toArray(), angle);
            if (hasTexCoords) {
                // uvs
                geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);
                // normals
                geometry.vertices.push(...tmpNormal.toArray());
            }
            // Add vertex colors (if supplied).
            if (vertexColors) {
                geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
            }
        }
    };
    for (let i = 0; i < pointCount; ++i) {
        // Retrieve the per-point tangents.
        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;
        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);
        // Process v0 and v1.
        if (i > 0) {
            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);
        }
        // Process v2 and v3.
        if (i + 1 < pointCount) {
            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);
        }
    }
    // Store the triangle indices in the final index buffer.
    for (let i = 0; i < pointCount - 1; ++i) {
        const base = baseVertex + i * 4;
        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);
    }
    return geometry;
}
exports.createLineGeometry = createLineGeometry;
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param polyline Array of `numbers` describing a polyline.
 * @param colors Array of `numbers` describing a polyline's colors.
 * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.
 */
function createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {
    if (polyline.length === 0) {
        return geometry;
    }
    const pointCount = polyline.length / 3;
    let index = geometry.vertices.length / 3;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    for (let i = 0; i < pointCount; ++i, index++) {
        if (i > 0) {
            geometry.indices.push(index);
        }
        if (i < pointCount - 1) {
            geometry.indices.push(index);
        }
        for (let j = 0; j < 3; ++j) {
            geometry.vertices.push(polyline[i * 3 + j]);
            if (vertexColors) {
                geometry.vertexColors.push(colors[i * 3 + j]);
            }
        }
    }
    return geometry;
}
exports.createSimpleLineGeometry = createSimpleLineGeometry;
/**
 * Class used to render groups (or batches) of width-variable lines (in the same tile).
 */
class LineGroup {
    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        this.hasNormalsAndUvs = hasNormalsAndUvs;
        this.highPrecision = highPrecision;
        this.isSimple = isSimple;
        this.m_geometry = new LineGeometry();
    }
    /**
     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.
     *
     * @param vertices Array of vertex attributes.
     * @param colors Array of vertex colors.
     * @param indices Array of vertex indices.
     * @param geometry [[BufferGeometry]] object which will store all the `Lines` attribute data.
     * @param hasNormalsAnUvs Whether vertices have normal and uv coordinates as attributes.
     * @param highPrecision If `true` will create high-precision vertex information.
     * @param isSimple `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.
     */
    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        if (isSimple) {
            geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
            if (colors.length === vertices.length) {
                geometry.addAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
        else {
            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);
            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);
            vertexDescriptor.attributes.forEach(descr => {
                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);
                geometry.addAttribute(descr.name, attribute);
            });
            if (colors.length === vertices.length) {
                geometry.addAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
    }
    /**
     * Clears the list of line strips.
     */
    clear() {
        this.m_geometry.vertices = [];
        this.m_geometry.vertexColors = [];
        this.m_geometry.indices = [];
    }
    /**
     * Add the given points to this line group.
     *
     * @param center World center of the provided points.
     * @param points Sequence of (x,y,z) coordinates.
     * @param uvs Sequence of (u,v) texture coordinates.
     * @param colors Sequence of (r,g,b) color components.
     */
    add(center, points, uvs, colors) {
        if (!this.isSimple) {
            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);
            createLineGeometry(center, points, uvs, colors, this.m_geometry, this.highPrecision);
        }
        else {
            createSimpleLineGeometry(points, colors, this.m_geometry);
        }
        return this;
    }
    /**
     * Returns the list of vertices.
     */
    get vertices() {
        return this.m_geometry.vertices;
    }
    /**
     * Returns the list of vertex colors.
     */
    get vertexColors() {
        return this.m_geometry.vertexColors;
    }
    /**
     * Returns the list of indices.
     */
    get indices() {
        return this.m_geometry.indices;
    }
    /**
     * Returns the list of [[VertexAttributeDescriptor]]s.
     */
    get vertexAttributes() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;
    }
    /**
     * Returns the vertex attribute stride.
     */
    get stride() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;
    }
    /**
     * Creates a three.js geometry.
     */
    createGeometry(geometry) {
        if (geometry === undefined) {
            geometry = new THREE.BufferGeometry();
        }
        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);
    }
}
exports.LineGroup = LineGroup;
function computeBitangent(n, t0, t1, bt) {
    let angle = 0;
    if (!t0.equals(t1)) {
        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));
        if (Number.isNaN(angle)) {
            angle = 0;
        }
    }
    bt.copy(t0)
        .add(t1)
        .normalize()
        .cross(n)
        .normalize();
    return angle;
}


/***/ }),

/***/ "../harp-lines/lib/TriangulateLines.ts":
/*!*********************************************!*\
  !*** ../harp-lines/lib/TriangulateLines.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const UNIT_Z = new THREE.Vector3(0, 0, 1);
const POINTS = [0, 1, 2, 1, 3, 2];
const BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];
const SECTORS_IN_CIRCLE = 8;
const STEP = Math.PI / SECTORS_IN_CIRCLE;
/**
 * Adds a half-circle geometry to original line
 *
 * @param x The line end X (used as circle center X)
 * @param y The line end Y (used as circle center Y)
 * @param lineAngle The cap incline angle
 * @param radius The cap (circle) radius
 * @param vertices The input vertex buffer (cap vertices are added there)
 * @param indices The input index buffer (cap indices are is added there)
 */
function addCircle(x, y, lineAngle, radius, vertices, indices) {
    const baseVertex = vertices.length / 3;
    // Add cap center to vertices directly (it doesn't need rotation)
    vertices.push(x, y, 0);
    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {
        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg
        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);
    }
}
/**
 * Returns the number of points in circle used for caps.
 *
 * @param lineWidth Width of line.
 */
// tslint:disable-next-line:no-unused-variable
function numCirclePoints(lineWidth) {
    return SECTORS_IN_CIRCLE + 1;
}
exports.numCirclePoints = numCirclePoints;
/**
 * Create a triangle mesh from the given polyline.
 *
 * @param points Sequence of (x,y,z) coordinates.
 * @param width The width of the extruded line.
 * @param vertices The output vertex buffer.
 * @param indices The output index buffer.
 * @param startWithCircle `true` if the line should start will a circle.
 * @param endWithCircle `true` if the line should end with a circle.
 */
function triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {
    if (points.length < 3) {
        return;
    }
    // This vector is used for computing cap angle
    const angleVec = new THREE.Vector2();
    if (startWithCircle) {
        // Define lineAngle as (direction - origin) vector angle to X axis
        const lineAngle = points.length !== 3
            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()
            : 0;
        addCircle(points[0], points[1], lineAngle, width, vertices, indices);
    }
    const baseVertex = vertices.length / 3;
    // bt = Bitangent (i.e. extrusion vector)
    const prevBt = new THREE.Vector3();
    const p = new THREE.Vector3(); // current point
    const n = new THREE.Vector3(); // next point
    const bt = new THREE.Vector3();
    const averageBt = new THREE.Vector3();
    const p0 = new THREE.Vector3();
    const p1 = new THREE.Vector3();
    const p2 = new THREE.Vector3();
    const p3 = new THREE.Vector3();
    const N = points.length / 3;
    let vertexOffset = 0;
    for (let i = 0; i < N; ++i) {
        let useBevel = false;
        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
        if (i + 1 < N) {
            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
            bt.copy(n)
                .sub(p)
                .normalize()
                .cross(UNIT_Z);
            averageBt.copy(bt);
            if (i > 0) {
                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));
                useBevel = prevBt.angleTo(bt) > Math.PI / 2;
                if (useBevel) {
                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
                    p0.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(-inclineWidth)
                        .add(p);
                    p1.copy(prevBt)
                        .multiplyScalar(width)
                        .add(p);
                    // p2 is used for "miter" connections
                    p2.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(inclineWidth)
                        .add(p);
                    p3.copy(bt)
                        .multiplyScalar(width)
                        .add(p);
                }
            }
            if (useBevel) {
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            }
            else {
                p0.copy(averageBt)
                    .multiplyScalar(-width)
                    .add(p);
                p1.copy(averageBt)
                    .multiplyScalar(width)
                    .add(p);
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
            prevBt.copy(bt);
        }
        else {
            p0.copy(prevBt)
                .multiplyScalar(-width)
                .add(p);
            p1.copy(prevBt)
                .multiplyScalar(width)
                .add(p);
            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
        }
        if (i !== N - 1) {
            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));
            vertexOffset += useBevel ? 4 : 2;
        }
    }
    if (endWithCircle) {
        const lineAngle = points.length !== 2
            ? angleVec
                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])
                .angle()
            : Math.PI;
        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);
    }
}
exports.triangulateLine = triangulateLine;
/**
 * Reconstruct the original points of a line from the vertices of the triangulated line.
 *
 * @param inBuffer Buffer with vertices.
 * @param startOffset Start index, will differ from `0` if the line has caps.
 * @returns Buffer containing the original points of the triangulated line.
 */
function reconstructLine(inBuffer, startOffset) {
    const outBuffer = new Float32Array(inBuffer.length / 2);
    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {
        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;
        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;
        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;
    }
    return outBuffer;
}
exports.reconstructLine = reconstructLine;
/**
 * Extract the line width from a triangulated line.
 *
 * @param inBuffer Array of vertex elements of a triangulated line.
 * @param startIndex Start index, will differ from `0` if the line has caps.
 */
function reconstructLineWidth(inBuffer, startIndex) {
    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}
exports.reconstructLineWidth = reconstructLineWidth;


/***/ }),

/***/ "../harp-lrucache/index.ts":
/*!*********************************!*\
  !*** ../harp-lrucache/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/LRUCache */ "../harp-lrucache/lib/LRUCache.ts"));


/***/ }),

/***/ "../harp-lrucache/lib/LRUCache.ts":
/*!****************************************!*\
  !*** ../harp-lrucache/lib/LRUCache.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/** @hidden */
class Entry {
    constructor(key, value, size, newer, older) {
        this.key = key;
        this.value = value;
        this.size = size;
        this.newer = newer;
        this.older = older;
    }
}
exports.Entry = Entry;
/**
 * Fixed size cache that evicts its entries in least-recently-used order when it overflows.
 * Modeled after standard JavaScript `Map` otherwise.
 */
class LRUCache {
    /**
     * Creates a new instance of `LRUCache`. The optional sizeFunction can be used
     * fine tune the size required to cache that item.
     *
     * @param cacheCapacity The maximum number of entries to store in the cache.
     * @param sizeFunction A function determining the size per element.
     */
    constructor(cacheCapacity, sizeFunction = () => 1) {
        this.m_size = 0;
        /**
         * The internal map object that keeps the key-value pairs and their order.
         */
        this.m_map = new Map();
        /**
         * The newest entry, i.e. the most recently used item.
         */
        this.m_newest = null;
        /**
         * The oldest entry, i.e. the least recently used item.
         */
        this.m_oldest = null;
        this.m_capacity = cacheCapacity;
        this.m_sizeFunction = sizeFunction;
    }
    /**
     * Iterates over all items from the most recently used item to the least recently used one.
     *
     * **Note**: Results are undefined if the cache is modified during iteration.
     *
     * @param callbackfn The callback to call for each item.
     * @param thisArg Optional this argument for the callback.
     */
    forEach(callbackfn, thisArg) {
        let entry = this.m_newest;
        while (entry !== null) {
            callbackfn.call(thisArg, entry.value, entry.key, this);
            entry = entry.older;
        }
    }
    /**
     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.
     *
     * @returns The size of the cache.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache can
     * contain.
     *
     * @returns The capacity of the cache.
     */
    get capacity() {
        return this.m_capacity;
    }
    /**
     * @deprecated - DO NOT USE. Will be removed in future versions.
     *
     * Returns the internal map object that keeps the key-value pairs and their order.
     *
     * @returns The internal map object.
     */
    get map() {
        // ### TODO - remove me. Cache must not expose its internal object,
        // modifications to it are fatal for the internal state machine.
        return this.m_map;
    }
    /**
     * Returns the newest entry in the cache.
     *
     * @returns Newest entry in the cache.
     */
    get newest() {
        return this.m_newest;
    }
    /**
     * Returns the oldest entry in the cache.
     *
     * Note: Does not promote the oldest item as most recently used item.
     *
     * @returns Oldest entry in the cache.
     */
    get oldest() {
        return this.m_oldest;
    }
    /**
     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,
     * all items will be evicted until the cache shrinks to `newCapacity`.
     *
     * @param newCapacity The new capacity of this cache.
     */
    setCapacity(newCapacity) {
        this.m_capacity = newCapacity;
        this.evict();
    }
    /**
     * Updates the size of all elements in this cache. If their aggregated size is larger than the
     * capacity, items will be evicted until the cache shrinks to fit the capacity.
     */
    shrinkToCapacity() {
        let size = 0;
        const sizeFunction = this.m_sizeFunction;
        let entry = this.m_newest;
        while (entry !== null) {
            const entrySize = sizeFunction(entry.value);
            entry.size = entrySize;
            size += entrySize;
            entry = entry.older;
        }
        this.m_size = size;
        this.evict();
    }
    /**
     * Inserts or updates a key/value pair in the cache.
     *
     * If the key already existed in the cache, it will be updated and promoted to the most recently
     * used item.
     *
     * If the key didn't exist in the cache, it will be inserted as most recently used item. An
     * eviction of the least recently used item takes place if the cache exceeded its capacity.
     *
     * @param key The key for the key-value pair to insert or update.
     * @param value The value for the key-value pair to insert or update.
     */
    set(key, value) {
        const valueSize = this.m_sizeFunction(value);
        let entry = this.m_map.get(key);
        if (entry !== undefined) {
            this.m_size = this.m_size - entry.size + valueSize;
            entry.value = value;
            entry.size = valueSize;
            this.promote(entry);
            this.evict();
        }
        else {
            if (valueSize > this.m_capacity) {
                return; // single item too big to cache
            }
            entry = new Entry(key, value, valueSize, null, null);
            if (this.m_map.size === 0) {
                this.m_newest = this.m_oldest = entry;
            }
            else {
                harp_utils_1.assert(this.m_newest !== null);
                const newest = this.m_newest;
                entry.older = this.m_newest;
                newest.newer = entry;
                this.m_newest = entry;
            }
            this.m_map.set(key, entry);
            this.m_size += valueSize;
            this.evict();
        }
    }
    /**
     * Looks up key in the cache and returns the associated value.
     *
     * @param key The key to look up.
     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.
     */
    get(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        this.promote(entry);
        return entry.value;
    }
    /**
     * Test if a key/value pair is in the cache.
     *
     * @param key The key to look up.
     * @returns `true` if the key-value pair is in the cache, `false` otherwise.
     */
    has(key) {
        return this.m_map.has(key);
    }
    /**
     * Clears the cache and removes all stored key-value pairs.
     *
     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the
     * eviction callback.
     */
    clear() {
        this.m_newest = this.m_oldest = null;
        this.m_size = 0;
        this.m_map.clear();
    }
    /**
     * Evicts all items from the cache, calling the eviction callback on each item.
     *
     * Use [[clear]] to remove all items without calling the eviction callback.
     */
    evictAll() {
        const cb = this.evictionCallback;
        if (cb !== undefined) {
            this.forEach((value, key) => cb(key, value));
        }
        this.clear();
    }
    /**
     * Explicitly removes a key-value pair from the cache.
     *
     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.
     *
     * @param key The key of the key-value pair to delete.
     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.
     */
    delete(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return false;
        }
        if (entry === this.m_newest) {
            this.m_newest = entry.older;
        }
        else if (entry.newer) {
            entry.newer.older = entry.older;
        }
        else {
            harp_utils_1.assert(false);
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        else if (entry.older) {
            entry.older.newer = entry.newer;
        }
        else {
            harp_utils_1.assert(false);
        }
        this.m_size -= entry.size;
        return this.m_map.delete(key);
    }
    evict() {
        while (this.m_oldest !== null && this.m_size > this.m_capacity) {
            const evicted = this.evictOldest();
            if (evicted === undefined) {
                return;
            }
        }
    }
    evictOldest() {
        harp_utils_1.assert(this.m_oldest !== null);
        const oldest = this.m_oldest;
        harp_utils_1.assert(oldest.older === null);
        let itemToRemove = oldest;
        if (this.canEvict !== undefined) {
            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {
                if (itemToRemove.newer === null) {
                    return undefined;
                }
                itemToRemove = itemToRemove.newer;
            }
        }
        if (itemToRemove === oldest) {
            this.m_oldest = itemToRemove.newer;
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = null;
            }
        }
        else {
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = itemToRemove.older;
                if (itemToRemove.older !== null) {
                    itemToRemove.older.newer = itemToRemove.newer;
                }
            }
            else {
                return undefined;
            }
        }
        const isOk = this.m_map.delete(itemToRemove.key);
        harp_utils_1.assert(isOk === true);
        if (isOk && this.evictionCallback !== undefined) {
            this.evictionCallback(itemToRemove.key, itemToRemove.value);
        }
        this.m_size -= itemToRemove.size;
        return itemToRemove;
    }
    promote(entry) {
        if (entry === this.m_newest) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        if (entry.newer) {
            harp_utils_1.assert(entry.newer.older === entry);
            entry.newer.older = entry.older;
        }
        if (entry.older) {
            harp_utils_1.assert(entry.older.newer === entry);
            entry.older.newer = entry.newer;
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        // re-link ourselves
        entry.newer = null;
        entry.older = this.m_newest;
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newest !== null);
        const newest = this.m_newest;
        harp_utils_1.assert(newest.newer === null);
        newest.newer = entry;
        this.m_newest = entry;
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "../harp-map-controls/lib/MapControls.ts":
/*!***********************************************!*\
  !*** ../harp-map-controls/lib/MapControls.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const utils = __webpack_require__(/*! ./Utils */ "../harp-map-controls/lib/Utils.ts");
var State;
(function (State) {
    State[State["NONE"] = 0] = "NONE";
    State[State["PAN"] = 1] = "PAN";
    State[State["ROTATE"] = 2] = "ROTATE";
    State[State["ORBIT"] = 3] = "ORBIT";
    State[State["TOUCH"] = 4] = "TOUCH";
})(State || (State = {}));
var TiltState;
(function (TiltState) {
    TiltState[TiltState["Tilted"] = 0] = "Tilted";
    TiltState[TiltState["Down"] = 1] = "Down";
})(TiltState = exports.TiltState || (exports.TiltState = {}));
/**
 * Map interaction events' names.
 */
var EventNames;
(function (EventNames) {
    EventNames["Update"] = "update";
    EventNames["BeginInteraction"] = "begin-interaction";
    EventNames["EndInteraction"] = "end-interaction";
})(EventNames = exports.EventNames || (exports.EventNames = {}));
// cast needed to workaround wrong three.js typings.
const MAPCONTROL_EVENT = { type: EventNames.Update };
const MAPCONTROL_EVENT_BEGIN_INTERACTION = {
    type: EventNames.BeginInteraction
};
const MAPCONTROL_EVENT_END_INTERACTION = {
    type: EventNames.EndInteraction
};
/**
 * Yaw rotation as quaternion. Declared as a const to avoid object re-creation across frames.
 */
const yawQuaternion = new THREE.Quaternion();
/**
 * Pitch rotation as quaternion. Declared as a const to avoid object re-creation across frames.
 */
const pitchQuaternion = new THREE.Quaternion();
/**
 * The yaw axis around which we rotate when we change the yaw.
 * This axis is fixed and is the -Z axis `(0,0,1)`.
 */
const yawAxis = new THREE.Vector3(0, 0, 1);
/**
 * The pitch axis which we use to rotate around when we change the pitch.
 * The axis is fix and is the +X axis `(1,0,0)`.
 */
const pitchAxis = new THREE.Vector3(1, 0, 0);
/**
 * The number of the steps for which, when pitching the camera, the delta altitude is scaled until
 * it reaches the minimum camera height.
 */
const MAX_DELTA_ALTITUDE_STEPS = 10;
/**
 * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.
 */
const USER_INPUTS_TO_CONSIDER = 5;
/**
 * The default maximum for the camera pitch. This value avoids seeing the horizon.
 */
const DEFAULT_MAX_PITCH_ANGLE = Math.PI / 4;
/**
 * Epsilon value to rule out when a number can be considered 0.
 */
const EPSILON = 0.01;
/**
 * Maximum duration between start and end touch events to define a finger tap.
 */
const MAX_TAP_DURATION = 120;
/**
 * This map control provides basic map-related building blocks to interact with the map. It also
 * provides a default way of handling user input. Currently we support basic mouse interaction and
 * touch input interaction.
 *
 * Mouse interaction:
 *  - Left mouse button + move = Panning the map.
 *  - Right mouse button + move = Orbits the camera around the focus point.
 *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right
 *    movement changes the yaw.
 *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.
 *
 * Touch interaction:
 *  - One finger = Panning the map.
 *  - Two fingers = Scale, rotate and panning the map.
 *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.
 *    Left/right changes the azimuth.
 */
class MapControls extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapControls` object.
     *
     * @param mapView [[MapView]] this controller modifies.Z
     */
    constructor(mapView) {
        super();
        this.mapView = mapView;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset for the rotation then.
         * Default value is `0.1`.
         */
        this.rotationMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current touch pointer position and the last
         * touch pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingTouchDeltaFactor = 0.1;
        /**
         * Set to `true` to enable input handling through this map control, `false` to disable input
         * handling. Even when disabling input handling, you can manually use the public functions to
         * change the view to the current map.
         */
        this.enabled = true;
        /**
         * Set to `true` to enable orbiting and Pitch axis rotation through this map control, `false` to
         * disable orbiting and Pitch axis rotation.
         */
        this.tiltEnabled = true;
        /**
         * Set to `true` to enable rotation through this map control, `false` to disable rotation.
         */
        this.rotateEnabled = true;
        /**
         * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.
         */
        this.inertiaEnabled = true;
        /**
         * Inertia damping duration for the zoom, in seconds.
         */
        this.zoomInertiaDampingDuration = 0.5;
        /**
         * Inertia damping duration for the panning, in seconds.
         */
        this.panInertiaDampingDuration = 1.0;
        /**
         * Duration in seconds of the camera animation when the tilt button is clicked. Independent of
         * inertia.
         */
        this.tiltToggleDuration = 0.5;
        /**
         * Camera pitch target when tilting it from the UI button.
         */
        this.tiltAngle = Math.PI / 4;
        /**
         * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel
         * movement the current zoom level will be added or subtracted by this value. The default value
         * is `0.2` - this means that every 5th mouse wheel movement you will cross a zoom level.
         *
         * **Note**: To reverse the zoom direction, you can provide a negative value.
         */
        this.zoomLevelDeltaOnMouseWheel = 0.2;
        /**
         * Zoom level delta when using the UI controls.
         */
        this.zoomLevelDeltaOnControl = 1.0;
        /**
         * Determines the minimum zoom level we can zoom to.
         */
        this.minZoomLevel = 0;
        /**
         * Determines the maximum zoom level we can zoom to.
         */
        this.maxZoomLevel = 20;
        /**
         * Determines the minimum camera height in meter.
         */
        this.minCameraHeight = 3;
        /**
         * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.
         */
        this.zoomLevelDeltaOnDoubleClick = 1.0;
        /**
         * Double click uses the OS delay through the double click event. Tapping is implemented locally
         * here in `MapControls` with this duration setting the maximum delay to define a double tap.
         * The value is in seconds. `300ms` is picked as the default value as jQuery does.
         */
        this.doubleTapTime = 0.3;
        this.m_currentViewDirection = new THREE.Vector3();
        this.m_lastMousePosition = new THREE.Vector2(0, 0);
        this.m_mouseDelta = new THREE.Vector2(0, 0);
        this.m_needsRenderLastFrame = true;
        this.m_panIsAnimated = false;
        this.m_panDistanceFrameDelta = new THREE.Vector3();
        this.m_panAnimationTime = 0;
        this.m_panAnimationStartTime = 0;
        this.m_lastAveragedPanDistanceOrAngle = 0;
        this.m_currentInertialPanningSpeed = 0;
        this.m_lastPanVector = new THREE.Vector3();
        this.m_rotateGlobeQuaternion = new THREE.Quaternion();
        this.m_lastRotateGlobeAxis = new THREE.Vector3();
        this.m_lastRotateGlobeAngle = 0;
        this.m_lastRotateGlobeFromVector = new THREE.Vector3();
        this.m_recentPanDistancesOrAngles = [
            0,
            0,
            0,
            0,
            0
        ];
        this.m_currentPanDistanceOrAngleIndex = 0;
        this.m_zoomIsAnimated = false;
        this.m_zoomDeltaRequested = 0;
        this.m_zoomTargetNormalizedCoordinates = new THREE.Vector2();
        this.m_zoomAnimationTime = 0;
        this.m_zoomAnimationStartTime = 0;
        this.m_startZoom = 0;
        this.m_tiltIsAnimated = false;
        this.m_pitchRequested = undefined;
        this.m_tiltAnimationTime = 0;
        this.m_tiltAnimationStartTime = 0;
        this.m_startPitch = 0;
        this.m_state = State.NONE;
        this.m_tmpVector2 = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        this.m_tapStartTime = 0;
        this.m_lastSingleTapTime = 0;
        this.m_fingerMoved = false;
        this.m_isDoubleTap = false;
        /**
         * Determines the minimum angle the camera can pitch to. It is defined in radians.
         */
        this.m_minPitchAngle = 0;
        /**
         * Determines the maximum angle the camera can pitch to. It is defined in radians.
         */
        this.m_maxPitchAngle = DEFAULT_MAX_PITCH_ANGLE;
        this.m_touchState = {
            touches: [],
            currentRotation: 0,
            initialRotation: 0
        };
        /**
         * Destroy this `MapControls` instance.
         *
         * Unregisters all global event handlers used. This is method should be called when you stop
         * using `MapControls`.
         */
        this.dispose = () => {
            // replaced with real code in bindInputEvents
        };
        this.camera = mapView.camera;
        this.domElement = mapView.renderer.domElement;
        this.maxZoomLevel = mapView.maxZoomLevel;
        this.minZoomLevel = mapView.minZoomLevel;
        this.minCameraHeight = mapView.minCameraHeight;
        this.bindInputEvents(this.domElement);
        this.handleZoom = this.handleZoom.bind(this);
        this.handlePan = this.handlePan.bind(this);
        this.tilt = this.tilt.bind(this);
        this.assignZoomAfterTouchZoomRender = this.assignZoomAfterTouchZoomRender.bind(this);
    }
    /**
     * Creates MapControls object and attaches it specified [[MapView]].
     *
     * @param mapView - [[MapView]] object to which MapControls should be attached to.
     */
    static create(mapView) {
        return new MapControls(mapView);
    }
    /**
     * Rotates the camera by the given delta yaw and delta pitch.
     *
     * @param deltaYaw Delta yaw in degrees.
     * @param deltaPitch Delta pitch in degrees.
     */
    rotate(deltaYaw, deltaPitch = 0) {
        if (this.inertiaEnabled && this.m_zoomIsAnimated) {
            this.stopZoom();
        }
        if (this.mapView.projection.type !== geoUtils.ProjectionType.Planar) {
            return;
        }
        const yawPitchRoll = harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion, this.mapView.projection.type);
        //yaw
        let yawAngle = yawPitchRoll.yaw;
        if (this.rotateEnabled) {
            yawAngle -= geoUtils.MathUtils.degToRad(deltaYaw);
        }
        yawQuaternion.setFromAxisAngle(yawAxis, yawAngle);
        //pitch
        const deltaPitchRadians = geoUtils.MathUtils.degToRad(deltaPitch);
        const pitchAngle = this.constrainPitchAngle(yawPitchRoll.pitch, deltaPitchRadians);
        pitchQuaternion.setFromAxisAngle(pitchAxis, pitchAngle);
        yawQuaternion.multiply(pitchQuaternion);
        this.mapView.camera.quaternion.copy(yawQuaternion);
        this.mapView.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Current viewing angles yaw/pitch/roll in degrees.
     */
    get yawPitchRoll() {
        const ypr = harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion, this.mapView.projection.type);
        return {
            yaw: geoUtils.MathUtils.radToDeg(ypr.yaw),
            pitch: geoUtils.MathUtils.radToDeg(ypr.pitch),
            roll: geoUtils.MathUtils.radToDeg(ypr.roll)
        };
    }
    /*
     * Orbits the camera around the focus point of the camera. The `deltaAzimuth` and
     * `deltaAltitude` are offsets in degrees to the current azimuth and altitude of the current
     * orbit.
     *
     * @param deltaAzimuth Delta azimuth in degrees.
     * @param deltaAltitude Delta altitude in degrees.
     */
    orbitFocusPoint(deltaAzimuth, deltaAltitude) {
        if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            return;
        }
        if (this.inertiaEnabled && this.m_zoomIsAnimated) {
            this.stopZoom();
        }
        this.mapView.camera.getWorldDirection(this.m_currentViewDirection);
        const currentAzimuthAltitude = utils.directionToAzimuthAltitude(this.m_currentViewDirection);
        const topElevation = (1.0 / Math.sin(currentAzimuthAltitude.altitude)) * this.mapView.camera.position.z;
        const focusPointInWorldPosition = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);
        const deltaAltitudeConstrained = this.getMinDelta(deltaAltitude);
        this.rotate(deltaAzimuth, deltaAltitudeConstrained);
        this.mapView.camera.getWorldDirection(this.m_currentViewDirection);
        const newAzimuthAltitude = utils.directionToAzimuthAltitude(this.m_currentViewDirection);
        const newElevation = Math.sin(newAzimuthAltitude.altitude) * topElevation;
        this.mapView.camera.position.z = newElevation;
        const newFocusPointInWorldPosition = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);
        if (!focusPointInWorldPosition || !newFocusPointInWorldPosition) {
            // We do this to trigger an update in all cases.
            this.updateMapView();
            return;
        }
        const diff = focusPointInWorldPosition.sub(newFocusPointInWorldPosition);
        harp_mapview_1.MapViewUtils.panCameraAboveFlatMap(this.mapView, diff.x, diff.y);
    }
    /**
     * Moves the camera along the view direction in meters.
     * A positive value will move the camera further away from the point where the camera looks at.
     * A negative value will move the camera near to the point where the camera looks at.
     *
     * @param amount Amount to move along the view direction in meters.
     */
    moveAlongTheViewDirection(amount) {
        this.mapView.camera.getWorldDirection(this.m_currentViewDirection);
        this.m_currentViewDirection.multiplyScalar(amount);
        this.mapView.camera.position.z += this.m_currentViewDirection.z;
        this.updateMapView();
        this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param yaw Yaw in degrees.
     * @param pitch Pitch in degrees.
     */
    setRotation(yaw, pitch) {
        harp_mapview_1.MapViewUtils.setRotation(this.mapView, yaw, pitch);
    }
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param targetPositionOnScreenXinNDC Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC Target y position in NDC space.
     */
    zoomOnTargetPosition(targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel);
    }
    /**
     * Zooms to the desired location by the provided value.
     *
     * @param zoomLevel Zoom level.
     * @param screenTarget Zoom target on screen.
     */
    setZoomLevel(zoomLevel, screenTarget = { x: 0, y: 0 }) {
        if (this.enabled === false) {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        // Register the zoom request
        this.m_startZoom = this.currentZoom;
        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;
        // Cancel panning so the point of origin of the zoom is maintained.
        this.stopPan();
        // Assign the new animation start time.
        this.m_zoomAnimationStartTime = performance.now();
        this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);
        this.handleZoom();
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    /**
     * Toggles the camera pitch between 0 (looking down) and the value at `this.tiltAngle`.
     */
    toggleTilt() {
        this.m_startPitch = this.currentPitch;
        const aimTilt = this.m_startPitch < EPSILON || this.m_tiltState === TiltState.Down;
        this.m_pitchRequested = aimTilt ? this.tiltAngle : 0;
        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;
        this.m_tiltAnimationStartTime = performance.now();
        this.tilt();
    }
    /**
     * Set the camera height.
     */
    set cameraHeight(height) {
        //Set the cameras height according to the given zoom level.
        this.camera.position.setZ(height);
        this.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Get the current camera height.
     */
    get cameraHeight() {
        // ### Sync with the way geoviz is computing the zoom level.
        return this.mapView.camera.position.z;
    }
    /**
     * Set camera max pitch angle.
     *
     * @param angle Angle in degrees.
     */
    set maxPitchAngle(angle) {
        this.m_maxPitchAngle = geoUtils.MathUtils.degToRad(angle);
    }
    /**
     * Get the camera max pitch angle in degrees.
     */
    get maxPitchAngle() {
        return geoUtils.MathUtils.radToDeg(this.m_maxPitchAngle);
    }
    /**
     * Set camera min pitch angle.
     *
     * @param angle Angle in degrees.
     */
    set minPitchAngle(angle) {
        this.m_minPitchAngle = geoUtils.MathUtils.degToRad(angle);
    }
    /**
     * Get the camera min pitch angle in degrees.
     */
    get minPitchAngle() {
        return geoUtils.MathUtils.radToDeg(this.m_minPitchAngle);
    }
    /**
     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented
     * values to the target instead of getting the random zoomLevel value during the interpolation.
     */
    get zoomLevelTargeted() {
        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;
    }
    /**
     * Handy getter to know if the view is in the process of looking down or not.
     */
    get tiltState() {
        if (this.m_tiltState === undefined) {
            this.m_tiltState =
                this.currentPitch < EPSILON || this.m_tiltState === TiltState.Down
                    ? TiltState.Tilted
                    : TiltState.Down;
        }
        return this.m_tiltState;
    }
    set currentZoom(zoom) {
        this.m_currentZoom = zoom;
    }
    get currentZoom() {
        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;
    }
    set currentPitch(pitch) {
        this.m_currentPitch = pitch;
    }
    get currentPitch() {
        return harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion, this.mapView.projection.type).pitch;
    }
    get targetedPitch() {
        return this.m_targetedPitch === undefined
            ? this.m_currentPitch === undefined
                ? this.currentPitch
                : this.m_currentPitch
            : this.m_targetedPitch;
    }
    assignZoomAfterTouchZoomRender() {
        this.m_currentZoom = this.mapView.zoomLevel;
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    tilt() {
        if (this.m_pitchRequested !== undefined) {
            this.m_targetedPitch = Math.max(Math.min(this.m_pitchRequested, this.maxPitchAngle), this.m_minPitchAngle);
            this.m_pitchRequested = undefined;
        }
        if (this.inertiaEnabled) {
            if (!this.m_tiltIsAnimated) {
                this.m_tiltIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
            }
            const currentTime = performance.now();
            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;
            const tiltFinished = this.m_tiltAnimationTime > this.tiltToggleDuration;
            if (tiltFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_tiltAnimationTime = this.tiltToggleDuration;
                    this.stopTilt();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_currentPitch = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startPitch, this.targetedPitch, Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration))
            : this.targetedPitch;
        const initialPitch = this.currentPitch;
        const deltaAngle = this.m_currentPitch - initialPitch;
        const oldCameraDistance = this.mapView.camera.position.z / Math.cos(initialPitch);
        const newHeight = Math.cos(this.currentPitch) * oldCameraDistance;
        this.orbitFocusPoint(newHeight - this.camera.position.z, geoUtils.MathUtils.radToDeg(deltaAngle));
        this.updateMapView();
    }
    stopTilt() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
        this.m_tiltIsAnimated = false;
        this.m_targetedPitch = this.m_currentPitch = undefined;
    }
    easeOutCubic(startValue, endValue, time) {
        return startValue + (endValue - startValue) * (--time * time * time + 1);
    }
    handleZoom() {
        if (this.m_zoomDeltaRequested !== 0) {
            this.m_targetedZoom = Math.max(Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel), this.minZoomLevel);
            this.m_zoomDeltaRequested = 0;
        }
        if (this.inertiaEnabled && this.zoomInertiaDampingDuration > 0) {
            if (!this.m_zoomIsAnimated) {
                this.m_zoomIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
            }
            const currentTime = performance.now();
            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;
            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;
            if (zoomFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;
                    this.stopZoom();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.currentZoom =
            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON
                ? this.zoomLevelTargeted
                : this.easeOutCubic(this.m_startZoom, this.zoomLevelTargeted, Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration));
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, this.m_zoomTargetNormalizedCoordinates.x, this.m_zoomTargetNormalizedCoordinates.y, this.currentZoom);
        this.updateMapView();
    }
    stopZoom() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
        this.m_zoomIsAnimated = false;
    }
    /**
     * Method to flip crêpes.
     */
    handlePan() {
        if (this.m_state === State.NONE && this.m_lastAveragedPanDistanceOrAngle === 0) {
            return;
        }
        if (this.inertiaEnabled && !this.m_panIsAnimated) {
            this.m_panIsAnimated = true;
            this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
        }
        const applyInertia = this.inertiaEnabled &&
            this.panInertiaDampingDuration > 0 &&
            this.m_state === State.NONE &&
            this.m_lastAveragedPanDistanceOrAngle > 0;
        if (applyInertia) {
            const currentTime = performance.now();
            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;
            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;
            if (panFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_panAnimationTime = this.panInertiaDampingDuration;
                    this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
                    this.m_panIsAnimated = false;
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;
            this.m_currentInertialPanningSpeed = this.easeOutCubic(this.m_lastAveragedPanDistanceOrAngle, 0, Math.min(1, animationTime));
            if (this.m_currentInertialPanningSpeed === 0) {
                this.m_lastAveragedPanDistanceOrAngle = 0;
            }
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                this.m_panDistanceFrameDelta
                    .copy(this.m_lastPanVector)
                    .setLength(this.m_currentInertialPanningSpeed);
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                this.m_rotateGlobeQuaternion
                    .setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_currentInertialPanningSpeed)
                    .normalize();
            }
        }
        else {
            let panDistanceOrAngle = 0;
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                panDistanceOrAngle = this.m_lastPanVector
                    .copy(this.m_panDistanceFrameDelta)
                    .length();
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                panDistanceOrAngle = this.m_lastRotateGlobeAngle;
                this.m_rotateGlobeQuaternion.setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_lastRotateGlobeAngle);
                this.m_rotateGlobeQuaternion.normalize();
            }
            this.m_currentPanDistanceOrAngleIndex =
                (this.m_currentPanDistanceOrAngleIndex + 1) % USER_INPUTS_TO_CONSIDER;
            this.m_recentPanDistancesOrAngles[this.m_currentPanDistanceOrAngleIndex] = panDistanceOrAngle;
            this.m_lastAveragedPanDistanceOrAngle =
                this.m_recentPanDistancesOrAngles.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;
        }
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            harp_mapview_1.MapViewUtils.panCameraAboveFlatMap(this.mapView, this.m_panDistanceFrameDelta.x, this.m_panDistanceFrameDelta.y);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            harp_mapview_1.MapViewUtils.rotateCameraAroundGlobe(this.mapView, this.m_lastRotateGlobeFromVector, this.m_tmpVector3
                .copy(this.m_lastRotateGlobeFromVector)
                .applyQuaternion(this.m_rotateGlobeQuaternion));
        }
        if (!applyInertia) {
            this.m_panDistanceFrameDelta.set(0, 0, 0);
            this.m_lastRotateGlobeAngle = 0;
        }
        this.updateMapView();
    }
    stopPan() {
        this.m_panDistanceFrameDelta.set(0, 0, 0);
        this.m_lastAveragedPanDistanceOrAngle = 0;
    }
    bindInputEvents(domElement) {
        const onContextMenu = this.contextMenu.bind(this);
        const onMouseDown = this.mouseDown.bind(this);
        const onMouseWheel = this.mouseWheel.bind(this);
        const onTouchStart = this.touchStart.bind(this);
        const onTouchEnd = this.touchEnd.bind(this);
        const onTouchMove = this.touchMove.bind(this);
        const onMouseDoubleClick = this.mouseDoubleClick.bind(this);
        domElement.addEventListener("dblclick", onMouseDoubleClick, false);
        domElement.addEventListener("contextmenu", onContextMenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        domElement.addEventListener("touchstart", onTouchStart, false);
        domElement.addEventListener("touchend", onTouchEnd, false);
        domElement.addEventListener("touchmove", onTouchMove, false);
        this.dispose = () => {
            domElement.removeEventListener("dblclick", onMouseDoubleClick, false);
            domElement.removeEventListener("contextmenu", onContextMenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("touchstart", onTouchStart, false);
            domElement.removeEventListener("touchend", onTouchEnd, false);
            domElement.removeEventListener("touchmove", onTouchMove, false);
        };
    }
    updateMapView() {
        this.dispatchEvent(MAPCONTROL_EVENT);
        this.mapView.update();
    }
    mouseDoubleClick(e) {
        if (this.enabled === false) {
            return;
        }
        this.zoomOnDoubleClickOrTap(e.clientX, e.clientY);
    }
    mouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.shiftKey || event.ctrlKey) {
            return;
        }
        event.stopPropagation();
        if (this.m_state !== State.NONE) {
            return;
        }
        if (event.button === 0) {
            this.m_state = State.PAN;
        }
        else if (event.button === 1) {
            this.m_state = State.ROTATE;
        }
        else if (event.button === 2 && this.tiltEnabled) {
            this.m_state = State.ORBIT;
        }
        else {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.m_lastMousePosition.setX(event.clientX);
        this.m_lastMousePosition.setY(event.clientY);
        const onMouseMove = this.mouseMove.bind(this);
        const onMouseUp = this.mouseUp.bind(this);
        window.addEventListener("mousemove", onMouseMove, false);
        window.addEventListener("mouseup", onMouseUp, false);
        this.m_cleanupMouseEventListeners = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
        };
    }
    mouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_mouseDelta.set(event.clientX - this.m_lastMousePosition.x, event.clientY - this.m_lastMousePosition.y);
        if (this.m_state === State.PAN) {
            const vectors = this.getWorldPositionWithElevation(this.m_lastMousePosition.x, this.m_lastMousePosition.y, event.clientX, event.clientY);
            if (vectors === undefined) {
                return;
            }
            const { fromWorld, toWorld } = vectors;
            this.panFromTo(fromWorld, toWorld);
        }
        else if (this.m_state === State.ROTATE) {
            this.rotate(-this.rotationMouseDeltaFactor * this.m_mouseDelta.x, this.rotationMouseDeltaFactor * this.m_mouseDelta.y);
        }
        else if (this.m_state === State.ORBIT) {
            this.orbitFocusPoint(this.orbitingMouseDeltaFactor * this.m_mouseDelta.x, -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y);
        }
        this.m_lastMousePosition.set(event.clientX, event.clientY);
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    mouseUp(event) {
        if (this.enabled === false) {
            return;
        }
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
        this.m_state = State.NONE;
        if (this.m_cleanupMouseEventListeners) {
            this.m_cleanupMouseEventListeners();
        }
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    mouseWheel(event) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const screenTarget = utils.calculateNormalizedDeviceCoordinates(event.offsetX, event.offsetY, width, height);
        this.setZoomLevel(this.zoomLevelTargeted + this.zoomLevelDeltaOnMouseWheel * (event.deltaY > 0 ? -1 : 1), screenTarget);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Calculates the angle of the vector, which is formed by two touch points in world space
     * against the X axis in world space on the map. The resulting angle is in radians and between
     * `-PI` and `PI`.
     */
    calculateAngleFromTouchPointsInWorldspace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        const x = this.m_touchState.touches[1].currentWorldPosition.x -
            this.m_touchState.touches[0].currentWorldPosition.x;
        const y = this.m_touchState.touches[1].currentWorldPosition.y -
            this.m_touchState.touches[0].currentWorldPosition.y;
        return Math.atan2(y, x);
    }
    /**
     * Calculates the difference of the current distance of two touch points against their initial
     * distance in world space.
     */
    calculatePinchDistanceInWorldSpace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            const previousDistance = this.m_tmpVector3
                .subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[1].initialWorldPosition)
                .length();
            const currentDistance = this.m_tmpVector3
                .subVectors(this.m_touchState.touches[0].currentWorldPosition, this.m_touchState.touches[1].currentWorldPosition)
                .length();
            return currentDistance - previousDistance;
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            const previousDistance = this.m_tmpVector2
                .subVectors(this.m_touchState.touches[0].lastTouchPoint, this.m_touchState.touches[1].lastTouchPoint)
                .length();
            const currentDistance = this.m_tmpVector2
                .subVectors(this.m_touchState.touches[0].currentTouchPoint, this.m_touchState.touches[1].currentTouchPoint)
                .length();
            return currentDistance - previousDistance;
        }
        return 0;
    }
    convertTouchPoint(touch, oldTouchState) {
        const newTouchPoint = new THREE.Vector2(touch.pageX, touch.pageY);
        if (oldTouchState !== undefined) {
            const oldTouchPoint = oldTouchState.currentTouchPoint;
            const vectors = this.getWorldPositionWithElevation(oldTouchPoint.x, oldTouchPoint.y, newTouchPoint.x, newTouchPoint.y);
            if (vectors === undefined) {
                return null;
            }
            const { toWorld } = vectors;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
        else {
            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
            const to = utils.calculateNormalizedDeviceCoordinates(newTouchPoint.x, newTouchPoint.y, width, height);
            const toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
            if (toWorld === null) {
                return null;
            }
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
    }
    setTouchState(touches) {
        this.m_touchState.touches = [];
        // TouchList doesn't conform to iterator interface so we cannot use 'for of'
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < touches.length; ++i) {
            const touchState = this.convertTouchPoint(touches[i]);
            if (touchState) {
                this.m_touchState.touches.push(touchState);
            }
        }
        if (this.m_touchState.touches.length !== 0) {
            this.updateTouchState();
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
    }
    updateTouchState() {
        this.m_touchState.currentRotation = this.calculateAngleFromTouchPointsInWorldspace();
    }
    updateTouches(touches) {
        const length = Math.min(touches.length, this.m_touchState.touches.length);
        for (let i = 0; i < length; ++i) {
            const oldTouchState = this.m_touchState.touches[i];
            const newTouchState = this.convertTouchPoint(touches[i], oldTouchState);
            if (newTouchState !== null) {
                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;
                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;
                this.m_touchState.touches[i] = newTouchState;
            }
        }
    }
    zoomOnDoubleClickOrTap(x, y) {
        if (this.zoomLevelDeltaOnDoubleClick === 0) {
            return;
        }
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const ndcCoords = utils.calculateNormalizedDeviceCoordinates(x, y, width, height);
        this.setZoomLevel(this.currentZoom + this.zoomLevelDeltaOnDoubleClick, ndcCoords);
    }
    touchStart(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_tapStartTime = performance.now();
        this.m_fingerMoved = false;
        this.m_state = State.TOUCH;
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.setTouchState(event.touches);
        this.updateTouches(event.touches);
        event.preventDefault();
        event.stopPropagation();
    }
    touchMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_fingerMoved = true;
        this.updateTouches(event.touches);
        this.updateTouchState();
        if (this.m_touchState.touches.length <= 2) {
            this.panFromTo(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[0].currentWorldPosition);
        }
        if (this.m_touchState.touches.length === 2) {
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                const deltaRotation = this.m_touchState.currentRotation - this.m_touchState.initialRotation;
                this.rotate(geoUtils.MathUtils.radToDeg(deltaRotation));
                const pinchDistance = this.calculatePinchDistanceInWorldSpace();
                this.moveAlongTheViewDirection(pinchDistance);
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                // TODO: HARP-6597: Implement yaw rotation for globe, use `moveAlongViewDirection`
                // in both Planar and Spherical.
                const pinchDistance = this.calculatePinchDistanceInWorldSpace();
                this.setZoomLevel(this.currentZoom + pinchDistance * 0.01);
            }
        }
        // Tilting
        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                const firstTouch = this.m_touchState.touches[0];
                const diff = this.m_tmpVector2.subVectors(firstTouch.currentTouchPoint, firstTouch.lastTouchPoint);
                this.orbitFocusPoint(this.orbitingTouchDeltaFactor * diff.x, -this.orbitingTouchDeltaFactor * diff.y);
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                // TODO: HARP-6023: Support tilting in globe.
            }
        }
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    touchEnd(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_state = State.NONE;
        this.handleDoubleTap();
        this.setTouchState(event.touches);
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    handleDoubleTap() {
        // Continue only if no touchmove happened.
        if (this.m_fingerMoved) {
            return;
        }
        const now = performance.now();
        const tapDuration = now - this.m_tapStartTime;
        // Continue only if proper tap.
        if (tapDuration > MAX_TAP_DURATION) {
            return;
        }
        // Continue only if this is the second valid tap.
        if (!this.m_isDoubleTap) {
            this.m_isDoubleTap = true;
            this.m_lastSingleTapTime = now;
            return;
        }
        // Continue only if the delay between the two taps is short enough.
        if (now - this.m_lastSingleTapTime > this.doubleTapTime * 1000) {
            // If too long, restart double tap validator too.
            this.m_isDoubleTap = false;
            return;
        }
        this.zoomOnDoubleClickOrTap(this.m_touchState.touches[0].currentTouchPoint.x, this.m_touchState.touches[0].currentTouchPoint.y);
        // Prevent a string of X valid taps and only consider pairs.
        this.m_isDoubleTap = false;
    }
    contextMenu(event) {
        event.preventDefault();
    }
    getWorldPositionWithElevation(fromX, fromY, toX, toY) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);
        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);
        let toWorld;
        let fromWorld;
        let elevationProviderResult;
        if (this.mapView.elevationProvider !== undefined) {
            elevationProviderResult = this.mapView.elevationProvider.rayCast(fromX, fromY);
        }
        if (elevationProviderResult === undefined) {
            fromWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
        }
        else {
            fromWorld = elevationProviderResult;
            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);
            // We can ensure that points under the mouse stay there by projecting the to point onto
            // a plane with the altitude based on the initial point.
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y, fromGeoAltitude);
        }
        if (fromWorld === null || toWorld === null) {
            return;
        }
        return { fromWorld, toWorld };
    }
    panFromTo(fromWorld, toWorld) {
        // Cancel zoom inertia if a panning is triggered, so that the mouse location is kept.
        this.stopZoom();
        // Assign the new animation start time.
        this.m_panAnimationStartTime = performance.now();
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            this.m_panDistanceFrameDelta.subVectors(fromWorld, toWorld);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            this.m_lastRotateGlobeFromVector.copy(fromWorld);
            this.m_lastRotateGlobeAxis.crossVectors(fromWorld, toWorld).normalize();
            this.m_lastRotateGlobeAngle = fromWorld.angleTo(toWorld);
            // When fromWorld and toWorld are too close, there is a risk of getting an NaN
            // value. The following ensures that the controls don't break.
            if (isNaN(this.m_lastRotateGlobeAngle)) {
                this.m_lastRotateGlobeAngle = 0;
            }
        }
        this.handlePan();
    }
    constrainPitchAngle(pitchAngle, deltaPitch) {
        const tmpPitchAngle = geoUtils.MathUtils.clamp(pitchAngle + deltaPitch, this.m_minPitchAngle, this.m_maxPitchAngle);
        if (this.tiltEnabled &&
            tmpPitchAngle <= this.m_maxPitchAngle &&
            tmpPitchAngle >= this.m_minPitchAngle) {
            pitchAngle = tmpPitchAngle;
        }
        return pitchAngle;
    }
    /**
     * This method approximates the minimum delta altitude by attempts. It has been preferred over a
     * solution where the minimum delta is calculated adding the new delta to the current delta,
     * because that solution would not have worked with terrains.
     */
    getMinDelta(deltaAltitude) {
        // Do not even start to calculate a delta if the camera is already under the minimum height.
        if (this.mapView.camera.position.z < this.minCameraHeight && deltaAltitude > 0) {
            return 0;
        }
        const checkMinCamHeight = (deltaAlt, camera) => {
            const cameraPos = camera.position;
            const cameraQuat = camera.quaternion;
            const newPitchQuaternion = new THREE.Quaternion();
            const viewDirection = new THREE.Vector3();
            const mockCamera = new THREE.Object3D();
            mockCamera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
            mockCamera.quaternion.set(cameraQuat.x, cameraQuat.y, cameraQuat.z, cameraQuat.w);
            // save the current direction of the camera in viewDirection
            mockCamera.getWorldDirection(viewDirection);
            //calculate the new azimuth and altitude
            const currentAzimuthAltitude = utils.directionToAzimuthAltitude(viewDirection);
            const topElevation = (1.0 / Math.sin(currentAzimuthAltitude.altitude)) * mockCamera.position.z;
            // get the current quaternion from the camera
            const yawPitchRoll = harp_mapview_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion, this.mapView.projection.type);
            //calculate the pitch
            const deltaPitchRadians = geoUtils.MathUtils.degToRad(deltaAlt);
            const pitchAngle = this.constrainPitchAngle(yawPitchRoll.pitch, deltaPitchRadians);
            newPitchQuaternion.setFromAxisAngle(pitchAxis, pitchAngle);
            // update the camera and the viewDirection vector
            mockCamera.quaternion.copy(newPitchQuaternion);
            mockCamera.matrixWorldNeedsUpdate = true;
            mockCamera.getWorldDirection(viewDirection);
            // use the viewDirection to get the height
            const newAzimuthAltitude = utils.directionToAzimuthAltitude(viewDirection);
            const newElevation = Math.sin(newAzimuthAltitude.altitude) * topElevation;
            return newElevation;
        };
        let constrainedDeltaAltitude = deltaAltitude;
        for (let i = 0; i < MAX_DELTA_ALTITUDE_STEPS; i++) {
            const cameraHeight = checkMinCamHeight(constrainedDeltaAltitude, this.mapView.camera);
            if (cameraHeight < this.minCameraHeight) {
                constrainedDeltaAltitude *= 0.5;
            }
            else {
                return constrainedDeltaAltitude;
            }
        }
        return constrainedDeltaAltitude;
    }
}
exports.MapControls = MapControls;


/***/ }),

/***/ "../harp-map-controls/lib/MapControlsUI.ts":
/*!*************************************************!*\
  !*** ../harp-map-controls/lib/MapControlsUI.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
/**
 * Base class to handle UI overlay elements.
 */
class MapControlsUI {
    /**
     * Constructor of the UI.
     *
     * @param controls Controls referencing a [[MapView]].
     */
    constructor(controls, options = {}) {
        this.controls = controls;
        /**
         * The DOM node containing the UI.
         */
        this.domElement = document.createElement("div");
        /**
         * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.
         */
        this.m_zoomLevelElement = null;
        this.m_onMapViewRenderEvent = () => {
            if (this.m_zoomLevelElement === null) {
                return;
            }
            const zoom = this.controls.zoomLevelTargeted.toFixed(1);
            if (this.m_zoomLevelElement.tagName === "INPUT") {
                this.m_zoomLevelElement.value = zoom;
            }
            else {
                this.m_zoomLevelElement.innerHTML = zoom;
            }
        };
        this.m_onWindowClick = (event) => {
            const input = this.m_zoomLevelElement;
            if (!event ||
                !event.target ||
                !event.target.contains ||
                (event.target === input || event.target.contains(input))) {
                return;
            }
            input.blur();
        };
        const zoomInButton = document.createElement("button");
        zoomInButton.innerText = "+";
        const zoomOutButton = document.createElement("button");
        zoomOutButton.innerText = "-";
        const tiltButton = document.createElement("button");
        tiltButton.innerText = "3D";
        tiltButton.id = "tiltButtonUi";
        // Optional zoom level displaying
        if (options.zoomLevel === "show") {
            const div = document.createElement("div");
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            this.m_zoomLevelElement = div;
        }
        else if (options.zoomLevel === "input") {
            const input = document.createElement("input");
            input.type = "number";
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            const updateZoom = (event) => {
                controls.setZoomLevel(parseFloat(input.value));
                event.preventDefault();
            };
            input.addEventListener("blur", updateZoom);
            input.addEventListener("keypress", event => {
                if (event.key === "Enter") {
                    updateZoom(event);
                }
            });
            window.addEventListener("click", this.m_onWindowClick);
            this.m_zoomLevelElement = input;
        }
        this.domElement.appendChild(zoomInButton);
        this.domElement.appendChild(tiltButton);
        if (this.m_zoomLevelElement !== null) {
            this.domElement.appendChild(this.m_zoomLevelElement);
        }
        this.domElement.appendChild(zoomOutButton);
        zoomInButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomOutButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        tiltButton.addEventListener("click", event => {
            controls.toggleTilt();
        });
        this.domElement.className = "harp-gl_controls";
        zoomInButton.className = zoomOutButton.className = tiltButton.className =
            "harp-gl_controls-button";
        if (this.m_zoomLevelElement !== null) {
            this.m_zoomLevelElement.className = "harp-gl_controls-zoom";
        }
        if (options.disableDefaultStyle !== true) {
            this.initStyle();
            this.domElement.style.cssText =
                "position: absolute; right: 10px; top: 50%; margin-top: -70px;";
        }
        return this;
    }
    /**
     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method
     * should be called when you stop using [[MapControlsUI]].
     */
    dispose() {
        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === "INPUT") {
            window.removeEventListener("click", this.m_onWindowClick);
        }
        this.controls.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        this.domElement.remove();
    }
    initStyle() {
        if (document.getElementById("here-harp-controls.map-controls-ui-styles") !== null) {
            return;
        }
        const style = document.createElement("style");
        style.id = "here-harp-controls.map-controls-ui-styles";
        style.appendChild(document.createTextNode(`
            .harp-gl_controls-button {
                display: block;
                background-color: #272d37;
                width: 40px;
                height: 40px;
                font-size: 22px;
                font-weight: bold;
                outline: none;
                margin: 5px;
                border: none;
                color: rgba(255, 255, 255, 0.8);
                cursor: pointer;
                border-radius: 4px;
                box-shadow: 0 1px 4px 0  rgba(15, 22, 33, 0.4);
                transition: all 0.1s;
                padding: 0 0 1px 1px;
                user-select: none;
            }
            #tiltButtonUi {
               font-size: 16px;
            }
            .harp-gl_controls-button:active {
                background-color: #37afaa;
                color: #eee;
            }
            .harp-gl_controls-zoom {
                display: block;
                background-color: #fff;
                width: 40px;
                height: 20px;
                font-size: 12px;
                font-weight: bold;
                outline: none;
                margin: 5px;
                border: none;
                color: #555;
                opacity: 0.87;
                border-radius: 4px;
                box-shadow: 0px 0px 4px #aaa;
                padding: 2px 0 0;
                text-align: center;
                user-select: text;
            }
            input.harp-gl_controls-zoom::-webkit-outer-spin-button,
            input.harp-gl_controls-zoom::-webkit-inner-spin-button {
                /* display: none; <- Crashes Chrome on hover */
                -webkit-appearance: none;
                margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
            }
            input.harp-gl_controls-zoom[type=number] {
                -moz-appearance:textfield; /* Firefox */
            }`));
        document.head.appendChild(style);
    }
}
exports.MapControlsUI = MapControlsUI;


/***/ }),

/***/ "../harp-map-controls/lib/Utils.ts":
/*!*****************************************!*\
  !*** ../harp-map-controls/lib/Utils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
/**
 * Transforms the given point in screen space into NDC space by taking the given screen dimension
 * into account.
 *
 * @param screenCoordinateX X coordinate in screen space.
 * @param screenCoordinateY Y coordinate in screen space.
 * @param screenSizeX Width of the reference screen size.
 * @param screenSizeY Height of the reference screen size.
 */
function calculateNormalizedDeviceCoordinates(screenCoordinateX, screenCoordinateY, screenSizeX, screenSizeY) {
    return new three_1.Vector2((screenCoordinateX / screenSizeX) * 2 - 1, -((screenCoordinateY / screenSizeY) * 2) + 1);
}
exports.calculateNormalizedDeviceCoordinates = calculateNormalizedDeviceCoordinates;
/**
 * Returns the azimuth and altitude in radians for the given direction vector.
 *
 * @param direction The direction vector. Does not have to be normalized.
 */
function directionToAzimuthAltitude(direction) {
    const normalizedDirection = direction.clone().normalize();
    //Shamelessly copied from Jan ;)
    const xy = new three_1.Vector2(normalizedDirection.x, normalizedDirection.y);
    const nxz = new three_1.Vector2(xy.length(), normalizedDirection.z).normalize();
    const azimuth = Math.atan2(xy.x, xy.y);
    const altitude = -Math.asin(nxz.y);
    return { azimuth, altitude };
}
exports.directionToAzimuthAltitude = directionToAzimuthAltitude;
/**
 * Returns the direction vector that is described by the given azimuth and altitude.
 *
 * @param azimuth Azimuth in radians.
 * @param altitude Altitude in radians.
 */
function azimuthAltitudeToDirection(azimuth, altitude) {
    azimuth = azimuth;
    altitude = altitude;
    //Shamelessly copied from Jan ;)
    const result = new three_1.Vector3();
    const cosAltitude = Math.cos(altitude);
    result.setX(Math.sin(azimuth) * cosAltitude);
    result.setY(Math.cos(azimuth) * cosAltitude);
    result.setZ(Math.sin(altitude));
    return result;
}
exports.azimuthAltitudeToDirection = azimuthAltitudeToDirection;
/**
 * Safely parses decimal value into `number`.
 *
 * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings
 * with characters other than digits.
 *
 * @param text Number as a text to be parsed.
 * @param fallback Default value, which is returned if `text` doesn't represent a valid number.
 */
function safeParseDecimalInt(text, fallback) {
    if (text === null || text === undefined || text === "") {
        return fallback;
    }
    if (!text.match(integerRe)) {
        return fallback;
    }
    const result = Number.parseInt(text, 10);
    if (isNaN(result)) {
        return fallback;
    }
    return result;
}
exports.safeParseDecimalInt = safeParseDecimalInt;
const integerRe = /^\d+$/;
/**
 * Extracts the CSS width and height of the given canvas if available, or width and height of the
 * canvas otherwise.
 *
 * @param canvas The canvas.
 */
function getWidthAndHeightFromCanvas(canvas) {
    return {
        //use clientWidth and clientHeight to support HiDPI devices
        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),
        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)
    };
}
exports.getWidthAndHeightFromCanvas = getWidthAndHeightFromCanvas;


/***/ }),

/***/ "../harp-mapview-decoder/index.ts":
/*!****************************************!*\
  !*** ../harp-mapview-decoder/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/TileDataSource */ "../harp-mapview-decoder/lib/TileDataSource.ts"));
__export(__webpack_require__(/*! ./lib/TileLoader */ "../harp-mapview-decoder/lib/TileLoader.ts"));


/***/ }),

/***/ "../harp-mapview-decoder/lib/TileDataSource.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview-decoder/lib/TileDataSource.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const TileLoader_1 = __webpack_require__(/*! ./TileLoader */ "../harp-mapview-decoder/lib/TileLoader.ts");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource [[Datasource]] this class belongs to.
     * @param tileKey Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        return new this.m_modelConstructor(dataSource, tileKey);
    }
}
exports.TileFactory = TileFactory;
const maxLevelTileLoaderCache = 3;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory Factory to create the [[Tile]] instances.
     * @param m_options Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        super(m_options.name, m_options.styleSetName, m_options.minZoomLevel, m_options.maxZoomLevel, m_options.storageLevelOffset);
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.m_decoder.configure(undefined, undefined, {
            storageLevelOffset: this.m_options.storageLevelOffset
        });
        this.useGeometryLoader = true;
        this.cacheable = true;
        this.m_tileLoaderCache = new harp_lrucache_1.LRUCache(this.getCacheCount());
    }
    dispose() {
        this.decoder.dispose();
    }
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);
            this.m_isReady = true;
        });
    }
    setStyleSet(styleSet, languages) {
        this.m_tileLoaderCache.clear();
        this.m_decoder.configure(styleSet, languages);
        this.mapView.markTilesDirty(this);
    }
    clearCache() {
        this.m_tileLoaderCache.clear();
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately.
     *
     * @param tileKey Quadtree address of the requested tile.
     */
    getTile(tileKey) {
        const tile = this.m_tileFactory.create(this, tileKey);
        const mortonCode = tileKey.mortonCode();
        const tileLoader = this.m_tileLoaderCache.get(mortonCode);
        if (tileLoader !== undefined) {
            tile.tileLoader = tileLoader;
        }
        else {
            const newTileLoader = new TileLoader_1.TileLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
            tile.tileLoader = newTileLoader;
            tile.copyrightInfo = this.m_options.copyrightInfo;
            // We don't cache tiles with level 4 and above, at this level, there are 16 (2^4) tiles
            // horizontally, given the assumption that the zoom level assumes the tile should be 256
            // pixels wide (see function [[calculateZoomLevelFromDistance]]), and the current
            // storage offset of -2 (which makes the tiles then 1024 pixels wide). this would mean a
            // horizontal width of ~16k pixels for the entire earth, this would be quite a lot to
            // pan, hence caching doesn't make sense above this point (as the chance that we need to
            // share the TileLoader is small, and even if we did eventually see it, the original
            // TileLoader would probably be evicted because it was removed by other more recent
            // tiles).
            if (tileKey.level <= maxLevelTileLoaderCache) {
                this.m_tileLoaderCache.set(mortonCode, newTileLoader);
            }
        }
        if (tile.tileLoader.decodedTile !== undefined) {
            tile.decodedTile = tile.tileLoader.decodedTile;
        }
        else {
            tile.load();
        }
        return tile;
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
    getCacheCount() {
        // We support up to [[maxLevelTileLoaderCache]] levels, this equates to roughly
        // 2^maxLevelTileLoaderCache^2 tiles in total (at level maxLevelTileLoaderCache), we don't
        // generally see that many, so we add a factor of 2 to try to get the worst case.
        return Math.pow(2, maxLevelTileLoaderCache) * 2;
    }
}
exports.TileDataSource = TileDataSource;


/***/ }),

/***/ "../harp-mapview-decoder/lib/TileLoader.ts":
/*!*************************************************!*\
  !*** ../harp-mapview-decoder/lib/TileLoader.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileLoader");
/**
 * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by
 * the [[TileDataSource]].
 *
 * A TileLoader supports loading for multiple tiles, this is required for the wrap around, where
 * it is possible to see the same tile multiple times.
 */
class TileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource The [[DataSource]] the tile belongs to.
     * @param tileKey The quadtree address of a [[Tile]].
     * @param dataProvider The [[DataProvider]] that retrieves the binary tile data.
     * @param tileDecoder The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].
     * @param priority The priority given to the loading job. Highest number will be served first.
     */
    constructor(dataSource, tileKey, dataProvider, tileDecoder, priority) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.dataProvider = dataProvider;
        this.tileDecoder = tileDecoder;
        this.priority = priority;
        /**
         * Current state of `TileLoader`.
         */
        this.state = harp_mapview_1.TileLoaderState.Initialized;
        /**
         * The abort controller notifying the [[DataProvider]] to cancel loading.
         */
        this.loadAbortController = new AbortController();
        /**
         * This is a form of reference counting for the result. We keep a track of this because when
         * cancelling, it is important to know if we can actually cancel, or if there is another Tile
         * that needs the result.
         */
        this.countRequests = 0;
    }
    /**
     * Start loading and/or proceed through the various states of loading of this tile.
     *
     * @returns A promise which resolves the [[TileLoaderState]].
     */
    loadAndDecode() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
                this.countRequests++;
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Ready:
            case harp_mapview_1.TileLoaderState.Failed:
            case harp_mapview_1.TileLoaderState.Initialized:
            case harp_mapview_1.TileLoaderState.Canceled:
                this.countRequests++;
                this.ensureLoadingStarted();
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Loaded:
                this.countRequests++;
                this.startDecodeTile();
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Decoding:
                this.cancelDecoding();
                this.ensureLoadingStarted();
                return this.donePromise;
        }
    }
    /**
     * Return the current state in form of a promise. Caller can then wait for the promise to be
     * resolved.
     *
     * @returns A promise which resolves the current [[TileLoaderState]].
     */
    waitSettled() {
        if (!this.donePromise) {
            return Promise.resolve(this.state);
        }
        return this.donePromise;
    }
    /**
     * Cancel loading of the [[Tile]] if there is only a single request remaining. Cancellation
     * token is notified, an internal state is cleaned up.
     *
     * Otherwise this just reduces the count of requests by one.
     */
    cancel() {
        if (--this.countRequests !== 0) {
            return;
        }
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
                this.loadAbortController.abort();
                this.loadAbortController = new AbortController();
                break;
            case harp_mapview_1.TileLoaderState.Decoding:
                if (this.requestController) {
                    this.requestController.abort();
                    this.requestController = undefined;
                }
                break;
        }
        this.onDone(harp_mapview_1.TileLoaderState.Canceled);
    }
    /**
     * Return `true` if [[Tile]] is still loading, `false` otherwise.
     */
    get isFinished() {
        return (this.state === harp_mapview_1.TileLoaderState.Ready ||
            this.state === harp_mapview_1.TileLoaderState.Canceled ||
            this.state === harp_mapview_1.TileLoaderState.Failed);
    }
    /**
     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests
     * in the request queue (used during heavy load).
     */
    updatePriority(priority) {
        this.priority = priority;
        if (this.requestController !== undefined) {
            this.requestController.priority = priority;
        }
    }
    /**
     * Depending on state: if not loaded yet, make sure it is loading.
     */
    ensureLoadingStarted() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Ready:
            case harp_mapview_1.TileLoaderState.Initialized:
            case harp_mapview_1.TileLoaderState.Canceled:
                this.doStartLoad();
                return;
            case harp_mapview_1.TileLoaderState.Loading:
            case harp_mapview_1.TileLoaderState.Loaded:
                // we may reuse already started loading promise
                logger.info("reusing already started load operation");
                return;
            case harp_mapview_1.TileLoaderState.Decoding:
                this.cancelDecoding();
                this.doStartLoad();
                return;
        }
    }
    /**
     * Start loading. Only call if loading did not start yet.
     */
    doStartLoad() {
        const myLoadCancellationToken = this.loadAbortController.signal;
        this.dataProvider
            .getTile(this.tileKey, myLoadCancellationToken)
            .then(payload => {
            if (myLoadCancellationToken.aborted) {
                // safety belt if getTile doesn't really support cancellation tokens
                const err = new Error("Aborted");
                err.name = "AbortError";
                throw err;
            }
            this.onLoaded(payload);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                return;
            }
            this.onError(error);
        });
        if (this.donePromise === undefined) {
            this.donePromise = new Promise((resolve, reject) => {
                this.resolveDonePromise = resolve;
                this.rejectedDonePromise = reject;
            });
        }
        this.state = harp_mapview_1.TileLoaderState.Loading;
    }
    /**
     * Called when binary data has been loaded. The loading state is now progressing to decoding.
     *
     * @param payload Binary data in form of [[ArrayBufferLike]], or any object.
     */
    onLoaded(payload) {
        this.state = harp_mapview_1.TileLoaderState.Loaded;
        this.payload = payload;
        if (payload.byteLength !== undefined) {
            if (payload.byteLength === 0) {
                this.onDone(harp_mapview_1.TileLoaderState.Ready);
                return;
            }
        }
        // Object is empty
        if (payload === {}) {
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
            return;
        }
        // TBD: we might suspend decode if tile is not visible ... ?
        this.startDecodeTile();
    }
    /**
     * Start decoding the payload.
     */
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)
            .then(decodedTile => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.onDecoded(decodedTile);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
    /**
     * Called when the decoding is finished, and the [[DecodedTile]] has been created.
     *
     * @param decodedTile The [[DecodedTile]].
     */
    onDecoded(decodedTile) {
        this.decodedTile = decodedTile;
        this.onDone(harp_mapview_1.TileLoaderState.Ready);
    }
    /**
     * Cancel the decoding process.
     */
    cancelDecoding() {
        if (this.requestController !== undefined) {
            // we should cancel any decodes already in progress!
            this.requestController.abort();
            this.requestController = undefined;
        }
    }
    /**
     * Called when loading and decoding has finished successfully. Resolves loading promise if the
     * state is Ready, otherwise it rejects the promise with the supplied state.
     *
     * @param doneState The latest state of loading.
     */
    onDone(doneState) {
        if (this.resolveDonePromise && doneState === harp_mapview_1.TileLoaderState.Ready) {
            this.resolveDonePromise(doneState);
        }
        else if (this.rejectedDonePromise) {
            this.rejectedDonePromise(doneState);
        }
        this.resolveDonePromise = undefined;
        this.rejectedDonePromise = undefined;
        this.donePromise = undefined;
        this.state = doneState;
    }
    /**
     * Called when loading or decoding has finished with an error.
     *
     * @param error Error object describing the failing.
     */
    onError(error) {
        if (this.state === harp_mapview_1.TileLoaderState.Canceled) {
            // If we're canceled, we should simply ignore any state transitions and errors from
            // underlying load/decode ops.
            return;
        }
        const dataSource = this.dataSource;
        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);
        this.error = error;
        this.onDone(harp_mapview_1.TileLoaderState.Failed);
    }
}
exports.TileLoader = TileLoader;
/**
 * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta
 * data, not the tile data itself.
 */
class TileInfoLoader extends TileLoader {
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileInfoLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)
            .then(tileInfo => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.tileInfo = tileInfo;
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
}
exports.TileInfoLoader = TileInfoLoader;


/***/ }),

/***/ "../harp-mapview/index.ts":
/*!********************************!*\
  !*** ../harp-mapview/index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts"));
__export(__webpack_require__(/*! ./lib/CameraMovementDetector */ "../harp-mapview/lib/CameraMovementDetector.ts"));
__export(__webpack_require__(/*! ./lib/ColorCache */ "../harp-mapview/lib/ColorCache.ts"));
__export(__webpack_require__(/*! ./lib/composing */ "../harp-mapview/lib/composing/index.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "../harp-mapview/lib/ConcurrentTilerFacade.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "../harp-mapview/lib/ConcurrentTilerFacade.ts"));
__export(__webpack_require__(/*! ./lib/CopyrightElementHandler */ "../harp-mapview/lib/CopyrightElementHandler.ts"));
__export(__webpack_require__(/*! ./lib/CopyrightInfo */ "../harp-mapview/lib/CopyrightInfo.ts"));
__export(__webpack_require__(/*! ./lib/DataSource */ "../harp-mapview/lib/DataSource.ts"));
__export(__webpack_require__(/*! ./lib/DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts"));
__export(__webpack_require__(/*! ./lib/DepthPrePass */ "../harp-mapview/lib/DepthPrePass.ts"));
__export(__webpack_require__(/*! ./lib/ElevationRangeSource */ "../harp-mapview/lib/ElevationRangeSource.ts"));
__export(__webpack_require__(/*! ./lib/image/Image */ "../harp-mapview/lib/image/Image.ts"));
__export(__webpack_require__(/*! ./lib/image/ImageCache */ "../harp-mapview/lib/image/ImageCache.ts"));
__export(__webpack_require__(/*! ./lib/image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts"));
__export(__webpack_require__(/*! ./lib/MapView */ "../harp-mapview/lib/MapView.ts"));
__export(__webpack_require__(/*! ./lib/MapViewFog */ "../harp-mapview/lib/MapViewFog.ts"));
__export(__webpack_require__(/*! ./lib/MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts"));
__export(__webpack_require__(/*! ./lib/PickHandler */ "../harp-mapview/lib/PickHandler.ts"));
__export(__webpack_require__(/*! ./lib/poi/Poi */ "../harp-mapview/lib/poi/Poi.ts"));
__export(__webpack_require__(/*! ./lib/poi/PoiManager */ "../harp-mapview/lib/poi/PoiManager.ts"));
__export(__webpack_require__(/*! ./lib/poi/PoiTableManager */ "../harp-mapview/lib/poi/PoiTableManager.ts"));
__export(__webpack_require__(/*! ./lib/RoadPicker */ "../harp-mapview/lib/RoadPicker.ts"));
__export(__webpack_require__(/*! ./lib/Statistics */ "../harp-mapview/lib/Statistics.ts"));
__export(__webpack_require__(/*! ./lib/text/TextElement */ "../harp-mapview/lib/text/TextElement.ts"));
__export(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts"));
__export(__webpack_require__(/*! ./lib/text/TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts"));
__export(__webpack_require__(/*! ./lib/ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts"));
__export(__webpack_require__(/*! ./lib/Tile */ "../harp-mapview/lib/Tile.ts"));
__export(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ "../harp-mapview/lib/geometry/TileDataAccessor.ts"));
__export(__webpack_require__(/*! ./lib/geometry/TileGeometry */ "../harp-mapview/lib/geometry/TileGeometry.ts"));
__export(__webpack_require__(/*! ./lib/Utils */ "../harp-mapview/lib/Utils.ts"));
__export(__webpack_require__(/*! ./lib/VisibleTileSet */ "../harp-mapview/lib/VisibleTileSet.ts"));
__export(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ "../harp-mapview/lib/WorkerBasedDecoder.ts"));
__export(__webpack_require__(/*! ./lib/WorkerBasedTiler */ "../harp-mapview/lib/WorkerBasedTiler.ts"));
__export(__webpack_require__(/*! ./lib/workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts"));


/***/ }),

/***/ "../harp-mapview/lib/AnimatedExtrusionHandler.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/AnimatedExtrusionHandler.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const MapView_1 = __webpack_require__(/*! ./MapView */ "../harp-mapview/lib/MapView.ts");
/**
 * Animation states for extrusion effect
 */
var AnimatedExtrusionState;
(function (AnimatedExtrusionState) {
    AnimatedExtrusionState[AnimatedExtrusionState["None"] = 0] = "None";
    AnimatedExtrusionState[AnimatedExtrusionState["Started"] = 1] = "Started";
    AnimatedExtrusionState[AnimatedExtrusionState["Playing"] = 2] = "Playing";
    AnimatedExtrusionState[AnimatedExtrusionState["Finished"] = 3] = "Finished";
})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));
/**
 * Handles animated extrusion effect of the buildings in [[MapView]].
 */
class AnimatedExtrusionHandler {
    /**
     * Creates an [[AnimatedExtrusionHandler]] in [[MapView]].
     *
     * @param m_mapView Instance of [[MapView]] that passes `zoomLevel`
     * through the `zoom` property update
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
        /**
         * Animate the extrusion of the buildings if set to `true`.
         */
        this.enabled = true;
        /**
         * Duration of the building's extrusion in milliseconds
         */
        this.duration = 750;
        /**
         * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`
         * values from [[extrudedPolygonTechnique]] will be ignored in [[Tile]] and
         * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used
         */
        this.forceEnabled = false;
        this.m_tileHandlerMap = new Map();
        this.m_zoomDirection = 0;
        this.m_zoomLevelPrevious = this.m_mapView.zoomLevel;
    }
    /**
     * Returns direction of the last zoom event.
     * Zoom in - positive value, zoom out - negative value
     */
    get zoomDirection() {
        return this.m_zoomDirection;
    }
    /**
     * [[MapView]] updates zoom level. Then [[AnimatedExtrusionTileHandler]] calculates actual
     * extrusion ratio and trigger animation
     */
    set zoom(zoomLevel) {
        // if zoomLevel has been changed since last render
        if (this.m_zoomLevelPrevious !== zoomLevel) {
            this.m_tileHandlerMap.forEach(tileHandler => {
                if (this.m_mapView.getDataSourceByName(tileHandler.tile.dataSource.name) !==
                    undefined) {
                    this.m_zoomDirection = zoomLevel > this.m_zoomLevelPrevious ? 1 : -1;
                    tileHandler.zoomLevelChanged(this.m_zoomDirection);
                }
            });
            this.m_zoomLevelPrevious = zoomLevel;
        }
    }
    /**
     * Checks whether animated extrusion effect was forcibly turned off/on in [[MapView]]
     */
    get forceAnimatedExtrusion() {
        return this.m_forceAnimatedExtrusion;
    }
    /**
     * If set to `true` it will force the animation extrusion effect to run.
     * In case it was set to `false` animation extrusion effect will be switched off.
     */
    set forceAnimatedExtrusion(animatedExtrusion) {
        this.m_forceAnimatedExtrusion = animatedExtrusion;
    }
    /**
     * Returns `animatedExtrusionDuration` value that was set in [[MapView]].
     */
    get forceAnimatedExtrusionDuration() {
        return this.m_forceAnimatedExtrusionDuration;
    }
    /**
     * If value is set, it will overlap in [[Tile]] with
     * `animatedExtrusionDuration` property from [[ExtrudedPolygonTechnique]]
     * and `DEFAULT_DURATION` from [[AnimatedExtrusionTileHandler]].
     */
    set forceAnimatedExtrusionDuration(extrusionDuration) {
        this.m_forceAnimatedExtrusionDuration = extrusionDuration;
    }
    /**
     * Adds an [[AnimatedExtrusionTileHandler]] to [[AnimatedExtrusionHandler]]
     */
    add(tileHandler) {
        this.m_tileHandlerMap.set(tileHandler.tile, tileHandler);
    }
    /**
     * Removes tile from the list subscribed for extrusion ratio updates
     */
    removeTile(tile) {
        this.m_tileHandlerMap.delete(tile);
    }
    /**
     * Returns first [[AnimatedExtrusionTileHandler]] existed from the list of [[Tile]]s
     */
    find(tileKeys) {
        for (const tileHandler of this.m_tileHandlerMap) {
            for (const tileKey of tileKeys) {
                if (tileKey !== undefined &&
                    tileHandler[0].tileKey.mortonCode() === tileKey.mortonCode()) {
                    return tileHandler[1];
                }
            }
        }
        return undefined;
    }
    /**
     * Is `true` if any extrusion handlers are currently animating.
     */
    get isAnimating() {
        for (const tileHandler of this.m_tileHandlerMap) {
            if (tileHandler[1].isAnimating) {
                return true;
            }
        }
        return false;
    }
}
exports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;
/**
 * Implements animated extrusion effect for the extruded objects in the [[Tile]]
 */
class AnimatedExtrusionTileHandler {
    constructor(m_tile, extrudedObjects, m_animatedExtrusionDuration) {
        this.m_tile = m_tile;
        this.m_animatedExtrusionDuration = m_animatedExtrusionDuration;
        this.m_extrudedObjects = [];
        this.m_animatedExtrusionRatio = AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
        this.m_animatedExtrusionState = AnimatedExtrusionState.None;
        this.m_animatedExtrusionStartTime = undefined;
        this.animateExtrusion = (event) => {
            if (this.m_animatedExtrusionState !== AnimatedExtrusionState.Playing) {
                if (this.m_animatedExtrusionState === AnimatedExtrusionState.Started) {
                    this.m_animatedExtrusionState = AnimatedExtrusionState.Playing;
                }
                else {
                    return;
                }
            }
            const currentTime = Date.now();
            if (this.m_animatedExtrusionStartTime === undefined ||
                this.m_animatedExtrusionStartTime <= 0) {
                this.m_animatedExtrusionStartTime = currentTime;
            }
            const timeProgress = Math.min(currentTime - this.m_animatedExtrusionStartTime, this.m_animatedExtrusionDuration);
            this.extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN, AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX, timeProgress / this.m_animatedExtrusionDuration);
            if (timeProgress >= this.m_animatedExtrusionDuration) {
                this.m_animatedExtrusionState = AnimatedExtrusionState.Finished;
                this.stopExtrusionAnimation();
            }
            this.m_tile.dataSource.requestUpdate();
        };
        this.m_mapView = m_tile.mapView;
        this.m_animatedExtrusionHandler = this.m_mapView.animatedExtrusionHandler;
        extrudedObjects.forEach(extrudedObject => {
            if (extrudedObject.materialFeature) {
                harp_materials_1.ExtrusionFeature.addRenderHelper(extrudedObject.object);
            }
            this.m_extrudedObjects.push(extrudedObject.object);
        });
        this.startExtrusionAnimationIfNeeded(this.m_animatedExtrusionHandler.zoomDirection);
    }
    /**
     * Set an extrusion ratio value for the materials [[MapMeshBasicMaterial]]
     * and [[EdgeMaterial]]. Controlled by [[AnimatedExtrusionHandler]]
     * for extrusion animation effect.
     */
    set extrusionRatio(value) {
        this.m_animatedExtrusionRatio = value;
        this.m_extrudedObjects.forEach(object => {
            const material = object
                .material;
            material.extrusionRatio = this.m_animatedExtrusionRatio;
        });
    }
    /**
     * Returns the [[Tile]] related to [[AnimatedExtrusionTileHandler]]
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * Return the current state of animated extrusion effect
     */
    get animationState() {
        return this.m_animatedExtrusionState;
    }
    /**
     * Is `true` if this handler is currently animating.
     */
    get isAnimating() {
        return this.m_animatedExtrusionState !== AnimatedExtrusionState.Finished;
    }
    /**
     * Cancel animation and remove from [[AnimatedExtrusionHandler]]
     */
    dispose() {
        this.stopExtrusionAnimation();
        this.m_animatedExtrusionHandler.removeTile(this.m_tile);
    }
    /**
     * Start / Stop extrusion animation if zoom level was changed
     */
    zoomLevelChanged(zoomDirection) {
        if (this.m_tile.isVisible === false &&
            this.m_animatedExtrusionState !== AnimatedExtrusionState.None) {
            this.m_animatedExtrusionState = AnimatedExtrusionState.None;
            this.stopExtrusionAnimation();
        }
        if (this.m_tile.isVisible === true &&
            this.m_animatedExtrusionState === AnimatedExtrusionState.None) {
            this.startExtrusionAnimationIfNeeded(zoomDirection);
        }
    }
    getChildTiles(tileKeys) {
        const result = [];
        tileKeys.forEach(tileKey => {
            const childTileKeys = this.tile.dataSource.getTilingScheme().getSubTileKeys(tileKey);
            for (const childTileKey of childTileKeys) {
                result.push(childTileKey);
            }
        });
        return result;
    }
    // search for the [[Tile]] with extrusion animation started
    startExtrusionAnimationIfNeeded(zoomDirection) {
        const { quadTreeSearchDistanceUp, quadTreeSearchDistanceDown } = this.tile.mapView.visibleTileSet.options;
        const tile = this.m_tile;
        let extrusionStartTime;
        if (zoomDirection !== undefined) {
            let tileHandler;
            // if zoom out, go down and look for a child tile
            if (zoomDirection < 0) {
                let nextLevelDiff = 0;
                let tileKeys = [tile.tileKey];
                while (quadTreeSearchDistanceDown > nextLevelDiff &&
                    extrusionStartTime === undefined) {
                    const childTileKeys = this.getChildTiles(tileKeys);
                    if (childTileKeys !== undefined) {
                        tileHandler = this.m_animatedExtrusionHandler.find(childTileKeys);
                        if (tileHandler !== undefined) {
                            extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;
                            break;
                        }
                        tileKeys = childTileKeys;
                    }
                    nextLevelDiff++;
                }
            }
            // if zoom in, go up and get the parent tile
            if (zoomDirection > 0) {
                let nextLevelDiff = 0;
                let tileKey = tile.tileKey;
                while (quadTreeSearchDistanceUp > nextLevelDiff &&
                    extrusionStartTime === undefined &&
                    tileKey.level !== 0) {
                    const parentTileKey = tileKey.parent();
                    tileHandler = this.m_animatedExtrusionHandler.find([parentTileKey]);
                    if (tileHandler !== undefined) {
                        extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;
                        break;
                    }
                    tileKey = parentTileKey;
                    nextLevelDiff++;
                }
            }
        }
        this.startExtrusionAnimation(extrusionStartTime);
    }
    startExtrusionAnimation(startTime) {
        this.m_animatedExtrusionState = AnimatedExtrusionState.Started;
        this.m_animatedExtrusionStartTime = startTime;
        this.animateExtrusion();
        this.m_mapView.addEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);
    }
    stopExtrusionAnimation() {
        this.m_mapView.removeEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);
    }
}
/**
 * Minimum ratio value for extrusion effect
 */
AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN = 0.001;
/**
 * Maximum ratio value for extrusion effect
 */
AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX = 1;
exports.AnimatedExtrusionTileHandler = AnimatedExtrusionTileHandler;


/***/ }),

/***/ "../harp-mapview/lib/BackgroundDataSource.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/BackgroundDataSource.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "../harp-mapview/lib/DataSource.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
/**
 * Provides background geometry for all tiles.
 */
class BackgroundDataSource extends DataSource_1.DataSource {
    constructor() {
        super("background");
        this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;
        this.cacheable = true;
    }
    updateStorageLevelOffset() {
        let storageLevelOffset;
        this.mapView.dataSources.forEach(ds => {
            if (ds === this) {
                return;
            }
            const tilingScheme = ds.getTilingScheme();
            if (tilingScheme === this.m_tilingScheme) {
                storageLevelOffset =
                    storageLevelOffset === undefined
                        ? ds.storageLevelOffset
                        : Math.max(storageLevelOffset, ds.storageLevelOffset);
            }
        });
        if (storageLevelOffset === undefined) {
            storageLevelOffset = 0;
        }
        if (storageLevelOffset !== this.storageLevelOffset) {
            this.storageLevelOffset = storageLevelOffset;
            this.mapView.clearTileCache(this.name);
        }
    }
    setTilingScheme(tilingScheme) {
        const newScheme = tilingScheme || BackgroundDataSource.DEFAULT_TILING_SCHEME;
        if (newScheme === this.m_tilingScheme) {
            return;
        }
        this.m_tilingScheme = newScheme;
        this.updateStorageLevelOffset();
        this.mapView.clearTileCache(this.name);
    }
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        tile.forceHasGeometry(true);
        tile.removeDecodedTile(); // Skip geometry loading.
        TileGeometryCreator_1.TileGeometryCreator.instance.addGroundPlane(tile);
        return tile;
    }
}
BackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;
exports.BackgroundDataSource = BackgroundDataSource;


/***/ }),

/***/ "../harp-mapview/lib/CameraMovementDetector.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/CameraMovementDetector.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * The default value for camera movement throttling, in milliseconds.
 */
const DEFAULT_THROTTLING_TIMEOUT = 300;
/**
 * The `CameraMovementDetector` class checks for changes in camera position and orientation, to
 * detect continuous movements without the animation mode activated in [[MapView]]. If the
 * interaction is not continuous enough, you can use a throttling timer to reduce the number of
 * callbacks.
 */
class CameraMovementDetector {
    /**
     * Initializes the detector with timeout value and callbacks. [[MapView]] also provides
     * events for client code to be notified when these cues occur.
     *
     * @param m_throttlingTimeout The delay, in milliseconds, between the last user interaction
     * detected and the call to `m_movementFinishedFunc`; the default is `300`.
     * @param m_movementStartedFunc Callback function, called when the user starts interacting.
     * @param m_movementFinishedFunc Callback function, called when the user stops interacting.
     */
    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
        this.m_throttlingTimeout = m_throttlingTimeout;
        this.m_movementStartedFunc = m_movementStartedFunc;
        this.m_movementFinishedFunc = m_movementFinishedFunc;
        this.m_lastCameraPos = new three_1.Vector3();
        this.m_newCameraPos = new three_1.Vector3();
        this.m_throttlingTimerId = undefined;
        this.m_movementDetectorDeadline = 0;
        this.onDeadlineTimer = () => {
            this.m_throttlingTimerId = undefined;
            const now = performance.now();
            if (now >= this.m_movementDetectorDeadline) {
                this.movementFinished();
            }
            else {
                this.startMovementFinishedTimer(now);
            }
        };
        if (this.m_throttlingTimeout === undefined) {
            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
        }
    }
    /**
     * Checks if the camera has moved since the last time it was checked. The
     * `m_movementStartedFunc` is called when a movement starts. If no movement
     * is detected, a timer for `m_movementFinishedFunc` starts.
     *
     * @param mapView [[Mapview]]'s position and camera are checked for modifications.
     */
    checkCameraMoved(mapView, now) {
        const newYawPitchRoll = Utils_1.MapViewUtils.extractYawPitchRoll(mapView.camera.quaternion, mapView.projection.type);
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        const cameraMoved = this.m_lastYawPitchRoll === undefined ||
            !this.m_lastCameraPos.equals(newCameraPos) ||
            newYawPitchRoll.yaw !== this.m_lastYawPitchRoll.yaw ||
            newYawPitchRoll.pitch !== this.m_lastYawPitchRoll.pitch ||
            newYawPitchRoll.roll !== this.m_lastYawPitchRoll.roll;
        if (cameraMoved) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastYawPitchRoll = newYawPitchRoll;
        }
        if (cameraMoved !== this.m_cameraMovedLastFrame) {
            if (cameraMoved) {
                this.movementStarted();
            }
            this.m_cameraMovedLastFrame = cameraMoved;
        }
        if (cameraMoved) {
            // Start timer
            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;
            this.startMovementFinishedTimer(now);
        }
        return this.m_cameraMovedLastFrame;
    }
    /**
     * Reset the saved camera position. Next time checkCameraMoved is called, it will return
     * `false`.
     */
    clear(mapView) {
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
        const newYawPitchRoll = Utils_1.MapViewUtils.extractYawPitchRoll(mapView.camera.quaternion, mapView.projection.type);
        this.m_lastYawPitchRoll = newYawPitchRoll;
    }
    /**
     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.
     */
    forceMoved() {
        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
    }
    /**
     * Returns `true` if the camera of this [[MapView]] is currently moving. In this case the
     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.
     */
    get cameraIsMoving() {
        return this.m_throttlingTimerId !== undefined;
    }
    /**
     * Disposes resources and kills the throttling timer.
     */
    dispose() {
        this.removeMovementFinishedTimer();
        this.m_movementStartedFunc = undefined;
        this.m_movementFinishedFunc = undefined;
    }
    /**
     * Returns `true` if the camera has moved in the last frame.
     */
    get cameraMovedLastFrame() {
        return this.m_cameraMovedLastFrame === true;
    }
    movementStarted() {
        if (this.m_movementStartedFunc !== undefined) {
            this.m_movementStartedFunc();
        }
    }
    movementFinished() {
        this.removeMovementFinishedTimer();
        if (this.m_movementFinishedFunc !== undefined) {
            this.m_movementFinishedFunc();
        }
    }
    startMovementFinishedTimer(now) {
        if (this.m_throttlingTimerId === undefined) {
            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);
            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
        }
    }
    removeMovementFinishedTimer() {
        if (this.m_throttlingTimerId !== undefined) {
            clearTimeout(this.m_throttlingTimerId);
            this.m_throttlingTimerId = undefined;
        }
    }
}
exports.CameraMovementDetector = CameraMovementDetector;


/***/ }),

/***/ "../harp-mapview/lib/ClipPlanesEvaluator.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/ClipPlanesEvaluator.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const epsilon = 0.000001;
/**
 * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.
 *
 * At general ground distance to camera along the surface normal is used as reference point for
 * planes evaluation, where near plane distance is set as fraction of this distance refered as
 * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],
 * which is applied to near plane and offset finally applied.
 * This evaluator supports both planar and spherical projections, although it's behaviour is
 * slightly different in each case. General algorithm sets near plane between camera and
 * ground level, while far plane is just calculated using scale and bias approach with far offset
 * and multiplier.
 * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which
 * is widelly used in examples.
 */
class InterpolatedClipPlanesEvaluator {
    constructor(nearMin = 0.1, nearMultiplier = 0.1, nearFarMultiplier = 50.0, farOffset = 200.0) {
        this.nearMin = nearMin;
        this.nearMultiplier = nearMultiplier;
        this.nearFarMultiplier = nearFarMultiplier;
        this.farOffset = farOffset;
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMultiplier >= 0);
        harp_utils_1.assert(farOffset >= 0);
        this.farMin = nearMin * nearFarMultiplier + farOffset;
    }
    evaluateClipPlanes(camera, projection) {
        let nearPlane = this.nearMin;
        let farPlane = this.farMin;
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // near and far plane for a set up where
            // the camera is looking at the center of the scene.
            const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
            const d = camera.position.length();
            const alpha = Math.asin(r / d);
            // Extract X, Y, Z axes into tmp vectors array.
            camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
            // Setup quaternion based on X axis.
            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);
            // Aquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).
            const fwd = this.m_tmpVectors[2].negate();
            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].
            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);
            // Store camera position tmpVectors[0] and reference it with p.
            const p = this.m_tmpVectors[0].copy(camera.position);
            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));
            farPlane = p.sub(camera.position).dot(fwd);
            const bias = 2000; // TODO: generalize.
            nearPlane = Math.max(this.nearMin, projection.groundDistance(camera.position) - bias);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            const groundDistance = projection.groundDistance(camera.position);
            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);
            // Will be already clamped to minFar due to clamping above.
            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;
        }
        else {
            harp_utils_1.assert(false, "Unsuported projection type");
        }
        const viewRanges = { near: nearPlane, far: farPlane, maximum: farPlane };
        return viewRanges;
    }
}
exports.InterpolatedClipPlanesEvaluator = InterpolatedClipPlanesEvaluator;
/**
 * Simple camera clip planes evaluator that computes near plane based on camera to ground distance.
 *
 * This evaluator supports both planar and spherical projections, although it behaviour is
 * slightly different in each case. General algorithm sets near plane and far plane close
 * to ground level, but taking into account some predefined margins.
 * @note This simple evaluator does behave correctly when camera is always pointing downwards the
 * ground surface (top view) along surface normal, but does not preserve correct planes when using
 * modifying camera pitch (tilt) angle. Suitable only top view camera modes.
 */
class AltitudeBasedClipPlanesEvaluator {
    /**
     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea
     * level as also minimum near plane and maximum far plane distance constraints.
     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near
     * and far planes to avoid flickering.
     * @param maxElevation defines near plane offset from the ground in the surface normal
     * direction, positive values allows to render elevated terrain features (mountains,
     * buildings).
     * @param minElevation defines far plane offset from the ground surface, negative values moves
     * far plane below the ground level (use it to render depressions).
     * @param nearMin minimum allowable near plane distance from camera, must be bigger then zero.
     * @param nearFarMargin minimum distance between near and far plane, have to be significantly
     * bigger then zero (especially if [[maxElevation]], [[minElevation]] are equal), otherwise you
     * may notice flickering during rendering, or even render empty scene if frustum planes are
     * almost equal.
     * @param farMaxRatio maximum ratio between ground and far plane distance, allows to limit
     * viewing distance at overall. Have to be bigger then 1.0.
     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation
     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],
     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires
     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes
     * anyway.
     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and
     * minimum renderable elevation respectivelly along the surface normal, when camera is
     * constantly looking downwards (top-down view). If you need [[ClipPlanesEvaluator]] for
     * cameras that support tilt or yaw please use [[TiltBasedClipPlanesEvaluator]].
     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,
     * the algorithm used there estimates distance to point on tangent where line from camera
     * touches the sphere horizont and there is no reason to clamp it.
     */
    constructor(maxElevation = 200, minElevation = -50, nearMin = 0.1, nearFarMargin = 1.0, farMaxRatio = 1.8) {
        this.nearMin = nearMin;
        this.nearFarMargin = nearFarMargin;
        this.farMaxRatio = farMaxRatio;
        /**
         * Helper for reducing number of objects created at runtime.
         */
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        /**
         * Helper object for reducing performance impact.
         */
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(maxElevation >= minElevation);
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMargin > epsilon);
        harp_utils_1.assert(farMaxRatio > 1.0);
        this.m_minElevation = minElevation;
        this.m_maxElevation = maxElevation;
        this.m_minimumViewRange = {
            near: nearMin,
            far: nearMin + nearFarMargin,
            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)
        };
    }
    /**
     * Set maximum elevation above sea level to be rendered.
     * @param elevation the elevation (altitude) value in world units (meters).
     * @note If you set this exactly to the maximum rendered feature height (altitude above
     * the sea, you may notice some flickering or even polygons disappearing related to rounding
     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little
     * bit offset to your assumed maximum elevation.
     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values
     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and
     * [[EarthConstant.MAX_ELEVATION]] respectivelly.
     * @see minElevation for more information about precision and rounding errors.
     */
    set maxElevation(elevation) {
        this.m_maxElevation = elevation;
        // Min elevation should be at least equal or smaller to max elevation.
        this.m_minElevation = Math.min(elevation, this.m_minElevation);
    }
    /**
     * Get maximum elevation to be covered by camera frustum.
     */
    get maxElevation() {
        return this.m_maxElevation;
    }
    /**
     * Set minimum elevation to be rendered, values beneath the sea level are negative.
     * @param elevation the minimum elevation (depression) in world units (meters).
     * @note If you set this parameter to zero you may not see any features rendered if they are
     * just below the sea level more then half of [[nearFarMargin]] assumed. Similarly if set to
     * -100m and rendered features lays exactly in such depression, you may notice that problem.
     * The errors ussually come from projection precision loss and depth buffer nature (significant
     * precision loss closer to far plane). Thus is such cases either increase the margin (if you
     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].
     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes
     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is
     * the highest point our planet.
     * @see https://developer.nvidia.com/content/depth-precision-visualized
     */
    set minElevation(elevation) {
        this.m_minElevation = elevation;
        // Max elevation should be at least equal or bigger then min elevation.
        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);
    }
    /**
     * Get minimum elevation to be covered by camera frustum.
     */
    get minElevation() {
        return this.m_minElevation;
    }
    /**
     * Get minimum view range that is possible to achieve with current evaluator settings.
     * @note This value will not change after evaluator is constructed.
     */
    get minimumViewRange() {
        return this.m_minimumViewRange;
    }
    evaluateClipPlanes(camera, projection) {
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            return this.evaluateDistanceSphericalProj(camera, projection);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            return this.evaluateDistancePlanarProj(camera, projection);
        }
        harp_utils_1.assert(false, "Unsuported projection type");
        return Object.assign({}, this.minimumViewRange);
    }
    /**
     * Calculate camera altitute (closest distance) to ground level in world units.
     * @param camera
     * @param projection
     */
    getCameraAltitude(camera, projection) {
        return projection.groundDistance(camera.position);
    }
    evaluateDistancePlanarProj(camera, projection) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // Calculate distance to closest point on the ground.
        const groundDistance = this.getCameraAltitude(camera, projection);
        const farMax = groundDistance * this.farMaxRatio;
        // We could at least try to keep margins along the eye vector (center of the view) in
        // tact with pitch angle changes, but this does not solve all tilt angle problems,
        // rather use more sophisticated evaluator.
        nearPlane = groundDistance - this.maxElevation;
        farPlane = groundDistance - this.minElevation;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane - this.nearFarMargin / 2, this.nearMin);
        farPlane = Math.min(farPlane, farMax);
        farPlane = Math.max(farPlane, nearPlane + this.nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            maximum: Math.max(farMax, farPlane)
        };
        return viewRanges;
    }
    evaluateDistanceSphericalProj(camera, projection) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // This solution computes near and far plane for a set up where
        // the camera is looking at the center of the scene.
        //         , - ~ ~ ~ - ,
        //     , '               ' ,        E
        //   ,           .           ,    . ' far + elev
        //  ,            .   r + e   , '   /
        // ,             .     ,  '    ,  /
        // ,             . O '         , / te
        // ,             | .           ,/
        //  ,            |   .  r     ,/
        //   ,           |      .    ,
        //     ,         |        , '_____ far
        //       ' -_, _ | _ ,  ' / T
        //     near      |      /
        //               |    / t
        //             d |  /
        //               |/
        //               C
        // The near plane calculus is quite straight forward and works the same as for planar
        // projections. We simply search for the closest point of the ground just above
        // the camera, then we apply margin (elevation) to it along the sphere surface normal:
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        nearPlane = cameraAltitude - this.maxElevation;
        // The far plane distance calculus requires finding the sphere tangent line that is
        // co-linear with (goes thru) camera position, such tangent creates right angle
        // with sphere diameter where it touches its surface (point T). Given that sphere is
        // always at world orgin and camera orbits around it we have:
        // angle(OTC) = 90
        // sin(OCT) = sin(alpha) = r / d
        // alpha = asin(r / d)
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        let d = camera.position.length();
        d = d === 0 ? epsilon : d;
        const alpha = Math.asin(r / d);
        // The distance to tangent point may be described as:
        // t = sqrt(d^2 - r^2)
        const t = Math.sqrt(d * d - r * r);
        // Because we would like to see elevated geometry that may be visible beyond the tangent
        // point on ground surface, we need to extend viewing distance along the tangent line
        // by te (see graph above). Knowing that OTE forms right angle, we have:
        // (r+e)^2 = r^2 + te^2
        // te = sqrt((r+e)^2 - r^2)
        // This reduces to:
        // te = sqrt(r^2 + 2*r*e + e^2 - r^2)
        // te = sqrt(2*r*e + e^2)
        // There may be situations when maximum elevation still remains below sea level (< 0) or
        // it is neglible, in such cases tangent extension (te) is not required.
        const te = this.maxElevation < epsilon
            ? 0
            : Math.sqrt(2 * r * this.maxElevation + this.maxElevation * this.maxElevation);
        // Next step is to project CT vector onto camera eye (forward) vector to get maximum
        // camera far plane distance. Point on sphere beyond that point won't be visible anyway
        // unless they are above the ground surface. For such cases [[this.maxElevation]] applies,
        // thus we project entire CE vector of length equal: t + te.
        // Extract camera X, Y, Z orientation axes into tmp vectors array.
        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
        // Setup quaternion (based on X axis) for angle between tangent and camera eye.
        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);
        // Aquire camera (eye) forward vector from Z axis reversed (keep it in tmpVectors[2]).
        const cameraFwdVec = this.m_tmpVectors[2].negate();
        // Apply quaternion to forward vector, creating tangent vector (store in tmpVectors[1]).
        const tangentVec = this.m_tmpVectors[1]
            .copy(cameraFwdVec)
            .applyQuaternion(this.m_tmpQuaternion);
        // Give it a proper length
        tangentVec.multiplyScalar(t + te);
        // Calculate tanget projection onto camera eye vector, giving far plane distance.
        farPlane = tangentVec.dot(cameraFwdVec);
        // Apply the constraints.
        nearPlane = Math.max(nearPlane - this.nearFarMargin / 2, this.nearMin);
        // In extreme cases the largest depression assumed may be further then tangent
        // based far plane distance, take it into account
        farPlane = Math.max(farPlane, cameraAltitude - this.minElevation);
        farPlane = Math.max(farPlane, nearPlane + this.nearFarMargin);
        const viewRanges = { near: nearPlane, far: farPlane, maximum: farPlane };
        return viewRanges;
    }
}
/**
 * Gives fast look up for ground normal in case of planar projections.
 */
AltitudeBasedClipPlanesEvaluator.GROUND_NORMAL_INV_PLANAR_PROJ = new THREE.Vector3(0, 0, -1);
exports.AltitudeBasedClipPlanesEvaluator = AltitudeBasedClipPlanesEvaluator;
/**
 * Evaluates camera clipping planes taking into account ground distance and camera angles.
 *
 * This evaluator provides support for camera with varying tilt (pitch) angle, the angle
 * between camera __look at__ vector and the ground surface normal.
 */
class TiltBasedClipPlanesEvaluator extends AltitudeBasedClipPlanesEvaluator {
    evaluateClipPlanes(camera, projection) {
        // Different algorithms are used for spherical and planar projections.
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            return this.evaluateSphericalProj(camera, projection);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            return this.evaluatePlanarProj(camera, projection);
        }
        harp_utils_1.assert(false, "Unsuported projection type");
        return Object.assign({}, this.minimumViewRange);
    }
    /**
     * Return camera tilt angle (in degrees).
     *
     * Tilt is the angle between camera __look at__ (forward) vector and ground normal.
     * @note It may depend on the projection type (in extended version).
     * @param camera
     * @param projection
     * @returns angle in radians.
     */
    getCameraTiltAngle(camera, projection) {
        const lookAt = new THREE.Vector3();
        camera.getWorldDirection(lookAt);
        return lookAt.angleTo(this.getGroundNormalInv(camera, projection));
    }
    /**
     * Calculate the camera distance to the ground in direction of look at vector.
     * This is not equivalent to camera altitute cause value will change according to look at
     * direction. It simply measures the distance of intersection point between ray from
     * camera and ground level, yet without taking into account terrain elevation nor buildings.
     * @param camera
     * @param projection
     */
    getCameraLookAtDistance(camera, projection) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        // Using simple trigonometry we may approximate the distance of camera eye vector
        // intersection with theoretical ground, knowing camera altitude and tilt angle:
        // cos(tiltAngle) = altitude / groundDistance
        // groundDistance = altitude / cos(tiltAngle)
        // where:
        // cos(tiltAngle) = dot(lookAt, eyeInverse)
        const lookAt = new THREE.Vector3();
        camera.getWorldDirection(lookAt).normalize();
        let cosTiltAngle = lookAt.dot(TiltBasedClipPlanesEvaluator.GROUND_NORMAL_INV_PLANAR_PROJ);
        cosTiltAngle = cosTiltAngle === 0 ? epsilon : cosTiltAngle;
        return this.getCameraAltitude(camera, projection) / cosTiltAngle;
    }
    /**
     * Return normal to the ground surface directly above camera position.
     * @param projection
     */
    getGroundNormalInv(camera, projection) {
        // Position on the ground for surface normal calculation does not matter for
        // any planar projections, so we may simplify calculus by returning const vector:
        if (projection.type !== harp_geoutils_1.ProjectionType.Spherical) {
            return TiltBasedClipPlanesEvaluator.GROUND_NORMAL_INV_PLANAR_PROJ;
        }
        else {
            const normal = new THREE.Vector3();
            projection.surfaceNormal(camera.position, normal);
            return normal.negate();
        }
    }
    /**
     * Calculate the lengths of frustum intersection with the ground plane.
     * This evaluates (vertical in camera space) distances between eye vector
     * ground intersection and bottom/top frustum planes.
     * @note This method assumes the world surface (ground) to be flat and
     * works only with planar projections.
     */
    getFrustumGroundIntersectionDist(camera, projection) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        // This algorithm computes the length of frustum intersection with a flat ground surface,
        // splitting the entire intersection into two sections, one for part above eye vector and
        // another below.
        // The following diagram may help explain the algorithm below.
        //   🎥
        //   C
        //   |\
        //   |.\ .
        //   | . \  .
        // z |  .  \   .c2
        //   |  c1.  \e    .
        //   |     .   \      .
        //___|a___D1.____\E1_____.D2______ g
        //   C1      .     \   .
        //            .      \.E2
        //             .    .
        //              . .
        //               .
        // Where:
        // - C gives the camera position.
        // - z is the height of the camera above the ground.
        // - a is a right angle.
        // - e is the look at vector of the camera.
        // - c1 and c2 are the frustum planes of the camera.
        // - angle between c1 to c2 is the fov.
        // - angles between c1 and e or e and c2 splits fov on equal halfs.
        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.
        // - angle between z and e is the tilt/pitch of the camera.
        // - g is the ground/world surface
        //
        // The goal is to find planar intersections of frustum with ground plane.
        // This are the distances from E1->D2 and D1->E1, and thoose are a longitude values,
        // that describes the length of frustum intersection with a ground (world) plane.
        // Please note that: E1>D2 >= E1->D1 (because we can't have a negative tilt).
        // To find E1->D2, we use the right triangle C, C1, D2 and subtract distance from C1->D2
        // with C1->E1.
        // C1->D2 is found using the angle between z and c2 edges from the camera, this angle
        // (between C1, C and E1) equals the tilt + half of the fov angle and thus using simple
        // trigonometry, we may say:
        // tan(tilt + fov/2) = C1->D2 / z,
        // C1->D2 = tan(tilt + fov/2) * z.
        // C1->E1 just need the tilt and trigonometry to compute, result is:
        // C1->E1 = tan(tilt) * z.
        // then E1->D2 is expressed with:
        // E1->D2 = C1->D2 - C1->E1
        // For computing D1->E1, we may use similar formulas, firstly calculate C1->D1:
        // C1->D1 = tan(tilt - fov/2) * z
        // and then D1->E1:
        // D1->E1 = C1->E1 - C1->D1
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        const cameraPitch = this.getCameraTiltAngle(camera, projection);
        // Angle between z and c2, note, the fov is vertical, otherwise we would need to
        // translate it using aspect ratio:
        // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        const aspect = 1;
        // Half fov angle in radians
        const halfFovAngleRad = harp_geoutils_1.MathUtils.degToRad((camera.fov * aspect) / 2);
        // Angle between z and c2
        const biggerAngleRad = cameraPitch + halfFovAngleRad;
        // Angle between z and c1
        const smallerAngleRad = cameraPitch - halfFovAngleRad;
        // Length C1->E1
        const projectionEyeVector = Math.tan(cameraPitch) * cameraAltitude;
        // Length C1->D2
        const projectionHighEdge = Math.tan(biggerAngleRad) * cameraAltitude;
        // Length E1->D2
        const projectionRightSide = projectionHighEdge - projectionEyeVector;
        // Length of C1->D1
        const projectionLowEdge = Math.tan(smallerAngleRad) * cameraAltitude;
        // Length D1->E1
        const projectionLeftSide = projectionEyeVector - projectionLowEdge;
        return {
            top: projectionRightSide,
            bottom: projectionLeftSide
        };
    }
    evaluatePlanarProj(camera, projection) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        const clipPlanes = Object.assign({}, this.minimumViewRange);
        const cameraTilt = this.getCameraTiltAngle(camera, projection);
        const lookAtDist = this.getCameraLookAtDistance(camera, projection);
        // Generally near/far planes are set to keep look at distance, then
        // margins are applied. Here margins (min/max elevations) are meant to be
        // defined as distance along the ground normal vector thus during camera
        // tilt they need to be projected on the eye vector:
        // actualMargin = margin / groundNormal.dot(eyeVec)
        // Assuming that tilt angle defined relative to actual ground normal, we have:
        let cameraEyeDotGround = Math.cos(cameraTilt);
        cameraEyeDotGround = cameraEyeDotGround === 0 ? epsilon : cameraEyeDotGround;
        clipPlanes.near = lookAtDist - this.maxElevation / cameraEyeDotGround;
        clipPlanes.far = lookAtDist - this.minElevation / cameraEyeDotGround;
        // Correct cliping planse distance for the top/bottom frustum planes (edges).
        // If we deal with perspective camera type, this step would not be required
        // for orthographic projections.
        if (camera.type === "PerspectiveCamera") {
            const frustumGroundProj = this.getFrustumGroundIntersectionDist(camera, projection);
            // Looking on the graph presented in getFrustumGroundIntersectionDist() method
            // we may, calculate far plane extension required in order to preserve look at
            // based distance at any tilt angle for frustum edges, the formulas are
            // presented below:
            // cos(90 - tilt) = farPlaneExt / frustumIntersectTop
            // farPlaneExt = cos(90 - tilt) * frustumIntersectTop
            const tiltAngleRestCos = Math.cos(Math.PI / 2 - cameraTilt);
            clipPlanes.far += frustumGroundProj.top * tiltAngleRestCos;
            // Similar formulas may be derived for near plane distance:
            // cos(90 - tilt) = nearPlaneExt / frustumIntersectBottom
            // nearPlaneExt = frustumIntersectBottom * cos(90 - tilt)
            clipPlanes.near -= frustumGroundProj.bottom * tiltAngleRestCos;
        }
        // Clamp values to constraints.
        const farMax = lookAtDist * this.farMaxRatio;
        clipPlanes.near = Math.max(clipPlanes.near, this.nearMin);
        clipPlanes.far = Math.min(clipPlanes.far, farMax);
        clipPlanes.maximum = farMax;
        return clipPlanes;
    }
    evaluateSphericalProj(camera, projection) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const clipPlanes = Object.assign({}, this.minimumViewRange);
        // Near plance calculus is pretty straightforward and does not depent on camera tilt:
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        clipPlanes.near = cameraAltitude - this.maxElevation;
        // For far plane we need to find tangent to sphere which gives the maximum
        // visible distance with regards to sphere curvature and camera position.
        const worldOrigin = new THREE.Vector3(0, 0, 0);
        // Acquire camera to origin vector.
        const cameraToOrigin = worldOrigin.sub(camera.position);
        // Extract camera X, Y, Z orientation axes into tmp vectors array.
        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
        const xaxis = this.m_tmpVectors[0];
        const yaxis = this.m_tmpVectors[1];
        // Extend the far plane by the margin along the shpere normal (radius).
        // In order to calculate far plane distance we need to find sphere tangent
        // line that passes thru camera position, method explanation may be found in
        // AltitudeBasedClipPlanesEvaluator.evaluateDistanceSphericalProj() method.
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        const d = cameraToOrigin.length();
        const dNorm = this.m_tmpVectors[2].copy(cameraToOrigin).multiplyScalar(1 / d);
        const sinAlpha = r / d;
        const alpha = Math.asin(sinAlpha);
        const cosAlpha = Math.sqrt(1 - sinAlpha * sinAlpha);
        // Apply tangent vector length onto camera to origin vector.
        let td;
        // There may be situations when maximum elevation remains below sea level (< 0), or
        // is neglible, in such cases simply apply tangent distance to camera to origin vector.
        if (this.maxElevation < epsilon) {
            // This may be calculated by several methods, firstly:
            // t_d = d_norm * |t|,
            // where:
            // |t| = sqrt(|d|^2 - |r|^2), or
            // |t| = cos(alpha) * |d|
            // By simplifying t_d equation with the second condition, we get:
            // t_d = d_norm * cos(alpha) * |d|, where d = d_norm * |d|
            // t_d = d * cos(alpha)
            // Cause cameraToOrigin is no longer needed re-use it to calulate td.
            td = cameraToOrigin.multiplyScalar(cosAlpha);
        }
        // Second case takes into account the elevation above the ground.
        else {
            // Here the length of the tangent is extended with 'te' vector that allows to see
            // elevated geometry beyond the tangent (horizon line), see
            // AltitudeBasedClipPlanesEvaluator for explanations.
            // t_d = d_norm * |t + te|,
            // where:
            // |t| = cos(alpha) * |d|
            // |te| = sqrt((r+e)^2 - r^2)
            // Which reduces to:
            // |te| = sqrt(2*r*e + e^2)
            const t = cosAlpha * d;
            const te = Math.sqrt(2 * r * this.maxElevation - this.maxElevation * this.maxElevation);
            // Re-use prealocated vector.
            td = cameraToOrigin.copy(dNorm).multiplyScalar(t + te);
        }
        // For tangent, oriented in the direction to origin, we then apply
        // rotation to it on every rotation axes using already known tangent angle,
        // the angle that defines maximum visibility along the sphere surface.
        // This gives us the tangent rays in all major directions.
        const ry = this.m_tmpQuaternion.setFromAxisAngle(yaxis.cross(dNorm), alpha);
        const tdry = td.clone().applyQuaternion(ry);
        const rx = this.m_tmpQuaternion.setFromAxisAngle(xaxis.cross(dNorm), alpha);
        const tdrx = td.clone().applyQuaternion(rx);
        const rx2 = this.m_tmpQuaternion.copy(rx).inverse();
        // Cause td vector in no longer needed, reuse it applying quaternion to it.
        const tdrx2 = td.applyQuaternion(rx2);
        // Rotated tangents are then added to camera position thus defining far plane
        // position and orientation - it is enough to have three cooplanar points to
        // define the plane.
        // p1 = camera.position + tdrx
        // p2 = camera.position + tdry
        // p3 = camera.position + tdrx2
        // const farPlane = new THREE.Plane().setFromCoplanarPoints(p1, p2, p3);
        // clipPlanes.far = farPlane.distanceToPoint(camera.position);
        // This of course may be simplified by moving calculus entirelly to camera space,
        // because far plane is indeed defined in that space anyway:
        const farPlane = new THREE.Plane().setFromCoplanarPoints(tdrx, tdry, tdrx2);
        clipPlanes.far = farPlane.constant;
        // Finally apply the constraints.
        clipPlanes.near = Math.max(clipPlanes.near - this.nearFarMargin / 2, this.nearMin);
        // Take into account largest depression assumed, that may be further then
        // tangent based far plane distance.
        clipPlanes.far = Math.max(clipPlanes.far, cameraAltitude - this.minElevation);
        clipPlanes.far = Math.max(clipPlanes.far, clipPlanes.near + this.nearFarMargin);
        clipPlanes.maximum = clipPlanes.far;
        return clipPlanes;
    }
}
exports.TiltBasedClipPlanesEvaluator = TiltBasedClipPlanesEvaluator;
/**
 * Provides the most basic evaluation concept giving fixed values with some constraints.
 */
class FixedClipPlanesEvaluator {
    constructor(minNear = 1, minFarOffset = 10) {
        this.minNear = minNear;
        this.minFarOffset = minFarOffset;
        this.minFar = minNear + minFarOffset;
        this.m_nearPlane = minNear;
        this.m_farPlane = this.minFar;
    }
    get nearPlane() {
        return this.m_nearPlane;
    }
    set nearPlane(fixedNear) {
        this.invalidatePlanes(fixedNear, this.m_farPlane);
    }
    get farPlane() {
        return this.m_farPlane;
    }
    set farPlane(fixedFar) {
        this.invalidatePlanes(this.m_nearPlane, fixedFar);
    }
    evaluateClipPlanes(camera, projection) {
        // We do not need to perform actual evaluation cause results are precomputed and
        // kept stable until somebody changes the properties.
        const viewRanges = {
            near: this.m_nearPlane,
            far: this.m_farPlane,
            maximum: this.m_farPlane
        };
        return viewRanges;
    }
    invalidatePlanes(near, far) {
        // When clamping prefer to extend far plane at about minimum distance, giving
        // near distance setup priority over far.
        const nearDist = Math.max(this.minNear, near);
        const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);
        this.m_nearPlane = nearDist;
        this.m_farPlane = farDist;
    }
}
exports.FixedClipPlanesEvaluator = FixedClipPlanesEvaluator;
/**
 * Default [[ClipPlanesEvaluator]] calculates near plane based on ground distance.
 */
// tslint:disable-next-line: max-line-length
exports.defaultClipPlanesEvaluator = new InterpolatedClipPlanesEvaluator();


/***/ }),

/***/ "../harp-mapview/lib/ColorCache.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/ColorCache.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Use `ColorCache` to reuse a color specified by name and save allocation as well as
 * setup time.
 *
 * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.
 */
class ColorCache {
    constructor() {
        this.m_map = new Map();
    }
    /**
     * Return instance of `ColorCache`.
     */
    static get instance() {
        return this.m_instance;
    }
    /**
     * Returns the color for the given `colorCode`. This function may reuse a previously generated
     * color, so you cannot modify the contents of the color.
     *
     * @param colorCode ThreeJS color code or name. You must provide a valid color code or name,
     * as this function does not do any validation.
     */
    getColor(colorCode) {
        if (typeof colorCode === "number") {
            colorCode = "#" + colorCode.toString(16).padStart(6, "0");
        }
        let color = this.m_map.get(colorCode);
        if (color !== undefined) {
            return color;
        }
        color = new THREE.Color(colorCode);
        this.m_map.set(colorCode, color);
        return color;
    }
    /**
     * Returns the number of elements in the cache.
     */
    get size() {
        return this.m_map.size;
    }
    /**
     * Clears the cache. Only references to the THREE.Color are removed from the cache.
     * Consequently, clearing the cache does not cause any negative visual impact.
     */
    clear() {
        this.m_map.clear();
    }
}
ColorCache.m_instance = new ColorCache();
exports.ColorCache = ColorCache;


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentDecoderFacade.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentDecoderFacade.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "../harp-mapview/lib/ConcurrentWorkerSet.ts");
const WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ "../harp-mapview/lib/WorkerBasedDecoder.ts");
/**
 * Default concurrent decoder helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to [[WorkerBasedDecoder]]s for data sources.
 */
class ConcurrentDecoderFacade {
    /**
     * Returns a [[WorkerBasedDecoder]] instance.
     *
     * @param decoderServiceType The name of the decoder service type.
     * @param scriptUrl The optional URL with the workers' script.
     * @param workerCount The number of web workers to use.
     */
    static getTileDecoder(decoderServiceType, scriptUrl, workerCount) {
        const workerSet = this.getWorkerSet(scriptUrl, workerCount);
        return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     * @param workerCount The number of web workers to use.
     */
    static getWorkerSet(scriptUrl, workerCount) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
}
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and decoders.
 */
ConcurrentDecoderFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentDecoderFacade.defaultWorkerCount = undefined;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentDecoderFacade.workerSets = {};
exports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentTilerFacade.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentTilerFacade.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "../harp-mapview/lib/ConcurrentWorkerSet.ts");
const WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ "../harp-mapview/lib/WorkerBasedTiler.ts");
/**
 * Default concurrent tiler helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to [[WorkerBasedTiler]]s for data sources.
 */
class ConcurrentTilerFacade {
    /**
     * Returns a [[WorkerBasedTiler]] instance.
     *
     * @param tilerServiceType The name of the tiler service type.
     * @param scriptUrl The optional URL with the workers' script.
     * @param workerCount The number of web workers to use.
     */
    static getTiler(tilerServiceType, scriptUrl, workerCount) {
        const workerSet = this.getWorkerSet(scriptUrl, workerCount);
        return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     * @param workerCount The number of web workers to use.
     */
    static getWorkerSet(scriptUrl, workerCount) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
}
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and tilers.
 */
ConcurrentTilerFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentTilerFacade.defaultWorkerCount = 1;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentTilerFacade.workerSets = {};
exports.ConcurrentTilerFacade = ConcurrentTilerFacade;


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentWorkerSet.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentWorkerSet.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts");
const logger = harp_utils_1.LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
    return message && typeof message.level === "number" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;
}
exports.isLoggingMessage = isLoggingMessage;
/**
 * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.
 */
const DEFAULT_WORKER_COUNT = 4;
/**
 * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances
 * running in Web Workers.
 *
 * Starts and manages a certain number of web workers and provides a means to communicate
 * with them using various communication schemes, such as:
 *  - [[addEventListener]] : receive a unidirectional messages
 *  - [[broadcastMessage]] : send unidirectional broadcast message
 *  - [[invokeRequest]] : send a request that waits for a response, with load balancing
 *  - [[postMessage]] : send a unidirectional message, with load balancing
 *
 * The request queue holds all requests before they are stuffed into the event queue, allows for
 * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage
 * when they return their previous result, or if they are idle. When they are idle, they are stored
 * in m_availableWorkers.
 */
class ConcurrentWorkerSet {
    /**
     * Creates a new `ConcurrentWorkerSet`.
     *
     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided
     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in
     * `navigator.hardwareConcurrency` is used instead.
     *
     * The worker set is implicitly started when constructed.
     */
    constructor(m_options) {
        this.m_options = m_options;
        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create("WorkerChannel");
        this.m_eventListeners = new Map();
        this.m_workers = new Array();
        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce
        // memory consumption in idle workers.
        this.m_availableWorkers = new Array();
        this.m_workerPromises = new Array();
        this.m_readyPromises = new Map();
        this.m_requests = new Map();
        this.m_workerRequestQueue = [];
        this.m_nextMessageId = 0;
        this.m_stopped = true;
        this.m_referenceCount = 0;
        /**
         * Handles messages received from workers. This method is protected so that the message
         * reception can be simulated through an extended class, to avoid relying on real workers.
         *
         * @param workerId The workerId of the web worker.
         * @param event The event to dispatch.
         */
        this.onWorkerMessage = (workerId, event) => {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {
                const response = event.data;
                if (response.messageId === null) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);
                    return;
                }
                const entry = this.m_requests.get(response.messageId);
                if (entry === undefined) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);
                    return;
                }
                if (workerId >= 0 && workerId < this.m_workers.length) {
                    const worker = this.m_workers[workerId];
                    this.m_availableWorkers.push(worker);
                    // Check if any new work has been put into the queue.
                    this.checkWorkerRequestQueue();
                }
                else {
                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);
                }
                if (response.error !== undefined) {
                    entry.resolver(new Error(response.error.toString()));
                }
                else {
                    entry.resolver(undefined, response.response);
                }
            }
            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {
                const readyPromise = this.getReadyPromise(event.data.service);
                if (++readyPromise.count === this.m_workerPromises.length) {
                    readyPromise.resolve();
                }
            }
            else if (isLoggingMessage(event.data)) {
                switch (event.data.level) {
                    case harp_utils_1.LogLevel.Trace:
                        this.m_workerChannelLogger.trace(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Debug:
                        this.m_workerChannelLogger.debug(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Log:
                        this.m_workerChannelLogger.log(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Info:
                        this.m_workerChannelLogger.info(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Warn:
                        this.m_workerChannelLogger.warn(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Error:
                        this.m_workerChannelLogger.error(...event.data.message);
                        break;
                }
            }
            else {
                this.eventHandler(event);
            }
        };
        this.start();
    }
    /**
     * Adds an external reference and increments the internal reference counter by one.
     *
     * To implement a reference-count based automatic resource cleanup, use this function with
     * [[removeReference]].
     */
    addReference() {
        this.m_referenceCount += 1;
        if (this.m_referenceCount === 1 && this.m_stopped) {
            this.start();
        }
    }
    /**
     * Decrements the internal reference counter by 1.
     *
     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the
     * resources.
     *
     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.
     */
    removeReference() {
        this.m_referenceCount -= 1;
        if (this.m_referenceCount === 0) {
            this.destroy();
        }
    }
    /**
     * Starts workers.
     *
     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.
     *
     * Note: The worker set is implicitly started on construction - no need to call [[start]] on
     * fresh instance.
     *
     * @param options optional, new worker set options
     */
    start(options) {
        if (options !== undefined) {
            this.m_options = options;
        }
        if (!this.m_stopped) {
            throw new Error("ConcurrentWorker set already started");
        }
        const workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== undefined
            ? // We need to have at least one worker
                harp_utils_1.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 4)
            : undefined, DEFAULT_WORKER_COUNT);
        // Initialize the workers. The workers now have an ID to identify specific workers and
        // handle their busy state.
        for (let workerId = 0; workerId < workerCount; ++workerId) {
            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl)
                .then(worker => {
                const listener = (evt) => {
                    this.onWorkerMessage(workerId, evt);
                };
                worker.addEventListener("message", listener);
                this.m_workers.push(worker);
                this.m_availableWorkers.push(worker);
                return {
                    worker,
                    listener
                };
            })
                .catch(error => {
                logger.error(`failed to load worker ${workerId}: ${error}`);
                return undefined;
            });
            this.m_workerPromises.push(workerPromise);
        }
        this.m_stopped = false;
    }
    /**
     * Stops workers.
     *
     * Waits for all pending requests to be finished and stops all workers.
     *
     * Use [[start]] to start this worker again.
     *
     * @returns `Promise` that resolves when all workers are destroyed.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.m_stopped = true;
            yield this.waitForAllResponses().then(() => {
                this.terminateWorkers();
            });
        });
    }
    /**
     * Destroys all workers immediately.
     *
     * Resolves all pending request promises with a `worker destroyed` error.
     *
     * Use [[start]] to start this worker again.
     */
    destroy() {
        this.m_stopped = true;
        // respond with all pending request
        this.m_requests.forEach(entry => {
            entry.resolver(new Error("worker destroyed"));
        });
        this.m_requests.clear();
        this.m_workerRequestQueue = [];
        this.terminateWorkers();
        // clean other stuff
        this.m_eventListeners.clear();
    }
    /**
     * Waits for `service` to be initialized in all workers.
     *
     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that
     * it has started successfully. This method resolves when all workers in a set have
     * `service` initialized.
     *
     * @param serviceId The service identifier.
     */
    connect(serviceId) {
        this.ensureStarted();
        return this.getReadyPromise(serviceId).promise;
    }
    /**
     * Registers an event listener for events that originated in a web worker, for a given
     * `serviceId`. You can only set one event listener per `serviceId`.
     *
     * @param serviceId The service to listen to.
     * @param callback The callback to invoke for matching events.
     */
    addEventListener(serviceId, callback) {
        this.m_eventListeners.set(serviceId, callback);
    }
    /**
     * Removes a previously set event listener for the given `serviceId`.
     *
     * @param serviceId The service from which to remove the event listeners.
     */
    removeEventListener(serviceId) {
        this.m_eventListeners.delete(serviceId);
    }
    /**
     * Invokes a request that expects a response from a random worker.
     *
     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from
     * workers. Use this function when interfacing with "RPC-like" calls to services.
     *
     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.
     * @param request The request to process.
     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.
     * @param requestController An optional [[RequestController]] to store state of cancelling.
     *
     * @returns A `Promise` that resolves with a response from the service.
     */
    invokeRequest(serviceId, request, transferList, requestController) {
        this.ensureStarted();
        const messageId = this.m_nextMessageId++;
        let resolver;
        const promise = new Promise((resolve, reject) => {
            resolver = (error, response) => {
                this.m_requests.delete(messageId);
                if (error !== undefined) {
                    reject(error instanceof Error ? error : new Error(error.toString()));
                }
                else {
                    resolve(response);
                }
            };
        });
        this.m_requests.set(messageId, {
            promise,
            resolver: resolver
        });
        const message = {
            service: serviceId,
            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
            messageId,
            request
        };
        this.postRequestMessage(message, transferList, requestController);
        return promise;
    }
    /**
     * Invokes a request that expects responses from all workers.
     *
     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching
     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers
     * before proceeding (like synchronous worker service creation).
     *
     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.
     * @param request The request to process.
     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.
     *
     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified
     * order).
     */
    broadcastRequest(serviceId, request, transferList) {
        this.ensureStarted();
        const promises = [];
        for (const worker of this.m_workers) {
            const messageId = this.m_nextMessageId++;
            let resolver;
            const promise = new Promise((resolve, reject) => {
                resolver = (error, response) => {
                    this.m_requests.delete(messageId);
                    if (error !== undefined) {
                        reject(new Error(error.toString()));
                    }
                    else {
                        resolve(response);
                    }
                };
            });
            promises.push(promise);
            this.m_requests.set(messageId, {
                promise,
                resolver: resolver
            });
            const message = {
                service: serviceId,
                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
                messageId,
                request
            };
            if (transferList !== undefined) {
                worker.postMessage(message, transferList);
            }
            else {
                worker.postMessage(message);
            }
        }
        return Promise.all(promises);
    }
    /**
     * Posts a message to all workers.
     *
     * @param message The message to send.
     * @param buffers Optional buffers to transfer to the workers.
     */
    broadcastMessage(message, buffers) {
        this.ensureStarted();
        if (buffers !== undefined) {
            this.m_workers.forEach(worker => worker.postMessage(message, buffers));
        }
        else {
            this.m_workers.forEach(worker => worker.postMessage(message));
        }
    }
    /**
     * The size of the request queue for debugging and profiling.
     */
    get requestQueueSize() {
        return this.m_workerRequestQueue.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numWorkers() {
        return this.m_workers.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numIdleWorkers() {
        return this.m_availableWorkers.length;
    }
    /**
     * Subclasses must call this function when a worker emits an event.
     *
     * @param event The event to dispatch.
     */
    eventHandler(event) {
        if (typeof event.data.type !== "string") {
            return; // not an event generated by us, ignore.
        }
        this.dispatchEvent(event.data.type, event);
    }
    /**
     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is
     * available, the request is put into a queue.
     *
     * @param message The message to send.
     * @param buffers Optional buffers to transfer to the worker.
     * @param requestController An optional [[RequestController]] to store state of cancelling.
     */
    postRequestMessage(message, buffers, requestController) {
        this.ensureStarted();
        if (this.m_workers.length === 0) {
            throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
        }
        // Check if the requestController has received the abort signal, in which case the request
        // is ignored.
        if (requestController !== undefined && requestController.signal.aborted) {
            const entry = this.m_requests.get(message.messageId);
            if (entry === undefined) {
                logger.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);
                return;
            }
            const err = new Error("Aborted");
            err.name = "AbortError";
            entry.resolver(err, undefined);
            return;
        }
        if (this.m_availableWorkers.length > 0) {
            const worker = this.m_availableWorkers.pop();
            if (buffers !== undefined) {
                worker.postMessage(message, buffers);
            }
            else {
                worker.postMessage(message);
            }
        }
        else {
            // We need a priority to keep sorting stable, so we have to add a RequestController.
            if (requestController === undefined) {
                requestController = new harp_datasource_protocol_1.RequestController(0);
            }
            if (requestController.priority === 0) {
                // If the requests do not get a priority, they should keep their sorting order.
                requestController.priority = -this.m_nextMessageId;
            }
            this.m_workerRequestQueue.unshift({
                message,
                buffers,
                requestController
            });
        }
    }
    ensureStarted() {
        if (this.m_stopped) {
            throw new Error("ConcurrentWorkerSet stopped");
        }
    }
    waitForAllResponses() {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = new Array();
            this.m_requests.forEach(entry => {
                promises.push(entry.promise);
            });
            yield Promise.all(promises);
        });
    }
    dispatchEvent(id, message) {
        const callback = this.m_eventListeners.get(id);
        if (callback === undefined) {
            return;
        } // unknown event, ignore.
        callback(message);
    }
    terminateWorkers() {
        // terminate all workers
        this.m_workerPromises.forEach(workerPromise => {
            workerPromise.then(workerEntry => {
                if (workerEntry === undefined) {
                    return;
                }
                workerEntry.worker.removeEventListener("message", workerEntry.listener);
                workerEntry.worker.terminate();
            });
        });
        this.m_workers = [];
        this.m_workerPromises = [];
        this.m_availableWorkers = [];
        this.m_readyPromises.clear();
    }
    getReadyPromise(id) {
        const readyPromise = this.m_readyPromises.get(id);
        if (readyPromise !== undefined) {
            return readyPromise;
        }
        const newPromise = {
            count: 0,
            promise: undefined,
            resolve: () => {
                /* placeholder */
            },
            reject: (error) => {
                newPromise.error = error;
            },
            error: undefined
        };
        newPromise.promise = new Promise((resolve, reject) => {
            const that = newPromise;
            if (that.error !== undefined) {
                reject(that.error);
            }
            else if (that.count === this.m_workerPromises.length) {
                resolve();
            }
            that.resolve = resolve;
            that.reject = reject;
        });
        this.m_readyPromises.set(id, newPromise);
        return newPromise;
    }
    /**
     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,
     * they will be executed with postRequestMessage. The requests in the queue are sorted before
     * the request with the highest priority is selected for processing.
     */
    checkWorkerRequestQueue() {
        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
            return;
        }
        this.m_workerRequestQueue.sort((a, b) => {
            return a.requestController.priority - b.requestController.priority;
        });
        // Get the request with the highest priority and send it (again).
        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {
            const request = this.m_workerRequestQueue.pop();
            this.postRequestMessage(request.message, request.buffers, request.requestController);
        }
    }
}
exports.ConcurrentWorkerSet = ConcurrentWorkerSet;


/***/ }),

/***/ "../harp-mapview/lib/CopyrightElementHandler.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/CopyrightElementHandler.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "../harp-mapview/lib/CopyrightInfo.ts");
const MapView_1 = __webpack_require__(/*! ./MapView */ "../harp-mapview/lib/MapView.ts");
/**
 * Helper class that maintains up-to-date [[MapView]] copyright information in DOM element.
 *
 * @example
 *
 *     // HTML snippet
 *     <div id="copyrightNotice" style="position:absolute; right:0; bottom:0; z-index:100"></div>
 *
 *     // Javascript
 *     const mapView = new MapView({ ... });
 *     CopyrightElementHandler.attach("copyrightNotice", mapView);
 */
class CopyrightElementHandler {
    /**
     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info
     * of the given `mapView`.
     *
     * Note: Generally, the static [[install]] method can be used to create and attach a new
     * `CopyrightElementHandler` to a [[MapView]]
     *
     * @param elementId HTML DOM element or a HTML DOM element id
     * @param mapView optional, [[attach]] to this [[MapView]] instance
     */
    constructor(element, mapView) {
        this.m_defaults = new Map();
        this.m_mapViews = [];
        /**
         * Update copyright info text in controlled HTML element.
         */
        this.update = () => {
            const mergedCopyrightInfo = this.m_mapViews
                .map(mapView => mapView.copyrightInfo)
                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, this.staticInfo || []);
            // Conditionally hiding of element with copyright information.
            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.
            if (mergedCopyrightInfo.length === 0) {
                this.m_element.style.display = "none";
                return;
            }
            else {
                this.m_element.style.display = "block";
            }
            if (this.m_defaults.size !== 0) {
                for (const sourceInfo of mergedCopyrightInfo) {
                    const defaults = this.m_defaults.get(sourceInfo.id);
                    if (defaults !== undefined) {
                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);
                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);
                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);
                    }
                }
            }
            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);
            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);
        };
        if (typeof element === "string") {
            this.m_element = document.getElementById(element);
            if (!this.m_element) {
                throw new Error(`CopyrightElementHandler: unable to find DOM element ${element}`);
            }
        }
        else {
            this.m_element = element;
        }
        if (mapView !== undefined) {
            this.attach(mapView);
        }
    }
    /**
     * Install [[CopyrightElementHandler]] on DOM element and - optionally - attach to a [[MapView]]
     * instance.
     *
     * @param element HTML DOM element or a HTML DOM element id
     * @param mapView, optional, [[attach]] to this [[MapView]]
     */
    static install(element, mapView) {
        return new CopyrightElementHandler(element, mapView);
    }
    /**
     * Destroys this object by removing all event listeners from the attached [[MapView]]s.
     */
    destroy() {
        for (const mapView of this.m_mapViews) {
            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        }
    }
    /**
     * Attaches this [[CopyrightInfo]] updates from [[MapView]] instance.
     */
    attach(mapView) {
        this.m_mapViews.push(mapView);
        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.update();
        return this;
    }
    /**
     * Stop following [[CopyrightInfo]] updates from [[MapView]] instance.
     */
    detach(mapView) {
        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);
        this.update();
        return this;
    }
    /**
     * Set [[CopyrightInfo]] defaults to be used in case [[DataSource]] does not provide deatailed
     * copyright information.
     *
     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright
     * information retrieved from [[MapView]].
     */
    setDefaults(defaults) {
        this.m_defaults.clear();
        if (defaults !== undefined) {
            for (const item of defaults) {
                this.m_defaults.set(item.id, item);
            }
        }
        return this;
    }
    /**
     * Sets the [[staticInfo]] property.
     *
     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and
     * copyright information obtained from attached [[MapView]]s.
     *
     * This information is used when [[DataSource]] instances of given [[MapView]] do not provide
     * copyright information.
     */
    setStaticCopyightInfo(staticInfo) {
        this.staticInfo = staticInfo;
        return this;
    }
}
exports.CopyrightElementHandler = CopyrightElementHandler;


/***/ }),

/***/ "../harp-mapview/lib/CopyrightInfo.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/CopyrightInfo.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
var CopyrightInfo;
(function (CopyrightInfo) {
    /**
     * Merge [[CopyrightInfo]] arrays, removing duplicates.
     *
     * `id` and `label` are considered keys in deduplication algorithm.
     *
     * @param sources non-duplicate elements from this array are added to `target`
     * @returns merge of all copyright infos in `sources`
     */
    function mergeArrays(a, b) {
        const result = [];
        for (const source of [a, b]) {
            if (source === undefined) {
                continue;
            }
            for (const sourceInfo of source) {
                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||
                    (findItem.label !== undefined && findItem.label === sourceInfo.label));
                if (existingInfo === undefined) {
                    result.push(Object.assign({}, sourceInfo));
                }
                else {
                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);
                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);
                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);
                }
            }
        }
        return result;
    }
    CopyrightInfo.mergeArrays = mergeArrays;
    /**
     * Format copyright information to a HTML string that can be displayed in the UI.
     *
     * * Empty list returns empty string.
     * * Entries with empty (but defined) labels are skipped.
     */
    function formatAsHtml(copyrightInfo) {
        if (copyrightInfo.length === 0) {
            return "";
        }
        const filtered = copyrightInfo.filter(entry => entry.label !== "");
        if (filtered.length === 0) {
            return "";
        }
        return ("© " +
            filtered
                .map(entry => {
                const label = entry.label !== undefined ? entry.label : entry.id;
                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;
                return entry.link ? `<a href="${entry.link}">${text}</a>` : `${text}`;
            })
                .join(", "));
    }
    CopyrightInfo.formatAsHtml = formatAsHtml;
})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));


/***/ }),

/***/ "../harp-mapview/lib/DataSource.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/DataSource.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const UPDATE_EVENT = { type: "update" };
/**
 * Derive a class from `DataSource` to contribute data and geometries to the [[MapView]].
 */
class DataSource extends THREE.EventDispatcher {
    /**
     * Constructs a new `DataSource`.
     *
     * @param uniqueName A unique name that represents this `DataSource`.
     * @param styleSetName The name of the [[StyleSet]] to refer to in a [[Theme]], to decode vector
     * tiles.
     * @param minZoomLevel Minimum zoom level this `DataSource` can be displayed in.
     * @param maxZoomLevel Maximum zoom level this `DataSource` can be displayed in.
     * @param storageLevelOffset Storage level offset applied to this `DataSource`.
     */
    constructor(uniqueName, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset) {
        super();
        /**
         * Set to `true` if this `DataSource` is enabled; `false` otherwise.
         */
        this.enabled = true;
        /**
         * Set to `true` if the [[MapView]] can cache tiles produced by this `DataSource`.
         */
        this.cacheable = false;
        /**
         * Set to `true` if the loader should be used to get the tile contents.
         */
        this.useGeometryLoader = false;
        /**
         * Minimum zoom level this `DataSource` can be displayed in.
         */
        this.m_minZoomLevel = 1;
        /**
         * Maximum zoom level this `DataSource` can be displayed in.
         */
        this.m_maxZoomLevel = 20;
        /**
         * Storage level offset applied to this `DataSource`.
         */
        this.m_storageLevelOffset = 0;
        if (uniqueName === undefined || uniqueName.length === 0) {
            uniqueName = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;
        }
        this.name = uniqueName;
        this.styleSetName = styleSetName;
        if (minZoomLevel !== undefined) {
            this.m_minZoomLevel = minZoomLevel;
        }
        if (maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = maxZoomLevel;
        }
        if (storageLevelOffset !== undefined) {
            this.m_storageLevelOffset = storageLevelOffset;
        }
    }
    /**
     * Returns the name of the [[StyleSet]] to use for the decoding.
     */
    get styleSetName() {
        return this.m_styleSetName;
    }
    /**
     * Sets the name of the [[StyleSet]] to use for the decoding. If this [[DataSource]] is already
     * attached to a [[MapView]], this setter then looks for a [[StyleSet]] with this name and
     * applies it.
     */
    set styleSetName(styleSetName) {
        this.m_styleSetName = styleSetName;
        if (this.m_mapView !== undefined &&
            styleSetName !== undefined &&
            this.m_mapView.theme.styles !== undefined) {
            this.setStyleSet(this.m_mapView.theme.styles[styleSetName]);
        }
    }
    /**
     * Destroys this `DataSource`.
     */
    dispose() {
        // to be overloaded by subclasses
    }
    /**
     * Purges all the caching done by this `DataSource`
     */
    clearCache() {
        // to be overloaded by subclasses
    }
    /**
     * Returns `true` if this `DataSource` is ready and the [[MapView]] can invoke `getTile()` to
     * start requesting data.
     */
    ready() {
        return true;
    }
    /**
     * The [[MapView]] that is holding this `DataSource`.
     */
    get mapView() {
        if (this.m_mapView === undefined) {
            throw new Error("This DataSource was not added to MapView");
        }
        return this.m_mapView;
    }
    /**
     * The [[Projection]] used by the [[MapView]] that is holding this `DataSource`.
     *
     * An `Error` is thrown if you call this method before this `DataSource` has been added
     * to a [[MapView]].
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * This method is called when the `DataSource` is added to a [[MapView]]. Reimplement this
     * method to provide any custom initialization, such as, to establish a network connection,
     * or to initialize complex data structures.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // to be overloaded by subclasses
        });
    }
    /**
     * This method is called when this `DataSource` is added to a [[MapView]].
     *
     * Reimplementations of this method must invoke the definition of the super class.
     *
     * @param mapView The instance of the [[MapView]].
     */
    attach(mapView) {
        this.m_mapView = mapView;
    }
    /**
     * This method is called when this `DataSource` is removed from a [[MapView]].
     *
     * Reimplementations of this method must invoke the definition of the super class.
     *
     * @param mapView The instance of the [[MapView]].
     */
    detach(mapView) {
        harp_utils_1.assert(this.m_mapView === mapView);
        this.m_mapView = undefined;
    }
    /**
     * Invoked by [[MapView]] to notify when the [[Theme]] has been changed.
     *
     * If `DataSource` depends on a theme, it must update its tiles' geometry.
     *
     * @param styleSet The new theme that [[MapView]] uses.
     * @param languages An optional list of languages for the `DataSource`.
     */
    // tslint:disable-next-line:no-unused-variable
    setStyleSet(styleSet, languages) {
        // to be overwritten by subclasses
    }
    /**
     * Used to configure the languages used by the `DataSource` according to priority;
     * the first language in the array has the highest priority.
     *
     * @param languages An array of ISO 639-1 language codes.
     */
    setLanguages(languages) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by [[MapView]] before the tile needs to be updated, for example after
     * a theme change.
     *
     * @param tile The [[Tile]] to update.
     */
    // tslint:disable-next-line:no-unused-variable
    updateTile(tile) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by the [[MapView]] to determine if the content of the surrounding
     * tiles must be preloaded.
     *
     * @returns `true` if the [[MapView]] should try to preload tiles surrounding the visible
     * tiles; `false` otherwise. The default is `false`.
     */
    shouldPreloadTiles() {
        return false;
    }
    /**
     * The minimum zoom level to use for display.
     *
     * @returns The minimum zoom level to use for display.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    set minZoomLevel(level) {
        this.m_minZoomLevel = level;
    }
    /**
     * The maximum zoom level to use for display.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    set maxZoomLevel(level) {
        this.m_maxZoomLevel = level;
    }
    /**
     * The difference between storage level and display level of tile.
     *
     * Storage level offset is a value applied (added) to current zoom level giving
     * a final tile level being displayed. This way we may differentate current
     * zoom level from the storage level that is displayed, giving fine grained
     * control over the tiles being decoded an displayed.
     */
    get storageLevelOffset() {
        return this.m_storageLevelOffset;
    }
    /**
     * Setup the relative offset between storage level and display level of tile.
     *
     * @param levelOffset Difference between zoom level and display level.
     */
    set storageLevelOffset(levelOffset) {
        this.m_storageLevelOffset = levelOffset;
    }
    /**
     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources
     * supporting this feature.
     *
     * @param value True to enable, false to disable.
     */
    setEnableElevationOverlay(enable) {
        // to be overloaded by subclasses
    }
    /**
     * Computes the zoom level to use for display.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @returns The zoom level to use for display.
     */
    getDisplayZoomLevel(zoomLevel) {
        return THREE.Math.clamp(zoomLevel + this.m_storageLevelOffset, this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns `true` if [[MapView]] should render the tile with given [[TileKey]] and zoom level.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the geometries created for the given [[TileKey]] should be rendered.
     */
    shouldRender(zoomLevel, tileKey) {
        return tileKey.level === zoomLevel;
    }
    /**
     * Returns `true` if [[MapView]] should render the text elements with the given [[TileKey]] and
     * zoom level.
     *
     * This is an additional check for the tiles that are already selected for rendering so the
     * default implementation returns `true`.
     *
     * @param zoomLevel The zoom level.
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the text elements created for the given [[TileKey]] should be rendered.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldRenderText(zoomLevel, tileKey) {
        return true;
    }
    /**
     * Sends a request to the [[MapView]] to redraw the scene.
     */
    requestUpdate() {
        this.dispatchEvent(UPDATE_EVENT);
    }
}
/**
 * A counter to generate unique names for each `DataSource`, if no name is provided in the
 * constructor.
 */
DataSource.uniqueNameCounter = 0;
exports.DataSource = DataSource;


/***/ }),

/***/ "../harp-mapview/lib/DebugContext.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/DebugContext.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const isNode = typeof window === "undefined";
/**
 * A `DebugOption` is a pair that consists of an option value and an array of change listeners.
 * Listeners are called up when setting the option's value.
 */
class DebugOption extends THREE.EventDispatcher {
    /**
     * Constructs the `DebugOption`.
     *
     * @param value The value of the option.
     */
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Updates the value of a given option.
     *
     * @param value The new value for the option.
     * @param name The name of the option to set.
     */
    set(value, name) {
        this.value = value;
        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });
    }
}
DebugOption.SET_EVENT_TYPE = "set";
/**
 * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their
 * names.
 */
class DebugContext {
    /**
     * Builds a `DebugContext`.
     */
    constructor() {
        this.m_optionsMap = new Map();
        // If we have a `window` object, we store the context in it to make it available in the
        // console.
        if (!isNode && typeof window !== "undefined" && window) {
            const debugInfo = window;
            debugInfo.__debugContext = this;
        }
    }
    /**
     * Sets the value of an option. Calls change listeners of that option, even if the value has
     * not been changed. The change listeners provided here are not called during this set
     * operation.
     *
     * @param name Name of the option.
     * @param value Value of the option.
     */
    setValue(name, value) {
        let opt = this.m_optionsMap.get(name);
        if (!opt) {
            opt = new DebugOption(value);
            this.m_optionsMap.set(name, opt);
        }
        else {
            opt.set(value, name);
        }
    }
    /**
     * Gets the option value.
     *
     * @param name Name of option.
     */
    getValue(name) {
        const opt = this.m_optionsMap.get(name);
        return opt ? opt.value : undefined;
    }
    /**
     * Determines if the option is registered.
     *
     * @param name Name of option.
     */
    hasOption(name) {
        return this.m_optionsMap.get(name) !== undefined;
    }
    /**
     * Adds a listener to a debug option.
     *
     * @param name Name of the option that requires a listener.
     * @param listener The listener function to add.
     */
    addEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Checks for a listener in a debug option.
     *
     * @param name Name of the option to check for.
     * @param listener The listener function to check for.
     */
    hasEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Removes a listener from a debug option.
     *
     * @param name Name of the option from which to remove a listener.
     * @param listener The listener function to remove.
     */
    removeEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Provides access to the options map. This method is useful for creating an automatic
     * browser GUI.
     */
    get options() {
        return this.m_optionsMap;
    }
    /**
     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API
     * to remove all event listeners.
     */
    clear() {
        this.m_optionsMap.forEach(option => {
            option.set(undefined, "");
        });
    }
}
exports.DebugContext = DebugContext;
exports.debugContext = new DebugContext();


/***/ }),

/***/ "../harp-mapview/lib/DecodedTileHelpers.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/DecodedTileHelpers.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "../harp-mapview/lib/ThemeHelpers.ts");
const logger = harp_utils_1.LoggerManager.instance.create("DecodedTileHelpers");
const DEFAULT_SKIP_PROPERTIES = [
    ...harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS,
    "mapProperties",
    "normalMapProperties",
    "displacementMapProperties",
    "roughnessMapProperties",
    "emissiveMapProperties",
    "alphaMapProperties",
    "metalnessMapProperties",
    "bumpMapProperties"
];
/**
 * Create a material, depending on the rendering technique provided in the options.
 *
 * @param options The material options the subsequent functions need.
 * @param materialUpdateCallback Optional callback when the material gets updated,
 *                               e.g. after texture loading.
 *
 * @returns new material instance that matches `technique.name`
 */
function createMaterial(options, textureReadyCallback) {
    const technique = options.technique;
    const Constructor = getMaterialConstructor(technique);
    const settings = {};
    if (Constructor === undefined) {
        return undefined;
    }
    if (Constructor.prototype instanceof THREE.RawShaderMaterial &&
        Constructor !== harp_materials_1.HighPrecisionLineMaterial) {
        settings.fog = options.fog;
    }
    const material = new Constructor(settings);
    if (technique.id !== undefined) {
        material.name = technique.id;
    }
    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        material.flatShading = true;
    }
    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
    if (harp_datasource_protocol_1.isStandardTechnique(technique) ||
        harp_datasource_protocol_1.isTerrainTechnique(technique) ||
        harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {
            const textureProperty = technique[texturePropertyName];
            if (textureProperty === undefined) {
                return;
            }
            const onLoad = (texture) => {
                const properties = technique[texturePropertyName + "Properties"];
                if (properties !== undefined) {
                    if (properties.wrapS !== undefined) {
                        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);
                    }
                    if (properties.wrapT !== undefined) {
                        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);
                    }
                    if (properties.magFilter !== undefined) {
                        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);
                    }
                    if (properties.minFilter !== undefined) {
                        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);
                    }
                    if (properties.flipY !== undefined) {
                        texture.flipY = properties.flipY;
                    }
                    if (properties.repeatU !== undefined) {
                        texture.repeat.x = properties.repeatU;
                    }
                    if (properties.repeatV !== undefined) {
                        texture.repeat.y = properties.repeatV;
                    }
                }
                material[texturePropertyName] = texture;
                texture.needsUpdate = true;
                material.needsUpdate = true;
                if (textureReadyCallback) {
                    textureReadyCallback(texture);
                }
            };
            const onError = (error) => {
                logger.error("#createMaterial: Failed to load texture: ", error);
            };
            let textureUrl;
            if (typeof textureProperty === "string") {
                textureUrl = textureProperty;
            }
            else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.type === "image/raw") {
                    const properties = textureProperty.dataTextureProperties;
                    if (properties !== undefined) {
                        const textureDataType = properties.type
                            ? ThemeHelpers_1.toTextureDataType(properties.type)
                            : undefined;
                        const textureBuffer = getTextureBuffer(textureProperty.buffer, textureDataType);
                        const texture = new THREE.DataTexture(textureBuffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);
                        onLoad(texture);
                    }
                    else {
                        onError("no data texture properties provided.");
                    }
                }
                else {
                    const textureBlob = new Blob([textureProperty.buffer], {
                        type: textureProperty.type
                    });
                    textureUrl = URL.createObjectURL(textureBlob);
                }
            }
            if (textureUrl) {
                new THREE.TextureLoader().load(textureUrl, onLoad, undefined, // onProgress
                onError);
            }
        });
    }
    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {
        // special case for ShaderTechnique.
        // The shader technique takes the argument from its `params' member.
        const params = technique.params;
        Object.getOwnPropertyNames(params).forEach(property => {
            const prop = property;
            if (prop === "name") {
                // skip reserved property names
                return;
            }
            const m = material;
            if (m[prop] instanceof THREE.Color) {
                m[prop].set(params[prop]);
            }
            else {
                m[prop] = params[prop];
            }
        });
    }
    else {
        applyTechniqueToMaterial(technique, material, options.level, options.skipExtraProps);
    }
    return material;
}
exports.createMaterial = createMaterial;
/**
 * Returns a [[THREE.BufferAttribute]] created from a provided [[BufferAttribute]] object.
 *
 * @param attribute BufferAttribute a WebGL compliant buffer
 */
function getBufferAttribute(attribute) {
    switch (attribute.type) {
        case "float":
            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
        case "uint8":
            return new THREE.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint16":
            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint32":
            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int8":
            return new THREE.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int16":
            return new THREE.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int32":
            return new THREE.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        default:
            throw new Error(`unsupported buffer of type ${attribute.type}`);
    } // switch
}
exports.getBufferAttribute = getBufferAttribute;
/**
 * Gets the default `three.js` object constructor associated with the given technique.
 *
 * @param technique The technique.
 */
function getObjectConstructor(technique) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
        case "standard":
        case "terrain":
        case "extruded-polygon":
        case "fill":
        case "solid-line":
        case "dashed-line":
            return THREE.Mesh;
        case "circles":
            return MapViewPoints_1.Circles;
        case "squares":
            return MapViewPoints_1.Squares;
        case "line":
            return THREE.LineSegments;
        case "segments":
            return THREE.LineSegments;
        case "shader": {
            if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {
                throw new Error("Invalid technique");
            }
            switch (technique.primitive) {
                case "line":
                    return THREE.Line;
                case "segments":
                    return THREE.LineSegments;
                case "point":
                    return THREE.Points;
                case "mesh":
                    return THREE.Mesh;
                default:
                    return undefined;
            }
        }
        case "text":
        case "labeled-icon":
        case "line-marker":
            return undefined;
    }
}
exports.getObjectConstructor = getObjectConstructor;
/**
 * Non material properties of [[BaseTechnique]]
 */
exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = [
    "name",
    "id",
    "renderOrder",
    "renderOrderBiasProperty",
    "renderOrderBiasGroup",
    "renderOrderBiasRange",
    "transient"
];
/**
 * Returns a [[MaterialConstructor]] basing on provided technique object.
 *
 * @param technique [[Technique]] object which the material will be based on.
 */
function getMaterialConstructor(technique) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                throw new Error("Invalid extruded-line technique");
            }
            return technique.shading === "standard"
                ? harp_materials_1.MapMeshStandardMaterial
                : harp_materials_1.MapMeshBasicMaterial;
        case "standard":
        case "terrain":
        case "extruded-polygon":
            return harp_materials_1.MapMeshStandardMaterial;
        case "solid-line":
            return harp_materials_1.SolidLineMaterial;
        case "dashed-line":
            return harp_materials_1.DashedLineMaterial;
        case "fill":
            return harp_materials_1.MapMeshBasicMaterial;
        case "squares":
            return THREE.PointsMaterial;
        case "circles":
            return harp_materials_1.CirclePointsMaterial;
        case "line":
        case "segments":
            return THREE.LineBasicMaterial;
        case "shader":
            return THREE.ShaderMaterial;
        case "text":
        case "labeled-icon":
        case "line-marker":
            return undefined;
    }
}
exports.getMaterialConstructor = getMaterialConstructor;
/**
 * Apply generic technique parameters to material.
 *
 * Skips non-material [[Technique]] props:
 *  * [[BaseTechnique]] props,
 *  * `name` which is used as discriminator for technique types,
 *  * props starting with `_`
 *  * props found `skipExtraProps`
 *
 * `THREE.Color` properties are supported.
 *
 * @param technique technique from where params are copied
 * @param material target material
 * @param level optional, tile zoom level for zoom-level dependent props
 * @param skipExtraProps optional, skipped props
 */
function applyTechniqueToMaterial(technique, material, level, skipExtraProps) {
    Object.getOwnPropertyNames(technique).forEach(propertyName => {
        if (propertyName.startsWith("_") ||
            exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS.indexOf(propertyName) !== -1 ||
            DEFAULT_SKIP_PROPERTIES.indexOf(propertyName) !== -1 ||
            (skipExtraProps !== undefined && skipExtraProps.indexOf(propertyName) !== -1)) {
            return;
        }
        const prop = propertyName;
        const m = material;
        let value = technique[prop];
        if (typeof m[prop] === "undefined") {
            return;
        }
        if (level !== undefined && harp_datasource_protocol_1.isInterpolatedProperty(value)) {
            value = harp_datasource_protocol_1.getPropertyValue(value, level);
        }
        if (m[prop] instanceof THREE.Color) {
            m[prop].set(value);
        }
        else {
            m[prop] = value;
        }
    });
}
exports.applyTechniqueToMaterial = applyTechniqueToMaterial;
function getTextureBuffer(buffer, textureDataType) {
    if (textureDataType === undefined) {
        return new Uint8Array(buffer);
    }
    switch (textureDataType) {
        case THREE.UnsignedByteType:
            return new Uint8Array(buffer);
        case THREE.ByteType:
            return new Int8Array(buffer);
        case THREE.ShortType:
            return new Int16Array(buffer);
        case THREE.UnsignedShortType:
            return new Uint16Array(buffer);
        case THREE.IntType:
            return new Int32Array(buffer);
        case THREE.UnsignedIntType:
            return new Uint32Array(buffer);
        case THREE.FloatType:
            return new Float32Array(buffer);
        case THREE.HalfFloatType:
            return new Uint16Array(buffer);
    }
    throw new Error("Unsupported texture data type");
}


/***/ }),

/***/ "../harp-mapview/lib/DepthPrePass.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/DepthPrePass.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position
 * from rendering color.
 */
exports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;
/**
 * Check if technique requires (and not disables) use of depth prepass.
 *
 * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly
 * disabled by `enableDepthPrePass` option.
 *
 * @param technique [[BaseStandardTechnique]] instance to be checked
 */
function isRenderDepthPrePassEnabled(technique) {
    return (technique.enableDepthPrePass !== false &&
        technique.opacity !== undefined &&
        technique.opacity > 0 &&
        technique.opacity < 1.0);
}
exports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;
/**
 * Creates material for depth prepass.
 *
 * Creates material that writes only to the z-buffer. Updates the original material instance, to
 * support depth prepass.
 *
 * @param baseMaterial The base material of mesh that is updated to work with depth prepass
 *     and then used. This parameter is a template for depth prepass material that is returned.
 * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.
 */
function createDepthPrePassMaterial(baseMaterial) {
    baseMaterial.depthWrite = false;
    baseMaterial.depthFunc = THREE.EqualDepth;
    baseMaterial.colorWrite = true;
    baseMaterial.transparent = true;
    const depthPassMaterial = baseMaterial.clone();
    depthPassMaterial.depthWrite = true;
    depthPassMaterial.depthTest = true;
    depthPassMaterial.depthFunc = THREE.LessDepth;
    depthPassMaterial.colorWrite = false;
    depthPassMaterial.transparent = false;
    depthPassMaterial.opacity = 1.0;
    return depthPassMaterial;
}
exports.createDepthPrePassMaterial = createDepthPrePassMaterial;
// tslint:disable:max-line-length
/**
 * Clones a given mesh to render it in the depth prepass with another material. Both the original
 * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass
 * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to
 * support the depth prepass. This method is usable only if the material of this mesh has an
 * opacity value in the range `(0,1)`.
 *
 * About render order: the DepthPrePass object that is created has the same `renderOrder` as
 * the original mesh. The proper sort orders of both the depth and the color pass objects are
 * guaranteed by ThreeJS's handling of transparent objects, which renders them after opaque
 * objects:
 *   - since the depth prepass object is never transparent, it is rendered first
 *   - since the color pass object is transparent, it is rendered second
 *
 * @see [Material.transparent in ThreeJS's doc](https://threejs.org/docs/#api/harp-materials/Material.transparent).
 *
 * @param mesh original mesh
 * @returns `Mesh` depth pre pass
 */
// tslint:enable:max-line-length
function createDepthPrePassMesh(mesh) {
    const originalGeometry = mesh.geometry;
    if (!(originalGeometry instanceof THREE.BufferGeometry)) {
        throw new Error("#createDepthPassMesh only BufferGeometry is supported");
    }
    const positionAttribute = originalGeometry.getAttribute("position");
    if (!positionAttribute) {
        throw new Error("#createDepthPassMesh position attribute not found");
    }
    const depthPassGeometry = new THREE.BufferGeometry();
    depthPassGeometry.addAttribute("position", positionAttribute);
    const uvAttribute = originalGeometry.getAttribute("uv");
    if (uvAttribute) {
        depthPassGeometry.addAttribute("uv", uvAttribute);
    }
    const extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
    if (extrusionAxisAttribute) {
        depthPassGeometry.addAttribute("extrusionAxis", extrusionAxisAttribute);
    }
    if (originalGeometry.index) {
        depthPassGeometry.setIndex(originalGeometry.index);
    }
    for (const group of originalGeometry.groups) {
        const { start, count, materialIndex } = group;
        depthPassGeometry.addGroup(start, count, materialIndex);
    }
    const depthPassMaterial = mesh.material instanceof Array
        ? mesh.material.map(createDepthPrePassMaterial)
        : createDepthPrePassMaterial(mesh.material);
    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);
    depthPassMesh.renderOrder = mesh.renderOrder;
    return depthPassMesh;
}
exports.createDepthPrePassMesh = createDepthPrePassMesh;
/**
 * Sets up all the needed stencil logic needed for the depth pre-pass.
 *
 * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have
 * coplanar triangles inside the same mesh.
 *
 * @param depthMesh Mesh created by `createDepthPrePassMesh`.
 * @param colorMesh Original mesh.
 */
function setDepthPrePassStencil(depthMesh, colorMesh) {
    // Set up depth mesh stencil logic.
    // Set the depth pre-pass stencil bit for all processed fragments. We use
    // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass
    // the stencil test and write the correct depth value.
    const depthMaterial = depthMesh.material;
    depthMaterial.stencilWrite = true;
    depthMaterial.stencilFail = THREE.KeepStencilOp;
    depthMaterial.stencilZFail = THREE.KeepStencilOp;
    depthMaterial.stencilZPass = THREE.ReplaceStencilOp;
    depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;
    depthMaterial.stencilRef = 0xff;
    depthMaterial.stencilMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
    // Set up color mesh stencil logic.
    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is
    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position
    // from rendering color again.
    const colorMaterial = colorMesh.material;
    colorMaterial.stencilWrite = true;
    colorMaterial.stencilFail = THREE.KeepStencilOp;
    colorMaterial.stencilZFail = THREE.KeepStencilOp;
    colorMaterial.stencilZPass = THREE.ZeroStencilOp;
    colorMaterial.stencilFunc = THREE.EqualStencilFunc;
    colorMaterial.stencilRef = 0xff;
    colorMaterial.stencilMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
}
exports.setDepthPrePassStencil = setDepthPrePassStencil;


/***/ }),

/***/ "../harp-mapview/lib/ElevationRangeSource.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/ElevationRangeSource.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Status of the elevation range calculation.
 */
var CalculationStatus;
(function (CalculationStatus) {
    // Calculated approximately. A more precise result may be available later.
    CalculationStatus[CalculationStatus["PendingApproximate"] = 0] = "PendingApproximate";
    // Calculation completed. The result is final, won't improve upon retrying.
    CalculationStatus[CalculationStatus["FinalPrecise"] = 1] = "FinalPrecise";
})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));


/***/ }),

/***/ "../harp-mapview/lib/FrustumIntersection.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/FrustumIntersection.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geometry_1 = __webpack_require__(/*! @here/harp-geometry */ "../harp-geometry/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ "../harp-mapview/lib/ElevationRangeSource.ts");
const MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ "../harp-mapview/lib/MapTileCuller.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Represents a unique TileKey and the area it takes up on screen.
 *
 * Note, in certain tiling projections, it is possible to have an offset, which represents a tile
 * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which
 * don't require it.
 */
class TileKeyEntry {
    constructor(tileKey, area, offset = 0) {
        this.tileKey = tileKey;
        this.area = area;
        this.offset = offset;
    }
}
exports.TileKeyEntry = TileKeyEntry;
function getGeoBox(tilingScheme, childTileKey, offset) {
    const geoBox = tilingScheme.getGeoBox(childTileKey);
    const longitudeOffset = 360.0 * offset;
    geoBox.northEast.longitude += longitudeOffset;
    geoBox.southWest.longitude += longitudeOffset;
    return geoBox;
}
/**
 * Computes the tiles intersected by the frustum defined by the current camera setup.
 */
class FrustumIntersection {
    constructor(m_camera, m_projection, m_extendedFrustumCulling, m_tileWrappingEnabled) {
        this.m_camera = m_camera;
        this.m_projection = m_projection;
        this.m_extendedFrustumCulling = m_extendedFrustumCulling;
        this.m_tileWrappingEnabled = m_tileWrappingEnabled;
        this.m_frustum = new THREE.Frustum();
        // used to project global coordinates into camera local coordinates
        this.m_viewProjectionMatrix = new THREE.Matrix4();
        this.m_rootTileKeys = [];
        this.m_tileKeyEntries = new Map();
        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);
    }
    /**
     * Updates the frustum to match the current camera setup.
     */
    updateFrustum() {
        this.m_viewProjectionMatrix.multiplyMatrices(this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
        this.m_frustum.setFromMatrix(this.m_viewProjectionMatrix);
        if (this.m_extendedFrustumCulling) {
            this.m_mapTileCuller.setup();
        }
        this.computeRequiredInitialRootTileKeys(this.m_camera.position);
    }
    /**
     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].
     *
     * @param tilingScheme The tiling scheme used to generate the tiles.
     * @param maxTileLevel The maximum tile level that will be checked for intersections.
     * @param elevationRangeSource Source of elevation range data if any.
     * @returns The computation result, see [[FrustumIntersection.Result]].
     */
    compute(tilingScheme, maxTileLevel, elevationRangeSource) {
        this.m_tileKeyEntries.clear();
        let calculationFinal = true;
        for (const item of this.m_rootTileKeys) {
            this.m_tileKeyEntries.set(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(item.tileKey, item.offset), new TileKeyEntry(item.tileKey, Infinity, item.offset));
        }
        const useElevationRangeSource = elevationRangeSource !== undefined &&
            elevationRangeSource.getTilingScheme() === tilingScheme;
        const tileBounds = new THREE.Box3();
        const workList = [...this.m_rootTileKeys];
        while (workList.length > 0) {
            const tileEntry = workList.pop();
            if (tileEntry === undefined) {
                continue;
            }
            const tileKey = tileEntry.tileKey;
            const uniqueKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, tileEntry.offset);
            const cachedTileEntry = this.m_tileKeyEntries.get(uniqueKey);
            harp_utils_1.assert(cachedTileEntry !== undefined);
            harp_utils_1.assert(cachedTileEntry.area > 0);
            if (tileKey.level > maxTileLevel) {
                continue;
            }
            for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                const offset = tileEntry.offset;
                const tileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
                harp_utils_1.assert(this.m_tileKeyEntries.get(tileKeyAndOffset) === undefined);
                const geoBox = getGeoBox(tilingScheme, childTileKey, offset);
                if (useElevationRangeSource) {
                    const range = elevationRangeSource.getElevationRange(childTileKey);
                    geoBox.southWest.altitude = range.minElevation;
                    geoBox.northEast.altitude = range.maxElevation;
                    calculationFinal =
                        calculationFinal &&
                            range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;
                }
                let subTileArea = 0;
                if (this.m_projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                    const obb = new harp_geometry_1.OrientedBox3();
                    this.m_projection.projectBox(geoBox, obb);
                    if (obb.intersects(this.m_frustum)) {
                        subTileArea = 1;
                    }
                }
                else {
                    this.m_projection.projectBox(geoBox, tileBounds);
                    subTileArea = this.computeSubTileArea(tileBounds);
                }
                if (subTileArea > 0) {
                    const subTileEntry = new TileKeyEntry(childTileKey, subTileArea, offset);
                    this.m_tileKeyEntries.set(tileKeyAndOffset, subTileEntry);
                    workList.push(subTileEntry);
                }
            }
        }
        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal };
    }
    // Computes the rough screen area of the supplied box.
    // TileBounds must be in world space.
    computeSubTileArea(tileBounds) {
        if ((!this.m_extendedFrustumCulling ||
            this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) &&
            this.m_frustum.intersectsBox(tileBounds)) {
            const contour = [
                new THREE.Vector3(tileBounds.min.x, tileBounds.min.y, 0).applyMatrix4(this.m_viewProjectionMatrix),
                new THREE.Vector3(tileBounds.max.x, tileBounds.min.y, 0).applyMatrix4(this.m_viewProjectionMatrix),
                new THREE.Vector3(tileBounds.max.x, tileBounds.max.y, 0).applyMatrix4(this.m_viewProjectionMatrix),
                new THREE.Vector3(tileBounds.min.x, tileBounds.max.y, 0).applyMatrix4(this.m_viewProjectionMatrix)
            ];
            contour.push(contour[0]);
            const n = contour.length;
            let subTileArea = 0;
            for (let p = n - 1, q = 0; q < n; p = q++) {
                subTileArea += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return Math.abs(subTileArea * 0.5);
        }
        return 0;
    }
    /**
     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0
     * and have an offset (see [[Tile]]) based on:
     * - the current position [[worldCenter]].
     * - the height of the camera above the world.
     * - the field of view of the camera (the maximum value between the horizontal / vertical
     *   values)
     * - the tilt of the camera (because we see more tiles when tilted).
     *
     * @param worldCenter The center of the camera in world space.
     */
    computeRequiredInitialRootTileKeys(worldCenter) {
        this.m_rootTileKeys = [];
        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);
        const tileWrappingEnabled = this.m_projection.type === harp_geoutils_1.ProjectionType.Planar;
        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, 0));
            return;
        }
        const worldGeoPoint = this.m_projection.unprojectPoint(worldCenter);
        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);
        // This algorithm computes the number of offsets we need to test. The following diagram may
        // help explain the algorithm below.
        //
        //   |🎥
        //   |.\ .
        //   | . \  .
        // z |  .  \   .c2
        //   |  c1.  \b    .
        //   |     .   \      .
        //___|a___d1.____\e______.d2______f
        //
        // Where:
        // - 🎥 is the camera
        // - z is the height of the camera above the ground.
        // - a is a right angle.
        // - b is the look at vector of the camera.
        // - c1 and c2 are the frustum planes of the camera.
        // - c1 to c2 is the fov.
        // - d1 and d2 are the intersection points of the frustum with the world plane.
        // - e is the tilt/pitch of the camera.
        // - f is the world
        //
        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it
        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).
        // To find e->d2, we use the right triangle 🎥, a, d2 and subtract the distance a->d2 with
        // a->e.
        // a->d2 is found using the angle between a and d2 from the 🎥, this is simply e (because of
        // similar triangles, angle between a, 🎥 and e equals the tilt) + half of the fov (because
        // we need the angle between e, 🎥 and d2) and using trigonometry, result is therefore:
        // (tan(a->d2) * z).
        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).
        const camera = this.m_camera;
        const cameraPitch = Utils_1.MapViewUtils.extractYawPitchRoll(camera.quaternion, this.m_projection.type).pitch;
        // Ensure that the aspect is >= 1.
        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.
        const totalAngleRad = harp_geoutils_1.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;
        // Length a->d2
        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
        // Length a->e
        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
        // Length e -> d2
        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
        const worldLeftGeoPoint = this.m_projection.unprojectPoint(worldLeftPoint);
        // We multiply by SQRT2 because we need to account for a rotated view (in which case there
        // are more tiles that can be seen).
        const offsetRange = harp_geoutils_1.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 
        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift
        // value which is used currently in the [[VisibleTileSet]] methods) hence we can have a
        // maximum range of 7 (because 2*7+1 = 15).
        7);
        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, 0, offset));
        }
    }
}
exports.FrustumIntersection = FrustumIntersection;


/***/ }),

/***/ "../harp-mapview/lib/MapTileCuller.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/MapTileCuller.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Second step tile culling: Do additional check for intersection of box and frustum by checking if
 * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of
 * the standard frustum test, which excludes many cases where the large terrain tiles straddle the
 * planes of the frustum.
 *
 * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm
 */
class MapTileCuller {
    /**
     * Constructs a `MapTileCuller`.
     *
     * @param m_camera A `THREE.Camera`.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_globalFrustumMin = new THREE.Vector3();
        this.m_globalFrustumMax = new THREE.Vector3();
        this.m_frustumCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
    }
    /**
     * Sets up culling and computes frustum corners. You mus call this function before the culling
     * starts.
     */
    setup() {
        const frustumCorners = this.getFrustumCorners();
        const matrix = this.m_camera.matrixWorld;
        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (const frustumCorner of frustumCorners) {
            frustumCorner.applyMatrix4(matrix);
            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
        }
    }
    /**
     * Checks if the tile's bounding box intersects with the current view's frustum.
     *
     * @param tileBounds The bounding box for the tile.
     */
    frustumIntersectsTileBox(tileBounds) {
        const globalFrustumMin = this.m_globalFrustumMin;
        const globalFrustumMax = this.m_globalFrustumMax;
        if (globalFrustumMax.x < tileBounds.min.x ||
            globalFrustumMax.y < tileBounds.min.y ||
            globalFrustumMax.z < tileBounds.min.z ||
            globalFrustumMin.x > tileBounds.max.x ||
            globalFrustumMin.y > tileBounds.max.y ||
            globalFrustumMin.z > tileBounds.max.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the eight corners of the frustum.
     */
    getFrustumCorners() {
        const frustumCorners = this.m_frustumCorners;
        const invProjMatrix = this.m_camera.projectionMatrixInverse;
        let cornerIndex = 0;
        function addPoint(x, y, z) {
            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
        }
        const w = 1;
        const h = 1;
        const n = -1;
        const f = 1;
        // near
        addPoint(-w, -h, n);
        addPoint(w, -h, n);
        addPoint(-w, h, n);
        addPoint(w, h, n);
        // far
        addPoint(-w, -h, f);
        addPoint(w, -h, f);
        addPoint(-w, h, f);
        addPoint(w, h, f);
        return frustumCorners;
    }
}
exports.MapTileCuller = MapTileCuller;


/***/ }),

/***/ "../harp-mapview/lib/MapView.ts":
/*!**************************************!*\
  !*** ../harp-mapview/lib/MapView.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "../harp-mapview/lib/BackgroundDataSource.ts");
const CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ "../harp-mapview/lib/CameraMovementDetector.ts");
const ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ "../harp-mapview/lib/ClipPlanesEvaluator.ts");
const composing_1 = __webpack_require__(/*! ./composing */ "../harp-mapview/lib/composing/index.ts");
const ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "../harp-mapview/lib/CopyrightInfo.ts");
const FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ "../harp-mapview/lib/FrustumIntersection.ts");
const overlayOnElevation_1 = __webpack_require__(/*! ./geometry/overlayOnElevation */ "../harp-mapview/lib/geometry/overlayOnElevation.ts");
const PhasedTileGeometryManager_1 = __webpack_require__(/*! ./geometry/PhasedTileGeometryManager */ "../harp-mapview/lib/geometry/PhasedTileGeometryManager.ts");
const TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ "../harp-mapview/lib/geometry/TileGeometryManager.ts");
const MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts");
const MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ "../harp-mapview/lib/MapViewFog.ts");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ "../harp-mapview/lib/poi/PoiManager.ts");
const PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ "../harp-mapview/lib/poi/PoiTableManager.ts");
const ScreenCollisions_1 = __webpack_require__(/*! ./ScreenCollisions */ "../harp-mapview/lib/ScreenCollisions.ts");
const ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ "../harp-mapview/lib/ScreenProjector.ts");
const SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ "../harp-mapview/lib/SkyBackground.ts");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const TextStyleCache_1 = __webpack_require__(/*! ./text/TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "../harp-mapview/lib/ThemeHelpers.ts");
const ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ "../harp-mapview/lib/VisibleTileSet.ts");
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
var MapViewEventNames;
(function (MapViewEventNames) {
    /** Called before this `MapView` starts to render a new frame. */
    MapViewEventNames["Update"] = "update";
    /** Called when the WebGL canvas is resized. */
    MapViewEventNames["Resize"] = "resize";
    /** Called when the frame is about to be rendered. */
    MapViewEventNames["Render"] = "render";
    /** Called after a frame has been rendered. */
    MapViewEventNames["AfterRender"] = "didrender";
    /** Called after the first frame has been rendered. */
    MapViewEventNames["FirstFrame"] = "first-render";
    /** Called when the first view has all the necessary tiles loaded and rendered. */
    MapViewEventNames["FrameComplete"] = "frame-complete";
    /** Called when the theme has been loaded with the internal [[ThemeLoader]]. */
    MapViewEventNames["ThemeLoaded"] = "theme-loaded";
    /** Called when the animation mode has started. */
    MapViewEventNames["AnimationStarted"] = "animation-started";
    /** Called when the animation mode has stopped. */
    MapViewEventNames["AnimationFinished"] = "animation-finished";
    /** Called when a camera interaction has been detected. */
    MapViewEventNames["MovementStarted"] = "movement-started";
    /** Called when a camera interaction has been stopped. */
    MapViewEventNames["MovementFinished"] = "movement-finished";
    /** Called when a data source has been connected or failed to connect. */
    MapViewEventNames["DataSourceConnect"] = "datasource-connect";
    /** Emitted when copyright info of rendered map has been changed. */
    MapViewEventNames["CopyrightChanged"] = "copyright-changed";
    /** Called when the WebGL context is lost. */
    MapViewEventNames["ContextLost"] = "webglcontext-lost";
    /** Called when the WebGL context is restored. */
    MapViewEventNames["ContextRestored"] = "webglcontext-restored";
    /** Called when camera position has been changed. */
    MapViewEventNames["CameraPositionChanged"] = "camera-changed";
})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
const DEFAULT_FONT_CATALOG = "./resources/fonts/Default_FontCatalog.json";
const DEFAULT_CLEAR_COLOR = 0xefe9e1;
const DEFAULT_FOV_CALCULATION = { type: "dynamic", fov: 40 };
const MAX_FIELD_OF_VIEW = 140;
const MIN_FIELD_OF_VIEW = 10;
const DEFAULT_MIN_ZOOM_LEVEL = 1;
/**
 * Default maximum zoom level.
 */
const DEFAULT_MAX_ZOOM_LEVEL = 20;
/**
 * Default minimum camera height.
 */
const DEFAULT_MIN_CAMERA_HEIGHT = 20;
/**
 * Amount of framerate values to pick average from
 */
const FRAME_RATE_RING_SIZE = 12;
/**
 * Default starting value for FPS computation.
 */
const FALLBACK_FRAME_RATE = 30;
/**
 * Zoom level to request terrain tiles for getting the height of the camera above terrain.
 */
const TERRAIN_ZOOM_LEVEL = 4;
// Event type: cast needed to workaround wrong THREE.js typings.
const RENDER_EVENT = { type: MapViewEventNames.Render };
const DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };
const FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };
const FRAME_COMPLETE_EVENT = { type: MapViewEventNames.FrameComplete };
const THEME_LOADED_EVENT = { type: MapViewEventNames.ThemeLoaded };
const ANIMATION_STARTED_EVENT = { type: MapViewEventNames.AnimationStarted };
const ANIMATION_FINISHED_EVENT = { type: MapViewEventNames.AnimationFinished };
const MOVEMENT_STARTED_EVENT = { type: MapViewEventNames.MovementStarted };
const MOVEMENT_FINISHED_EVENT = { type: MapViewEventNames.MovementFinished };
const CONTEXT_LOST_EVENT = { type: MapViewEventNames.ContextLost };
const CONTEXT_RESTORED_EVENT = { type: MapViewEventNames.ContextRestored };
const COPYRIGHT_CHANGED_EVENT = { type: MapViewEventNames.CopyrightChanged };
const tmpVector = new THREE.Vector2();
/**
 * Hint for the WebGL implementation on which power mode to prefer.
 *
 * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12
 */
var MapViewPowerPreference;
(function (MapViewPowerPreference) {
    /** Default value. */
    MapViewPowerPreference["Default"] = "default";
    /** Lower power mode, used to conserve energy. */
    MapViewPowerPreference["LowPower"] = "low-power";
    /** Maximum performance. */
    MapViewPowerPreference["HighPerformance"] = "high-performance";
})(MapViewPowerPreference = exports.MapViewPowerPreference || (exports.MapViewPowerPreference = {}));
/**
 * Default settings used by [[MapView]] collected in one place.
 */
exports.MapViewDefaults = {
    projection: harp_geoutils_1.mercatorProjection,
    clipPlanesEvaluator: ClipPlanesEvaluator_1.defaultClipPlanesEvaluator,
    maxVisibleDataSourceTiles: 120,
    extendedFrustumCulling: true,
    tileCacheSize: 20,
    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,
    quadTreeSearchDistanceUp: 3,
    quadTreeSearchDistanceDown: 2,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== undefined
        ? window.devicePixelRatio
        : 1.0
};
/**
 * The core class of the library to call in order to create a map visualization. It needs to be
 * linked to datasources.
 */
class MapView extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapView` with the given options or canvas element.
     *
     * @param options The `MapView` options or the HTML canvas element used to display the map.
     */
    constructor(options) {
        super();
        /**
         * The string of the default font catalog to use for labelling.
         */
        this.defaultFontCatalog = DEFAULT_FONT_CATALOG;
        this.dumpNext = false;
        /**
         * Allows discarding the text rendering after the map rendering.
         */
        this.renderLabels = true;
        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();
        this.m_visibleTileSetLock = false;
        this.m_tileWrappingEnabled = true;
        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;
        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;
        this.m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);
        /**
         * Relative to eye camera.
         *
         * This camera is internal camera used to improve precision
         * when rendering geometries.
         */
        this.m_rteCamera = new THREE.PerspectiveCamera();
        this.m_scene = new THREE.Scene();
        this.m_fog = new MapViewFog_1.MapViewFog(this.m_scene);
        this.m_mapTilesRoot = new THREE.Object3D();
        this.m_mapAnchors = new THREE.Object3D();
        this.m_animationCount = 0;
        this.m_drawing = false;
        this.m_updatePending = false;
        this.m_frameNumber = 0;
        this.m_maxFps = 0;
        this.m_detectedFps = FALLBACK_FRAME_RATE;
        this.m_textRenderStyleCache = new TextStyleCache_1.TextRenderStyleCache();
        this.m_textLayoutStyleCache = new TextStyleCache_1.TextLayoutStyleCache();
        this.m_overlayTextElements = [];
        this.m_forceCameraAspect = undefined;
        //
        // sources
        //
        this.m_tileDataSources = [];
        this.m_connectedDataSources = new Set();
        this.m_failedDataSources = new Set();
        // gestures
        this.m_raycaster = new THREE.Raycaster();
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        this.m_theme = {};
        this.m_firstFrameRendered = false;
        this.m_firstFrameComplete = false;
        this.m_frameTimeIndex = 0;
        this.m_frameTimeRing = [];
        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache(this);
        this.m_poiManager = new PoiManager_1.PoiManager(this);
        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);
        this.m_lastTileIds = "";
        this.m_copyrightInfo = [];
        /**
         * Default handler for webglcontextlost event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextLost = (event) => {
            this.dispatchEvent(CONTEXT_LOST_EVENT);
            logger.log("WebGL context lost", event);
        };
        /**
         * Default handler for webglcontextrestored event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextRestored = (event) => {
            this.dispatchEvent(CONTEXT_RESTORED_EVENT);
            if (this.m_renderer !== undefined) {
                if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {
                    this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));
                }
                else {
                    this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
                }
                this.update();
            }
            logger.log("WebGL context restored", event);
        };
        // make a copy to avoid unwanted changes to the original options.
        this.m_options = Object.assign({}, options);
        if (this.m_options.minZoomLevel !== undefined) {
            this.m_minZoomLevel = this.m_options.minZoomLevel;
        }
        if (this.m_options.maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = this.m_options.maxZoomLevel;
        }
        if (this.m_options.minCameraHeight !== undefined) {
            this.m_minCameraHeight = this.m_options.minCameraHeight;
        }
        if (this.m_options.fontCatalog !== undefined) {
            this.defaultFontCatalog = this.m_options.fontCatalog;
        }
        if (this.m_options.decoderUrl !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_options.decoderUrl;
        }
        if (this.m_options.decoderCount !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;
        }
        this.m_visibleTileSetOptions = Object.assign({}, exports.MapViewDefaults);
        if (options.projection !== undefined) {
            this.m_visibleTileSetOptions.projection = options.projection;
        }
        if (options.clipPlanesEvaluator !== undefined) {
            this.m_visibleTileSetOptions.clipPlanesEvaluator = options.clipPlanesEvaluator;
        }
        if (options.extendedFrustumCulling !== undefined) {
            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
        }
        if (options.maxVisibleDataSourceTiles !== undefined) {
            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =
                options.maxVisibleDataSourceTiles;
        }
        if (options.tileCacheSize !== undefined) {
            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
        }
        if (options.resourceComputationType !== undefined) {
            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
        }
        if (options.quadTreeSearchDistanceUp !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =
                options.quadTreeSearchDistanceUp;
        }
        if (options.quadTreeSearchDistanceDown !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =
                options.quadTreeSearchDistanceDown;
        }
        this.m_pixelRatio = options.pixelRatio;
        if (options.maxFps !== undefined) {
            this.m_maxFps = Math.max(0, options.maxFps);
        }
        this.m_options.enableStatistics = this.m_options.enableStatistics === true;
        this.m_languages = this.m_options.languages;
        if (!isProduction &&
            this.m_options.collisionDebugCanvas !== undefined &&
            this.m_options.collisionDebugCanvas !== null) {
            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;
            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_collisionDebugCanvas);
        }
        this.handleRequestAnimationFrame = this.renderFunc.bind(this);
        this.handlePostponedAnimationFrame = this.postponedAnimationFrame.bind(this);
        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enableRoadPicking === true);
        if (this.m_options.tileWrappingEnabled !== undefined) {
            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;
        }
        // Initialization of the stats
        this.setupStats(this.m_options.enableStatistics);
        this.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.addEventListener("webglcontextrestored", this.onWebGLContextRestored);
        // Initialization of the renderer
        this.m_renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: this.m_options.enableNativeWebglAntialias === undefined
                ? this.pixelRatio < 2.0
                : this.m_options.enableNativeWebglAntialias,
            alpha: this.m_options.alpha,
            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,
            powerPreference: this.m_options.powerPreference === undefined
                ? MapViewPowerPreference.Default
                : this.m_options.powerPreference
        });
        this.m_renderer.autoClear = false;
        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info
        // When using several WebGLRenderer#render calls per frame, it is the only way to get
        // correct rendering data from ThreeJS.
        this.m_renderer.info.autoReset = false;
        this.setupRenderer();
        this.m_options.fovCalculation =
            this.m_options.fovCalculation === undefined
                ? DEFAULT_FOV_CALCULATION
                : this.m_options.fovCalculation;
        this.m_options.fovCalculation.fov = harp_geoutils_1.MathUtils.clamp(this.m_options.fovCalculation.fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        // Initialization of mCamera and mVisibleTiles
        const { width, height } = this.getCanvasClientSize();
        const aspect = width / height;
        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, 0.1, 4000000);
        this.m_camera.up.set(0, 0, 1);
        this.m_lookAtDistance = 0;
        this.m_focalLength = 0;
        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.
        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);
        this.setupCamera();
        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());
        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;
        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
        this.m_tileGeometryManager =
            this.m_options.enablePhasedLoading === false
                ? new TileGeometryManager_1.SimpleTileGeometryManager(this)
                : new PhasedTileGeometryManager_1.PhasedTileGeometryManager(this);
        this.m_visibleTiles = new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this.m_visibleTileSetOptions.projection, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled), this.m_tileGeometryManager, this.m_visibleTileSetOptions);
        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);
        this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();
        this.addDataSource(this.m_backgroundDataSource);
        if (options.backgroundTilingScheme !== undefined) {
            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);
        }
        this.initTheme();
        this.drawFrame();
    }
    /**
     * @hidden
     * The [[TextElementsRenderer]] select the visible [[TextElement]]s and renders them.
     */
    get textElementsRenderer() {
        return this.m_textElementsRenderer;
    }
    /**
     * @hidden
     * The [[TextRenderStyleCache]] used for this instance of `MapView`.
     */
    get textRenderStyleCache() {
        return this.m_textRenderStyleCache;
    }
    /**
     * @hidden
     * The [[TextLayoutStyleCache]] used for this instance of `MapView`.
     */
    get textLayoutStyleCache() {
        return this.m_textLayoutStyleCache;
    }
    /**
     * @hidden
     * The [[CameraMovementDetector]] detects camera movements. Made available for performance
     * measurements.
     */
    get cameraMovementDetector() {
        return this.m_movementDetector;
    }
    /**
     * The [[AnimatedExtrusionHandler]] controls animated extrusion effect
     * of the extruded objects in the [[Tile]]
     */
    get animatedExtrusionHandler() {
        return this.m_animatedExtrusionHandler;
    }
    /**
     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of
     * specified [[GeometryKind]]s.
     */
    get tileGeometryManager() {
        return this.m_tileGeometryManager;
    }
    /**
     * Disposes this `MapView`.
     *
     * This function cleans the resources that are managed manually including those that exist in
     * shared caches.
     *
     * Note: This function does not try to clean objects that can be disposed off easily by
     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full
     * cleanup, you must ensure that all references to this `MapView` are removed.
     */
    dispose() {
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.canvas.removeEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.removeEventListener("webglcontextrestored", this.onWebGLContextRestored);
        for (const dataSource of this.m_tileDataSources) {
            dataSource.dispose();
        }
        this.m_visibleTiles.clearTileCache();
        this.m_renderer.dispose();
        this.m_imageCache.clear();
        this.m_movementDetector.dispose();
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_visibleTiles.resourceComputationType;
    }
    set resourceComputationType(value) {
        this.m_visibleTiles.resourceComputationType = value;
    }
    /**
     * Returns the cache size.
     */
    getCacheSize() {
        return this.m_visibleTiles.getDataSourceCacheSize();
    }
    /**
     * Sets the cache size in number of tiles.
     *
     * @param size The cache size in tiles.
     * @param numVisibleTiles The number of tiles visible, which is size/2 by default.
     */
    setCacheSize(size, numVisibleTiles) {
        this.m_visibleTiles.setDataSourceCacheSize(size);
        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;
        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));
        this.updateImages();
        this.updateLighting();
        this.updateTextRenderer();
        this.updateSkyBackground();
        this.update();
    }
    /**
     * Specfies whether extended frustum culling is enabled or disabled.
     */
    get extendedFrustumCulling() {
        return this.m_options.extendedFrustumCulling !== undefined
            ? this.m_visibleTileSetOptions.extendedFrustumCulling
            : true;
    }
    /**
     * Enable of disable extended frustum culling.
     */
    set extendedFrustumCulling(value) {
        this.m_visibleTileSetOptions.extendedFrustumCulling = value;
    }
    /**
     * Returns the status of frustum culling after each update.
     */
    get lockVisibleTileSet() {
        return this.m_visibleTileSetLock;
    }
    /**
     * Enable of disable frustum culling after each update.
     */
    set lockVisibleTileSet(value) {
        this.m_visibleTileSetLock = value;
    }
    /**
     * Gets the optional camera used to render the scene.
     */
    get pointOfView() {
        return this.m_pointOfView;
    }
    /**
     * Sets the optional camera used to render the scene.
     */
    set pointOfView(pointOfView) {
        this.m_pointOfView = pointOfView;
        this.update();
    }
    /**
     * Loads a post effects definition file.
     *
     * @param postEffectsFile File URL describing the post effects.
     */
    loadPostEffects(postEffectsFile) {
        fetch(postEffectsFile)
            .then(response => response.json())
            .then((postEffects) => {
            this.m_postEffects = postEffects;
            this.setPostEffects();
        });
    }
    /**
     * The abstraction of the [[MapRenderingManager]] API for post effects.
     */
    get postEffects() {
        return this.m_postEffects;
    }
    set postEffects(postEffects) {
        this.m_postEffects = postEffects;
        this.setPostEffects();
    }
    /**
     * Gets the current `Theme` used by this `MapView` to style map elements.
     */
    get theme() {
        return this.m_theme;
    }
    /**
     * Changes the `Theme` used by this `MapView` to style map elements.
     */
    set theme(theme) {
        if (!ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {
            // If theme is not yet loaded, let's set theme asynchronously
            ThemeLoader_1.ThemeLoader.load(theme)
                .then(loadedTheme => {
                this.theme = loadedTheme;
            })
                .catch(error => {
                logger.error(`failed to set theme: ${error}`, error);
            });
            return;
        }
        // Fog and sky.
        this.m_theme.fog = theme.fog;
        this.m_theme.sky = theme.sky;
        this.updateSkyBackground();
        this.m_fog.reset(this.m_theme);
        this.m_theme.lights = theme.lights;
        this.updateLighting();
        // Clear color.
        this.m_theme.clearColor = theme.clearColor;
        this.renderer.setClearColor(new THREE.Color(theme.clearColor));
        // Images.
        this.m_theme.images = theme.images;
        this.m_theme.imageTextures = theme.imageTextures;
        this.updateImages();
        // POI tables.
        this.m_theme.poiTables = theme.poiTables;
        this.loadPoiTables();
        // Text.
        this.m_theme.textStyles = theme.textStyles;
        this.m_theme.defaultTextStyle = theme.defaultTextStyle;
        this.m_theme.fontCatalogs = theme.fontCatalogs;
        this.m_textRenderStyleCache.clear();
        this.m_textLayoutStyleCache.clear();
        this.updateTextRenderer();
        if (this.m_theme.styles === undefined) {
            this.m_theme.styles = {};
        }
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (theme.styles[styleSetName] !== undefined) {
                    const styleSet = theme.styles[styleSetName];
                    this.getDataSourcesByStyleSetName(styleSetName).forEach(ds => ds.setStyleSet(styleSet));
                    this.m_theme.styles[styleSetName] = styleSet;
                }
            }
        }
        this.dispatchEvent(THEME_LOADED_EVENT);
        this.update();
    }
    /**
     * Gets the value of the forced custom camera aspect.
     * Every time a frame is rendered, `MapView` resets the camera aspect.
     *
     * You can disable this behavior by setting the value to `undefined`.
     */
    get forceCameraAspect() {
        return this.m_forceCameraAspect;
    }
    /**
     * Sets the custom forced camera aspect ratio to use while rendering.
     */
    set forceCameraAspect(aspect) {
        this.m_forceCameraAspect = aspect;
    }
    /**
     * Maximum FPS. If defined (and > 0) it is the maximum FPS that is used.
     */
    set maxFps(fps) {
        this.m_maxFps = Math.max(0, fps);
    }
    get maxFps() {
        return Math.max(0, this.m_maxFps);
    }
    /**
     * Lists the ISO 639-1 language codes for DataSources to use.
     */
    get languages() {
        return this.m_languages;
    }
    /**
     * Sets the list of ISO 639-1 language codes for DataSources to use.
     */
    set languages(languages) {
        this.m_languages = languages;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setLanguages(this.m_languages);
        });
        this.clearTileCache();
        this.update();
    }
    get copyrightInfo() {
        return this.m_copyrightInfo;
    }
    /**
     * @hidden
     * Return if all fading animations (for debugging and performance measurement) should be
     * disabled.
     */
    get fadingDisabled() {
        return this.m_options.disableFading === true;
    }
    /**
     * @hidden
     * Return current frame number.
     */
    get frameNumber() {
        return this.m_frameNumber;
    }
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get canvas() {
        return this.m_options.canvas;
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get collisionDebugCanvas() {
        return this.m_collisionDebugCanvas;
    }
    /**
     * The THREE.js scene used by this `MapView`.
     */
    get scene() {
        return this.m_scene;
    }
    /**
     * The THREE.js camera used by this `MapView` to render the main scene.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * The THREE.js `WebGLRenderer` used by this scene.
     */
    get renderer() {
        return this.m_renderer;
    }
    /**
     * The color used to clear the view.
     */
    get clearColor() {
        const rendererClearColor = this.m_renderer.getClearColor();
        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
    }
    /**
     * The color used to clear the view.
     */
    set clearColor(color) {
        this.m_renderer.setClearColor(color);
    }
    /**
     * The projection used to project geo coordinates to world coordinates.
     */
    get projection() {
        return this.m_visibleTileSetOptions.projection;
    }
    /**
     * Changes the projection at run time.
     *
     * TODO: There seems to be some issue with the sphere projection, when changing from this
     * projection to a planar projection, the map is rotated. This needs to be fixed.
     */
    set projection(projection) {
        // The geo center must be reset when changing the projection, because the
        // camera's position is based on the projected geo center.
        const geoCenter = this.geoCenter;
        this.m_visibleTileSetOptions.projection = projection;
        this.clearTileCache();
        // We reset the theme, this has the affect of ensuring all caches are cleared.
        this.theme = this.theme;
        this.geoCenter = geoCenter;
        // Necessary for the sphereProjection, however this also resets the camera position, so it
        // should be fixed.
        //this.setupCamera();
    }
    /**
     * Get camera clipping planes evaluator used.
     */
    get clipPlanesEvaluator() {
        return this.m_visibleTileSetOptions.clipPlanesEvaluator;
    }
    /**
     * Changes the clip planes evaluator at run time.
     */
    set clipPlanesEvaluator(clipPlanesEvaluator) {
        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;
    }
    /**
     * The distance (in pixels) between the screen and the camera.
     */
    get focalLength() {
        return this.m_focalLength;
    }
    /**
     * Get distance from camera to the point of focus in world units.
     */
    get lookAtDistance() {
        return this.m_lookAtDistance;
    }
    /**
     * The position in geo coordinates of the center of the scene.
     */
    get geoCenter() {
        return this.projection.unprojectPoint(this.m_camera.position).normalized();
    }
    /**
     * The position in geo coordinates of the center of the scene.
     * Longitude values outside of -180 and +180 are acceptable.
     */
    set geoCenter(geoCenter) {
        if (geoCenter.altitude !== undefined) {
            this.projection.projectPoint(geoCenter, this.m_camera.position);
        }
        else {
            // Preserve the current altitude
            const altitude = this.geoCenter.altitude;
            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
        }
        this.update();
    }
    /**
     * The node in this MapView's scene containing the user [[MapAnchor]]s.
     * All (first level) children of this node will be positioned in world space according to the
     * [[MapAnchor.geoPosition]].
     * Deeper level children can be used to position custom objects relative to the anchor node.
     */
    get mapAnchors() {
        return this.m_mapAnchors;
    }
    /**
     * The position in world coordinates of the center of the scene.
     */
    get worldCenter() {
        return this.m_camera.position;
    }
    /**
     * The root object of the scene. Contains all `rootObjects` of the [[Tile]]s.
     */
    get worldRootObject() {
        return this.m_mapTilesRoot;
    }
    /**
     * Get the [[PickHandler]] for this `mapView`.
     */
    get pickHandler() {
        return this.m_pickHandler;
    }
    /**
     * Get the [[ImageCache]] that belongs to this `MapView`.
     */
    get imageCache() {
        return this.m_imageCache;
    }
    /**
     * @hidden
     * Get the [[PoiManager]] that belongs to this `MapView`.
     */
    get poiManager() {
        return this.m_poiManager;
    }
    /**
     * @hidden
     * Get the array of [[PoiTableManager]] that belongs to this `MapView`.
     */
    get poiTableManager() {
        return this.m_poiTableManager;
    }
    /**
     * The minimum camera height in meters.
     */
    get minCameraHeight() {
        return this.m_minCameraHeight;
    }
    /**
     * The minimum zoom level.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * The minimum zoom level.
     */
    set minZoomLevel(zoomLevel) {
        this.m_minZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * The maximum zoom level. Default is 14.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    /**
     * The maximum zoom level.
     */
    set maxZoomLevel(zoomLevel) {
        this.m_maxZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * Returns the zoom level for the given camera setup.
     */
    get zoomLevel() {
        return this.m_zoomLevel;
    }
    /**
     * Returns the storage level for the given camera setup.
     * Actual storage level of the rendered data also depends on [[DataSource.storageLevelOffset]].
     */
    get storageLevel() {
        return THREE.Math.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns height of the viewport in pixels.
     */
    get viewportHeight() {
        return this.canvas.height;
    }
    /**
     * Returns `true` if the native WebGL antialiasing is enabled.
     */
    get nativeWebglAntialiasEnabled() {
        return this.m_options.enableNativeWebglAntialias !== false;
    }
    /**
     * Returns [[DataSource]]s displayed by this `MapView`.
     */
    get dataSources() {
        return this.m_tileDataSources;
    }
    /**
     * Set's the way in which the fov is calculated on the map view. Note, for
     * this to take visual effect, the map should be rendered after calling this
     * function.
     * @param fovCalculation How the FOV is calculated.
     */
    setFovCalculation(fovCalculation) {
        this.m_options.fovCalculation = fovCalculation;
        this.calculateFocalLength(this.m_renderer.getSize(tmpVector).height);
        this.updateCameras();
    }
    /**
     * Returns the unique [[DataSource]] matching the given name.
     */
    getDataSourceByName(dataSourceName) {
        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);
    }
    /**
     * Returns the array of [[DataSource]]s referring to the same [[StyleSet]].
     */
    getDataSourcesByStyleSetName(styleSetName) {
        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);
    }
    /**
     * Returns true if the specified [[DataSource]] is enabled.
     */
    isDataSourceEnabled(dataSource) {
        return (dataSource.enabled &&
            dataSource.ready() &&
            this.m_connectedDataSources.has(dataSource.name));
    }
    /**
     * Adds a new [[DataSource]] to this `MapView`. `MapView` needs at least one [[DataSource]] to
     * display something.
     *
     * @param dataSource The data source.
     */
    addDataSource(dataSource) {
        const twinDataSource = this.getDataSourceByName(dataSource.name);
        if (twinDataSource !== undefined) {
            throw new Error(`A DataSource with the name "${dataSource.name}" already exists in this MapView.`);
        }
        dataSource.attach(this);
        this.m_tileDataSources.push(dataSource);
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
        return dataSource
            .connect()
            .then(() => {
            return new Promise(resolve => {
                if (this.theme !== undefined && this.theme.styles !== undefined) {
                    resolve();
                    return;
                }
                const resolveOnce = () => {
                    this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
                    resolve();
                };
                this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
            });
        })
            .then(() => {
            const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;
            if (alreadyRemoved) {
                return;
            }
            dataSource.addEventListener(MapViewEventNames.Update, () => {
                this.update();
            });
            if (this.m_theme.styles !== undefined && dataSource.styleSetName !== undefined) {
                const styleSet = this.m_theme.styles[dataSource.styleSetName];
                dataSource.setStyleSet(styleSet, this.m_languages);
            }
            this.m_connectedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name
            });
            this.update();
        })
            .catch(error => {
            this.m_failedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name,
                error
            });
        });
    }
    /**
     * Removes [[DataSource]] from this `MapView`.
     *
     * @param dataSource The data source to be removed
     */
    removeDataSource(dataSource) {
        const dsIndex = this.m_tileDataSources.indexOf(dataSource);
        if (dsIndex === -1) {
            return;
        }
        dataSource.detach(this);
        this.m_visibleTiles.removeDataSource(dataSource.name);
        this.m_tileDataSources.splice(dsIndex, 1);
        this.m_connectedDataSources.delete(dataSource.name);
        this.m_failedDataSources.delete(dataSource.name);
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
        this.update();
    }
    /**
     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.
     */
    get visibleTileSet() {
        return this.m_visibleTiles;
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    addOverlayText(textElements) {
        if (this.m_overlayTextElements !== undefined) {
            this.m_overlayTextElements = this.m_overlayTextElements.concat(textElements);
        }
        this.updateTextRenderer();
        this.update();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    clearOverlayText() {
        this.m_overlayTextElements = [];
    }
    /**
     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)
     * to the `target` location, from a certain azimuth (`azimuthAngle`).
     *
     * @param target The location to look at.
     * @param distance The distance of the camera to the target in meters.
     * @param tiltDeg The camera tilt angle in degrees (0 is vertical).
     * @param azimuthDeg The camera azimuth angle in degrees and clockwise, starting north.
     */
    lookAt(target, distance, tiltDeg = 0, azimuthDeg = 0) {
        this.geoCenter = Utils_1.MapViewUtils.getCameraCoordinatesFromTargetCoordinates(target, distance, -azimuthDeg, tiltDeg, this);
        Utils_1.MapViewUtils.setRotation(this, -azimuthDeg, tiltDeg);
        const pitchRad = THREE.Math.degToRad(tiltDeg);
        if (this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.camera.position.setZ(Math.cos(pitchRad) * distance);
        }
        else if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            this.camera.position.setLength(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS + distance);
            // TODO: HARP-6597 and HARP-6023: Support rotation and tilting for yaw and pitch in
            // globe.
        }
    }
    /**
     * Moves the camera to the specified [[GeoCoordinates]], sets the desired `zoomLevel` and
     * adjusts the yaw and pitch.
     *
     * @param geoPos Geolocation to move the camera to.
     * @param zoomLevel Desired zoom level.
     * @param yawDeg Camera yaw in degrees.
     * @param pitchDeg Camera pitch in degrees.
     */
    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {
        this.geoCenter = geoPos;
        // TODO: HARP-6597 and HARP-6023: Support rotation and tilting for yaw and pitch in globe.
        if (this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            Utils_1.MapViewUtils.setRotation(this, yawDeg, pitchDeg);
        }
        else if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_camera.lookAt(this.scene.position);
        }
        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);
        this.update();
    }
    /**
     * Returns `true` if this `MapView` is constantly redrawing the scene.
     */
    get animating() {
        return this.m_animationCount > 0;
    }
    /**
     * Begin animating the scene.
     */
    beginAnimation() {
        if (this.m_animationCount++ === 0) {
            if (!this.m_updatePending) {
                this.m_updatePending = true;
                this.drawFrame();
            }
            ANIMATION_STARTED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_STARTED_EVENT);
        }
    }
    /**
     * Stop animating the scene.
     */
    endAnimation() {
        if (this.m_animationCount > 0) {
            --this.m_animationCount;
        }
        if (this.m_animationCount === 0) {
            ANIMATION_FINISHED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_FINISHED_EVENT);
        }
    }
    /**
     * Returns `true` if the camera moved in the last frame.
     */
    get cameraIsMoving() {
        return this.m_movementDetector.cameraIsMoving;
    }
    /**
     * Returns `true` if the current frame will immediately be followed by another frame.
     */
    get isDynamicFrame() {
        return this.cameraIsMoving || this.animating || this.m_updatePending;
    }
    /**
     * Returns the ratio between a pixel and a world unit for the current camera (in the center of
     * the camera projection).
     */
    get pixelToWorld() {
        if (this.m_pixelToWorld === undefined) {
            // At this point fov calculation should be always defined.
            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
            // NOTE: Look at distance is the distance to camera focus (and pivot) point.
            // In screen space this point is located in the center of canvas.
            // Given that zoom level is not modified (clamped by camera pitch), the following
            // formulas are all equivalent:
            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);
            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);
            // Here we may use precalculated distance (once pre frame):
            const lookAtDistance = this.m_lookAtDistance;
            // Find world space object size that corresponds to one pixel on screen.
            this.m_pixelToWorld = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.m_focalLength, lookAtDistance, 1);
        }
        return this.m_pixelToWorld;
    }
    /**
     * Returns the ratio between a world and a pixel unit for the current camera (in the center of
     * the camera projection).
     */
    get worldToPixel() {
        return 1.0 / this.pixelToWorld;
    }
    get pixelRatio() {
        if (this.m_pixelRatio !== undefined) {
            return this.m_pixelRatio;
        }
        return typeof window !== "undefined" && window.devicePixelRatio !== undefined
            ? window.devicePixelRatio
            : 1.0;
    }
    /**
     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens
     * (HiDPI).
     *
     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value
     * of `1.0` will disable the use of HiDPI on all devices.
     *
     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)
     * they may appear in the wrong size now. To ensure proper display of data, a call to
     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.
     *
     * @memberof MapView
     */
    set pixelRatio(pixelRatio) {
        this.m_pixelRatio = pixelRatio;
        if (this.renderer.getPixelRatio() !== this.pixelRatio) {
            this.renderer.setPixelRatio(this.pixelRatio);
        }
    }
    /**
     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful
     * when rendering on high resolution displays with low performance GPUs that may be
     * fill-rate-limited.
     *
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. Values between 0.5 and
     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger
     * than `window.devicePixelRatio`.
     *
     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`
     * defined, visual artifacts may occur, especially with thin lines..
     *
     * @note The resolution of icons and text labels is not affected.
     *
     * @default `undefined`
     */
    set dynamicPixelRatio(ratio) {
        this.mapRenderingManager.lowResPixelRatio = ratio;
    }
    get dynamicPixelRatio() {
        return this.mapRenderingManager.lowResPixelRatio;
    }
    /**
     * Returns the screen position of the given geo coordinates.
     *
     * @param geoPos The geo coordinates.
     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or
     * `undefined`.
     */
    getScreenPosition(geoPos) {
        const worldPos = new THREE.Vector3();
        this.projection.projectPoint(geoPos, worldPos);
        const p = this.m_screenProjector.project(worldPos);
        if (p !== undefined) {
            const { width, height } = this.getCanvasClientSize();
            p.x = p.x + width / 2;
            p.y = height - (p.y + height / 2);
        }
        return p;
    }
    /**
     * Returns a ray caster using the supplied screen positions.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     *
     * @alpha
     *
     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen
     * points.
     */
    raycasterFromScreenPoint(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);
        return this.m_raycaster;
    }
    /**
     * Returns the world space position from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getWorldPositionAt(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
        const worldPosition = new THREE.Vector3();
        return this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, worldPosition)
            : this.m_raycaster.ray.intersectPlane(this.m_plane, worldPosition);
    }
    /**
     * Returns the [[GeoCoordinates]] from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getGeoCoordinatesAt(x, y) {
        const worldPosition = this.getWorldPositionAt(x, y);
        if (!worldPosition) {
            return null;
        }
        return this.projection.unprojectPoint(worldPosition);
    }
    /**
     * Returns the normalized screen coordinates from the given pixel position.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getNormalizedScreenCoordinates(x, y) {
        // use clientWidth and clientHeight as it does not apply the pixelRatio and
        // therefore supports also HiDPI devices
        const { width, height } = this.getCanvasClientSize();
        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);
    }
    /**
     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that
     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested
     * for intersection.
     *
     * Note, if a [[DataSource]] adds an [[Object3D]] to a [[Tile]], it will be only pickable once
     * [[MapView.render]] has been called, this is because [[MapView.render]] method creates the
     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.
     * This method will not test for intersection custom objects added to the scene by for
     * example calling directly the [[scene.add]] method from THREE.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     * @returns The list of intersection results.
     */
    intersectMapObjects(x, y) {
        return this.m_pickHandler.intersectMapObjects(x, y);
    }
    /**
     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.
     *
     * @param width The new width.
     * @param height The new height.
     */
    resize(width, height) {
        this.m_renderer.setSize(width, height, false);
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        if (this.mapRenderingManager !== undefined) {
            this.mapRenderingManager.setSize(width, height);
        }
        if (this.collisionDebugCanvas !== undefined) {
            this.collisionDebugCanvas.width = width;
            this.collisionDebugCanvas.height = height;
        }
        this.updateCameras();
        this.update();
        this.dispatchEvent({
            type: MapViewEventNames.Resize,
            size: {
                width,
                height
            }
        });
    }
    /**
     * Requests a redraw of the scene.
     */
    update() {
        if (this.m_updatePending) {
            return;
        } // compress the update request
        this.m_updatePending = true;
        if (this.animating) {
            return;
        } // nothing to do
        this.drawFrame();
    }
    /**
     * Returns `true` if an update has already been requested, such that after a currently rendering
     * frame, the next frame will be rendered immediately.
     */
    get updatePending() {
        return this.m_updatePending;
    }
    /**
     * Requests a redraw of the scene.
     * @deprecated Use the [[update]] method instead.
     */
    requestUpdateIfNeeded() {
        this.update();
    }
    /**
     * Clear the tile cache.
     *
     * Remove the [[Tile]] objects created by cacheable [[DataSource]]s. If a [[DataSource]] name is
     * provided, this method restricts the eviction the [[DataSource]] with the given name.
     *
     * @param dataSourceName The name of the [[DataSource]].
     */
    clearTileCache(dataSourceName) {
        this.m_visibleTiles.clearTileCache(dataSourceName);
        if (dataSourceName !== undefined) {
            const dataSource = this.getDataSourceByName(dataSourceName);
            if (dataSource) {
                dataSource.clearCache();
            }
        }
        else {
            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());
        }
        if (this.m_elevationProvider !== undefined) {
            this.m_elevationProvider.clearCache();
        }
    }
    /**
     * Apply visitor to all visible tiles.
     *
     * @param fun Visitor function
     */
    forEachVisibleTile(fun) {
        this.m_visibleTiles.forEachVisibleTile(fun);
    }
    /**
     * Apply a visitor function to all tiles in the cache.
     *
     * @param visitor Visitor function
     */
    forEachCachedTile(visitor) {
        this.m_visibleTiles.forEachCachedTile(visitor);
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.
     * If `undefined`, tiles from all [[DataSource]]s are processed.
     */
    markTilesDirty(dataSource) {
        this.m_visibleTiles.markTilesDirty(dataSource);
    }
    /**
     * Sets the DataSource which contains the elevations, the elevation range source, and the
     * elevation provider. Only a single elevation source is possible per [[MapView]]
     *
     * If the terrain-datasource is merged with this repository, we could internally construct
     * the [[ElevationRangeSource]] and the [[ElevationProvider]] and access would be granted to
     * the application when it asks for it, to simplify the API.
     *
     * @param elevationSource The datasource containing the terrain tiles.
     * @param elevationRangeSource Allows access to the elevation min / max per tile.
     * @param elevationProvider Allows access to the elevation at a given location or a ray
     *      from the camera.
     */
    setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {
        // Try to remove incase this method was already called, will do nothing if it doesn't exist.
        this.removeDataSource(elevationSource);
        this.addDataSource(elevationSource);
        this.m_elevationRangeSource = elevationRangeSource;
        this.m_elevationRangeSource.connect();
        this.m_elevationProvider = elevationProvider;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(true);
        });
        this.m_tileGeometryManager.setTileUpdateCallback((tile) => {
            overlayOnElevation_1.overlayOnElevation(tile);
        });
        this.clearTileCache();
    }
    /**
     * Clears any elevation sources and provider previously set.
     * @param elevationSource The datasource to be cleared.
     */
    clearElevationSource(elevationSource) {
        this.removeDataSource(elevationSource);
        this.m_elevationRangeSource = undefined;
        this.m_elevationProvider = undefined;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(false);
        });
        this.m_tileGeometryManager.setTileUpdateCallback(undefined);
        this.clearTileCache();
    }
    /**
     * Public access to [[MapViewFog]] allowing to toggle it by setting its `enabled` property.
     */
    get fog() {
        return this.m_fog;
    }
    setPostEffects() {
        // First clear all the effects, then enable them from what is specified.
        this.mapRenderingManager.bloom.enabled = false;
        this.mapRenderingManager.outline.enabled = false;
        this.mapRenderingManager.vignette.enabled = false;
        this.mapRenderingManager.sepia.enabled = false;
        if (this.m_postEffects !== undefined) {
            if (this.m_postEffects.bloom !== undefined) {
                this.mapRenderingManager.bloom = this.m_postEffects.bloom;
            }
            if (this.m_postEffects.outline !== undefined) {
                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
            }
            if (this.m_postEffects.vignette !== undefined) {
                this.mapRenderingManager.vignette = this.m_postEffects.vignette;
            }
            if (this.m_postEffects.sepia !== undefined) {
                this.mapRenderingManager.sepia = this.m_postEffects.sepia;
            }
        }
    }
    /**
     * Returns the elevation provider.
     */
    get elevationProvider() {
        return this.m_elevationProvider;
    }
    /**
     * Updates the camera and the projections and resets the screen collisions,
     * note, setupCamera must be called before this is called.
     */
    updateCameras() {
        const { width, height } = this.m_renderer.getSize(tmpVector);
        this.m_camera.aspect =
            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;
        this.setFovOnCamera(this.m_options.fovCalculation, height);
        const clipPlanes = this.m_visibleTileSetOptions.clipPlanesEvaluator.evaluateClipPlanes(this.m_camera, this.projection);
        this.m_camera.near = clipPlanes.near;
        this.m_camera.far = clipPlanes.far;
        this.m_camera.updateProjectionMatrix();
        this.m_camera.updateMatrixWorld(false);
        // Update the "relative to eye" camera. Copy the public camera parameters
        // and place the "relative to eye" at the world's origin.
        this.m_rteCamera.copy(this.m_camera);
        this.m_rteCamera.position.setScalar(0);
        this.m_rteCamera.updateMatrixWorld(true);
        this.m_screenCamera.left = width / -2;
        this.m_screenCamera.right = width / 2;
        this.m_screenCamera.bottom = height / -2;
        this.m_screenCamera.top = height / 2;
        this.m_screenCamera.updateProjectionMatrix();
        this.m_screenCamera.updateMatrixWorld(false);
        this.m_screenProjector.update(this.camera, width, height);
        this.m_screenCollisions.update(width, height);
        this.m_pixelToWorld = undefined;
        const cameraPitch = Utils_1.MapViewUtils.extractYawPitchRoll(this.m_camera.quaternion, this.projection.type).pitch;
        const cameraPosZ = this.getCameraHeightAboveTerrain(TERRAIN_ZOOM_LEVEL);
        this.m_lookAtDistance = cameraPosZ / Math.cos(cameraPitch);
        const zoomLevelDistance = cameraPosZ / Math.cos(Math.min(cameraPitch, Math.PI / 3));
        this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(zoomLevelDistance, this);
        this.m_fog.update(this.m_camera, this.projection, clipPlanes.maximum);
    }
    /**
     * Returns the height of the camera above the earths surface.
     *
     * If there is an ElevationProvider, this is used. Otherwise the projection is used to determine
     * how high the camera is above the surface.
     *
     * @param level Which level to request the surface height from.
     * @return Height in world units.
     */
    getCameraHeightAboveTerrain(level) {
        if (this.elevationProvider !== undefined) {
            const heightAboveTerrain = this.elevationProvider.getHeight(this.geoCenter, level);
            if (heightAboveTerrain !== undefined) {
                const height = this.projection.unprojectAltitude(this.m_camera.position) - heightAboveTerrain;
                return Math.max(height, 1);
            }
        }
        return Math.abs(this.projection.groundDistance(this.m_camera.position));
    }
    detectCurrentFps(now) {
        // Skip the first frames, they are from not originated from requestAnimationFrame()
        if (this.m_previousRequestAnimationTime !== undefined && this.m_frameNumber > 5) {
            const currentFps = 1000 / (now - this.m_previousRequestAnimationTime);
            this.m_frameTimeRing[this.m_frameTimeIndex % FRAME_RATE_RING_SIZE] = currentFps;
            this.m_frameTimeIndex++;
            const capturedFrames = Math.min(this.m_frameTimeIndex, FRAME_RATE_RING_SIZE);
            let sum = 0;
            for (let i = 0; i < capturedFrames; i++) {
                sum += this.m_frameTimeRing[i];
            }
            this.m_detectedFps = sum / capturedFrames;
        }
        this.m_previousRequestAnimationTime = now;
    }
    /**
     * Draw a new frame.
     */
    drawFrame() {
        if (this.m_drawing) {
            return;
        }
        // Cancel an active requestAnimationFrame() cycle. Failure to do this may end up in
        // rendering multiple times during a single frame.
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        if (this.m_maxFps <= 0) {
            // Render at maximum FPS.
            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
            return;
        }
        // Magic ingredient to compensate time flux.
        const fudgeTimeInMs = 3;
        const vSyncFrameTime = 1000 / this.m_detectedFps;
        const frameInterval = 1000 / this.m_maxFps;
        const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;
        // Compute a practical value to compare against.
        const targetTime = previousFrameTime + frameInterval - vSyncFrameTime - fudgeTimeInMs;
        this.m_targetRequestAnimationTime = targetTime;
        this.postponedAnimationFrame(previousFrameTime);
    }
    postponedAnimationFrame(now) {
        if (this.m_targetRequestAnimationTime === undefined) {
            return;
        }
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.detectCurrentFps(now);
        this.m_animationFrameHandle = requestAnimationFrame(now > this.m_targetRequestAnimationTime
            ? this.handleRequestAnimationFrame
            : this.handlePostponedAnimationFrame);
    }
    /**
     * Draw a new frame.
     */
    renderFunc(time) {
        this.render(time);
    }
    /**
     * Returns the list of the enabled data sources.
     */
    getEnabledTileDataSources() {
        // ### build this list once decoders && datasources are ready
        const enabledDataSources = [];
        for (const dataSource of this.m_tileDataSources) {
            if (this.isDataSourceEnabled(dataSource)) {
                enabledDataSources.push(dataSource);
            }
        }
        return enabledDataSources;
    }
    /**
     * Renders the current frame.
     */
    render(time) {
        if (this.m_drawing) {
            return;
        }
        ++this.m_frameNumber;
        const stats = Statistics_1.PerformanceStatistics.instance;
        const gatherStatistics = stats.enabled;
        const frameStartTime = time;
        RENDER_EVENT.time = time;
        this.dispatchEvent(RENDER_EVENT);
        let currentFrameEvent;
        if (gatherStatistics) {
            currentFrameEvent = stats.currentFrame;
            currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
            if (this.m_previousFrameTimeStamp !== undefined) {
                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
                if (gatherStatistics) {
                    currentFrameEvent.setValue("render.fullFrameTime", timeSincePreviousFrame);
                    // For convenience and easy readability
                    currentFrameEvent.setValue("render.fps", 1000 / timeSincePreviousFrame);
                }
            }
        }
        this.m_previousFrameTimeStamp = frameStartTime;
        let setupTime;
        let cullTime;
        let textPlacementTime;
        let drawTime;
        let textDrawTime;
        let endTime;
        this.m_renderer.info.reset();
        this.m_updatePending = false;
        this.m_thisFrameTilesChanged = undefined;
        this.m_drawing = true;
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        this.updateCameras();
        this.m_renderer.clear();
        // clear the scene
        while (this.m_mapTilesRoot.children.length > 0) {
            this.m_mapTilesRoot.remove(this.m_mapTilesRoot.children[0]);
        }
        if (gatherStatistics) {
            setupTime = harp_utils_1.PerformanceTimer.now();
        }
        // TBD: Update renderList only any of its params (camera, etc...) has changed.
        if (!this.lockVisibleTileSet) {
            this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_elevationRangeSource);
        }
        if (gatherStatistics) {
            cullTime = harp_utils_1.PerformanceTimer.now();
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        renderList.forEach(({ zoomLevel, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                this.renderTileObjects(tile, zoomLevel);
                //We know that rendered tiles are visible (in the view frustum), so we update the
                //frame number, note we don't do this for the visibleTiles because some may still be
                //loading (and therefore aren't visible in the sense of being seen on the screen).
                //Note also, this number isn't currently used anywhere so should be considered to be
                //removed in the future (though could be good for debugging purposes).
                tile.frameNumLastVisible = this.m_frameNumber;
            });
        });
        this.m_mapAnchors.children.forEach((childObject) => {
            if (childObject.geoPosition === undefined) {
                return;
            }
            this.projection.projectPoint(childObject.geoPosition, childObject.position);
            childObject.position.sub(this.camera.position);
        });
        this.m_animatedExtrusionHandler.zoom = this.m_zoomLevel;
        if (currentFrameEvent !== undefined) {
            // Make sure the counters all have a value.
            currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
            currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
            currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
            // Increment the counters for all data sources.
            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {
                currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
            });
        }
        if (this.m_movementDetector.checkCameraMoved(this, time)) {
            const { yaw, pitch, roll } = Utils_1.MapViewUtils.extractYawPitchRoll(this.camera.quaternion, this.projection.type);
            const { latitude, longitude, altitude } = this.geoCenter;
            this.dispatchEvent({
                type: MapViewEventNames.CameraPositionChanged,
                latitude,
                longitude,
                altitude,
                yaw,
                pitch,
                roll,
                zoom: this.zoomLevel
            });
        }
        // The camera used to render the scene.
        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;
        if (this.renderLabels) {
            this.prepareRenderTextElements(time);
        }
        if (gatherStatistics) {
            textPlacementTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.m_skyBackground !== undefined && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.m_skyBackground.updateCamera(this.m_camera);
        }
        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);
        if (gatherStatistics) {
            drawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.renderLabels) {
            this.finishRenderTextElements();
        }
        if (gatherStatistics) {
            textDrawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (!this.m_firstFrameRendered) {
            this.m_firstFrameRendered = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrame", time);
            }
            FIRST_FRAME_EVENT.time = time;
            this.dispatchEvent(FIRST_FRAME_EVENT);
        }
        if (!this.m_firstFrameComplete &&
            this.m_visibleTiles.allVisibleTilesLoaded &&
            this.m_connectedDataSources.size + this.m_failedDataSources.size ===
                this.m_tileDataSources.length &&
            !this.m_updatePending &&
            !this.animating &&
            !this.cameraIsMoving &&
            !this.m_animatedExtrusionHandler.isAnimating &&
            this.m_textElementsRenderer !== undefined &&
            !this.m_textElementsRenderer.loading &&
            this.m_poiTableManager.finishedLoading) {
            this.m_firstFrameComplete = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrameComplete", time);
            }
            FRAME_COMPLETE_EVENT.time = time;
            this.dispatchEvent(FRAME_COMPLETE_EVENT);
        }
        this.m_visibleTiles.disposePendingTiles();
        this.m_drawing = false;
        if (this.animating || this.m_updatePending) {
            this.drawFrame();
        }
        this.checkCopyrightUpdates();
        if (currentFrameEvent !== undefined) {
            endTime = harp_utils_1.PerformanceTimer.now();
            currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
            currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
            currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
            currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
            currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
            currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
            currentFrameEvent.setValue("render.frameRenderTime", endTime - frameStartTime);
            Statistics_1.PerformanceStatistics.instance.storeFrameInfo(this.m_renderer.info);
        }
        DID_RENDER_EVENT.time = time;
        this.dispatchEvent(DID_RENDER_EVENT);
    }
    renderTileObjects(tile, zoomLevel) {
        const worldOffsetX = this.projection.worldExtent(0, 0).max.x * tile.offset;
        if (tile.willRender(zoomLevel)) {
            for (const object of tile.objects) {
                object.position.copy(tile.center);
                if (object.displacement !== undefined) {
                    object.position.add(object.displacement);
                }
                object.position.x += worldOffsetX;
                object.position.sub(this.m_camera.position);
                if (tile.localTangentSpace) {
                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
                }
                this.m_mapTilesRoot.add(object);
            }
        }
        tile.didRender();
    }
    prepareRenderTextElements(time) {
        // Disable rendering of text elements for debug camera. TextElements are rendered using an
        // orthographic camera that covers the entire available screen space. Unfortunately, this
        // particular camera set up is not compatible with the debug camera.
        const debugCameraActive = this.m_pointOfView !== undefined;
        if (this.m_textElementsRenderer === undefined ||
            !this.m_textElementsRenderer.ready ||
            debugCameraActive) {
            return;
        }
        if (this.checkIfTextElementsChanged() || this.checkIfTilesChanged()) {
            this.m_textElementsRenderer.placeAllTileLabels();
        }
        // User TextElements have the priority when it comes to reserving screen space, so
        // they are handled first. They will be rendered after the normal map objects and
        // TextElements
        this.m_textElementsRenderer.reset();
        this.m_textElementsRenderer.renderUserTextElements(time, this.m_frameNumber);
        this.m_textElementsRenderer.renderAllTileText(time, this.m_frameNumber);
        this.m_textElementsRenderer.renderOverlay(this.m_overlayTextElements);
        this.m_textElementsRenderer.update();
    }
    finishRenderTextElements() {
        const canRenderTextElements = this.m_pointOfView === undefined;
        if (canRenderTextElements && this.m_textElementsRenderer !== undefined) {
            // copy far value from scene camera, as the distance to the POIs matter now.
            this.m_screenCamera.far = this.m_camera.far;
            this.m_textElementsRenderer.renderText(this.m_screenCamera);
        }
    }
    initTheme() {
        if (this.m_options.theme === undefined) {
            return;
        }
        Promise.resolve(this.m_options.theme)
            .then(theme => ThemeLoader_1.ThemeLoader.load(theme))
            .then(theme => {
            this.theme = theme;
            THEME_LOADED_EVENT.time = Date.now();
            this.dispatchEvent(THEME_LOADED_EVENT);
        });
    }
    setupCamera() {
        const { width, height } = this.getCanvasClientSize();
        const defaultGeoCenter = new harp_geoutils_1.GeoCoordinates(52.518611, 13.376111, 3000);
        this.projection.projectPoint(defaultGeoCenter, this.m_camera.position);
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_camera.lookAt(this.scene.position);
        }
        this.m_lookAtDistance = defaultGeoCenter.altitude;
        this.calculateFocalLength(height);
        this.m_visibleTiles = new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this.m_visibleTileSetOptions.projection, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled), this.m_tileGeometryManager, this.m_visibleTileSetOptions);
        // ### move & customize
        this.resize(width, height);
        this.geoCenter = defaultGeoCenter;
        this.m_screenCamera.position.z = 1;
        this.m_screenCamera.near = 0;
    }
    updateSkyBackground() {
        if (this.m_theme === undefined) {
            return;
        }
        const theme = this.m_theme;
        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky !== undefined) {
            // there is a sky in the view and there is a sky option in the theme. Update the colors
            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);
        }
        else if (this.m_skyBackground === undefined && theme.sky !== undefined) {
            // there is no sky in the view but there is a sky option in the theme
            this.addNewSkyBackground(theme.sky, theme.clearColor);
            return;
        }
        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky === undefined) {
            // there is a sky in the view, but not in the theme
            this.removeSkyBackGround();
        }
    }
    addNewSkyBackground(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.projection.type, this.m_camera);
        this.m_scene.background = this.m_skyBackground.texture;
    }
    removeSkyBackGround() {
        this.m_scene.background = null;
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.dispose();
            this.m_skyBackground = undefined;
        }
    }
    updateSkyBackgroundColors(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.updateTexture(sky, this.projection.type);
        }
    }
    updateLighting() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        if (theme.clearColor !== undefined) {
            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));
        }
        if (this.m_createdLights) {
            this.m_createdLights.forEach((light) => {
                this.m_scene.remove(light);
            });
        }
        if (theme.lights !== undefined) {
            this.m_createdLights = [];
            theme.lights.forEach((lightDescription) => {
                const light = ThemeHelpers_1.createLight(lightDescription);
                if (!light) {
                    logger.log(
                    // tslint:disable-next-line: max-line-length
                    `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
                    return;
                }
                this.m_scene.add(light);
                this.m_createdLights.push(light);
            });
        }
    }
    movementStarted() {
        if (this.m_textElementsRenderer !== undefined) {
            this.m_textElementsRenderer.movementStarted();
        }
        MOVEMENT_STARTED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_STARTED_EVENT);
    }
    movementFinished() {
        if (this.m_textElementsRenderer !== undefined) {
            this.m_textElementsRenderer.movementFinished();
        }
        MOVEMENT_FINISHED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);
        // render at the next possible time.
        if (!this.animating) {
            setTimeout(() => this.update(), 0);
        }
    }
    /**
     * Check if the `textElementsChanged` flag in any tile has been set to `true`. If any flag was
     * `true`, this function returns `true`, and resets the flag in all tiles to `false`.
     */
    checkIfTextElementsChanged() {
        const renderList = this.m_visibleTiles.dataSourceTileList;
        let textElementsChanged = false;
        renderList.forEach(({ renderedTiles }) => {
            renderedTiles.forEach(tile => {
                if (tile.textElementsChanged) {
                    tile.textElementsChanged = false;
                    textElementsChanged = true;
                }
            });
        });
        return textElementsChanged;
    }
    /**
     * Check if the set of visible tiles changed since the last frame.
     *
     * May be called multiple times per frame.
     *
     * Equality is computed by creating a string containing the IDs of the tiles.
     */
    checkIfTilesChanged() {
        if (this.m_thisFrameTilesChanged !== undefined) {
            return this.m_thisFrameTilesChanged;
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        const tileIdList = [];
        tileIdList.length = 0;
        renderList.forEach(({ dataSource, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
            });
        });
        tileIdList.sort();
        const newTileIds = tileIdList.join("#");
        if (newTileIds !== this.m_lastTileIds) {
            this.m_lastTileIds = newTileIds;
            this.m_thisFrameTilesChanged = true;
        }
        else {
            this.m_thisFrameTilesChanged = false;
        }
        return this.m_thisFrameTilesChanged;
    }
    checkCopyrightUpdates() {
        if (!this.checkIfTilesChanged()) {
            return;
        }
        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
        if (newCopyrightInfo === this.m_copyrightInfo) {
            return;
        }
        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
            let allEqual = true;
            for (let i = 0; i < newCopyrightInfo.length; i++) {
                const a = newCopyrightInfo[i];
                const b = this.m_copyrightInfo[i];
                if (a.label !== b.label) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return;
            }
        }
        this.m_copyrightInfo = newCopyrightInfo;
        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);
    }
    getRenderedTilesCopyrightInfo() {
        let result = [];
        for (const tileList of this.m_visibleTiles.dataSourceTileList) {
            for (const tile of tileList.renderedTiles) {
                const tileCopyrightInfo = tile.copyrightInfo;
                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {
                    continue;
                }
                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
            }
        }
        return result;
    }
    updateImages() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        this.m_imageCache.clear();
        this.poiManager.clear();
        if (theme.images !== undefined) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                this.m_imageCache.addImage(name, image.url, image.preload === true);
                if (typeof image.atlas === "string") {
                    this.poiManager.addTextureAtlas(name, image.atlas);
                }
            }
        }
        if (theme.imageTextures !== undefined) {
            theme.imageTextures.forEach((imageTexture) => {
                this.poiManager.addImageTexture(imageTexture);
            });
        }
    }
    loadPoiTables() {
        if (this.m_theme === undefined) {
            return;
        }
        this.poiTableManager.clear();
        // Add the POI tables defined in the theme.
        this.poiTableManager.loadPoiTables(this.m_theme);
    }
    setupStats(enable) {
        // tslint:disable-next-line:no-unused-expression
        new Statistics_1.PerformanceStatistics(enable, 1000);
    }
    setupRenderer() {
        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
        this.m_scene.add(this.m_mapTilesRoot);
        this.m_scene.add(this.m_mapAnchors);
    }
    /**
     * Gradually initialize & update TextRenderer as assets arrive.
     */
    updateTextRenderer() {
        if (this.m_theme.textStyles === undefined) {
            return;
        }
        if (this.m_textElementsRenderer === undefined) {
            this.m_textElementsRenderer = new TextElementsRenderer_1.TextElementsRenderer(this, this.m_screenCollisions, this.m_screenProjector, this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs, this.m_theme, this.m_options.maxNumVisibleLabels, this.m_options.numSecondChanceLabels, this.m_options.labelDistanceScaleMin, this.m_options.labelDistanceScaleMax, this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);
        }
        this.m_textElementsRenderer.placeAllTileLabels();
    }
    limitFov(fov, aspect) {
        fov = harp_geoutils_1.MathUtils.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        let hFov = harp_geoutils_1.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(harp_geoutils_1.MathUtils.degToRad(fov), aspect));
        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {
            hFov = harp_geoutils_1.MathUtils.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
            fov = harp_geoutils_1.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateVerticalFovByHorizontalFov(harp_geoutils_1.MathUtils.degToRad(hFov), aspect));
        }
        return fov;
    }
    /**
     * Sets the field of view calculation, and applies it immediately to the camera.
     *
     * @param type How to calculate the FOV
     */
    setFovOnCamera(fovCalculation, height) {
        let fov = 0;
        if (fovCalculation.type === "fixed") {
            this.calculateFocalLength(height);
            fov = fovCalculation.fov;
        }
        else {
            harp_utils_1.assert(this.m_focalLength !== 0);
            fov = Utils_1.MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);
        }
        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);
    }
    /**
     * Sets the focal length based on the supplied fov and the height of the canvas. This must be
     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is
     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas
     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is
     * fixed but the FOV changes.
     * @param height Height of the canvas in css / client pixels.
     */
    calculateFocalLength(height) {
        harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
        this.m_focalLength = Utils_1.MapViewUtils.calculateFocalLengthByVerticalFov(harp_geoutils_1.MathUtils.degToRad(this.m_options.fovCalculation.fov), height);
    }
    /**
     * Get canvas client size in css/client pixels.
     *
     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by
     * calculating it from actual canvas size and current pixel ratio.
     */
    getCanvasClientSize() {
        const { clientWidth, clientHeight } = this.canvas;
        if (clientWidth === 0 ||
            clientHeight === 0 ||
            typeof clientWidth !== "number" ||
            typeof clientHeight !== "number") {
            const pixelRatio = this.m_renderer.getPixelRatio();
            return {
                width: Math.round(this.canvas.width / pixelRatio),
                height: Math.round(this.canvas.height / pixelRatio)
            };
        }
        else {
            return { width: clientWidth, height: clientHeight };
        }
    }
}
exports.MapView = MapView;


/***/ }),

/***/ "../harp-mapview/lib/MapViewFog.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/MapViewFog.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Manages the fog display in [[MapView]].
 */
class MapViewFog {
    /**
     * Constructs a `MapViewFog` instance.
     *
     * @param m_scene The scene used in [[MapView]] that contains the map objects.
     */
    constructor(m_scene) {
        this.m_scene = m_scene;
        this.m_enabled = true;
        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.
        this.m_fogIsDefined = false;
        this.m_cachedTheme = { styles: {} };
    }
    /**
     * Allows for disabling the fog, even if it is defined in the theme. Use this property for
     * custom views like the demo app's debug camera. However, if the theme does not define a
     * fog, enabling this property here has no effect.
     *
     * @param value A boolean that specifies whether the fog should be enabled or disabled.
     */
    set enabled(enableFog) {
        this.m_enabled = enableFog;
        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
            this.add();
        }
        else if (!enableFog && this.m_scene.fog !== null) {
            this.remove();
        }
    }
    /**
     * Returns the current fog status, enabled or disabled.
     */
    get enabled() {
        return this.m_enabled;
    }
    /**
     * Sets the fog depending on the [[Theme]] instance provided. This function is called when a
     * theme is loaded. Fog is added only if the theme contains a fog definition with a:
     * - `color` property, used to set the fog color.
     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far
     * clipping plane distance.
     *
     * @param theme A [[Theme]] instance.
     */
    reset(theme) {
        this.m_cachedTheme = theme;
        if (theme !== undefined &&
            theme.fog !== undefined &&
            theme.fog.color !== undefined &&
            theme.fog.startRatio !== undefined) {
            this.m_fogIsDefined = true;
            this.m_fog.color.set(theme.fog.color);
            if (this.m_enabled && this.m_scene.fog === null) {
                this.add();
            }
        }
        else {
            this.m_fogIsDefined = false;
            if (this.m_scene.fog !== null) {
                this.remove();
            }
        }
    }
    /**
     * Updates the fog at runtime, depending on the camera.
     *
     * @param camera An instance of a `THREE.Camera` with a `far` property.
     */
    update(camera, projection, viewDistance) {
        if (this.m_scene.fog !== null &&
            this.m_cachedTheme !== undefined &&
            this.m_cachedTheme.fog &&
            this.m_cachedTheme.fog.startRatio !== undefined &&
            (camera.far !== undefined || viewDistance !== undefined)) {
            // If maximum visibility range is available use it instead of camera.far distance,
            // this makes fog independent from dynamic camera planes and keeps consistent
            // distance based "melting" (fog) effect during a tilt.
            const viewRange = viewDistance !== undefined ? viewDistance : camera.far;
            // TODO: We may move below constants to theme Fog definition
            // Density of the fog when viewing straight along the horizont line.
            const horizontalDensity = 1.0;
            // Theoretical density of the fog when viewing straight from top to down.
            const verticalDensity = 0.0;
            // The fraction of the maximum viewing distance along the eye vector
            // to start applying the fog.
            const startRatio = this.m_cachedTheme.fog.startRatio;
            // The fraction of maximum viewing range at which fog fully covers geometry.
            const endRatio = 1.0;
            harp_utils_1.assert(startRatio <= endRatio);
            const t = Math.abs(Math.cos(Utils_1.MapViewUtils.getCameraTiltAngle(camera, projection)));
            const density = harp_utils_1.MathUtils.smoothStep(horizontalDensity, verticalDensity, t);
            this.m_fog.near = harp_utils_1.MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);
            this.m_fog.far = harp_utils_1.MathUtils.lerp(viewRange * endRatio, viewRange, density);
            this.m_fog.near = Math.min(this.m_fog.near, camera.far);
            this.m_fog.far = Math.min(this.m_fog.far, camera.far);
        }
    }
    /**
     * Handles fog addition.
     */
    add() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = this.m_fog;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(true);
    }
    /**
     * Handles fog removal.
     */
    remove() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = null;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(false);
    }
    /**
     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified
     * explicitly.
     *
     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298
     */
    setFogInRawShaderMaterials(enableFog) {
        this.m_scene.traverse(object => {
            if (object instanceof THREE.Mesh) {
                if (object.material instanceof THREE.Material) {
                    if (object.material instanceof THREE.Material &&
                        // HighPrecisionLineMaterial does not support fog
                        !(object.material instanceof harp_materials_1.HighPrecisionLineMaterial)) {
                        if (object.material instanceof harp_materials_1.SolidLineMaterial) {
                            const material = object.material;
                            material.updateFog(enableFog);
                        }
                        object.material.fog = enableFog;
                        object.material.needsUpdate = true;
                    }
                }
            }
        });
    }
}
exports.MapViewFog = MapViewFog;


/***/ }),

/***/ "../harp-mapview/lib/MapViewPoints.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/MapViewPoints.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `MapViewPoints` is a class to extend for the `"circles"` and `"squares"` [[Technique]]s to
 * implement raycasting of [[THREE.Points]] as expected in [[MapView]], that is in screen space. It
 * copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its
 * children classes, [[Circles]] and [[Squares]], who hold the intersection testing in the
 * `testPoint` method. This class also has the ability to dismiss the testing via the
 * `enableRayTesting` flag.
 *
 * Its main motivation is to handle the point styles of XYZ projects.
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js
 */
class MapViewPoints extends THREE.Points {
    constructor() {
        super(...arguments);
        /**
         * This allows to discard the ray testing.
         */
        this.enableRayTesting = true;
    }
    /**
     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it
     * then calls the tailored `testPoint` method in the children classes to test intersections
     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.
     *
     * @param raycaster The raycaster.
     * @param intersects The array to fill with the results.
     */
    raycast(raycaster, intersects) {
        if (!this.enableRayTesting) {
            return;
        }
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const screenCoords = raycaster.ray.origin
            .clone()
            .add(raycaster.ray.direction)
            .project(raycaster.mapView.camera);
        const { clientWidth, clientHeight } = raycaster.mapView.canvas;
        const mouseCoords = new THREE.Vector2(Math.ceil(((screenCoords.x + 1) / 2) * clientWidth), Math.ceil(((1 - screenCoords.y) / 2) * clientHeight));
        if (geometry instanceof THREE.BufferGeometry) {
            const point = new THREE.Vector3();
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices = index.array;
                for (let i = 0, il = indices.length; i < il; i++) {
                    const a = indices[i];
                    point.fromArray(positions, a * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
            else {
                for (let i = 0, l = positions.length / 3; i < l; i++) {
                    point.fromArray(positions, i * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
        }
        else {
            const vertices = geometry.vertices;
            for (let index = 0; index < vertices.length; index++) {
                const point = vertices[index];
                const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);
                if (pointInfo.pointIsOnScreen) {
                    this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);
                }
            }
        }
    }
}
exports.MapViewPoints = MapViewPoints;
function getPointInfo(point, matrixWorld, raycaster, width, height) {
    const worldPosition = point.clone();
    worldPosition.applyMatrix4(matrixWorld);
    const distance = worldPosition.distanceTo(raycaster.ray.origin);
    worldPosition.project(raycaster.mapView.camera);
    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
    const pointIsOnScreen = relativeScreenPosition.x < 1 &&
        relativeScreenPosition.x > -1 &&
        relativeScreenPosition.y < 1 &&
        relativeScreenPosition.y > -1;
    if (pointIsOnScreen) {
        worldPosition.x = ((worldPosition.x + 1) / 2) * width;
        worldPosition.y = ((1 - worldPosition.y) / 2) * height;
        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
        return {
            absoluteScreenPosition,
            pointIsOnScreen,
            distance
        };
    }
    return {
        pointIsOnScreen
    };
}
/**
 * Point object that implements the raycasting of circles in screen space.
 */
class Circles extends MapViewPoints {
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const radius = this.material.size / 2;
        if (dist <= radius) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Circles = Circles;
/**
 * Point object that implements the raycasting of squares in screen space.
 */
class Squares extends MapViewPoints {
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const halfSize = this.material.size / 2;
        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Squares = Squares;


/***/ }),

/***/ "../harp-mapview/lib/PickHandler.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/PickHandler.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts");
const RoadPicker_1 = __webpack_require__(/*! ./RoadPicker */ "../harp-mapview/lib/RoadPicker.ts");
/**
 * Describes the general type of a picked object.
 */
var PickObjectType;
(function (PickObjectType) {
    /**
     * Unspecified.
     */
    PickObjectType[PickObjectType["Unspecified"] = 0] = "Unspecified";
    /**
     * A point object.
     */
    PickObjectType[PickObjectType["Point"] = 1] = "Point";
    /**
     * A line object.
     */
    PickObjectType[PickObjectType["Line"] = 2] = "Line";
    /**
     * An area object.
     */
    PickObjectType[PickObjectType["Area"] = 3] = "Area";
    /**
     * The text part of a [[TextElement]]
     */
    PickObjectType[PickObjectType["Text"] = 4] = "Text";
    /**
     * The Icon of a [[TextElement]].
     */
    PickObjectType[PickObjectType["Icon"] = 5] = "Icon";
    /**
     * Any general 3D object, for example, a landmark.
     */
    PickObjectType[PickObjectType["Object3D"] = 6] = "Object3D";
})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));
/**
 * Handles the picking of scene geometry and roads.
 */
class PickHandler {
    constructor(mapView, camera, enableRoadPicking = true) {
        this.mapView = mapView;
        this.camera = camera;
        this.enableRoadPicking = enableRoadPicking;
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        if (enableRoadPicking) {
            this.m_roadPicker = new RoadPicker_1.RoadPicker(mapView);
        }
    }
    /**
     * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js,
     * since their geometry is generated in the vertex shader. The `RoadPicker` requires that
     * all [[Tile]]s are registered before they can be picked successfully.
     */
    registerTile(tile) {
        return this.m_roadPicker !== undefined ? this.m_roadPicker.registerTile(tile) : undefined;
    }
    /**
     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to
     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the
     * shader cannot be tested for intersection.
     *
     * @param x The X position in CSS/client coordinates, without the applied display ratio.
     * @param y The Y position in CSS/client coordinates, without the applied display ratio.
     * @returns the list of intersection results.
     */
    intersectMapObjects(x, y) {
        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);
        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);
        const pickResults = [];
        if (this.mapView.textElementsRenderer !== undefined) {
            const { clientWidth, clientHeight } = this.mapView.canvas;
            const screenX = worldPos.x * clientWidth * 0.5 * this.mapView.pixelRatio;
            const screenY = worldPos.y * clientHeight * 0.5 * this.mapView.pixelRatio;
            const scenePosition = new THREE.Vector2(screenX, screenY);
            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);
        }
        // calculate objects intersecting the picking ray
        const intersects = rayCaster.intersectObjects(this.mapView.worldRootObject.children, true);
        for (const intersect of intersects) {
            const pickResult = {
                type: PickObjectType.Unspecified,
                point: intersect.point,
                distance: intersect.distance,
                intersection: intersect
            };
            if (intersect.object.userData === undefined ||
                intersect.object.userData.feature === undefined) {
                pickResults.push(pickResult);
                continue;
            }
            const featureData = intersect.object.userData.feature;
            this.addObjInfo(featureData, intersect, pickResult);
            if (featureData.ids !== undefined) {
                const featureId = featureData.ids.length === 1 ? featureData.ids[0] : undefined;
                pickResult.featureId = featureId;
            }
            let pickObjectType;
            switch (featureData.geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    pickObjectType = PickObjectType.Point;
                    break;
                case harp_datasource_protocol_1.GeometryType.Line:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    pickObjectType = PickObjectType.Line;
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    pickObjectType = PickObjectType.Area;
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    pickObjectType = PickObjectType.Object3D;
                    break;
                default:
                    pickObjectType = PickObjectType.Unspecified;
            }
            pickResult.type = pickObjectType;
            pickResults.push(pickResult);
        }
        if (this.enableRoadPicking) {
            const planeIntersectPosition = new THREE.Vector3();
            const cameraPos = this.mapView.camera.position.clone();
            rayCaster.setFromCamera(worldPos, this.mapView.camera);
            rayCaster.ray.intersectPlane(this.m_plane, planeIntersectPosition);
            this.mapView.forEachVisibleTile(tile => {
                this.m_roadPicker.intersectRoads(tile, cameraPos, planeIntersectPosition, pickResults);
            });
        }
        pickResults.sort((a, b) => {
            return a.distance - b.distance;
        });
        return pickResults;
    }
    addObjInfo(featureData, intersect, pickResult) {
        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {
            pickResult.userData = featureData.objInfos[intersect.index];
            return;
        }
        else if (featureData.objInfos === undefined ||
            featureData.starts === undefined ||
            intersect.faceIndex === undefined) {
            return;
        }
        if (featureData.starts.length > 1) {
            let objInfosIndex = 0;
            for (const polygonStartFace of featureData.starts) {
                if (polygonStartFace > intersect.faceIndex * 3) {
                    break;
                }
                objInfosIndex++;
            }
            pickResult.userData = featureData.objInfos[objInfosIndex - 1];
        }
        else {
            pickResult.userData = featureData.objInfos[0];
        }
    }
}
exports.PickHandler = PickHandler;


/***/ }),

/***/ "../harp-mapview/lib/RoadPicker.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/RoadPicker.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const logger = harp_utils_1.LoggerManager.instance.create("RoadPicker");
const MAX_DISTANCE_ERROR = 0.01;
/**
 * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js, since
 * their geometry is generated in the vertex shader.
 */
class RoadPicker {
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
    }
    /**
     * Registers a tile with the `RoadPicker`. This function extracts line data from the [[Tile]],
     * but only if the tile has the necessary [[ExtendedTileInfo]] that allows for road features to
     * be reconstructed.
     *
     * @param tile The tile to register.
     */
    registerTile(tile) {
        harp_utils_1.assert(tile.decodedTile !== undefined);
        if (tile.decodedTile === undefined || tile.decodedTile.tileInfo === undefined) {
            return undefined;
        }
        const extendedTileInfo = tile.decodedTile.tileInfo;
        const lineFeatures = extendedTileInfo.lineGroup;
        if (lineFeatures === undefined || lineFeatures.numFeatures === 0) {
            // tileInfo not of expected type [[ExtendedTileInfo]]
            return undefined;
        }
        const widths = [];
        widths.length = lineFeatures.numFeatures;
        const level = tile.tileKey.level;
        for (let i = 0; i < lineFeatures.numFeatures; i++) {
            const technique = extendedTileInfo.techniqueCatalog[lineFeatures.techniqueIndex[i]];
            const width = this.getLineWidthInWorldUnit(technique, level);
            widths[i] = width !== undefined ? Math.max(1, width) : 1;
        }
        const objInfos = extendedTileInfo.lineGroup.userData;
        const roadIntersectionData = {
            ids: lineFeatures.featureIds,
            techniqueIndex: lineFeatures.techniqueIndex,
            starts: lineFeatures.positionIndex,
            widths,
            positions: lineFeatures.positions,
            techniques: extendedTileInfo.techniqueCatalog,
            objInfos
        };
        return roadIntersectionData;
    }
    /**
     * Tests the `pickPos` point for intersection with all roads on a tile.
     *
     * @param tile The tile to pick.
     * @param eyePos The WorldPosition of eye or camera to compute distances.
     * @param pickPos The WorldPosition of the picked point, on the plane.
     * @param results The existing array of [[PickResult]]; new results should be appended.
     */
    intersectRoads(tile, eyePos, pickPos, results) {
        if (tile.boundingBox.distanceToPoint(pickPos) > MAX_DISTANCE_ERROR) {
            // outside of bounding box of tile
            return false;
        }
        const roadIntersectionData = tile.roadIntersectionData;
        if (roadIntersectionData === undefined) {
            return false;
        }
        const ids = roadIntersectionData.ids;
        const techniques = roadIntersectionData.techniques;
        const techniqueIndices = roadIntersectionData.techniqueIndex;
        const numFeatures = ids.length;
        const positions = roadIntersectionData.positions;
        const widths = roadIntersectionData.widths;
        const px = pickPos.x - tile.center.x;
        const py = pickPos.y - tile.center.y;
        const pickDistance = pickPos.distanceTo(eyePos);
        if (widths.length !== ids.length ||
            ids.length !== techniqueIndices.length ||
            techniqueIndices.length !== roadIntersectionData.starts.length) {
            logger.error("The amount of widths, ids, techniqueIndices and starts has to be the same");
            return false;
        }
        for (let i = 0; i < numFeatures; i++) {
            const technique = techniques[techniqueIndices[i]];
            // if the technique is marked as background or as transient, we ignore it for picking
            if ( /*technique.isBackground === true ||*/technique.transient === true) {
                continue;
            }
            const featureStart = roadIntersectionData.starts[i];
            const featureEnd = i < numFeatures - 1
                ? roadIntersectionData.starts[i + 1]
                : roadIntersectionData.positions.length;
            let startX = positions[featureStart];
            let startY = positions[featureStart + 1];
            const lineWidthSqr = widths[i] * widths[i];
            let closestDistSqr = Number.MAX_VALUE;
            for (let j = featureStart + 2; j < featureEnd; j += 2) {
                const endX = positions[j];
                const endY = positions[j + 1];
                const distSqr = harp_utils_1.Math2D.distToSegmentSquared(px, py, startX, startY, endX, endY);
                if (distSqr < lineWidthSqr) {
                    if (distSqr < closestDistSqr) {
                        closestDistSqr = distSqr;
                    }
                }
                startX = endX;
                startY = endY;
            }
            if (closestDistSqr < Number.MAX_VALUE) {
                const roadPickResult = {
                    type: PickHandler_1.PickObjectType.Line,
                    point: pickPos,
                    distance: pickDistance,
                    distFromCenter: Math.sqrt(closestDistSqr),
                    featureId: ids[i],
                    positions: positions.slice(featureStart, featureEnd),
                    technique
                };
                this.addUserData(roadPickResult, i, roadIntersectionData.objInfos);
                results.push(roadPickResult);
            }
        }
        return false;
    }
    addUserData(roadPickResult, index, objInfos) {
        if (objInfos !== undefined && objInfos.length > 0) {
            roadPickResult.userData = Object.assign({}, objInfos[index]);
        }
    }
    getLineWidthInWorldUnit(technique, level) {
        const solidLineTech = technique;
        if (solidLineTech.metricUnit === "Pixel") {
            const lineWidth = harp_datasource_protocol_1.getPropertyValue(solidLineTech.lineWidth, level, this.m_mapView.pixelToWorld) * 0.5;
            return lineWidth !== undefined
                ? lineWidth
                : harp_materials_1.SolidLineMaterial.DEFAULT_WIDTH;
        }
        else {
            const lineTechnique = technique;
            return harp_datasource_protocol_1.getPropertyValue(lineTechnique.lineWidth, level);
        }
    }
}
exports.RoadPicker = RoadPicker;


/***/ }),

/***/ "../harp-mapview/lib/ScreenCollisions.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/ScreenCollisions.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const DebugContext_1 = __webpack_require__(/*! ./DebugContext */ "../harp-mapview/lib/DebugContext.ts");
// tslint:disable-next-line:no-var-requires
const RTree = __webpack_require__(/*! rtree */ "../../node_modules/rtree/lib/index.js");
const logger = harp_utils_1.LoggerManager.instance.create("ScreenCollissions");
/**
 * @hidden
 */
class ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object.
     */
    constructor() {
        /** The screen bounding box. */
        this.screenBounds = new harp_utils_1.Math2D.Box();
        /** Tree of allocated bounds. */
        this.rtree = new RTree();
        /**
         * An array of temporary variables used when converting boxes to reduce allocations.
         */
        this.m_returnArray = [];
        //
    }
    /**
     * Converts a [[THREE.Box2]] to an internal [[Math2D.Box]].
     *
     * @param threeBox The [[THREE.Box2]] to convert.
     * @param box2 The conversion target.
     */
    static toBox2D(threeBox, box2) {
        box2.x = threeBox.min.x;
        box2.y = threeBox.min.y;
        box2.w = threeBox.max.x - threeBox.min.x;
        box2.h = threeBox.max.y - threeBox.min.y;
    }
    /**
     * Resets the list of allocated screen bounds.
     */
    reset() {
        this.rtree = new RTree();
    }
    /**
     * Updates the screen bounds that are used to check if bounding boxes are visible.
     *
     * @param width The width of the container.
     * @param height The height of the container.
     */
    update(width, height) {
        this.screenBounds.set(width / -2, height / -2, width, height);
        this.reset();
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    allocate(bounds) {
        this.rtree.insert(bounds, null);
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        // Re-use array to reduce allocations.
        this.m_returnArray.length = 0;
        this.m_returnArray = this.rtree.search(bounds, undefined, this.m_returnArray);
        return this.m_returnArray.length !== 0;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isVisible(bounds) {
        return this.screenBounds.intersects(bounds);
    }
}
exports.ScreenCollisions = ScreenCollisions;
/**
 * @hidden
 *
 * Shows requests for screen space during labelling in an HTML canvas, which should be sized like
 * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests
 * for screen space were done.
 *
 * Also logs statistics.
 */
class ScreenCollisionsDebug extends ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.
     */
    constructor(debugCanvas) {
        super();
        /** 2D rendering context. */
        this.m_renderContext = null;
        this.m_renderingEnabled = false;
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
        if (debugCanvas !== undefined && debugCanvas !== null) {
            this.m_renderContext = debugCanvas.getContext("2d");
        }
    }
    /**
     * Resets the list of allocated bounds and clears the debug canvas.
     */
    reset() {
        super.reset();
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
    }
    /**
     * Updates the screen bounds used to check if bounding boxes are visible.
     *
     * @param width The width of the container.
     * @param height The height of the container.
     */
    update(width, height) {
        if (this.m_renderingEnabled) {
            logger.log(
            // tslint:disable-next-line: max-line-length
            `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);
        }
        super.update(width, height);
        if (this.m_renderContext !== null) {
            this.m_renderContext.canvas.width = width;
            this.m_renderContext.canvas.height = height;
        }
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_SCREEN_COLLISIONS", true)
        this.m_renderingEnabled = DebugContext_1.debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds the bounding box in world coordinates.
     */
    allocate(bounds) {
        super.allocate(bounds);
        this.m_numAllocations++;
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            this.m_renderContext.strokeStyle = "#6666ff";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y - 1, bounds.w, -bounds.h);
        }
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        const isFailed = super.isAllocated(bounds);
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            const offset = isFailed ? 2 : 0;
            this.m_renderContext.strokeStyle = isFailed ? "#FF0000" : "#00ff00";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x - offset, this.screenBounds.y + this.screenBounds.h - bounds.y - 1 + offset, bounds.w + 2 * offset, -bounds.h - 2 * offset);
        }
        if (isFailed) {
            this.m_numFailedTests++;
        }
        else {
            this.m_numSuccessfulTests++;
        }
        return isFailed;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isVisible(bounds) {
        const visible = super.isVisible(bounds);
        if (visible) {
            this.m_numSuccessfulVisibilityTests++;
        }
        else {
            this.m_numFailedVisibilityTests++;
        }
        return visible;
    }
}
exports.ScreenCollisionsDebug = ScreenCollisionsDebug;


/***/ }),

/***/ "../harp-mapview/lib/ScreenProjector.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/ScreenProjector.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * @hidden
 * Handles the projection of world coordinates to screen coordinates.
 */
class ScreenProjector {
    /**
     * Constructs a new `ScreenProjector`.
     *
     * @param m_camera Camera to project against.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_width = 0;
        this.m_height = 0;
    }
    /**
     * Height of the screen.
     */
    get width() {
        return this.m_width;
    }
    /**
     * Width of the screen.
     */
    get height() {
        return this.m_height;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into screen
     * coordinates.
     *
     * @param {(THREE.Vector3 | THREE.Vector4)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    project(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2);
            return target;
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector. Stores result
     * in NDC in the target vector.
     *
     * @param {(THREE.Vector3 | THREE.Vector4)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    projectVector(source, target) {
        target.set(source.x, source.y, source.z).project(this.m_camera);
        return target;
    }
    /**
     * Fast test to check if projected point is on screen.
     *
     * @returns {boolean} `true` if point is on screen, `false` otherwise.
     */
    onScreen(source) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            return p.x >= -1 && p.x <= 1 && p.y >= -1 && p.y <= 1;
        }
        return false;
    }
    /**
     * Update the `ScreenProjector` with the latest values of the screen and the camera.
     *
     * @param {THREE.Camera} camera Camera to project against.
     * @param {number} width Width of screen/canvas.
     * @param {number} height Height of screen/canvas.
     */
    update(camera, width, height) {
        this.m_camera = camera;
        this.m_width = width;
        this.m_height = height;
    }
}
ScreenProjector.tempV2 = new THREE.Vector2();
ScreenProjector.tempV3 = new THREE.Vector3();
exports.ScreenProjector = ScreenProjector;


/***/ }),

/***/ "../harp-mapview/lib/SkyBackground.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/SkyBackground.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "../harp-mapview/lib/SkyCubemapTexture.ts");
const SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ "../harp-mapview/lib/SkyGradientTexture.ts");
/**
 * Class that handles [[MapView]]'s sky background.
 */
class SkyBackground {
    /**
     * Constructs a new `SkyBackground`.
     *
     * @param m_sky Sky configuration parameters.
     * @param m_projectionType [[MapView]]'s projection type.
     * @param camera [[MapView]]'s camera.
     */
    constructor(m_sky, m_projectionType, camera) {
        this.m_sky = m_sky;
        this.m_projectionType = m_projectionType;
        switch (this.m_sky.type) {
            case "gradient":
                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);
                this.updateCamera(camera);
                break;
            case "cubemap": {
                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);
                break;
            }
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skyTexture.dispose();
    }
    /**
     * Sky texture.
     */
    get texture() {
        return this.m_skyTexture.texture;
    }
    /**
     * This method updates the skybox based on the camera position (needed for some types of sky).
     *
     * @param camera The camera used in the map view.
     */
    updateCamera(camera) {
        if (this.m_sky.type === "gradient") {
            this.m_skyTexture.update(camera);
        }
    }
    /**
     * Updates the sky texture with new parameters.
     *
     * @param params New sky configuration parameters.
     * @param projectionType Which projection is used, this may also change (in which case the
     * textures should be recreated).
     */
    updateTexture(params, projectionType) {
        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
        switch (params.type) {
            case "gradient":
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);
                }
                break;
            case "cubemap": {
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);
                }
                break;
            }
        }
        this.m_projectionType = projectionType;
        this.m_sky = params;
    }
}
exports.SkyBackground = SkyBackground;


/***/ }),

/***/ "../harp-mapview/lib/SkyCubemapTexture.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/SkyCubemapTexture.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("SkyCubemapTexture");
/**
 * Number of faces that form a [[SkyCubemapTexture]].
 */
exports.SKY_CUBEMAP_FACE_COUNT = 6;
/**
 * Maps the faceId to the expected position in the threejs faces array.
 */
var SkyCubemapFaceId;
(function (SkyCubemapFaceId) {
    SkyCubemapFaceId[SkyCubemapFaceId["positiveX"] = 0] = "positiveX";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeX"] = 1] = "negativeX";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveY"] = 2] = "positiveY";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeY"] = 3] = "negativeY";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveZ"] = 4] = "positiveZ";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeZ"] = 5] = "negativeZ";
})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));
/**
 * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].
 */
class SkyCubemapTexture {
    /**
     * Constructs a new `SkyCubemapTexture`.
     *
     * @param sky Initial [[CubemapSky]] configuration.
     */
    constructor(sky) {
        const faces = this.createCubemapFaceArray(sky);
        this.m_skybox =
            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skybox.dispose();
    }
    /**
     * `SkyCubemapTexture`'s texture resource.
     */
    get texture() {
        return this.m_skybox;
    }
    /**
     * Updates the `SkyCubemapTexture` with new parameters.
     *
     * @param params New [[CubemapSky]] configuration.
     */
    updateTexture(sky) {
        const faces = this.createCubemapFaceArray(sky);
        if (faces === undefined) {
            return;
        }
        this.m_skybox = new three_1.CubeTextureLoader().load(faces);
    }
    createCubemapFaceArray(sky) {
        const faces = [
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined
        ];
        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {
            const face = sky[SkyCubemapFaceId[i]];
            if (face === undefined) {
                logger.error(`Face "${SkyCubemapFaceId[i]}" was not defined.`);
                return;
            }
            faces[i] = face;
        }
        return faces;
    }
}
exports.SkyCubemapTexture = SkyCubemapTexture;


/***/ }),

/***/ "../harp-mapview/lib/SkyGradientTexture.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/SkyGradientTexture.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
exports.DEFAULT_TEXTURE_SIZE = 512;
exports.DEFAULT_MONOMIAL_POWER = 1;
// Vectors used for skybox bitmap computation.
const cameraDir = [
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0),
    new three_1.Vector3(0, -1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1)
];
const cameraRight = [
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0)
];
const cameraUp = [
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0)
];
/**
 * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].
 *
 * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,
 * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom
 *  hemisphere..
 */
class SkyGradientTexture {
    /**
     * Constructs a new `SkyGradientTexture`.
     *
     * @param sky Initial [[GradientSky]] configuration.
     * @param m_projectionType [[MapView]]'s projection type.
     * @param m_height Optional height parameter.
     */
    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {
        this.m_projectionType = m_projectionType;
        this.m_height = m_height;
        const topColor = new three_1.Color(sky.topColor);
        const bottomColor = new three_1.Color(sky.bottomColor);
        const groundColor = new three_1.Color(sky.groundColor);
        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;
        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;
        this.m_faces = [];
        for (let i = 0; i < this.m_faceCount; ++i) {
            const data = new Uint8Array(3 * this.m_width * this.m_height);
            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);
            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);
            texture.needsUpdate = true;
            texture.unpackAlignment = 1;
            this.m_faces.push(texture);
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox = new three_1.CubeTexture(this.m_faces);
            this.m_skybox.needsUpdate = true;
        }
        else {
            this.m_farClipPlaneDividedVertically = new three_1.Line3();
            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));
            this.m_bottomMidFarPoint = new three_1.Vector3();
            this.m_topMidFarPoint = new three_1.Vector3();
            this.m_horizonPosition = new three_1.Vector3();
            this.m_farClipPlaneCorners = [
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3()
            ];
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.m_faces[i].dispose();
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.dispose();
        }
    }
    /**
     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on
     * [[MapView]]'s projection).
     */
    get texture() {
        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;
    }
    /**
     * This method updates the position of the texture depending on the camera frustum.
     *
     * @param camera The camera used in the map view.
     */
    update(camera) {
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {
            this.setHorizonPosition(camera);
            this.updateTexturePosition();
        }
    }
    /**
     * Updates the `SkyGradientTexture` with new parameters.
     *
     * @param params New [[GradientSky]] configuration.
     */
    updateTexture(sky) {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);
            this.m_faces[i].needsUpdate = true;
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.needsUpdate = true;
        }
    }
    // When creating the texture, a Uint8Array is required, because the resulting texture passed
    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because
    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.
    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
        const color = new three_1.Color();
        const dir = new three_1.Vector3();
        const right = new three_1.Vector3();
        const up = new three_1.Vector3();
        const upDir = new three_1.Vector3(0, 0, 1);
        for (let i = 0; i < this.m_height; ++i) {
            for (let j = 0; j < this.m_width; ++j) {
                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
                    const offsetX = right
                        .copy(cameraRight[faceIdx])
                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);
                    const offsetY = up
                        .copy(cameraUp[faceIdx])
                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);
                    dir.copy(cameraDir[faceIdx])
                        .add(offsetX)
                        .add(offsetY)
                        .normalize();
                    const t = Math.max(upDir.dot(dir), 0);
                    color
                        .copy(groundColor)
                        .lerp(bottomColor, Math.min(t * 100, 1))
                        .lerp(topColor, Math.pow(t, harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER)))
                        .multiplyScalar(255);
                }
                else {
                    const t = i / this.m_height;
                    if (i === 0) {
                        color.copy(groundColor).multiplyScalar(255);
                    }
                    else {
                        color
                            .copy(bottomColor)
                            .lerp(topColor, Math.pow(t, harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER)))
                            .multiplyScalar(255);
                    }
                }
                data[i * this.m_width * 3 + j * 3] = color.r;
                data[i * this.m_width * 3 + j * 3 + 1] = color.g;
                data[i * this.m_width * 3 + j * 3 + 2] = color.b;
            }
        }
    }
    setHorizonPosition(camera) {
        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])
            .add(this.m_farClipPlaneCorners[1])
            .multiplyScalar(0.5);
        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])
            .add(this.m_farClipPlaneCorners[3])
            .multiplyScalar(0.5);
        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
        // When there is no intersection between the ground plane and the
        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous
        // intersection point stored in the m_horizonPosition will be considered the valid one.
        if (!hasIntersection) {
            this.m_horizonPosition.set(0.0, 0.0, 0.0);
        }
    }
    updateTexturePosition() {
        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();
        const skyRatio = coveredBySky / frustumHeight;
        // If there is no intersection between the ground plane and the line that defines the far
        // clip plane divided vertically, it means that there is no sky visible and therefore the
        // ground color should be displayed. When there is no intersection, the length of the
        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with
        // all the three components to zero.
        // If there is an intersection, calculate the offset.
        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
        // If the bottom part of the far clipping plane is under the ground plane, scroll the
        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture
        // up.
        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
    }
}
exports.SkyGradientTexture = SkyGradientTexture;


/***/ }),

/***/ "../harp-mapview/lib/Statistics.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/Statistics.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("Statistics");
/**
 * A simple ring buffer to store the last `n` values of the timer. The buffer works on
 * a First-In-First-Out (FIFO) basis.
 */
class RingBuffer {
    /**
     * Sets up the ring buffer.
     *
     * @param capacity The buffer's capacity.
     */
    constructor(capacity) {
        this.capacity = capacity;
        this.buffer = new Array(capacity);
        this.capacity = capacity;
        this.head = this.tail = this.size = 0;
    }
    /**
     * Clears the contents, removes all elements.
     */
    clear() {
        this.head = this.tail = this.size = 0;
    }
    /**
     * Adds a single element to the ring buffer.
     *
     * @param data Data element.
     */
    enqOne(data) {
        let next = this.head + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size < this.capacity) {
            this.size++;
        }
        this.buffer[this.head] = data;
        this.head = next;
        if (this.size === this.capacity) {
            this.tail = this.head;
        }
    }
    /**
     * Adds one or more elements.
     *
     * @param data The elements to add.
     */
    enq(...data) {
        for (const v of data) {
            this.enqOne(v);
        }
    }
    /**
     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.
     * Before calling this method, make sure that `size > 0`.
     */
    deq() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        const data = this.buffer[this.tail];
        let next = this.tail + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size > 0) {
            this.size--;
        }
        this.tail = next;
        return data;
    }
    /**
     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get top() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        return this.buffer[this.tail];
    }
    /**
     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get bottom() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        let previous = this.head - 1;
        if (previous < 0) {
            previous = this.capacity - 1;
        }
        return this.buffer[previous];
    }
    /**
     * Creates an iterator for the buffer.
     */
    iterator() {
        return new RingBuffer.Iterator(this);
    }
    /**
     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.
     */
    asArray() {
        const array = new Array();
        for (let i = 0; i < this.size; i++) {
            array.push(this.buffer[(this.tail + i) % this.capacity]);
        }
        return array;
    }
}
exports.RingBuffer = RingBuffer;
(function (RingBuffer) {
    /**
     * A local class for RingBuffer<T>
     */
    class Iterator {
        /**
         * Creates an iterator for the ring buffer.
         *
         * @param m_buffer `Ringbuffer` to iterate over.
         * @param m_index Start index.
         */
        constructor(m_buffer, m_index = 0) {
            this.m_buffer = m_buffer;
            this.m_index = m_index;
        }
        /**
         * Gets the iterator's current value. This function does not fail even if an overrun occurs.
         * To detect an overrun, watch the result for [[next]].
         */
        get value() {
            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
        }
        /**
         * Advances the iterator to the next element.
         *
         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.
         */
        next() {
            this.m_index++;
            return this.m_index < this.m_buffer.size;
        }
    }
    RingBuffer.Iterator = Iterator;
})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));
/**
 * A simple timer that stores only the latest measurement.
 */
class SimpleTimer {
    constructor(statistics, name) {
        this.statistics = statistics;
        this.name = name;
        /** `true` if timer has been started. */
        this.running = false;
    }
    /**
     * Gets the latest measurement. This function may return `undefined` if no measurement
     * was done.
     */
    get value() {
        return this.m_currentValue;
    }
    /**
     * Sets the measurement value for the amount of time that has elapsed from start() to stop().
     * Use this function to override the timer's duration.
     *
     * @param val The timer's duration.
     */
    setValue(val) {
        this.m_currentValue = val;
    }
    /**
     * Resets the value to be able to start again.
     */
    reset() {
        this.m_currentValue = undefined;
    }
    /**
     * Starts the timer. Returns the current time, based on `Performance.now()`.
     */
    start() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (this.running) {
            throw new Error("Timer '" + this.name + "' is already running");
        }
        this.running = true;
        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());
    }
    /**
     * Stops the timer. Requires that the timer has started.
     */
    stop() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            // this.currentValue is a number now!
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            this.m_currentValue = t;
            this.setValue(t);
            this.running = false;
            return t;
        }
    }
    /**
     * Samples the timer. Requires that the timer has started.
     *
     * @returns the current timer value; `-1` if statistics are disabled.
     */
    now() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            return t;
        }
    }
}
exports.SimpleTimer = SimpleTimer;
/**
 * A timer that stores the last `n` samples in a ring buffer.
 */
class SampledTimer extends SimpleTimer {
    /**
     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!
     *
     * @param statistics Statistics to use for management.
     * @param name Name of the timer. Use colons to build a hierarchy.
     */
    constructor(statistics, name) {
        super(statistics, name);
        this.statistics = statistics;
        this.name = name;
        /**
         * The number of times the timer has reset.
         */
        this.numResets = 0;
        /**
         * Maximum samples until the statistics are reset and updated, which may destroy a median
         * computation.
         */
        this.maxNumSamples = 1000;
        /**
         * The array of sampled values, its length cannot exceed `maxNumSamples`.
         */
        this.samples = new RingBuffer(this.maxNumSamples);
    }
    /**
     * Resets the timer and clears all of its historical values.
     */
    reset() {
        super.reset();
        this.getStats();
        this.samples.clear();
        this.numResets++;
    }
    /**
     * Add a single measurement to the sample.
     *
     * @param val A measurement to add.
     */
    setValue(val) {
        super.setValue(val);
        if (val !== undefined) {
            this.samples.enqOne(val);
        }
    }
    /**
     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,
     * as it requires a copy of the sampled values.
     */
    getStats() {
        return computeArrayStats(this.samples.asArray());
    }
}
exports.SampledTimer = SampledTimer;
/**
 * Only exported for testing
 * @ignore
 *
 * Compute the [[ArrayStats]] for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the
 *      entries.
 * @returns {(Stats | undefined)}
 */
function computeArrayStats(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    samples.sort((a, b) => {
        return a - b;
    });
    const min = samples[0];
    const max = samples[samples.length - 1];
    let median;
    let median90;
    let median95;
    let median97;
    let median99;
    let median999;
    if (samples.length === 1) {
        median90 = median95 = median97 = median99 = median999 = median = samples[0];
    }
    else if (samples.length === 2) {
        median = samples[0] * 0.5 + samples[1] * 0.5;
        median90 = median95 = median97 = median99 = median999 = samples[1];
    }
    else {
        const mid = Math.floor(samples.length / 2);
        median =
            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
        const mid90 = Math.round(samples.length * 0.9) - 1;
        median90 = samples[mid90];
        const mid95 = Math.round(samples.length * 0.95) - 1;
        median95 = samples[mid95];
        const mid97 = Math.round(samples.length * 0.97) - 1;
        median97 = samples[mid97];
        const mid99 = Math.round(samples.length * 0.99) - 1;
        median99 = samples[mid99];
        const mid999 = Math.round(samples.length * 0.999) - 1;
        median999 = samples[mid999];
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return {
        min,
        max,
        avg,
        median,
        median90,
        median95,
        median97,
        median99,
        median999,
        numSamples: samples.length
    };
}
exports.computeArrayStats = computeArrayStats;
/**
 * Measures a sequence of connected events, such as multiple processing stages in a function.
 * Each stage is identified with a timer name, that must be a valid timer in the statistics
 * object. Additionally, all timers within a `MultiStageTimer` must be unique.
 *
 * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,
 * one timer stops and the next timer starts.
 */
class MultiStageTimer {
    /**
     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.
     *
     * @param statistics The statistics object that manages the timers.
     * @param name Name of this `MultiStageTimer`.
     * @param stages List of timer names.
     */
    constructor(statistics, name, stages) {
        this.statistics = statistics;
        this.name = name;
        this.stages = stages;
        if (stages.length < 1) {
            throw new Error("MultiStageTimer needs stages");
        }
        stages.forEach(stage => {
            if (!statistics.hasTimer(stage)) {
                throw new Error("Unknown timer: " + stage);
            }
        });
    }
    /**
     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its
     * last stage, the value is `undefined`.
     */
    get value() {
        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
    }
    /**
     * Resets the timers across all stages.
     */
    reset() {
        if (!this.statistics.enabled) {
            return;
        }
        this.stages.forEach(stage => {
            this.statistics.getTimer(stage).reset();
        });
    }
    /**
     * Starts the `MultiStageTimer` at its first stage.
     */
    start() {
        this.stage = this.stages[0];
        return this.statistics.getTimer(this.stages[0]).value || -1;
    }
    /**
     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be
     * `undefined` if not all stages started.
     */
    stop() {
        this.stage = undefined;
        return this.value !== undefined ? this.value : -1;
    }
    /**
     * Gets the current stage.
     */
    get stage() {
        return this.currentStage;
    }
    /**
     * Sets the current stage. If a new stage is provided, the current timer (if available) is
     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,
     * this is equivalent to calling `stop` on the `MultiStageTimer`.
     *
     * @param stage The next stage to start.
     */
    set stage(stage) {
        if (this.currentStage === stage) {
            return;
        }
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).stop();
        }
        this.currentStage = stage;
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).start();
        }
    }
}
exports.MultiStageTimer = MultiStageTimer;
/**
 * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can
 * disable statistics to minimize their impact on performance.
 */
class Statistics {
    /**
     * Sets up a group of timers.
     *
     * @param name The statistics name, for logging purposes.
     * @param enabled If `false`, the timers do not measure the performance.
     */
    constructor(name, enabled = false) {
        this.name = name;
        this.enabled = enabled;
        this.timers = new Map();
        this.nullTimer = new SimpleTimer(this, "<null>");
    }
    /**
     * Adds a timer, based on the name specified.
     *
     * @param name The timer's name; must be unique.
     */
    createTimer(name, keepSamples = true) {
        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);
        return this.addTimer(timer);
    }
    /**
     * Adds the timer specified.
     *
     * @param timer The timer's name, which must be unique within this statistics object.
     */
    addTimer(timer) {
        if (this.timers.get(timer.name) !== undefined) {
            throw new Error("Duplicate timer name: '" + timer.name + "'");
        }
        this.timers.set(timer.name, timer);
        return timer;
    }
    /**
     * Gets a timer by name.
     *
     * @param name The timer's name.
     */
    getTimer(name) {
        if (!this.enabled) {
            return this.nullTimer;
        }
        const t = this.timers.get(name);
        return t === undefined ? this.nullTimer : t;
    }
    /**
     * Checks if a timer with the specified name already exists.
     *
     * @param name The timer's name.
     * @returns `true` if a timer with `name` already exists; `false` otherwise.
     */
    hasTimer(name) {
        const t = this.timers.get(name);
        return t !== undefined;
    }
    /**
     * Resets all timers.
     */
    reset() {
        this.timers.forEach((timer) => {
            timer.reset();
        });
    }
    /**
     * Prints all values to the console.
     *
     * @param header Optional header line.
     * @param footer Optional footer line.
     */
    log(header, footer) {
        if (header !== undefined || this.name !== undefined) {
            logger.log(header !== undefined ? header : this.name);
        }
        let maxNameLength = 0;
        this.timers.forEach((timer) => {
            maxNameLength = Math.max(maxNameLength, timer.name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.timers.forEach((timer) => {
            let s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
            s += print(timer.value);
            // sampled timers also update their stats and log them
            if (timer instanceof SampledTimer) {
                const simpleStats = timer.getStats();
                if (simpleStats !== undefined) {
                    s +=
                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                            `N=${print(simpleStats.numSamples)} ]`;
                }
            }
            logger.log(s);
        });
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
}
exports.Statistics = Statistics;
/**
 * Class containing all counters, timers and events of the current frame.
 */
class FrameStats {
    constructor() {
        this.entries = new Map();
        this.messages = undefined;
    }
    /**
     * Retrieve the value of the performance number.
     *
     * @param name Name of the performance number.
     * @returns The value of the performance number or `undefined` if it has not been declared by
     *      `setValue` before.
     */
    getValue(name) {
        return this.entries.get(name);
    }
    /**
     * Set the value of the performance number.
     *
     * @param name Name of the performance number.
     * @param name New value of the performance number.
     */
    setValue(name, value) {
        this.entries.set(name, value);
    }
    /**
     * Add a value to the current value of the performance number. If the performance is not known,
     * it will be initialized with `value`.
     *
     * @param name Name of the performance number.
     * @param name Value to be added to the performance number.
     */
    addValue(name, value) {
        const oldValue = this.entries.get(name);
        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));
    }
    /**
     * Add a text message to the frame, like "Font XYZ has been loaded"
     *
     * @param message The message to add.
     */
    addMessage(message) {
        if (this.messages === undefined) {
            this.messages = [];
        }
        this.messages.push(message);
    }
    /**
     * Reset all known performance values to `0` and the messages to `undefined`.
     */
    reset() {
        this.entries.forEach((value, name) => {
            this.entries.set(name, 0);
        });
        this.messages = undefined;
    }
}
exports.FrameStats = FrameStats;
/**
 * @ignore
 * Only exported for testing.
 *
 * Instead of passing around an array of objects, we store the frame statistics as an object of
 * arrays. This allows convenient computations from [[RingBuffer]],
 */
class FrameStatsArray {
    constructor(capacity = 0) {
        this.capacity = capacity;
        this.frameEntries = new Map();
        this.messages = new RingBuffer(capacity);
    }
    get length() {
        return this.messages.size;
    }
    reset() {
        this.frameEntries.forEach((buffer, name) => {
            buffer.clear();
        });
        this.messages.clear();
    }
    addFrame(frameStats) {
        const currentSize = this.length;
        const frameEntries = this.frameEntries;
        frameStats.entries.forEach((value, name) => {
            let buffer = frameEntries.get(name);
            if (buffer === undefined) {
                // If there is a buffer that has not been known before, add it to the known buffers,
                // fill it up with with 0 to the size of all the other buffers to make them of equal
                // size to make PerfViz happy.
                buffer = new RingBuffer(this.capacity);
                for (let i = 0; i < currentSize; i++) {
                    buffer.enqOne(0);
                }
                this.frameEntries.set(name, buffer);
            }
            buffer.enqOne(value);
        });
        this.messages.enq(frameStats.messages);
    }
    /**
     * Prints all values to the console.
     */
    log() {
        let maxNameLength = 0;
        this.frameEntries.forEach((buffer, name) => {
            maxNameLength = Math.max(maxNameLength, name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.frameEntries.forEach((buffer, name) => {
            let s = name + ": " + " ".repeat(maxNameLength - name.length);
            const simpleStats = computeArrayStats(buffer.asArray());
            if (simpleStats !== undefined) {
                s +=
                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                        `N=${print(simpleStats.numSamples)} ]`;
            }
            logger.log(s);
        });
    }
}
exports.FrameStatsArray = FrameStatsArray;
/**
 * Performance measurement central. Maintains the current [[FrameStats]], which holds all individual
 * performance numbers.
 *
 * Implemented as an instance for easy access.
 */
class PerformanceStatistics {
    /**
     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.
     *
     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.
     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.
     * @memberof PerformanceStatistics
     */
    constructor(enabled = true, maxNumFrames = 1000) {
        this.enabled = enabled;
        this.maxNumFrames = maxNumFrames;
        /**
         * Current frame statistics. Contains all values for the current frame. Will be cleared when
         * [[PerformanceStatistics#storeFrameInfo]] is called.
         *
         * @type {FrameStats}
         * @memberof PerformanceStatistics
         */
        this.currentFrame = new FrameStats();
        /**
         * Additional results stored for the current application run, not per frame. Only the last value
         * is stored.
         *
         * @type {(Map<string, number>)}
         */
        this.appResults = new Map();
        /**
         * Additional configuration values stored for the current application run, not per frame. Only
         * the last value is stored.
         *
         * @type {(Map<string, string>)}
         * @memberof PerformanceStatistics
         */
        this.configs = new Map();
        PerformanceStatistics.m_instance = this;
        this.m_frameEvents = new FrameStatsArray(maxNumFrames);
    }
    /**
     * Returns `true` when the maximum number of storable frames is reached.
     *
     * @readonly
     * @type {boolean}
     * @memberof PerformanceStatistics
     */
    get isFull() {
        return this.m_frameEvents.length >= this.maxNumFrames;
    }
    /**
     * Global instance to the instance. The current instance can be overridden by creating a new
     * `PerformanceStatistics`.
     */
    static get instance() {
        if (PerformanceStatistics.m_instance === undefined) {
            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);
        }
        return PerformanceStatistics.m_instance;
    }
    /**
     * @ignore
     * Only exported for testing.
     *
     * Return the array of frame events.
     */
    get frameEvents() {
        return this.m_frameEvents;
    }
    /**
     * Clears all settings, all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clear() {
        this.clearFrames();
        this.configs.clear();
        this.appResults.clear();
    }
    /**
     * Clears only all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clearFrames() {
        this.m_frameEvents.reset();
        this.currentFrame.reset();
    }
    /**
     * Stores the current frame events into the array of events. Uses [[THREE.WebGLInfo]] to add the
     * render state information to the current frame.
     *
     * @param {THREE.WebGLInfo} webGlInfo
     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.
     * @memberof PerformanceStatistics
     */
    storeFrameInfo(webGlInfo) {
        if (this.m_frameEvents.length >= this.maxNumFrames) {
            return false;
        }
        if (webGlInfo !== undefined) {
            if (webGlInfo.render !== undefined) {
                this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
                this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
                this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
                this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
            }
            if (webGlInfo.memory !== undefined) {
                this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
                this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
            }
            if (webGlInfo.programs !== undefined) {
                this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
            }
        }
        if (window !== undefined && window.performance !== undefined) {
            const memory = window.performance.memory;
            if (memory !== undefined) {
                this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
                this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
                this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
            }
        }
        this.m_frameEvents.addFrame(this.currentFrame);
        this.currentFrame.reset();
        return true;
    }
    /**
     * Logs all values to the logger.
     *
     * @param header Optional header line.
     * @param footer Optional footer line.
     */
    log(header, footer) {
        logger.log(header !== undefined ? header : "PerformanceStatistics");
        const appResults = this.appResults;
        appResults.forEach((value, name) => {
            logger.log(name, value);
        });
        const configs = this.configs;
        configs.forEach((value, name) => {
            logger.log(name, value);
        });
        this.m_frameEvents.log();
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
    /**
     * Convert to a plain object that can be serialized. Required to copy the test results over to
     * nightwatch.
     */
    getAsPlainObject() {
        const appResults = {};
        const configs = {};
        const frames = {};
        const plainObject = {
            configs,
            appResults,
            frames
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults[name] = value;
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs[name] = value;
        });
        for (const [name, buffer] of this.m_frameEvents.frameEntries) {
            frames[name] = buffer.asArray();
        }
        plainObject.messages = this.m_frameEvents.messages.asArray();
        return plainObject;
    }
    /**
     * Convert the last frame values to a plain object that can be serialized. Required to copy the
     * test results over to nightwatch.
     */
    getLastFrameStatistics() {
        const appResults = {};
        const configs = {};
        const frames = {};
        const plainObject = {
            configs,
            appResults,
            frames
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults[name] = value;
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs[name] = value;
        });
        for (const [name, buffer] of this.m_frameEvents.frameEntries) {
            frames[name] = buffer.bottom;
        }
        plainObject.messages = this.m_frameEvents.messages.asArray();
        return plainObject;
    }
}
PerformanceStatistics.m_instance = undefined;
exports.PerformanceStatistics = PerformanceStatistics;


/***/ }),

/***/ "../harp-mapview/lib/ThemeHelpers.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/ThemeHelpers.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.
 */
function toPixelFormat(format) {
    switch (format) {
        case "Alpha":
            return THREE.AlphaFormat;
        case "RGB":
            return THREE.RGBFormat;
        case "RGBA":
            return THREE.RGBAFormat;
        case "Luminance":
            return THREE.LuminanceFormat;
        case "LuminanceAlpha":
            return THREE.LuminanceAlphaFormat;
        case "RGBE":
            return THREE.RGBEFormat;
        case "Depth":
            return THREE.DepthFormat;
        case "DepthStencil":
            return THREE.DepthStencilFormat;
        case "Red":
            return THREE.RedFormat;
        default:
            throw new Error(`invalid pixel format: ${format}`);
    }
}
exports.toPixelFormat = toPixelFormat;
/**
 * Returns `three.js` texture data types based on a [[TextureDataType]] specified.
 */
function toTextureDataType(dataType) {
    switch (dataType) {
        case "UnsignedByte":
            return THREE.UnsignedByteType;
        case "Byte":
            return THREE.ByteType;
        case "Short":
            return THREE.ShortType;
        case "UnsignedShort":
            return THREE.UnsignedShortType;
        case "Int":
            return THREE.IntType;
        case "UnsignedInt":
            return THREE.UnsignedIntType;
        case "Float":
            return THREE.FloatType;
        case "HalfFloat":
            return THREE.HalfFloatType;
        default:
            throw new Error(`invalid texture data type: ${dataType}`);
    }
}
exports.toTextureDataType = toTextureDataType;
/**
 * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.
 */
function toWrappingMode(mode) {
    switch (mode) {
        case "clamp":
            return THREE.ClampToEdgeWrapping;
        case "repeat":
            return THREE.RepeatWrapping;
        case "mirror":
            return THREE.MirroredRepeatWrapping;
        default:
            throw new Error(`invalid wrapping mode: ${mode}`);
    }
}
exports.toWrappingMode = toWrappingMode;
/**
 * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.
 */
function toTextureFilter(filter) {
    switch (filter) {
        case "nearest":
            return THREE.NearestFilter;
        case "nearestMipMapNearest":
            return THREE.NearestMipMapNearestFilter;
        case "nearestMipMapLinear":
            return THREE.NearestMipMapLinearFilter;
        case "linear":
            return THREE.LinearFilter;
        case "linearMipMapNearest":
            return THREE.LinearMipMapNearestFilter;
        case "linearMipMapLinear":
            return THREE.LinearMipMapLinearFilter;
        default:
            throw new Error(`invalid texture filter: ${filter}`);
    }
}
exports.toTextureFilter = toTextureFilter;
/**
 * Create a specific light for lightening the map.
 */
function createLight(lightDescription) {
    switch (lightDescription.type) {
        case "ambient": {
            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            return light;
        }
        case "directional": {
            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            if (lightDescription.castShadow !== undefined) {
                light.castShadow = lightDescription.castShadow;
            }
            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
            light.position.normalize();
            return light;
        }
    }
}
exports.createLight = createLight;


/***/ }),

/***/ "../harp-mapview/lib/ThemeLoader.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/ThemeLoader.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Theme_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Theme */ "../harp-datasource-protocol/lib/Theme.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "../harp-mapview/lib/SkyCubemapTexture.ts");
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;
/**
 * Loads and validates a theme from URL objects.
 */
class ThemeLoader {
    /**
     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a
     * JSON-encoded theme.
     *
     * By default, resolves following features of theme:
     *
     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])
     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section
     *     of theme (see [[resolveThemeReferences]])
     *
     * Relative URLs of reference resources are resolved to full URL using the document's base URL
     * (see [[resolveUrls]]).
     *
     * @param theme [[Theme]] instance or theme URL to the theme.
     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for
     *    this load request.
     */
    static load(theme, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = options || {};
            if (typeof theme === "string") {
                const themeUrl = harp_utils_1.defaultUrlResolver(theme);
                const response = yield fetch(themeUrl, { signal: options.signal });
                if (!response.ok) {
                    throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);
                }
                theme = (yield response.json());
                theme.url = themeUrl;
            }
            if (theme === null || theme === undefined) {
                throw new Error("ThemeLoader#load: loaded resource is not valid JSON");
            }
            theme = theme;
            // Remember the URL where the theme has been loaded from.
            theme = this.resolveUrls(theme);
            const resolveDefinitions = harp_utils_1.getOptionValue(options.resolveDefinitions, true);
            theme = yield ThemeLoader.resolveBaseTheme(theme, options);
            if (resolveDefinitions) {
                const contextLoader = new harp_utils_1.ContextLogger(options.logger || console, `when processing Theme ${theme.url}:`);
                ThemeLoader.resolveThemeReferences(theme, contextLoader);
            }
            return theme;
        });
    }
    /**
     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.
     *
     * @param theme
     */
    static isThemeLoaded(theme) {
        return theme.extends === undefined;
    }
    /**
     * @deprecated Please use `ThemeLoader.load`
     *
     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a JSON-encoded
     * theme.
     *
     * @param themeUrl The URL to the theme.
     *
     */
    static loadAsync(themeUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            return ThemeLoader.load(themeUrl);
        });
    }
    /**
     * Resolves all [[Theme]]'s relatives URLs to full URL using the [[Theme]]'s URL
     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
     *
     * This method mutates original `theme` instance.
     *
     * @param theme The [[Theme]] to resolve.
     */
    static resolveUrls(theme) {
        // Ensure that all resources referenced in theme by relative URLs are in fact relative to
        // theme.
        if (theme.url === undefined) {
            return theme;
        }
        const childUrlResolver = harp_utils_1.composeUrlResolvers((childUrl) => harp_utils_1.resolveReferenceUrl(theme.url, childUrl), harp_utils_1.defaultUrlResolver);
        if (theme.extends) {
            if (typeof theme.extends === "string") {
                theme.extends = childUrlResolver(theme.extends);
            }
            else {
                if (theme.extends.url === undefined) {
                    theme.extends.url = theme.url;
                    theme.extends = this.resolveUrls(theme.extends);
                }
            }
        }
        if (theme.sky && theme.sky.type === "cubemap") {
            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {
                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];
                if (faceUrl !== undefined) {
                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver(faceUrl);
                }
            }
        }
        if (theme.images) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                image.url = childUrlResolver(image.url);
                if (image.atlas !== undefined) {
                    image.atlas = childUrlResolver(image.atlas);
                }
            }
        }
        if (theme.fontCatalogs) {
            for (const font of theme.fontCatalogs) {
                font.url = childUrlResolver(font.url);
            }
        }
        if (theme.poiTables) {
            for (const poiTable of theme.poiTables) {
                poiTable.url = childUrlResolver(poiTable.url);
            }
        }
        if (theme.styles) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                const styleSet = theme.styles[styleSetName];
                for (const style of styleSet) {
                    if (!style.attr) {
                        continue;
                    }
                    ["map", "normalMap", "displacementMap", "roughnessMap"].forEach(texturePropertyName => {
                        const textureProperty = style.attr[texturePropertyName];
                        if (textureProperty && typeof textureProperty === "string") {
                            style.attr[texturePropertyName] = childUrlResolver(textureProperty);
                        }
                    });
                }
            }
        }
        return theme;
    }
    /**
     * Expand all `ref` expressions in [[Theme]] basing on `definitions`.
     *
     * This method mutates original `theme` instance.
     */
    static resolveThemeReferences(theme, contextLogger) {
        if (theme.definitions !== undefined) {
            contextLogger.pushAttr("definitions");
            /**
             * First, try to resolve all internal references in definitions, so if we may save few
             * CPU cycles if some definition is used many times in actual style sets.
             */
            for (const definitionName in theme.definitions) {
                if (!theme.definitions.hasOwnProperty(definitionName)) {
                    continue;
                }
                const def = theme.definitions[definitionName];
                if (Theme_1.isActualSelectorDefinition(def)) {
                    contextLogger.pushAttr(definitionName);
                    const resolvedDef = ThemeLoader.resolveStyle(def, theme.definitions, contextLogger);
                    contextLogger.pop();
                    if (resolvedDef === undefined) {
                        contextLogger.pushAttr(definitionName);
                        contextLogger.warn("skipping invalid style in definition");
                        contextLogger.pop();
                        delete theme.definitions[definitionName];
                    }
                    else {
                        theme.definitions[definitionName] = resolvedDef;
                    }
                }
            }
            contextLogger.pop();
        }
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                contextLogger.pushAttr("styles");
                contextLogger.pushAttr(styleSetName);
                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(theme.styles[styleSetName], theme.definitions, contextLogger);
                contextLogger.pop();
                contextLogger.pop();
            }
        }
        return theme;
    }
    /**
     * Expand all `ref` in [[StyleSet]] basing on `definitions`.
     */
    static resolveStyleSet(styleSet, definitions, contextLogger) {
        const result = [];
        for (let index = 0; index < styleSet.length; ++index) {
            const currentStyle = styleSet[index];
            contextLogger.pushIndex(index);
            const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);
            if (resolvedStyle !== undefined) {
                result.push(resolvedStyle);
            }
            else {
                contextLogger.warn("invalid style, ignored");
            }
            contextLogger.pop();
        }
        return result;
    }
    /**
     * Expand all `ref` in [[Style]] instance basing on `definitions`.
     */
    static resolveStyle(style, definitions, contextLogger) {
        if (Theme_1.isReference(style)) {
            // expand and instantiate references to style definitions.
            const def = definitions && definitions[style[1]];
            if (!def) {
                contextLogger.warn(`invalid reference '${style[1]}' - not found`);
                return undefined;
            }
            if (!Theme_1.isActualSelectorDefinition(def)) {
                contextLogger.warn(`invalid reference '${style[1]}' - expected style definition`);
                return undefined;
            }
            // instantiate the style
            style = harp_utils_1.cloneDeep(def);
        }
        style = style;
        if (Theme_1.isReference(style.when)) {
            const ref = style.when[1];
            contextLogger.pushAttr("when");
            const def = definitions && definitions[ref];
            if (!def) {
                contextLogger.warn(`invalid reference '${ref}' - not found`);
                contextLogger.pop();
                return undefined;
            }
            if (!Theme_1.isSelectorDefinition(def)) {
                contextLogger.warn(`invalid reference '${ref}' - expected selector definition`);
                contextLogger.pop();
                return undefined;
            }
            style.when = def.value;
        }
        if (style.attr !== undefined) {
            const attr = style.attr;
            contextLogger.pushAttr("attr");
            for (const prop in attr) {
                if (!attr.hasOwnProperty(prop)) {
                    continue;
                }
                const value = attr[prop];
                if (!Theme_1.isReference(value)) {
                    continue; // nothing to do
                }
                const def = definitions && definitions[value[1]];
                if (!def) {
                    delete attr[prop];
                    contextLogger.pushAttr(prop);
                    contextLogger.warn(`invalid reference '${value[1]}' - not found`);
                    contextLogger.pop();
                    continue;
                }
                if (!Theme_1.isValueDefinition(def)) {
                    delete attr[prop];
                    contextLogger.pushAttr(prop);
                    contextLogger.warn(`invalid reference '${value[1]}' - expected value definition`);
                    contextLogger.pop();
                    continue;
                }
                attr[prop] = def.value;
            }
            contextLogger.pop();
        }
        return style;
    }
    /**
     * Realize `extends` clause by merging `theme` with it's base [[Theme]].
     *
     * @param theme [Theme] object
     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for
     *    this load request.
     */
    static resolveBaseTheme(theme, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = options || {};
            if (theme.extends === undefined) {
                return theme;
            }
            const maxInheritanceDepth = harp_utils_1.getOptionValue(options.maxInheritanceDepth, exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);
            if (maxInheritanceDepth <= 0) {
                throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);
            }
            const baseTheme = theme.extends;
            delete theme.extends;
            const actualBaseTheme = yield ThemeLoader.load(baseTheme, Object.assign({}, options, { resolveDefinitions: false, maxInheritanceDepth: maxInheritanceDepth - 1 }));
            const definitions = Object.assign({}, actualBaseTheme.definitions, theme.definitions);
            const styles = Object.assign({}, actualBaseTheme.styles, theme.styles);
            return Object.assign({}, actualBaseTheme, theme, { definitions, styles });
        });
    }
}
exports.ThemeLoader = ThemeLoader;


/***/ }),

/***/ "../harp-mapview/lib/Tile.ts":
/*!***********************************!*\
  !*** ../harp-mapview/lib/Tile.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const harp_geometry_1 = __webpack_require__(/*! @here/harp-geometry */ "../harp-geometry/index.ts");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const logger = harp_utils_1.LoggerManager.instance.create("Tile");
function decodedTileHasGeometry(decodedTile) {
    return (decodedTile.geometries.length ||
        (decodedTile.poiGeometries !== undefined && decodedTile.poiGeometries.length) ||
        (decodedTile.textGeometries !== undefined && decodedTile.textGeometries.length) ||
        (decodedTile.textPathGeometries !== undefined && decodedTile.textPathGeometries.length));
}
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * A default empty [[DecodedTile]], for tiles that must be rendered but do not have any objects.
 */
const defaultEmptyDecodedTile = {
    techniques: [],
    geometries: []
};
/**
 * Compute the memory footprint of `TileFeatureData`.
 */
function getFeatureDataSize(featureData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    if (featureData.ids !== undefined) {
        numBytes += featureData.ids.length * 8;
    }
    if (featureData.starts !== undefined) {
        numBytes += featureData.starts.length * 8;
    }
    if (featureData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
exports.getFeatureDataSize = getFeatureDataSize;
/**
 * Compute the memory footprint of `RoadIntersectionData`.
 */
function getRoadIntersectionDataSize(intersectionData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    // 8 bytes per techniqueIndex
    // 8 bytes per start
    // 8 bytes per width
    // 8 bytes per position
    // 100 (estimated) bytes per technique
    const bytesPerEntry = 8 + 8 + 8 + 8 + MINIMUM_OBJECT_SIZE_ESTIMATION;
    const numEntries = intersectionData.techniqueIndex.length;
    numBytes += intersectionData.techniqueIndex.length * bytesPerEntry;
    if (intersectionData.ids !== undefined) {
        numBytes += numEntries * 8;
    }
    if (intersectionData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += numEntries * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
/**
 * Missing Typedoc
 */
var TileLoaderState;
(function (TileLoaderState) {
    TileLoaderState[TileLoaderState["Initialized"] = 0] = "Initialized";
    TileLoaderState[TileLoaderState["Loading"] = 1] = "Loading";
    TileLoaderState[TileLoaderState["Loaded"] = 2] = "Loaded";
    TileLoaderState[TileLoaderState["Decoding"] = 3] = "Decoding";
    TileLoaderState[TileLoaderState["Ready"] = 4] = "Ready";
    TileLoaderState[TileLoaderState["Canceled"] = 5] = "Canceled";
    TileLoaderState[TileLoaderState["Failed"] = 6] = "Failed";
})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));
/**
 * The class that holds the tiled data for a [[DataSource]].
 */
class Tile {
    /**
     * Creates a new [[Tile]].
     *
     * @param dataSource The [[DataSource]] that created this [[Tile]].
     * @param tileKey The unique identifier for this [[Tile]]. Currently only up to level 24 is
     * supported, because of the use of the upper bits for the offset.
     * @param offset The optional offset, this is an integer which represents what multiple of 360
     * degrees to shift, only useful for flat projections, hence optional.
     * @param localTangentSpace Whether the tile geometry is in local tangent space or not.
     */
    constructor(dataSource, tileKey, offset = 0, localTangentSpace) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.offset = offset;
        /**
         * A list of the THREE.js objects stored in this `Tile`.
         */
        this.objects = [];
        /**
         * The optional list of HERE TileKeys of tiles with geometries that cross
         * the boundaries of this `Tile`.
         */
        this.dependencies = new Array();
        /**
         * The bounding box of this `Tile` in world coordinates.
         */
        this.boundingBox = new harp_geometry_1.OrientedBox3();
        /**
         * Keeping some stats for the individual [[Tile]]s to analyze caching behavior.
         *
         * The frame the [[Tile]] was last requested. This is required to know when the given [[Tile]]
         * can be removed from the cache.
         */
        this.frameNumLastRequested = -1;
        /**
         * The frame the `Tile` was first visible.
         */
        this.frameNumVisible = -1;
        /**
         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine
         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is
         * visible.
         */
        this.frameNumLastVisible = -1;
        /**
         * After removing from cache, this is the number of frames the `Tile` was visible.
         */
        this.numFramesVisible = 0;
        /**
         * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the
         * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of
         * computing visibility.
         */
        this.visibilityCounter = -1;
        this.m_disposed = false;
        this.m_localTangentSpace = false;
        this.m_forceHasGeometry = undefined;
        // Used for [[TextElement]]s which the developer defines.
        this.m_userTextElements = [];
        // Used for [[TextElement]]s that are stored in the data, and that are placed explicitly,
        // fading in and out.
        this.m_textElementGroups = new harp_utils_1.GroupedPriorityList();
        // All visible [[TextElement]]s.
        this.m_placedTextElements = new harp_utils_1.GroupedPriorityList();
        // If `true`, the text content of the [[Tile]] changed.
        this.m_textElementsChanged = false;
        this.m_visibleArea = 0;
        // List of owned textures for disposal
        this.m_ownedTextures = new WeakSet();
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.projection.projectBox(this.geoBox, this.boundingBox);
        this.m_localTangentSpace = localTangentSpace !== undefined ? localTangentSpace : false;
    }
    /**
     * The visibility status of the [[Tile]]. It is actually visible or planned to become visible.
     */
    get isVisible() {
        // Tiles are not evaluated as invisible until the second frame they aren't requested.
        // This happens in order to prevent that, during [[VisibleTileSet]] visibility evaluation,
        // visible tiles that haven't yet been evaluated for the current frame are preemptively
        // removed from [[DataSourceCache]].
        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
    }
    set isVisible(visible) {
        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
    }
    /**
     * The [[Projection]] currently used by the [[MapView]].
     */
    get projection() {
        return this.dataSource.projection;
    }
    /**
     * The [[MapView]] this `Tile` belongs to.
     */
    get mapView() {
        return this.dataSource.mapView;
    }
    /**
     * Whether the data of this tile is in local tangent space or not.
     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then
     * [[MapView]] will rotate the objects before rendering using the rotation matrix of the
     * oriented [[boundingBox]].
     */
    get localTangentSpace() {
        return this.m_localTangentSpace;
    }
    /**
     * Get the currently visible [[TextElement]]s of this `Tile`. This list is continuously
     * modified, and is not designed to be used to store developer-defined [[TextElements]].
     */
    get placedTextElements() {
        return this.m_placedTextElements;
    }
    /*
     * The size of this Tile in system memory.
     */
    get memoryUsage() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo.heapSize;
    }
    /**
     * The center of this `Tile` in world coordinates.
     */
    get center() {
        return this.boundingBox.position;
    }
    /**
     * Compute [[TileResourceInfo]] of this `Tile`. May be using a cached value. The method
     * `invalidateResourceInfo` can be called beforehand to force a recalculation.
     *
     * @returns `TileResourceInfo` for this `Tile`.
     */
    getResourceInfo() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo;
    }
    /**
     * Force invalidation of the cached [[TileResourceInfo]]. Useful after the `Tile` has been
     * modified.
     */
    invalidateResourceInfo() {
        this.m_resourceInfo = undefined;
    }
    /**
     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is
     * disposed.
     * @param texture Texture to be owned by the `Tile`
     */
    addOwnedTexture(texture) {
        this.m_ownedTextures.add(texture);
    }
    /**
     * Gets the list of developer-defined [[TextElement]] in this `Tile`. This list is always
     * rendered first.
     */
    get userTextElements() {
        return this.m_userTextElements;
    }
    /**
     * Adds a developer-defined [[TextElement]] to this `Tile`. The [[TextElement]] is always
     * visible, if it's in the map's currently visible area.
     *
     * @param textElement The Text element to add.
     */
    addUserTextElement(textElement) {
        this.m_userTextElements.push(textElement);
        this.textElementsChanged = true;
    }
    /**
     * Removes a developer-defined [[TextElement]] from this `Tile`.
     *
     * @param textElement A developer-defined TextElement to remove.
     * @returns `true` if the element has been removed successfully; `false` otherwise.
     */
    removeUserTextElement(textElement) {
        const foundIndex = this.m_userTextElements.indexOf(textElement);
        if (foundIndex >= 0) {
            this.m_userTextElements.splice(foundIndex, 1);
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }
    /**
     * Adds a [[TextElement]] to this `Tile`, which is added to the visible set of
     * [[TextElement]]s based on the capacity and visibility. The [[TextElement]]'s priority
     * controls if or when it becomes visible.
     *
     * To ensure that a TextElement is visible, use a high value for its priority, such as
     * `Number.MAX_SAFE_INTEGER`. Since the number of visible TextElements is limited by the
     * screen space, not all TextElements are visible at all times.
     *
     * @param textElement The TextElement to add.
     */
    addTextElement(textElement) {
        this.textElementGroups.add(textElement);
        this.textElementsChanged = true;
    }
    /**
     * Removes a [[TextElement]] from this `Tile`. For the element to be removed successfully, the
     * priority of the [[TextElement]] has to be equal to its priority when it was added.
     *
     * @param textElement The TextElement to remove.
     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.
     */
    removeTextElement(textElement) {
        if (this.textElementGroups.remove(textElement)) {
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }
    /**
     * Gets the current [[GroupedPriorityList]] which contains a list of all [[TextElement]]s to be
     * selected and placed for rendering.
     */
    get textElementGroups() {
        return this.m_textElementGroups;
    }
    /**
     * Gets the current modification state for the list of [[TextElement]]s in the `Tile`. If the
     * value is `true` the TextElement is placed for rendering during the next frame.
     */
    get textElementsChanged() {
        return this.m_textElementsChanged;
    }
    set textElementsChanged(changed) {
        this.m_textElementsChanged = changed;
    }
    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare its road
     * geometry for picking.
     */
    prepareTileInfo() {
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        if (this.m_decodedTile === undefined || this.m_disposed || !this.isVisible) {
            return;
        }
        if (this.m_decodedTile.tileInfo !== undefined) {
            this.roadIntersectionData = this.dataSource.mapView.pickHandler.registerTile(this);
        }
    }
    /**
     * Called before [[MapView]] starts rendering this `Tile`.
     *
     * @param zoomLevel The current zoom level.
     * @returns Returns `true` if this `Tile` should be rendered.
     */
    willRender(_zoomLevel) {
        return true;
    }
    /**
     * Called after [[MapView]] has rendered this `Tile`.
     */
    didRender() {
        // to be overridden by subclasses
    }
    /**
     * Estimated visible area of tile used for sorting the priorities during loading.
     */
    get visibleArea() {
        return this.m_visibleArea;
    }
    set visibleArea(area) {
        this.m_visibleArea = area;
        if (this.tileLoader !== undefined) {
            this.tileLoader.updatePriority(area);
        }
    }
    /**
     * Gets the decoded tile; it is removed after geometry handling.
     */
    get decodedTile() {
        return this.m_decodedTile;
    }
    /**
     * Applies the decoded tile to the tile.
     * If the geometry is empty, then the tile's forceHasGeometry flag is set.
     * Map is updated.
     * @param decodedTile The decoded tile to set.
     */
    set decodedTile(decodedTile) {
        if (decodedTile && decodedTileHasGeometry(decodedTile)) {
            if (decodedTile.copyrightHolderIds !== undefined) {
                this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));
            }
            this.setDecodedTile(decodedTile);
        }
        else {
            // empty tiles are traditionally ignored and don't need decode
            this.forceHasGeometry(true);
        }
        this.dataSource.requestUpdate();
    }
    /**
     * Remove the decodedTile when no longer needed.
     */
    removeDecodedTile() {
        this.m_decodedTile = undefined;
        this.invalidateResourceInfo();
    }
    /**
     * Called by the [[TileLoader]] after the `Tile` has finished loading its map data. Can be used
     * to add content to the `Tile`. The [[DecodedTile]] should still be available.
     */
    loadingFinished() {
        // To be used in subclasses.
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free the geometry of a `Tile` object.
     *
     * @param object The object that references the geometry.
     * @returns `true` if the geometry can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectGeometry(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a `Tile` object's material.
     *
     * @param object The object referencing the geometry.
     * @returns `true` if the material can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectMaterial(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a Texture that is part of a `Tile` object's material.
     *
     * @param texture The texture about to be disposed.
     * @returns `true` if the texture can be disposed.
     */
    shouldDisposeTexture(texture) {
        return this.m_ownedTextures.has(texture);
    }
    /**
     * Returns `true` if this `Tile` has been disposed.
     */
    get disposed() {
        return this.m_disposed;
    }
    /**
     * Gets the [[TileGeometryLoader]] that manages this tile.
     */
    get tileGeometryLoader() {
        return this.m_tileGeometryLoader;
    }
    /**
     * Sets the [[TileGeometryLoader]] to manage this tile.
     *
     * @param tileGeometryLoader A [[TileGeometryLoader]] instance to manage the geometry creation
     *      for this tile.
     */
    set tileGeometryLoader(tileGeometryLoader) {
        this.m_tileGeometryLoader = tileGeometryLoader;
    }
    /**
     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.
     */
    get basicGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded.
     */
    get allGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * MapView checks if this `Tile` is ready to be rendered while culling.
     *
     * By default, MapView checks if the [[objects]] list is not empty. However, you can override
     * this check by manually setting this property.
     */
    get hasGeometry() {
        if (this.m_forceHasGeometry === undefined) {
            return this.objects.length !== 0;
        }
        else {
            return this.m_forceHasGeometry;
        }
    }
    /**
     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.
     *
     * @param value A new value for the [[hasGeometry]] flag.
     */
    forceHasGeometry(value) {
        if (value === true) {
            this.setDecodedTile(defaultEmptyDecodedTile);
        }
        this.m_forceHasGeometry = value;
    }
    /**
     * Reset the visibility counter. This will force the visibility check to be rerun on all objects
     * in this `Tile`.
     */
    resetVisibilityCounter() {
        this.visibilityCounter = -1;
    }
    /**
     * Gets the [[ITileLoader]] that manages this tile.
     */
    get tileLoader() {
        return this.m_tileLoader;
    }
    /**
     * Sets the [[ITileLoader]] to manage this tile.
     *
     * @param tileLoader A [[ITileLoader]] instance to manage the loading process for this tile.
     */
    set tileLoader(tileLoader) {
        this.m_tileLoader = tileLoader;
    }
    /**
     * Loads this `Tile` geometry.
     */
    load() {
        const tileLoader = this.tileLoader;
        if (tileLoader === undefined) {
            return;
        }
        tileLoader
            .loadAndDecode()
            .then(tileLoaderState => {
            this.clear();
            harp_utils_1.assert(tileLoaderState === TileLoaderState.Ready);
            const decodedTile = tileLoader.decodedTile;
            this.decodedTile = decodedTile;
        })
            .catch(tileLoaderState => {
            if (tileLoaderState !== TileLoaderState.Canceled &&
                tileLoaderState !== TileLoaderState.Failed) {
                logger.error("Unknown error" + tileLoaderState);
            }
        });
    }
    /**
     * Handler for animation of `Tile` geometries.
     */
    get animatedExtrusionTileHandler() {
        return this.m_animatedExtrusionTileHandler;
    }
    set animatedExtrusionTileHandler(handler) {
        this.m_animatedExtrusionTileHandler = handler;
    }
    /**
     * Frees the rendering resources allocated by this `Tile`.
     *
     * The default implementation of this method frees the geometries and the materials for all the
     * reachable objects.
     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this
     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).
     */
    clear() {
        const disposeMaterial = (material) => {
            Object.getOwnPropertyNames(material).forEach((property) => {
                const materialProperty = material[property];
                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {
                    const texture = materialProperty;
                    if (this.shouldDisposeTexture(texture)) {
                        texture.dispose();
                    }
                }
            });
            material.dispose();
        };
        const disposeObject = (object) => {
            if (object.geometry !== undefined && this.shouldDisposeObjectGeometry(object)) {
                object.geometry.dispose();
            }
            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {
                if (object.material instanceof Array) {
                    object.material.forEach((material) => {
                        if (material !== undefined) {
                            disposeMaterial(material);
                        }
                    });
                }
                else {
                    disposeMaterial(object.material);
                }
            }
        };
        this.objects.forEach((rootObject) => {
            rootObject.traverse((object) => {
                disposeObject(object);
            });
            disposeObject(rootObject);
        });
        this.objects.length = 0;
        if (this.preparedTextPaths) {
            this.preparedTextPaths = [];
        }
        if (this.m_animatedExtrusionTileHandler !== undefined) {
            this.m_animatedExtrusionTileHandler.dispose();
        }
        this.placedTextElements.clear();
        this.textElementGroups.clear();
        this.userTextElements.length = 0;
        this.invalidateResourceInfo();
    }
    /**
     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.
     */
    dispose() {
        if (this.m_disposed) {
            return;
        }
        if (this.m_tileLoader) {
            this.m_tileLoader.cancel();
            this.m_tileLoader = undefined;
        }
        if (this.m_tileGeometryLoader !== undefined) {
            this.m_tileGeometryLoader.dispose();
            this.m_tileGeometryLoader = undefined;
        }
        this.clear();
        this.userTextElements.length = 0;
        this.m_disposed = true;
        // Ensure that tile is removable from tile cache.
        this.frameNumLastRequested = 0;
    }
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        if (this.m_decodedTile.boundingBox !== undefined) {
            // If the decoder provides a more accurate bounding box than the one we computed from
            // the flat geo box we take it instead.
            this.boundingBox.copy(this.m_decodedTile.boundingBox);
        }
        this.invalidateResourceInfo();
        const stats = Statistics_1.PerformanceStatistics.instance;
        if (stats.enabled && decodedTile.decodeTime !== undefined) {
            stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
        }
    }
    computeResourceInfo() {
        let heapSize = 0;
        let num3dObjects = 0;
        let numTextElements = 0;
        let numUserTextElements = 0;
        const aggregatedObjSize = {
            heapSize: 0,
            gpuSize: 0
        };
        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.
        // They should be counted only once even if they are shared.
        const visitedObjects = new Map();
        for (const object of this.objects) {
            if (object.visible) {
                num3dObjects++;
            }
            Utils_1.MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);
        }
        for (const group of this.textElementGroups.groups) {
            numTextElements += group[1].elements.length;
        }
        numUserTextElements = this.userTextElements.length;
        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes
        // was the minimum retained size of a TextElement that was not being rendered. If a
        // TextElement is actually rendered, the size may be _much_ bigger.
        heapSize += (numTextElements + numUserTextElements) * 312;
        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {
            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
        }
        if (this.roadIntersectionData !== undefined) {
            heapSize += getRoadIntersectionDataSize(this.roadIntersectionData);
        }
        this.m_resourceInfo = {
            heapSize: aggregatedObjSize.heapSize + heapSize,
            gpuSize: aggregatedObjSize.gpuSize,
            num3dObjects,
            numTextElements,
            numUserTextElements
        };
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "../harp-mapview/lib/Utils.ts":
/*!************************************!*\
  !*** ../harp-mapview/lib/Utils.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewUtils");
// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.
// There may be cases where it is possible to construct Object3Ds with considerable less memory
// consumption, but this value is used to simplify the estimation.
const MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;
const MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
// Caching those for performance reasons.
const groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);
const groundNormalInvPlanarProj = groundNormalPlanarProj.clone().negate();
const groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());
const groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);
const cameraZPosition = new THREE.Vector3(0, 0, 0);
const rotationMatrix = new THREE.Matrix4();
const unprojectionMatrix = new THREE.Matrix4();
const rayCaster = new THREE.Raycaster();
const yawQuaternion = new THREE.Quaternion();
const pitchQuaternion = new THREE.Quaternion();
const tmpQuaternion = new THREE.Quaternion();
const tmpMatrix = new THREE.Matrix4();
const tmpVectors = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
var MapViewUtils;
(function (MapViewUtils) {
    /**
     * The yaw axis around we rotate when we change the yaw.
     * This axis is fix and is the -Z axis `(0,0,1)`.
     */
    const yawAxis = new THREE.Vector3(0, 0, 1);
    /**
     * The pitch axis which we use to rotate around when we change the pitch.
     * The axis is fix and is the +X axis `(1,0,0)`.
     */
    const pitchAxis = new THREE.Vector3(1, 0, 0);
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param mapView Instance of MapView.
     * @param targetPositionOnScreenXinNDC Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC Target y position in NDC space.
     * @param zoomLevel The desired zoom level.
     */
    function zoomOnTargetPosition(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        // Get current target position in world space before we zoom.
        const targetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);
        const zoomDistance = calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel);
        // Set the cameras height according to the given zoom level.
        if (mapView.projection.type === geoUtils.ProjectionType.Planar) {
            mapView.camera.position.setZ(zoomDistance);
        }
        else if (mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            mapView.camera.position.setLength(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + zoomDistance);
        }
        mapView.camera.matrixWorldNeedsUpdate = true;
        // Get new target position after the zoom
        const newTargetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);
        if (!targetPosition || !newTargetPosition) {
            return;
        }
        if (mapView.projection.type === geoUtils.ProjectionType.Planar) {
            // Calculate the difference and pan the map to maintain the map relative to the target
            // position.
            targetPosition.sub(newTargetPosition);
            panCameraAboveFlatMap(mapView, targetPosition.x, targetPosition.y);
        }
        else if (mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            rotateCameraAroundGlobe(mapView, targetPosition, newTargetPosition);
        }
    }
    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;
    /**
     * Returns the [[GeoCoordinates]] of the camera, given its target coordinates on the map and its
     * zoom, yaw and pitch.
     *
     * @param targetCoordinates Coordinates of the center of the view.
     * @param distance Distance to the target in meters.
     * @param yawDeg Camera yaw in degrees.
     * @param pitchDeg Camera pitch in degrees.
     * @param mapView Active MapView, needed to get the camera fov and map projection.
     */
    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
        // Get the world distance between the target and the camera.
        const pitchRad = THREE.Math.degToRad(pitchDeg);
        const cameraHeight = distance * Math.cos(pitchRad);
        const projectedDistanceOnTheGround = cameraHeight * Math.tan(pitchRad);
        // Get the camera coordinates.
        const yawRad = THREE.Math.degToRad(yawDeg);
        const worldTargetCoordinates = mapView.projection.projectPoint(targetCoordinates);
        const cameraWorldCoordinates = {
            x: worldTargetCoordinates.x + Math.sin(yawRad) * projectedDistanceOnTheGround,
            y: worldTargetCoordinates.y - Math.cos(yawRad) * projectedDistanceOnTheGround,
            z: 0
        };
        // Convert back to GeoCoordinates and return result.
        return mapView.projection.unprojectPoint(cameraWorldCoordinates);
    }
    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
    /**
     * Casts a ray in NDC space from the current map view and returns the intersection point of that
     * ray wih the map in world space.
     *
     * @param mapView Instance of MapView.
     * @param pointOnScreenXinNDC X coordinate in NDC space.
     * @param pointOnScreenYinNDC Y coordinate in NDC space.
     * @param elevation Optional param used to offset the ground plane. Used when wanting to pan
     * based on a plane at some altitude. Necessary for example when panning with terrain.
     *
     * @returns Intersection coordinates, or `null` if raycast failed.
     */
    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
        const pointInNDCPosition = new THREE.Vector3(pointOnScreenXinNDC, pointOnScreenYinNDC, 0.5);
        cameraZPosition.copy(mapView.camera.position);
        rotationMatrix.extractRotation(mapView.camera.matrixWorld);
        // Prepare the unprojection matrix which projects from NDC space to camera space
        // and takes the current rotation of the camera into account.
        unprojectionMatrix.multiplyMatrices(rotationMatrix, unprojectionMatrix.getInverse(mapView.camera.projectionMatrix));
        // Unproject the point via the unprojection matrix.
        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(unprojectionMatrix);
        // Use the point in camera space as the vector towards this point.
        rayCaster.set(cameraZPosition, pointInCameraSpace.normalize());
        if (elevation !== undefined) {
            groundPlane.constant = -elevation;
        }
        const worldPosition = new THREE.Vector3();
        const result = mapView.projection.type === geoUtils.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)
            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
        groundPlane.constant = 0;
        return result;
    }
    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;
    /**
     * Calculates and returns the distance from the ground, which is needed to put the camera to
     * this height, to see the size of the area that would be covered by one tile for the given zoom
     * level.
     *
     * @param mapView Instance of MapView.
     * @param zoomLevel The zoom level to get the equivalent height to.
     */
    function calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel) {
        const cameraPitch = extractYawPitchRoll(mapView.camera.quaternion, mapView.projection.type)
            .pitch;
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return ((mapView.focalLength * tileSize) / 256) * Math.cos(cameraPitch);
    }
    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
    /**
     * Pans the camera according to the projection.
     *
     * @param mapView Instance of MapView.
     * @param xOffset In world space. Value > 0 will pan the map to the right, value < 0 will pan
     * the map to the left in default camera orientation.
     * @param yOffset In world space. Value > 0 will pan the map upwards, value < 0 will pan the map
     * downwards in default camera orientation.
     */
    function panCameraAboveFlatMap(mapView, offsetX, offsetY) {
        mapView.camera.position.x += offsetX;
        mapView.camera.position.y += offsetY;
    }
    MapViewUtils.panCameraAboveFlatMap = panCameraAboveFlatMap;
    /**
     * The function doing a pan when [[MapView]]'s active [[ProjectionType]] is spherical.
     *
     * @param mapView MapView instance.
     * @param fromWorld Start vector representing the scene position of a geolocation.
     * @param toWorld End vector representing the scene position of a geolocation.
     */
    function rotateCameraAroundGlobe(mapView, fromWorld, toWorld) {
        tmpQuaternion.setFromUnitVectors(fromWorld.normalize(), toWorld.normalize()).inverse();
        tmpMatrix.makeRotationFromQuaternion(tmpQuaternion);
        mapView.camera.applyMatrix(tmpMatrix);
        mapView.camera.updateMatrixWorld();
    }
    MapViewUtils.rotateCameraAroundGlobe = rotateCameraAroundGlobe;
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param mapView Instance of MapView.
     * @param yaw Yaw in degrees.
     * @param pitch Pitch in degrees.
     */
    function setRotation(mapView, yaw, pitch) {
        yawQuaternion.setFromAxisAngle(yawAxis, geoUtils.MathUtils.degToRad(yaw));
        pitchQuaternion.setFromAxisAngle(pitchAxis, geoUtils.MathUtils.degToRad(pitch));
        yawQuaternion.multiply(pitchQuaternion);
        mapView.camera.quaternion.copy(yawQuaternion);
        mapView.camera.matrixWorldNeedsUpdate = true;
    }
    MapViewUtils.setRotation = setRotation;
    /**
     * Extracts yaw, pitch, and roll rotation in radians.
     * - Yaw : Rotation around the Z axis `(0,0,1)`.
     * - Pitch :Rotation around the X axis `(1,0,0)`.
     * - Roll : Rotation around the Y axis `(0,1,0)`.
     *
     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
     *
     * @param q Quaternion that represents the given rotation
     * from which to extract the yaw, roll, and pitch.
     * @param projectionType The active type of map projection used to deduce the yaw, pitch and
     * roll values.
     */
    function extractYawPitchRoll(q, projectionType) {
        switch (projectionType) {
            case geoUtils.ProjectionType.Planar:
                const ysqr = q.y * q.y;
                // pitch (x-axis rotation)
                const t0 = +2.0 * (q.w * q.x + q.y * q.z);
                const t1 = +1.0 - 2.0 * (q.x * q.x + ysqr);
                const pitch = Math.atan2(t0, t1);
                // roll (y-axis rotation)
                let t2 = +2.0 * (q.w * q.y - q.z * q.x);
                t2 = t2 > 1.0 ? 1.0 : t2;
                t2 = t2 < -1.0 ? -1.0 : t2;
                const roll = Math.asin(t2);
                // yaw (z-axis rotation)
                const t3 = +2.0 * (q.w * q.z + q.x * q.y);
                const t4 = +1.0 - 2.0 * (ysqr + q.z * q.z);
                const yaw = Math.atan2(t3, t4);
                return { yaw, pitch, roll };
            case geoUtils.ProjectionType.Spherical:
                // TODO: HARP-6597 and HARP-6023: Support rotation and tilting for yaw and pitch in
                // globe (and roll?).
                return {
                    yaw: 0,
                    pitch: 0,
                    roll: 0
                };
        }
    }
    MapViewUtils.extractYawPitchRoll = extractYawPitchRoll;
    /**
     * Return camera tilt angle (in degrees).
     *
     * Tilt is the angle between camera __look at__ (forward) vector and ground normal.
     *
     * @note It may depend on the projection type.
     *
     * @param camera The camera used for tilt angle calculation.
     * @param projection The projection used to convert geo coordinated to world coordinates.
     * @returns angle in radians.
     */
    function getCameraTiltAngle(camera, projection) {
        // Note using different temporary vector then internal function used.
        const lookAt = tmpVectors[0];
        camera.getWorldDirection(lookAt);
        return lookAt.angleTo(getGroundNormalInv(camera.position, projection));
    }
    MapViewUtils.getCameraTiltAngle = getCameraTiltAngle;
    /**
     * Return normal to the ground surface directly above camera position.
     *
     * @note Function is not exposed cause it returns internal temporary vectors that
     * can not be modified. Use with care and clone the result if required.
     *
     * @param position The position above the ground for which normal is calculated.
     * @param projection The projection used to transform geo coordinates to world space.
     */
    function getGroundNormalInv(position, projection) {
        // Position on the ground for surface normal calculation does not matter for
        // any planar projections, so we may simplify calculus by returning const vector:
        if (projection.type === geoUtils.ProjectionType.Planar) {
            return groundNormalInvPlanarProj;
        }
        else {
            // Note using different vector then caller, otherwise vector data could be
            // silently modified.
            const normal = tmpVectors[1];
            projection.surfaceNormal(position, normal);
            return normal.negate();
        }
    }
    /**
     * Casts a ray in NDC space from the current view of the camera and returns the intersection
     * point of that ray against the map in geo coordinates. The return value can be `null` when
     * the raycast is above the horizon.
     *
     * @param mapView Instance of MapView.
     * @param pointOnScreenXNDC  Abscissa in NDC space.
     * @param pointOnScreenYNDC  Ordinate in NDC space.
     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.
     */
    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
        if (!worldCoordinates) {
            return null;
        }
        return mapView.projection.unprojectPoint(worldCoordinates);
    }
    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;
    /**
     * Calculates the zoom level, which corresponds to the current distance from
     * camera to lookAt point.
     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in
     * between zoom levels. By setting the zoom level, you change the height position of the camera
     * in away that the field of view of the camera should be able to cover one tile for the given
     * zoom level.
     *
     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you
     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of
     * you.
     *
     * @param distance The distance in meters, which are scene units in [[MapView]].
     * @param mapView [[MapView]] instance.
     */
    function calculateZoomLevelFromDistance(distance, mapView) {
        const tileSize = (256 * distance) / mapView.focalLength;
        return geoUtils.MathUtils.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), mapView.minZoomLevel, mapView.maxZoomLevel);
    }
    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
    /**
     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.
     * This is useful as the depth values are not stored in the depth buffer linearly, and this can
     * lead into confusing behavior when not taken into account.
     *
     * @param clipDistance Distance from the camera in clip space (range: [0, 1]).
     * @param camera Camera applying the perspective projection.
     */
    function calculateDepthFromClipDistance(clipDistance, camera) {
        const perspCam = camera;
        const cameraRange = perspCam.far - perspCam.near;
        const viewSpaceDistance = clipDistance * perspCam.far;
        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
    }
    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
    /**
     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
     * [0..cameraFar].
     *
     * @param distance Distance from the camera (range: [0, 1]).
     * @param camera Camera applying the perspective projection.
     */
    function cameraToWorldDistance(distance, camera) {
        const perspCam = camera;
        return distance * perspCam.far;
    }
    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;
    /**
     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.
     *
     * @param hFov Horizontal field of view in rad.
     * @param aspect Aspect ratio.
     */
    function calculateVerticalFovByHorizontalFov(hFov, aspect) {
        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
    }
    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
    /**
     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.
     *
     * @param hFov Vertical field of view in rad.
     * @param aspect Aspect ratio.
     */
    function calculateHorizontalFovByVerticalFov(vFov, aspect) {
        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);
    }
    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
    /**
     * Calculates the focal length based on the vertical FOV and height.
     *
     * @param vFov Vertical field of view in rad.
     * @param height Height of canvas in pixels.
     */
    function calculateFocalLengthByVerticalFov(vFov, height) {
        return height / 2 / Math.tan(vFov / 2);
    }
    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
    /**
     * Calculates the vertical field of view based on the focal length and the height.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param height Height of canvas in pixels.
     */
    function calculateFovByFocalLength(focalLength, height) {
        return geoUtils.MathUtils.radToDeg(2 * Math.atan(height / 2 / focalLength));
    }
    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;
    /**
     * Calculates object's screen size based on the focal length and it's camera distance.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance Object distance in world space.
     * @param worldSize Object size in world space.
     * @return object size in screen space.
     */
    function calculateScreenSizeByFocalLength(focalLength, distance, worldSize) {
        return (focalLength * worldSize) / distance;
    }
    MapViewUtils.calculateScreenSizeByFocalLength = calculateScreenSizeByFocalLength;
    /**
     * Calculates object's world size based on the focal length and it's camera distance.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance Object distance in world space.
     * @param screenSize Object size in screen space.
     * @return object size in world space.
     */
    function calculateWorldSizeByFocalLength(focalLength, distance, screenSize) {
        return (distance * screenSize) / focalLength;
    }
    MapViewUtils.calculateWorldSizeByFocalLength = calculateWorldSizeByFocalLength;
    /**
     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials
     * and/or attributes will be counted multiple times.
     *
     * @param object The mesh object to evaluate
     * @param size The [[MemoryUsage]] to update.
     * @param visitedObjects Optional map to store large objects that could be shared.
     *
     * @returns Estimate of object size in bytes for heap and GPU.
     */
    function estimateObject3dSize(object, parentSize, visitedObjects) {
        const size = parentSize !== undefined
            ? parentSize
            : {
                heapSize: 0,
                gpuSize: 0
            };
        if (visitedObjects === undefined) {
            visitedObjects = new Map();
        }
        estimateMeshSize(object, size, visitedObjects);
        if (object.children.length > 0) {
            for (const child of object.children) {
                estimateObject3dSize(child, size, visitedObjects);
            }
        }
        return size;
    }
    MapViewUtils.estimateObject3dSize = estimateObject3dSize;
    function estimateTextureSize(texture, objectSize, visitedObjects) {
        if (texture === null || texture.image === undefined) {
            return;
        }
        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {
            return;
        }
        visitedObjects.set(texture.uuid, true);
        // May be HTMLImage or ImageData
        const image = texture.image;
        // Assuming RGBA
        const imageBytes = 4 * image.width * image.height;
        objectSize.heapSize += imageBytes;
        objectSize.gpuSize += imageBytes;
    }
    function estimateMaterialSize(material, objectSize, visitedObjects) {
        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {
            return;
        }
        visitedObjects.set(material.uuid, true);
        if (material instanceof THREE.RawShaderMaterial ||
            material instanceof THREE.ShaderMaterial) {
            const rawMaterial = material;
            for (const name in rawMaterial.uniforms) {
                if (rawMaterial.uniforms[name] !== undefined) {
                    const uniform = rawMaterial.uniforms[name];
                    if (uniform instanceof THREE.Texture) {
                        estimateTextureSize(uniform, objectSize, visitedObjects);
                    }
                }
            }
        }
        else if (material instanceof THREE.MeshBasicMaterial ||
            material instanceof harp_materials_1.MapMeshBasicMaterial) {
            const meshMaterial = material;
            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {
            const standardMaterial = material;
            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof THREE.LineBasicMaterial ||
            material instanceof THREE.LineDashedMaterial) {
            // Nothing to be done here
        }
        else {
            logger.warn("estimateMeshSize: unidentified material: ", material);
        }
    }
    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
        // Attributes (apparently) do not have their uuid set up.
        if (attribute.uuid === undefined) {
            attribute.uuid = THREE.Math.generateUUID();
        }
        if (visitedObjects.get(attribute.uuid) === true) {
            return;
        }
        visitedObjects.set(attribute.uuid, true);
        let attrBytes = 0;
        let bytesPerElement = 4;
        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {
            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
        }
        if (attribute instanceof THREE.InterleavedBufferAttribute ||
            attribute instanceof THREE.BufferAttribute) {
            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified attribute: ", attrName);
        }
        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
        objectSize.gpuSize += attrBytes;
    }
    function estimateGeometrySize(geometry, objectSize, visitedObjects) {
        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;
        if (!isNewObject) {
            return;
        }
        visitedObjects.set(geometry.uuid, true);
        let bufferGeometry;
        if (geometry instanceof THREE.Geometry) {
            // Each vertex is represented as 3 floats vector (24 bytes).
            objectSize.heapSize += geometry.vertices.length * 24;
            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and
            // colors are not counted here.
            objectSize.heapSize += geometry.faces.length * (24 + 24);
            // Additionally, the internal _bufferGeometry is also counted:
            bufferGeometry = geometry._bufferGeometry;
        }
        else if (geometry instanceof THREE.BufferGeometry) {
            bufferGeometry = geometry;
        }
        if (bufferGeometry === undefined) {
            // Nothing more to calculate.
            return;
        }
        const attributes = bufferGeometry.attributes;
        if (attributes === undefined) {
            logger.warn("estimateGeometrySize: unidentified geometry: ", geometry);
            return;
        }
        for (const property in attributes) {
            if (attributes[property] !== undefined) {
                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
            }
        }
        if (bufferGeometry.index !== null) {
            estimateAttributeSize(bufferGeometry.index, "index", objectSize, visitedObjects);
        }
    }
    function estimateMeshSize(object, objectSize, visitedObjects) {
        if (!object.isObject3D || object instanceof THREE.Scene) {
            return;
        }
        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {
            return;
        }
        visitedObjects.set(object.uuid, true);
        if (object.isMesh || object.isLine || object.isPoints) {
            // Estimated minimum impact on heap.
            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
            const gpuSize = 0;
            // Cast to Points class which contains the minimal required properties sub-set.
            const mesh = object;
            // Calculate material(s) impact.
            if (mesh.material !== undefined) {
                if (Array.isArray(mesh.material)) {
                    const materials = mesh.material;
                    for (const material of materials) {
                        estimateMaterialSize(material, objectSize, visitedObjects);
                    }
                }
                else {
                    const material = mesh.material;
                    estimateMaterialSize(material, objectSize, visitedObjects);
                }
            }
            // Calculate cost of geometry.
            if (mesh.geometry !== undefined) {
                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
            }
            // Add info that is required for picking (parts of) objects and match them to
            // the featureID in the map data.
            const featureData = object.userData !== undefined
                ? object.userData.feature
                : undefined;
            if (featureData !== undefined) {
                heapSize += Tile_1.getFeatureDataSize(featureData);
            }
            objectSize.heapSize += heapSize;
            objectSize.gpuSize += gpuSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified object", object);
        }
    }
    /**
     * Gets language list used by the browser
     *
     * @returns Array of iso language codes
     */
    function getBrowserLanguages() {
        if (navigator.languages !== undefined && navigator.languages.length > 0) {
            const languageList = [];
            for (const lang of navigator.languages) {
                languageList.push(getIsoLanguageCode(lang));
            }
            return languageList;
        }
        if (navigator.language !== undefined) {
            return [getIsoLanguageCode(navigator.language)];
        }
        return undefined;
    }
    MapViewUtils.getBrowserLanguages = getBrowserLanguages;
    /**
     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)
     */
    function getIsoLanguageCode(language) {
        return language.substring(0, 2);
    }
})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000
];
var TileOffsetUtils;
(function (TileOffsetUtils) {
    /**
     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the
     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because
     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the
     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24
     * levels. Given the current support up to level 19 this should be fine.
     *
     * @param tileKey The unique [[TileKey]] from which to compute the unique key.
     * @param offset How much the given [[TileKey]] is offset
     * @param bitshift How much space we have to store the offset. The default of 4 means we have
     *      enough space to store 16 unique tiles in a single view.
     */
    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {
        const shiftedOffset = getShiftedOffset(offset, bitshift);
        return tileKey.mortonCode() + shiftedOffset;
    }
    TileOffsetUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
    /**
     * Extracts the offset and morton key from the given key (must be created by:
     * [[getKeyForTileKeyAndOffset]])
     *
     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and
     * would truncate the numbers, hence using powers of two.
     *
     * @param key Key to extract offset and morton key.
     * @param bitshift How many bits to shift by, must be the same as was used when creating the
     * key.
     */
    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {
        let offset = 0;
        let mortonCode = key;
        let i = 0;
        // Compute the offset
        for (; i < bitshift; i++) {
            // Note, we use 52, because 2^53-1 is the biggest value, the highest value
            // that can be set is the bit in the 52th position.
            const num = powerOfTwo[52 - i];
            if (mortonCode >= num) {
                mortonCode -= num;
                offset += powerOfTwo[bitshift - 1 - i];
            }
        }
        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset
        offset -= powerOfTwo[bitshift - 1];
        return { offset, mortonCode };
    }
    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
    /**
     * Returns the key of the parent. Key must have been computed using the function
     * [[getKeyForTileKeyAndOffset]].
     *
     * @param calculatedKey Key to decompose
     * @param bitshift Bit shift used to create the key
     */
    function getParentKeyFromKey(calculatedKey, bitshift = 4) {
        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);
        const parentTileKey = geoUtils.TileKey.fromMortonCode(geoUtils.TileKey.parentMortonCode(mortonCode));
        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
    }
    TileOffsetUtils.getParentKeyFromKey = getParentKeyFromKey;
    /**
     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and
     * 2^(52-bitshift).
     *
     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really
     * matter, this is primarily used to find a unique id, if there is an offset 10, which is
     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.
     * What can be a problem though is that the cache gets filled up and isn't emptied.
     *
     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set
     * the high bits instead.
     *
     * @param offset Offset to pack into the high bits.
     * @param offsetBits How many bits to use to pack the offset.
     */
    function getShiftedOffset(offset, offsetBits = 4) {
        let result = 0;
        const totalOffsetsToStore = powerOfTwo[offsetBits];
        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,
        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -
        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be
        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).
        offset += totalOffsetsToStore / 2;
        while (offset < 0) {
            offset += totalOffsetsToStore;
        }
        while (offset >= totalOffsetsToStore) {
            offset -= totalOffsetsToStore;
        }
        // Offset is now a number between >= 0 and < totalOffsetsToStore
        for (let i = 0; i < offsetBits && offset > 0; i++) {
            // tslint:disable: no-bitwise
            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an
            // integer safely.
            if (offset & 0x1) {
                result += powerOfTwo[53 - offsetBits + i];
            }
            offset >>>= 1;
            // tslint:enable: no-bitwise
        }
        harp_utils_1.assert(offset === 0);
        return result;
    }
})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));


/***/ }),

/***/ "../harp-mapview/lib/VisibleTileSet.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/VisibleTileSet.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If
 * it is in MB, an estimation is used.
 */
var ResourceComputationType;
(function (ResourceComputationType) {
    ResourceComputationType[ResourceComputationType["EstimationInMb"] = 0] = "EstimationInMb";
    ResourceComputationType[ResourceComputationType["NumberOfTiles"] = 1] = "NumberOfTiles";
})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));
const MB_FACTOR = 1.0 / (1024.0 * 1024.0);
/**
 * Missing Typedoc
 */
class DataSourceCache {
    constructor(options, dataSource) {
        this.dataSource = dataSource;
        this.disposedTiles = [];
        this.resourceComputationType = ResourceComputationType.EstimationInMb;
        this.resourceComputationType =
            options.resourceComputationType === undefined
                ? ResourceComputationType.EstimationInMb
                : options.resourceComputationType;
        this.tileCache = new harp_lrucache_1.LRUCache(options.tileCacheSize, (tile) => {
            if (this.resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
        this.tileCache.evictionCallback = (_, tile) => {
            if (tile.tileLoader !== undefined) {
                // Cancel downloads as early as possible.
                tile.tileLoader.cancel();
            }
            this.disposedTiles.push(tile);
        };
        this.tileCache.canEvict = (_, tile) => {
            // Tiles can be evicted that weren't requested in the last frame.
            return !tile.isVisible;
        };
    }
    disposeTiles() {
        this.disposedTiles.forEach(tile => {
            tile.dispose();
        });
        this.disposedTiles.length = 0;
    }
    get(tileCode) {
        return this.tileCache.get(tileCode);
    }
}
/**
 * Manages visible [[Tile]]s for [[MapView]].
 *
 * Responsible for election of rendered tiles:
 *  - quad-tree traversal
 *  - frustum culling
 *  - sorting tiles by relevance (visible area) to prioritize load
 *  - limiting number of visible tiles
 *  - caching tiles
 *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby
 *    zoom levels
 */
class VisibleTileSet {
    constructor(m_frustumIntersection, m_tileGeometryManager, options) {
        this.m_frustumIntersection = m_frustumIntersection;
        this.m_tileGeometryManager = m_tileGeometryManager;
        this.dataSourceTileList = [];
        this.allVisibleTilesLoaded = false;
        this.m_dataSourceCache = new Map();
        this.m_ResourceComputationType = ResourceComputationType.EstimationInMb;
        this.options = options;
    }
    /**
     * Returns cache size.
     */
    getDataSourceCacheSize() {
        return this.options.tileCacheSize;
    }
    /**
     * Sets cache size.
     *
     * @param size cache size
     * @param computationType Optional value specifying the way a [[Tile]]s cache usage is computed,
     *      either based on size in MB (mega bytes) or in number of tiles. Defaults to
     *      `ResourceComputationType.EstimationInMb`.
     */
    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {
        this.options.tileCacheSize = size;
        this.resourceComputationType = computationType;
    }
    /**
     * Retrieves maximum number of visible tiles.
     */
    getNumberOfVisibleTiles() {
        return this.options.maxVisibleDataSourceTiles;
    }
    /**
     * Sets maximum number of visible tiles.
     *
     * @param size size of visible tiles array
     */
    setNumberOfVisibleTiles(size) {
        this.options.maxVisibleDataSourceTiles = size;
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_ResourceComputationType;
    }
    set resourceComputationType(computationType) {
        this.m_ResourceComputationType = computationType;
        this.m_dataSourceCache.forEach(dataStore => {
            dataStore.tileCache.setCapacity(this.options.tileCacheSize);
            dataStore.resourceComputationType = computationType;
            dataStore.tileCache.shrinkToCapacity();
        });
    }
    /**
     * Calculates a new set of visible tiles.
     * @param storageLevel The camera storage level, see [[MapView.storageLevel]].
     * @param zoomLevel The camera zoom level.
     * @param dataSources The data sources for which the visible tiles will be calculated.
     * @param elevationRangeSource Source of elevation range data if any.
     */
    updateRenderList(storageLevel, zoomLevel, dataSources, elevationRangeSource) {
        let allVisibleTilesLoaded = true;
        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);
        this.dataSourceTileList = [];
        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {
            // Sort by projected (visible) area, now the tiles that are further away are at the end
            // of the list.
            //
            // Sort is unstable if distance is equal, which happens a lot when looking top-down.
            // Unstable sorting makes label placement unstable at tile borders, leading to
            // flickering.
            visibleTileKeys.sort((a, b) => {
                const areaDiff = b.area - a.area;
                // Take care or numerical precision issues
                const minDiff = (a.area + b.area) * 0.001;
                return Math.abs(areaDiff) < minDiff
                    ? b.tileKey.mortonCode() - a.tileKey.mortonCode()
                    : areaDiff;
            });
            const actuallyVisibleTiles = [];
            let allDataSourceTilesLoaded = true;
            let numTilesLoading = 0;
            // Create actual tiles only for the allowed number of visible tiles
            const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);
            for (let i = 0; i < visibleTileKeys.length &&
                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {
                const tileEntry = visibleTileKeys[i];
                if (!dataSource.shouldRender(displayZoomLevel, tileEntry.tileKey)) {
                    continue;
                }
                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);
                if (tile === undefined) {
                    continue;
                }
                tile.prepareTileInfo();
                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;
                if (!tile.allGeometryLoaded) {
                    numTilesLoading++;
                }
                else {
                    tile.numFramesVisible++;
                    if (tile.frameNumVisible < 0) {
                        // Store the fist frame the tile became visible.
                        tile.frameNumVisible = dataSource.mapView.frameNumber;
                    }
                }
                actuallyVisibleTiles.push(tile);
                // Update the visible area of the tile. This is used for those tiles that are
                // currently loaded and are waiting to be decoded to sort the jobs by area.
                tile.visibleArea = tileEntry.area;
            }
            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);
            this.dataSourceTileList.push({
                dataSource,
                storageLevel,
                zoomLevel: displayZoomLevel,
                allVisibleTileLoaded: allDataSourceTilesLoaded,
                numTilesLoading,
                visibleTiles: actuallyVisibleTiles,
                renderedTiles: actuallyVisibleTiles
            });
            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;
        }
        this.allVisibleTilesLoaded =
            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;
        this.fillMissingTilesFromCache();
        this.forEachCachedTile(tile => {
            // Remove all tiles that are still being loaded, but are no longer visible. They have to
            // be reloaded when they become visible again. Hopefully, they are still in the browser
            // cache by then.
            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {
                // The internal TileLoader is cancelled automatically when the Tile is disposed.
                this.disposeTile(tile);
            }
        });
        this.dataSourceTileList.forEach(renderListEntry => {
            const dataSource = renderListEntry.dataSource;
            const cache = this.m_dataSourceCache.get(dataSource.name);
            if (cache !== undefined) {
                cache.tileCache.shrinkToCapacity();
            }
        });
    }
    getTile(dataSource, tileKey, offset = 0) {
        function updateTile(tileToUpdate) {
            if (tileToUpdate === undefined) {
                return;
            }
            // Keep the tile from being removed from the cache.
            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;
        }
        if (!dataSource.cacheable) {
            const resultTile = dataSource.getTile(tileKey);
            updateTile(resultTile);
            return resultTile;
        }
        const { tileCache } = this.getOrCreateCache(dataSource);
        const tileKeyMortonCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset);
        let tile = tileCache.get(tileKeyMortonCode);
        if (tile !== undefined && tile.offset === offset) {
            updateTile(tile);
            return tile;
        }
        tile = dataSource.getTile(tileKey);
        if (tile !== undefined) {
            tile.offset = offset;
            updateTile(tile);
            tileCache.set(tileKeyMortonCode, tile);
            this.m_tileGeometryManager.initTile(tile);
        }
        return tile;
    }
    /**
     * Removes all internal bookkeeping entries and cache related to specified datasource.
     *
     * Called by [[MapView]] when [[DataSource]] has been removed from [[MapView]].
     */
    removeDataSource(dataSourceName) {
        this.clearTileCache(dataSourceName);
        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource.name !== dataSourceName);
        this.m_dataSourceCache.delete(dataSourceName);
    }
    /**
     * Clear the tile cache.
     *
     * Remove the [[Tile]] objects created by cacheable [[DataSource]]. If a [[DataSource]] name is
     * provided, this method restricts the eviction the [[DataSource]] with the given name.
     *
     * @param dataSourceName The name of the [[DataSource]].
     */
    clearTileCache(dataSourceName) {
        if (dataSourceName !== undefined) {
            const cache = this.m_dataSourceCache.get(dataSourceName);
            if (cache) {
                cache.tileCache.evictAll();
            }
        }
        else {
            this.m_dataSourceCache.forEach(dataSourceCache => {
                dataSourceCache.tileCache.evictAll();
            });
        }
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.
     *     If `undefined`, tiles from all [[DataSource]]s are processed.
     */
    markTilesDirty(dataSource) {
        if (dataSource === undefined) {
            this.dataSourceTileList.forEach(renderListEntry => {
                this.markDataSourceTilesDirty(renderListEntry);
            });
        }
        else {
            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);
            if (renderListEntry === undefined) {
                return;
            }
            this.markDataSourceTilesDirty(renderListEntry);
        }
    }
    /**
     * Dispose tiles that are marked for removal by [[LRUCache]] algorithm.
     */
    disposePendingTiles() {
        this.m_dataSourceCache.forEach(cache => {
            cache.disposeTiles();
        });
    }
    forEachVisibleTile(fun) {
        for (const listEntry of this.dataSourceTileList) {
            listEntry.renderedTiles.forEach(fun);
        }
    }
    forEachCachedTile(fun, filterDataSource) {
        this.m_dataSourceCache.forEach(dataSourceCache => {
            if (filterDataSource === undefined || filterDataSource(dataSourceCache.dataSource)) {
                dataSourceCache.tileCache.forEach(tile => {
                    fun(tile);
                });
            }
        });
    }
    /**
     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.
     */
    disposeTile(tile) {
        const cache = this.m_dataSourceCache.get(tile.dataSource.name);
        if (cache) {
            const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
            cache.tileCache.delete(tileCode);
            tile.dispose();
        }
    }
    /**
     * Search cache to replace visible but yet empty tiles with already loaded siblings in nearby
     * zoom levels.
     *
     * Useful, when zooming in/out and when "newly elected" tiles are not yet loaded. Prevents
     * flickering by rendering already loaded tiles from upper/higher zoom levels.
     */
    fillMissingTilesFromCache() {
        this.dataSourceTileList.forEach(renderListEntry => {
            const dataSource = renderListEntry.dataSource;
            const tilingScheme = dataSource.getTilingScheme();
            const displayZoomLevel = renderListEntry.zoomLevel;
            const renderedTiles = new Map();
            const checkedTiles = new Set();
            // Direction in quad tree to search: up -> shallower levels, down -> deeper levels.
            let SearchDirection;
            (function (SearchDirection) {
                SearchDirection[SearchDirection["UP"] = 0] = "UP";
                SearchDirection[SearchDirection["DOWN"] = 1] = "DOWN";
                SearchDirection[SearchDirection["BOTH"] = 2] = "BOTH";
            })(SearchDirection || (SearchDirection = {}));
            const tileCache = this.m_dataSourceCache.get(dataSource.name);
            if (tileCache === undefined) {
                return;
            }
            const cacheSearchUp = this.options.quadTreeSearchDistanceUp > 0 &&
                displayZoomLevel > dataSource.minZoomLevel;
            const cacheSearchDown = this.options.quadTreeSearchDistanceDown > 0 &&
                displayZoomLevel < dataSource.maxZoomLevel;
            if (!cacheSearchDown && !cacheSearchUp) {
                return;
            }
            const defaultSearchDirection = cacheSearchDown && cacheSearchUp
                ? SearchDirection.BOTH
                : cacheSearchDown
                    ? SearchDirection.DOWN
                    : SearchDirection.UP;
            let incompleteTiles = new Map();
            renderListEntry.visibleTiles.forEach(tile => {
                const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
                if (tile.hasGeometry) {
                    renderedTiles.set(tileCode, tile);
                }
                else {
                    // if dataSource supports cache and it was existing before this render
                    // then enable searching for loaded tiles in cache
                    incompleteTiles.set(tileCode, defaultSearchDirection);
                }
            });
            if (incompleteTiles.size === 0) {
                // short circuit, nothing to be done
                return;
            }
            // iterate over incomplete (not loaded tiles)
            // and find their parents or children that are in cache that can be rendered temporarily
            // until tile is loaded
            while (incompleteTiles.size !== 0) {
                const nextLevelCandidates = new Map();
                incompleteTiles.forEach((searchDirection, tileKeyCode) => {
                    if (searchDirection === SearchDirection.BOTH ||
                        searchDirection === SearchDirection.UP) {
                        const parentCode = Utils_1.TileOffsetUtils.getParentKeyFromKey(tileKeyCode);
                        if (!checkedTiles.has(parentCode) && !renderedTiles.get(parentCode)) {
                            checkedTiles.add(parentCode);
                            const parentTile = tileCache.get(parentCode);
                            if (parentTile !== undefined && parentTile.hasGeometry) {
                                // parentTile has geometry, so can be reused as fallback
                                renderedTiles.set(parentCode, parentTile);
                                return;
                            }
                            const { mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);
                            const parentTileKey = parentTile
                                ? parentTile.tileKey
                                : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
                            // if parentTile is missing or incomplete, try at max 3 levels up from
                            // current display level
                            const nextLevelDiff = Math.abs(displayZoomLevel - parentTileKey.level);
                            if (nextLevelDiff < this.options.quadTreeSearchDistanceUp) {
                                nextLevelCandidates.set(parentCode, SearchDirection.UP);
                            }
                        }
                    }
                    if (searchDirection === SearchDirection.BOTH ||
                        searchDirection === SearchDirection.DOWN) {
                        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);
                        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
                        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                            const childTileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
                            checkedTiles.add(childTileCode);
                            const childTile = tileCache.get(childTileCode);
                            if (childTile !== undefined && childTile.hasGeometry) {
                                // childTile has geometry, so can be reused as fallback
                                renderedTiles.set(childTileCode, childTile);
                                return;
                            }
                            const nextLevelDiff = Math.abs(childTileKey.level - displayZoomLevel);
                            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
                                nextLevelCandidates.set(childTileCode, SearchDirection.DOWN);
                            }
                        }
                    }
                });
                incompleteTiles = nextLevelCandidates;
            }
            renderListEntry.renderedTiles = Array.from(renderedTiles.values());
        });
    }
    getOrCreateCache(dataSource) {
        const dataSourceName = dataSource.name;
        let dataSourceCache = this.m_dataSourceCache.get(dataSourceName);
        if (dataSourceCache === undefined) {
            dataSourceCache = new DataSourceCache(this.options, dataSource);
            this.m_dataSourceCache.set(dataSourceName, dataSourceCache);
        }
        return dataSourceCache;
    }
    markDataSourceTilesDirty(renderListEntry) {
        const dataSourceCache = this.m_dataSourceCache.get(renderListEntry.dataSource.name);
        const retainedTiles = new Set();
        function markTileDirty(tile, tileGeometryManager) {
            const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
            if (!retainedTiles.has(tileCode)) {
                retainedTiles.add(tileCode);
                if (tile.tileGeometryLoader !== undefined) {
                    tile.tileGeometryLoader.reset();
                }
                tile.load();
            }
        }
        renderListEntry.visibleTiles.forEach(tile => {
            markTileDirty(tile, this.m_tileGeometryManager);
        });
        renderListEntry.renderedTiles.forEach(tile => {
            markTileDirty(tile, this.m_tileGeometryManager);
        });
        if (dataSourceCache !== undefined) {
            dataSourceCache.tileCache.forEach((tile, tileCode) => {
                if (!retainedTiles.has(tileCode)) {
                    tile.dispose();
                    dataSourceCache.tileCache.delete(tileCode);
                }
            });
        }
    }
    // Computes the visible tile keys for each supplied datasource.
    getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {
        const tileKeys = Array();
        let allBoundingBoxesFinal = true;
        if (dataSources.length === 0) {
            return { tileKeys, allBoundingBoxesFinal };
        }
        const dataSourceBuckets = new Map();
        dataSources.forEach(dataSource => {
            const tilingScheme = dataSource.getTilingScheme();
            const bucket = dataSourceBuckets.get(tilingScheme);
            if (bucket === undefined) {
                dataSourceBuckets.set(tilingScheme, [dataSource]);
            }
            else {
                bucket.push(dataSource);
            }
        });
        this.m_frustumIntersection.updateFrustum();
        // For each bucket of data sources with same tiling scheme, calculate frustum intersection
        // once using the maximum display level.
        for (const [tilingScheme, bucket] of dataSourceBuckets) {
            const maxDisplayLevel = Math.max(...bucket.map(dataSource => dataSource.getDisplayZoomLevel(zoomLevel)));
            const result = this.m_frustumIntersection.compute(tilingScheme, maxDisplayLevel, elevationRangeSource);
            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;
            for (const dataSource of bucket) {
                const visibleTileKeys = [];
                // For each data source check what tiles from the intersection should be rendered
                // at this zoom level.
                const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);
                for (const tileEntry of result.tileKeyEntries.values()) {
                    if (dataSource.shouldRender(displayZoomLevel, tileEntry.tileKey)) {
                        visibleTileKeys.push(tileEntry);
                    }
                }
                tileKeys.push({ dataSource, visibleTileKeys });
            }
        }
        return { tileKeys, allBoundingBoxesFinal };
    }
}
exports.VisibleTileSet = VisibleTileSet;


/***/ }),

/***/ "../harp-mapview/lib/WorkerBasedDecoder.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/WorkerBasedDecoder.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
/**
 * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Decoder based on [[ConcurrentWorkerSet]].
 *
 * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends decode requests,
 * - configuration.
 */
class WorkerBasedDecoder {
    /**
     * Creates a new `WorkerBasedDecoder`.
     *
     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.
     * @param decoderServiceType Service type identifier.
     */
    constructor(workerSet, decoderServiceType) {
        this.workerSet = workerSet;
        this.decoderServiceType = decoderServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tile decoder services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
            if (!this.m_serviceCreated) {
                yield this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                    type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                    targetServiceType: this.decoderServiceType,
                    targetServiceId: this.serviceId
                });
                this.m_serviceCreated = true;
            }
        });
    }
    /**
     * Get [[Tile]] from tile decoder service in worker.
     *
     * Invokes [[DecodeTileRequest]] on [[TileDecoderService]] running in worker pool.
     */
    decodeTile(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Get [[TileInfo]] from tile decoder service in worker.
     *
     * Invokes [[TileInfoRequest]] on [[TileDecoderService]] running in worker pool.
     */
    getTileInfo(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Configure tile decoder service in workers.
     *
     * Broadcasts [[ConfigurationMessage]] to all [[TileDecoderService]]s running in worker pool.
     *
     * @param styleSet  new [[StyleSet]], undefined means no change
     * @param languages new list of languages
     * @param options   new options, undefined options are not changed
     */
    configure(styleSet, languages, options) {
        const message = {
            service: this.serviceId,
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration,
            styleSet,
            options,
            languages
        };
        this.workerSet.broadcastMessage(message);
    }
}
exports.WorkerBasedDecoder = WorkerBasedDecoder;


/***/ }),

/***/ "../harp-mapview/lib/WorkerBasedTiler.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/WorkerBasedTiler.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
/**
 * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Tiler based on [[ConcurrentWorkerSet]].
 *
 * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends tile requests,
 * - configuration.
 */
class WorkerBasedTiler {
    /**
     * Creates a new `WorkerBasedTiler`.
     *
     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.
     * @param tilerServiceType Service type identifier.
     */
    constructor(workerSet, tilerServiceType) {
        this.workerSet = workerSet;
        this.tilerServiceType = tilerServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tiler services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TilerService]]s in all workers to serve tiling requests.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
            if (!this.m_serviceCreated) {
                yield this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                    type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                    targetServiceType: this.tilerServiceType,
                    targetServiceId: this.serviceId
                });
                this.m_serviceCreated = true;
            }
        });
    }
    /**
     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId Index identifier.
     * @param input Url to the index payload, or direct GeoJSON.
     */
    registerIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId Index identifier.
     * @param input Url to the index payload, or direct GeoJSON.
     */
    updateIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Retrieves a tile for a previously registered index.
     *
     * @param indexId Index identifier.
     * @param tileKey The [[TileKey]] that identifies the tile.
     */
    getTile(indexId, tileKey) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,
            index: indexId,
            tileKey: tileKeyCode
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
}
exports.WorkerBasedTiler = WorkerBasedTiler;


/***/ }),

/***/ "../harp-mapview/lib/composing/LowResRenderPass.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/composing/LowResRenderPass.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
/**
 * The `LowResRenderPass` renders the scene at a lower resolution into an internal
 * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal
 * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.
 *
 * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be
 * visible.
 */
class LowResRenderPass extends Pass_1.Pass {
    /**
     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at
     * a quad.
     *
     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     */
    constructor(lowResPixelRatio) {
        super();
        this.lowResPixelRatio = lowResPixelRatio;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_savedWidth = 0;
        this.m_savedHeight = 0;
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
        this.m_pixelRatio = lowResPixelRatio;
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        this.m_quadMaterial.dispose();
        this.m_quad.geometry.dispose();
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     *
     * @default `undefined`
     */
    set pixelRatio(ratio) {
        this.m_pixelRatio = ratio;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
        }
    }
    get pixelRatio() {
        return this.m_pixelRatio;
    }
    /**
     * The render function of `LowResRenderPass`. It renders the whole scene into an internal
     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.
     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it
     * is the screen.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene The ThreeJS Scene instance to render the scene with.
     * @param camera The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled || this.pixelRatio === undefined) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_savedWidth = readBuffer.width;
            this.m_savedHeight = readBuffer.height;
            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                depthBuffer: true,
                stencilBuffer: true
            });
            this.m_renderTarget.texture.name = "LowResRenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        this.m_quadUniforms.opacity.value = 1.0;
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.m_renderTarget);
        renderer.clear();
        // Render into the low resolution internal render target.
        renderer.render(scene, camera);
        // Render the low resolution target into the screen.
        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.clear();
        renderer.render(this.m_quadScene, this.m_localCamera);
        renderer.setRenderTarget(oldRenderTarget);
    }
    /**
     * Resize the internal render target to match the new size specified. The size of internal
     * buffer depends on the `pixelRatio`.
     *
     * @param width New width to apply to the render target.
     * @param height New height to apply to the render target.
     */
    setSize(width, height) {
        this.m_savedWidth = width;
        this.m_savedHeight = height;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
        }
    }
}
exports.LowResRenderPass = LowResRenderPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/MSAARenderPass.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/composing/MSAARenderPass.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
/**
 * This enum represents the sampling level to apply to a [[MSAARenderPass]] instance. At level 0,
 * only one sample is performed, which is like disabling the MSAA pass.
 */
var MSAASampling;
(function (MSAASampling) {
    MSAASampling[MSAASampling["Level_0"] = 0] = "Level_0";
    MSAASampling[MSAASampling["Level_1"] = 1] = "Level_1";
    MSAASampling[MSAASampling["Level_2"] = 2] = "Level_2";
    MSAASampling[MSAASampling["Level_3"] = 3] = "Level_3";
    MSAASampling[MSAASampling["Level_4"] = 4] = "Level_4";
    MSAASampling[MSAASampling["Level_5"] = 5] = "Level_5";
})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));
/**
 * [[MapView]]'s MSAA implementation. MSAA stands for Multi Sampling Anti-Aliasing, and its concept
 * is to provide a rendering engine with additional color values for each pixel, so they can include
 * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation
 * with four samples. Because of its native nature, it is more efficient and one may not want to use
 * MapView's MSAA implementation when these four samples are satisfying. However in some situations
 * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the
 * number of samples at runtime. On the other hand, when the interaction stops, the engine also
 * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then
 * turn very noticeable. In such static renders, the number of samples could be dramatically
 * increased on a last frame to render.
 */
class MSAARenderPass extends Pass_1.Pass {
    /**
     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a
     * quad.
     *
     * @param m_scene The scene to render.
     * @param m_camera The camera to render the scene through.
     */
    constructor() {
        super();
        /**
         * The sampling level determines the number of samples that will be performed per frame.
         * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.
         * Therefore there can be between 1 and 32 samples.
         *
         * @default `SamplingLevel.Level_1`
         */
        this.samplingLevel = MSAASampling.Level_1;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * The render function of `MSAARenderPass`. At each call of this method, and for each sample,
     * the [[MapView]] camera provided in the `render` method is offset within the dimension of a
     * pixel on screen. It then renders the whole scene with this offset to a local
     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera
     * created in the constructor shoots the quad and renders to the write buffer or to the frame
     * buffer. The quad material's opacity is modified so the renders can accumulate in the
     * targetted buffer.
     *
     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].
     *
     * If there is no further pass, the [[Pass.renderToScreen]] flag can be set to `true` to
     * output directly to the framebuffer.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene The ThreeJS Scene instance to render the scene with.
     * @param camera The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            this.m_renderTarget.texture.name = "MSAARenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];
        const rendererClearColor = renderer.getClearColor();
        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain
        // its usability externally (like for the triple view in mosaic demo) we must cache the
        // previous values stored in `camera.view` and re-assign them at the end of the pass.
        // 1. Create a default cache object, with default dimensions the size of our read buffer.
        const oldView = {
            enabled: camera.view !== null && camera.view.enabled,
            fullWidth: readBuffer.width,
            fullHeight: readBuffer.height,
            x: 0,
            y: 0,
            width: readBuffer.width,
            height: readBuffer.height
        };
        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called
        // externally: copy the existing `camera.view` values in the cache. Override the cache
        // object with the values provided externally.
        if (oldView.enabled && camera.view !== null) {
            oldView.fullWidth = camera.view.fullWidth;
            oldView.fullHeight = camera.view.fullHeight;
            oldView.x = camera.view.offsetX;
            oldView.y = camera.view.offsetY;
            oldView.width = camera.view.width;
            oldView.height = camera.view.height;
        }
        const oldRenderTarget = renderer.getRenderTarget();
        for (let i = 0; i < offsets.length; i++) {
            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the
            // `camera.view` object in Three.js.
            const offset = offsets[i];
            camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
            // 5. Divide the opacity of the quad by the number of samples to accumulate on the
            // target buffer, and reduce the impact of the offset on color to reduce banding. Then
            // render.
            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;
            this.m_quadUniforms.opacity.value = sampleWeight;
            renderer.setRenderTarget(this.m_renderTarget);
            renderer.clear();
            renderer.render(scene, camera);
            // 6. Render the quad on top of the previous renders.
            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
            if (i === 0) {
                renderer.setClearColor(0x000000);
                renderer.clear();
            }
            renderer.render(this.m_quadScene, this.m_localCamera);
            if (i === 0 && rendererClearColor !== undefined) {
                renderer.setClearColor(oldClearColor);
            }
        }
        renderer.setRenderTarget(oldRenderTarget);
        // 7. Restore `camera.view` as set externally (or not).
        if (camera.view !== null) {
            camera.view.enabled = oldView.enabled;
            camera.view.offsetX = oldView.x;
            camera.view.offsetY = oldView.y;
        }
    }
    /**
     * Resize the internal render target to match the new size specified.
     *
     * @param width New width to apply to the render target.
     * @param height New height to apply to the render target.
     */
    setSize(width, height) {
        if (this.m_renderTarget) {
            this.m_renderTarget.setSize(width, height);
        }
    }
}
// tslint:disable:max-line-length
/**
 * The list of offsets to apply to the camera, per sampling level, adapted from :
 *
 * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 */
// tslint:enable:max-line-length
// tslint:disable-next-line:member-ordering
MSAARenderPass.OffsetVectors = [
    [[0, 0]],
    [[4, 4], [-4, -4]],
    [[-2, -6], [6, -2], [-6, 2], [2, 6]],
    [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]],
    [
        [1, 1],
        [-1, -3],
        [-3, 2],
        [4, -1],
        [-5, -2],
        [2, 5],
        [5, 3],
        [3, -5],
        [-2, 6],
        [0, -7],
        [-4, -6],
        [-6, 4],
        [-8, 0],
        [7, -4],
        [6, 7],
        [-7, -8]
    ],
    [
        [-4, -7],
        [-7, -5],
        [-3, -5],
        [-5, -4],
        [-1, -4],
        [-2, -2],
        [-6, -1],
        [-4, 0],
        [-7, 1],
        [-1, 2],
        [-6, 3],
        [-3, 3],
        [-7, 6],
        [-3, 6],
        [-5, 7],
        [-1, 7],
        [5, -7],
        [1, -6],
        [6, -5],
        [4, -4],
        [2, -3],
        [7, -2],
        [1, -1],
        [4, -1],
        [2, 1],
        [6, 2],
        [0, 4],
        [4, 4],
        [2, 5],
        [7, 5],
        [5, 6],
        [3, 7]
    ]
];
exports.MSAARenderPass = MSAARenderPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/MapRenderingManager.ts":
/*!************************************************************!*\
  !*** ../harp-mapview/lib/composing/MapRenderingManager.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ "../harp-mapview/lib/composing/LowResRenderPass.ts");
const MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "../harp-mapview/lib/composing/MSAARenderPass.ts");
const Outline_1 = __webpack_require__(/*! ./Outline */ "../harp-mapview/lib/composing/Outline.ts");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
const UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ "../harp-mapview/lib/composing/UnrealBloomPass.ts");
const DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;
const DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;
/**
 * The implementation of [[IMapRenderingManager]] to instantiate in [[MapView]] and manage the map
 * rendering.
 */
class MapRenderingManager {
    /**
     * The constructor of `MapRenderingManager`.
     *
     * @param width Width of the frame buffer.
     * @param height Height of the frame buffer.
     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     * @param antialiasSetting The object defining the demeanor of MSAA.
     */
    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {
        this.bloom = {
            enabled: false,
            strength: 1.5,
            radius: 0.4,
            threshold: 0.85
        };
        this.outline = {
            enabled: false,
            thickness: 0.005,
            color: "#000000",
            ghostExtrudedPolygons: false,
            needsUpdate: false
        };
        this.vignette = {
            enabled: false,
            offset: 1.0,
            darkness: 1.0
        };
        this.sepia = {
            enabled: false,
            amount: 0.5
        };
        this.m_width = 1;
        this.m_height = 1;
        this.m_renderPass = new Pass_1.RenderPass();
        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);
        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);
        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);
        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);
        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);
        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();
        this.m_msaaPass.enabled =
            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;
        this.m_dynamicMsaaSamplingLevel =
            antialiasSettings.dynamicMsaaSamplingLevel === undefined
                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.dynamicMsaaSamplingLevel;
        this.m_staticMsaaSamplingLevel =
            antialiasSettings.staticMsaaSamplingLevel === undefined
                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.staticMsaaSamplingLevel;
        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);
        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;
    }
    updateOutline(options) {
        this.outline.color = options.color;
        this.outline.thickness = options.thickness;
        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
        this.outline.needsUpdate = true;
    }
    /**
     * The method to call to render the map with the `MapRenderingManager` instance. It contains the
     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering
     * conditions as disabling AA when a high DPI device is in use.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the map with.
     * @param scene The ThreeJS Scene instance containing the map objects to render.
     * @param camera The ThreeJS Camera instance to render the scene through.
     * @param isStaticFrame Whether the frame to render is static or dynamic. Selects level of
     * antialiasing.
     */
    render(renderer, scene, camera, isStaticFrame) {
        const target = null;
        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {
            // Not designed to be combined with our own MSAA
            this.m_lowResPass.renderToScreen = true;
            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
            return;
        }
        const usePostEffects = this.bloom.enabled ||
            this.outline.enabled ||
            this.vignette.enabled ||
            this.sepia.enabled;
        let activeTarget = null;
        // 1. If the bloom is enabled, clear the depth.
        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
            renderer.setRenderTarget(this.m_target1);
            renderer.clearDepth();
        }
        // 2. Render the map.
        if (this.m_msaaPass.enabled) {
            // Use a higher MSAA sampling level for static rendering.
            this.m_msaaPass.samplingLevel = isStaticFrame
                ? this.m_staticMsaaSamplingLevel
                : this.m_dynamicMsaaSamplingLevel;
            // MSAA is the only effect for the moment.
            this.m_msaaPass.renderToScreen = !usePostEffects;
            // Render to the specified target with the MSAA pass.
            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
        }
        else {
            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                activeTarget = this.m_target1;
                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
            }
            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {
                renderer.render(scene, camera);
            }
        }
        // 3. Apply effects
        if (this.outline.enabled) {
            if (this.m_outlineEffect === undefined) {
                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);
            }
            if (this.outline.needsUpdate) {
                this.m_outlineEffect.color = this.outline.color;
                this.m_outlineEffect.thickness = this.outline.thickness;
                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
                this.outline.needsUpdate = false;
            }
            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
            if (nextEffectEnabled) {
                activeTarget = this.m_target1;
            }
            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
            this.m_outlineEffect.render(scene, camera);
        }
        if (this.bloom.enabled) {
            if (this.m_bloomPass === undefined) {
                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
            }
            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;
            this.m_bloomPass.renderToScreen = !nextEffectEnabled;
            this.m_bloomPass.radius = this.bloom.radius;
            this.m_bloomPass.strength = this.bloom.strength;
            this.m_bloomPass.threshold = this.bloom.threshold;
            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
        }
        else if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.dispose();
            this.m_bloomPass = undefined;
        }
        if (this.vignette.enabled) {
            const oldTarget = activeTarget;
            const nextEffectEnabled = this.sepia.enabled;
            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
            this.m_vignettePass.renderToScreen = !nextEffectEnabled;
            if (nextEffectEnabled) {
                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
            }
            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
        }
        if (this.sepia.enabled) {
            this.m_sepiaPass.renderToScreen = true;
            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
        }
    }
    /**
     * The resize function to call on resize events to resize the render targets. It shall include
     * the resize methods of all the sub-passes used in `MapRenderingManager`.
     *
     * @param width New width to use.
     * @param height New height to use.
     */
    setSize(width, height) {
        this.m_readBuffer.setSize(width, height);
        this.m_msaaPass.setSize(width, height);
        if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.setSize(width, height);
        }
        this.m_lowResPass.setSize(width, height);
        this.m_target1.setSize(width, height);
        this.m_target2.setSize(width, height);
        this.m_width = width;
        this.m_height = height;
    }
    /**
     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values
     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of
     * `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     */
    get lowResPixelRatio() {
        return this.m_lowResPass.pixelRatio;
    }
    set lowResPixelRatio(pixelRatio) {
        this.m_lowResPass.pixelRatio = pixelRatio;
        this.m_lowResPass.enabled = pixelRatio !== undefined;
    }
    /**
     * Set the level of sampling while the user interacts.
     *
     * @param samplingLevel The sampling level.
     */
    set dynamicMsaaSamplingLevel(samplingLevel) {
        this.m_dynamicMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined during continuous rendering.
     */
    get dynamicMsaaSamplingLevel() {
        return this.m_dynamicMsaaSamplingLevel;
    }
    /**
     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided
     * in the [[MapRenderingManager.render]] method to render the scene.
     *
     * @param value If `true`, MSAA is enabled, disabled otherwise.
     */
    set msaaEnabled(value) {
        this.m_msaaPass.enabled = value;
    }
    /**
     * Return whether the MSAA is enabled.
     */
    get msaaEnabled() {
        return this.m_msaaPass.enabled;
    }
    /**
     * Set the sampling level for rendering static frames.
     *
     * @param samplingLevel The sampling level.
     */
    set staticMsaaSamplingLevel(samplingLevel) {
        this.m_staticMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined for rendering static frames.
     */
    get staticMsaaSamplingLevel() {
        return this.m_staticMsaaSamplingLevel;
    }
}
exports.MapRenderingManager = MapRenderingManager;


/***/ }),

/***/ "../harp-mapview/lib/composing/Outline.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/composing/Outline.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const vertexShaderChunk = `
    uniform float outlineThickness;

    vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {

        float thickness = outlineThickness;
        const float ratio = 1.0;
        vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );
        vec4 norm = normalize( pos - pos2 );
        return pos + norm * thickness * pos.w * ratio;

    }`;
const vertexShaderChunk2 = `
    #if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )
        #ifndef USE_ENVMAP
            vec3 objectNormal = normalize( normal );
        #endif
    #endif

    #ifdef FLIP_SIDED
        objectNormal = -objectNormal;
    #endif

    #ifdef DECLARE_TRANSFORMED
        vec3 transformed = vec3( position );
    #endif

    gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );

    #include <fog_vertex>`;
const fragmentShader = `
    #include <common>
    #include <fog_pars_fragment>

    uniform vec3 outlineColor;
    uniform float outlineAlpha;

    void main() {

        gl_FragColor = vec4( outlineColor, outlineAlpha );

        #include <fog_fragment>

    }`;
class OutlineEffect {
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.enabled = true;
        this.m_defaultThickness = 0.02;
        this.m_defaultColor = new THREE.Color(0, 0, 0);
        this.m_defaultAlpha = 1;
        this.m_defaultKeepAlive = false;
        this.m_ghostExtrudedPolygons = false;
        this.m_cache = {};
        this.m_removeThresholdCount = 60;
        this.m_originalMaterials = {};
        this.m_originalOnBeforeRenders = {};
        this.m_shaderIDs = {
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical"
        };
        this.m_uniformsChunk = {
            outlineThickness: { value: this.m_defaultThickness },
            outlineColor: { value: this.m_defaultColor },
            outlineAlpha: { value: this.m_defaultAlpha }
        };
        this.autoClear = m_renderer.autoClear;
        this.domElement = m_renderer.domElement;
        this.shadowMap = m_renderer.shadowMap;
    }
    set thickness(thickness) {
        this.m_defaultThickness = thickness;
        this.m_uniformsChunk.outlineThickness.value = thickness;
        this.m_cache = {};
    }
    set color(color) {
        this.m_defaultColor.set(color);
        this.m_cache = {};
    }
    set ghostExtrudedPolygons(ghost) {
        this.m_ghostExtrudedPolygons = ghost;
    }
    clear(color, depth, stencil) {
        this.m_renderer.clear(color, depth, stencil);
    }
    getPixelRatio() {
        return this.m_renderer.getPixelRatio();
    }
    setPixelRatio(value) {
        this.m_renderer.setPixelRatio(value);
    }
    getSize(target) {
        return this.m_renderer.getSize(target);
    }
    setSize(width, height, updateStyle) {
        this.m_renderer.setSize(width, height, updateStyle);
    }
    setViewport(x, y, width, height) {
        this.m_renderer.setViewport(x, y, width, height);
    }
    setScissor(x, y, width, height) {
        this.m_renderer.setScissor(x, y, width, height);
    }
    setScissorTest(boolean) {
        this.m_renderer.setScissorTest(boolean);
    }
    setRenderTarget(renderTarget) {
        this.m_renderer.setRenderTarget(renderTarget);
    }
    render(scene, camera) {
        // Re-rendering the scene with the outline effect enables to hide the
        // extruded polygons and show only the outlines (it is a hack and should be
        // implemented another way!).
        if (this.m_ghostExtrudedPolygons) {
            if (!this.enabled) {
                this.m_renderer.render(scene, camera);
                return;
            }
            const currentAutoClear = this.m_renderer.autoClear;
            this.m_renderer.autoClear = this.autoClear;
            this.m_renderer.render(scene, camera);
            this.m_renderer.autoClear = currentAutoClear;
        }
        this.renderOutline(scene, camera);
    }
    renderOutline(scene, camera) {
        const currentAutoClear = this.m_renderer.autoClear;
        const currentSceneAutoUpdate = scene.autoUpdate;
        const currentSceneBackground = scene.background;
        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
        scene.autoUpdate = false;
        scene.background = null;
        this.m_renderer.autoClear = false;
        this.m_renderer.shadowMap.enabled = false;
        scene.traverse(this.setOutlineMaterial.bind(this));
        this.m_renderer.render(scene, camera);
        scene.traverse(this.restoreOriginalMaterial.bind(this));
        this.cleanupCache();
        scene.autoUpdate = currentSceneAutoUpdate;
        scene.background = currentSceneBackground;
        this.m_renderer.autoClear = currentAutoClear;
        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
    }
    createInvisibleMaterial() {
        return new THREE.ShaderMaterial({ name: "invisible", visible: false });
    }
    createMaterial(originalMaterial) {
        const shaderID = this.m_shaderIDs[originalMaterial.type];
        let originalUniforms;
        let originalVertexShader;
        if (shaderID !== undefined) {
            const shader = THREE.ShaderLib[shaderID];
            originalUniforms = shader.uniforms;
            originalVertexShader = shader.vertexShader;
        }
        else if (originalMaterial.isRawShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
            if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) ||
                !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                return this.createInvisibleMaterial();
            }
        }
        else if (originalMaterial.isShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
        }
        else {
            return this.createInvisibleMaterial();
        }
        const uniforms = Object.assign({}, originalUniforms, this.m_uniformsChunk);
        const vertexShader = originalVertexShader
            // put vertexShaderChunk right before "void main() {...}"
            .replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()")
            // put vertexShaderChunk2 the end of "void main() {...}"
            // Note: here assums originalVertexShader ends with "}" of "void main() {...}"
            .replace(/\}\s*$/, vertexShaderChunk2 + "\n}")
            // remove any light related lines
            // Note: here is very sensitive to originalVertexShader
            // TODO: consider safer way
            .replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
        const defines = {};
        if (!/vec3\s+transformed\s*=/.test(originalVertexShader) &&
            !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
            defines.DECLARE_TRANSFORMED = true;
        }
        return new THREE.ShaderMaterial({
            defines,
            uniforms,
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
            //wireframe: true,
            skinning: false,
            morphTargets: false,
            morphNormals: false,
            fog: false
        });
    }
    getOutlineMaterialFromCache(originalMaterial) {
        let data = this.m_cache[originalMaterial.uuid];
        if (data === undefined) {
            data = {
                material: this.createMaterial(originalMaterial),
                used: true,
                keepAlive: this.m_defaultKeepAlive,
                count: 0
            };
            this.m_cache[originalMaterial.uuid] = data;
        }
        data.used = true;
        return data.material;
    }
    getOutlineMaterial(originalMaterial) {
        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
        this.updateOutlineMaterial(outlineMaterial, originalMaterial);
        return outlineMaterial;
    }
    setOutlineMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.getOutlineMaterial(object.material[i]);
            }
        }
        else {
            object.material = this.getOutlineMaterial(object
                .material);
        }
        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
    }
    restoreOriginalMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.m_originalMaterials[object.material[i].uuid];
            }
        }
        else {
            object.material = this.m_originalMaterials[object.material.uuid];
        }
        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const originalMaterial = this.m_originalMaterials[material.uuid];
        // just in case
        if (originalMaterial === undefined) {
            return;
        }
        this.updateUniforms(material, originalMaterial);
    }
    updateUniforms(material, originalMaterial) {
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.uniforms.outlineAlpha.value = originalMaterial.opacity;
        if (outlineParameters !== undefined) {
            if (outlineParameters.thickness !== undefined) {
                material.uniforms.outlineThickness.value = outlineParameters.thickness;
            }
            if (outlineParameters.color !== undefined) {
                material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
            }
            if (outlineParameters.alpha !== undefined) {
                material.uniforms.outlineAlpha.value = outlineParameters.alpha;
            }
        }
    }
    updateOutlineMaterial(material, originalMaterial) {
        if (material.name === "invisible") {
            return;
        }
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.skinning = originalMaterial.skinning;
        material.morphTargets = originalMaterial.morphTargets;
        material.morphNormals = originalMaterial.morphNormals;
        material.fog = originalMaterial.fog;
        if (outlineParameters !== undefined) {
            material.visible =
                originalMaterial.visible === false
                    ? false
                    : outlineParameters.visible !== undefined
                        ? outlineParameters.visible
                        : true;
            material.transparent =
                outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0
                    ? true
                    : originalMaterial.transparent;
            if (outlineParameters.keepAlive !== undefined) {
                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
            }
        }
        else {
            material.transparent = originalMaterial.transparent;
            material.visible = originalMaterial.visible;
        }
        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
            material.visible = false;
        }
    }
    cleanupCache() {
        let keys;
        // clear originialMaterials
        keys = Object.keys(this.m_originalMaterials);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalMaterials[keys[i]] = undefined;
        }
        // clear originalOnBeforeRenders
        keys = Object.keys(this.m_originalOnBeforeRenders);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalOnBeforeRenders[keys[i]] = undefined;
        }
        // remove unused outlineMaterial from cache
        keys = Object.keys(this.m_cache);
        for (const key of keys) {
            if (this.m_cache[key].used === false) {
                this.m_cache[key].count++;
                if (this.m_cache[key].keepAlive === false &&
                    this.m_cache[key].count > this.m_removeThresholdCount) {
                    delete this.m_cache[key];
                }
            }
            else {
                this.m_cache[key].used = false;
                this.m_cache[key].count = 0;
            }
        }
    }
}
exports.OutlineEffect = OutlineEffect;


/***/ }),

/***/ "../harp-mapview/lib/composing/Pass.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/composing/Pass.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base class to extend for further passes in [[MapView]], like the [[MSAARenderPass]], possibly
 * a text pass, an AO effect etc. `Pass` provides the core logic for both :
 * - render passes (proper scene renders),
 * - and shader passes (quad renders, i.e. effects added on top of the render output as a
 * postprocess).
 *
 * Even some shader passes still actually fall within the render pass category as they need to
 * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the
 * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.
 * These only are proper shader passes.
 */
class Pass {
    constructor() {
        this.enabled = false;
        this.renderToScreen = false;
        // tslint:enable:no-unused-variable
    }
    // tslint:disable-next-line:no-unused-variable
    setSize(width, height) {
        // Implemented in sub-classes.
    }
    // tslint:disable:no-unused-variable
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        // Implemented in sub-classes.
    }
}
exports.Pass = Pass;
/**
 * The pass that does a default normal scene rendering for further post-effects.
 */
class RenderPass extends Pass {
    constructor() {
        super();
    }
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.render(scene, camera);
    }
}
exports.RenderPass = RenderPass;
/**
 * The base class to extend for post-effects on the final render (like Vignette, Sepia, color
 * correction...)
 */
class ShaderPass extends Pass {
    constructor(shader, textureID = "tDiffuse") {
        super();
        this.textureID = textureID;
        if (shader instanceof THREE.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        }
        else {
            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
            this.material = new THREE.ShaderMaterial({
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        this.fsQuad = new FullScreenQuad(this.material);
    }
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        this.fsQuad.render(renderer);
    }
}
exports.ShaderPass = ShaderPass;
class FullScreenQuad {
    constructor(material) {
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const geometry = new THREE.PlaneBufferGeometry(2, 2);
        this.m_mesh = new THREE.Mesh(geometry, material);
    }
    get material() {
        return this.m_mesh.material;
    }
    set material(value) {
        this.m_mesh.material = value;
    }
    render(renderer) {
        renderer.render(this.m_mesh, this.m_camera);
    }
}


/***/ }),

/***/ "../harp-mapview/lib/composing/UnrealBloomPass.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/composing/UnrealBloomPass.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
const BlurDirectionX = new THREE.Vector2(1.0, 0.0);
const BlurDirectionY = new THREE.Vector2(0.0, 1.0);
/**
 * The TS version of ThreeJS's UnrealBloomPass.
 */
class BloomPass extends Pass_1.Pass {
    constructor(resolution, strength, radius, threshold) {
        super();
        this.resolution = new THREE.Vector2(256, 256);
        this.m_renderTargetsHorizontal = [];
        this.m_renderTargetsVertical = [];
        this.m_nMips = 5;
        this.m_separableBlurMaterials = [];
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_scene = new THREE.Scene();
        this.m_basic = new THREE.MeshBasicMaterial();
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));
        this.m_bloomTintColors = [
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1)
        ];
        this.strength = strength;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution;
        this.m_quad.frustumCulled = false;
        this.m_scene.add(this.m_quad);
        const pars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat
        };
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
        this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
        this.m_renderTargetBright.texture.generateMipmaps = false;
        for (let i = 0; i < this.m_nMips; i++) {
            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this.m_renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);
        // tslint:disable:no-string-literal
        this.m_highPassUniforms["luminosityThreshold"].value = threshold;
        this.m_highPassUniforms["smoothWidth"].value = 0.01;
        this.m_materialHighPassFilter = new THREE.ShaderMaterial({
            uniforms: this.m_highPassUniforms,
            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,
            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,
            defines: {}
        });
        // Gaussian Blur Materials
        const kernelSizeArray = [3, 5, 7, 9, 11];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // Composite material
        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);
        this.m_compositeMaterial.uniforms["blurTexture1"].value = this.m_renderTargetsVertical[0].texture;
        this.m_compositeMaterial.uniforms["blurTexture2"].value = this.m_renderTargetsVertical[1].texture;
        this.m_compositeMaterial.uniforms["blurTexture3"].value = this.m_renderTargetsVertical[2].texture;
        this.m_compositeMaterial.uniforms["blurTexture4"].value = this.m_renderTargetsVertical[3].texture;
        this.m_compositeMaterial.uniforms["blurTexture5"].value = this.m_renderTargetsVertical[4].texture;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        this.m_compositeMaterial.needsUpdate = true;
        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
        this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);
        this.m_copyUniforms["opacity"].value = 1.0;
        // tslint:enable:no-string-literal
        this.m_materialCopy = new THREE.ShaderMaterial({
            uniforms: this.m_copyUniforms,
            vertexShader: harp_materials_1.CopyShader.vertexShader,
            fragmentShader: harp_materials_1.CopyShader.fragmentShader,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
    }
    dispose() {
        for (const rt of this.m_renderTargetsHorizontal) {
            rt.dispose();
        }
        for (const rt of this.m_renderTargetsVertical) {
            rt.dispose();
        }
        this.m_renderTargetBright.dispose();
    }
    setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.m_renderTargetBright.setSize(resx, resy);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_renderTargetsHorizontal[i].setSize(resx, resy);
            this.m_renderTargetsVertical[i].setSize(resx, resy);
            // tslint:disable-next-line:no-string-literal
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        // tslint:disable:no-string-literal
        // Render input to screen
        if (this.renderToScreen) {
            this.m_quad.material = this.m_basic;
            this.m_basic.map = readBuffer.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
        }
        // 1. Extract bright areas
        this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.m_quad.material = this.m_materialHighPassFilter;
        renderer.setRenderTarget(this.m_renderTargetBright);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // 2. Blur all the mips progressively
        let inputRenderTarget = this.m_renderTargetBright;
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_quad.material = this.m_separableBlurMaterials[i];
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value =
                inputRenderTarget.texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            inputRenderTarget = this.m_renderTargetsVertical[i];
        }
        // Composite all the mips
        this.m_quad.material = this.m_compositeMaterial;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // Blend it additively over the input texture
        this.m_quad.material = this.m_materialCopy;
        this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            renderer.render(this.m_scene, this.m_camera);
        }
        else {
            renderer.setRenderTarget(readBuffer);
            renderer.render(this.m_scene, this.m_camera);
        }
        // tslint:enable:no-string-literal
    }
    getSeperableBlurMaterial(kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                colorTexture: { value: null },
                texSize: { value: new THREE.Vector2(0.5, 0.5) },
                direction: { value: new THREE.Vector2(0.5, 0.5) }
            },
            vertexShader: `varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `#include <common>
            varying vec2 vUv;
            uniform sampler2D colorTexture;
            uniform vec2 texSize;
            uniform vec2 direction;

            float gaussianPdf(in float x, in float sigma) {
                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
            }
            void main() {\n\
                vec2 invSize = 1.0 / texSize;
                float fSigma = float(SIGMA);
                float weightSum = gaussianPdf(0.0, fSigma);
                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                    float x = float(i);
                    float w = gaussianPdf(x, fSigma);
                    vec2 uvOffset = direction * invSize * x;
                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                    diffuseSum += (sample1 + sample2) * w;
                    weightSum += 2.0 * w;
                }
                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
            }`
        });
    }
    getCompositeMaterial(nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                blurTexture1: { value: null },
                blurTexture2: { value: null },
                blurTexture3: { value: null },
                blurTexture4: { value: null },
                blurTexture5: { value: null },
                dirtTexture: { value: null },
                bloomStrength: { value: 1.0 },
                bloomFactors: { value: null },
                bloomTintColors: { value: null },
                bloomRadius: { value: 0.0 }
            },
            vertexShader: `varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
            fragmentShader: `varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`
        });
    }
}
exports.BloomPass = BloomPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/index.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/composing/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ "../harp-mapview/lib/composing/MapRenderingManager.ts");
exports.MapRenderingManager = MapRenderingManager_1.MapRenderingManager;
var Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
exports.Pass = Pass_1.Pass;
var MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "../harp-mapview/lib/composing/MSAARenderPass.ts");
exports.MSAARenderPass = MSAARenderPass_1.MSAARenderPass;
exports.MSAASampling = MSAARenderPass_1.MSAASampling;


/***/ }),

/***/ "../harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts":
/*!****************************************************************!*\
  !*** ../harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "../harp-mapview/lib/Statistics.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
/**
 * The `PhasedTileGeometryLoader` loads the geometry of a [[Tile]] using a list of [[Phase]]s.
 *
 */
class PhasedTileGeometryLoader {
    /**
     * Creates an instance of PhasedTileGeometryLoader of a [[Tile]]. It stores the phases in which
     * its geometry should be created.
     *
     * @param {Tile} m_tile Tile the loader manages.
     * @param {Phase[]} m_loadPhaseDefinitions The definitions of the loading phases.
     * @param {GeometryKindSet} m_basicGeometryKinds The set of [[GeometryKind]] s that have to be
     *      created before the [[Tile]] is made visible.
     */
    constructor(m_tile, m_loadPhaseDefinitions, m_basicGeometryKinds) {
        this.m_tile = m_tile;
        this.m_loadPhaseDefinitions = m_loadPhaseDefinitions;
        this.m_basicGeometryKinds = m_basicGeometryKinds;
        this.m_isFinished = false;
        this.m_geometryKindsLoaded = new harp_datasource_protocol_1.GeometryKindSet();
        this.m_currentPhaseIndex = 0;
    }
    /**
     * The [[Tile]] this loader is managing.
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * The index into the array of loading phases.
     */
    get currentPhase() {
        return this.m_currentPhaseIndex;
    }
    /**
     * The number of phases defined.
     */
    get numberOfPhases() {
        return this.m_loadPhaseDefinitions.length;
    }
    /**
     * The set of [[GeometryKind]]s already created in this [[Tile]].
     */
    get geometryKindsCreated() {
        return this.m_geometryKindsLoaded;
    }
    /**
     * The set of [[GeometryKind]]s available in this [[Tile]].
     */
    get availableGeometryKinds() {
        return this.m_availableGeometryKinds;
    }
    /**
     * Returns `true` if all basic [[GeometryKind]]s have been loaded. The set of basic
     * [[GeometryKind]]s is defined in the constructor of `PhasedTileGeometryLoader`.
     */
    get basicGeometryLoaded() {
        for (const kind of this.m_basicGeometryKinds) {
            if (!this.m_geometryKindsLoaded.has(kind)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns `true` if all [[GeometryKind]]s have been loaded.
     */
    get allGeometryLoaded() {
        return this.currentPhase >= this.m_loadPhaseDefinitions.length;
    }
    /**
     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and
     * prepares its content for later processing in the 'updateXXX' methods.
     *
     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to
     *      this tile.
     * @returns {DecodedTile} The processed decoded tile.
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        this.m_currentPhaseIndex = 0;
        this.m_geometryKindsLoaded.clear();
        if (this.m_decodedTile !== undefined) {
            this.m_availableGeometryKinds = TileGeometryLoader_1.TileGeometryLoader.prepareDecodedTile(this.m_decodedTile);
        }
        return this.m_decodedTile;
    }
    /**
     * Update the tile to have all the content in its decoded tile. Load phases will be ignored.
     *
     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be
     *      enabled.
     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be
     *      disabled.
     * @returns {boolean} `true` if actual geometry has been created.
     */
    updateCompletely(enabledKinds, disabledKinds) {
        return this.update(enabledKinds, disabledKinds, true);
    }
    /**
     * Update the tile to the specified phase (index). All intermediate phases between the current
     * and the specified phase will be processed.
     *
     * @param toPhase A value between 0 and `numberOfPhases`.
     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be
     *      enabled.
     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be
     *      disabled.
     * @returns {boolean} `true` if `updateToPhase` was successful.
     */
    updateToPhase(toPhase, enabledKinds, disabledKinds) {
        let didUpdate = false;
        toPhase = Math.min(toPhase, this.numberOfPhases);
        while (this.currentPhase < toPhase) {
            if (!this.update(enabledKinds, disabledKinds)) {
                break;
            }
            didUpdate = true;
        }
        return didUpdate;
    }
    /**
     * Create all geometries in the current phase, or ignore the phases and create all remaining
     * geometries if `doFullUpdate` is `true`.
     *
     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be
     *      enabled.
     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be
     *      disabled.
     * @param doFullUpdate If a value of `true` is specified, the current phase is ignored and all
     *      remaining geometries are created.
     * @returns {boolean} `true` if `update` was successful. If `currentPhase` is smaller than
     *      `numberOfPhases`, `update` can be called again. If `false` is returned, another call to
     *      `update` is not required.
     */
    update(enabledKinds, disabledKinds, doFullUpdate = false) {
        const tile = this.tile;
        const loadPhaseDefinitions = this.m_loadPhaseDefinitions;
        if (!tile.dataSource.cacheable) {
            this.m_currentPhaseIndex = loadPhaseDefinitions.length;
            return false;
        }
        let decodedTile = this.m_decodedTile;
        const currentPhase = this.currentPhase;
        // First time this tile is handled:
        if (decodedTile === undefined && tile.decodedTile !== undefined) {
            decodedTile = this.setDecodedTile(tile.decodedTile);
            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(decodedTile, enabledKinds, disabledKinds);
        }
        if (decodedTile === undefined || currentPhase >= this.numberOfPhases) {
            return false;
        }
        const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const stats = Statistics_1.PerformanceStatistics.instance;
        let now = 0;
        if (stats.enabled) {
            now = harp_utils_1.PerformanceTimer.now();
        }
        if (doFullUpdate) {
            geometryCreator.createAllGeometries(tile, decodedTile);
            // Mark it as finished.
            this.m_currentPhaseIndex = loadPhaseDefinitions.length;
        }
        else {
            const currentPhaseDefinition = loadPhaseDefinitions[currentPhase];
            for (const kind of currentPhaseDefinition) {
                this.createKind(geometryCreator, kind);
            }
        }
        if (stats.enabled) {
            stats.currentFrame.addValue("geometry.geometryCreationTime", harp_utils_1.PerformanceTimer.now() - now);
        }
        if (this.nextPhase() === undefined) {
            // All done, update the stats
            if (stats.enabled) {
                const currentFrame = stats.currentFrame;
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined
                    ? decodedTile.textPathGeometries.length
                    : 0);
                currentFrame.addMessage(`Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} ` +
                    `col=${tile.tileKey.column} row=${tile.tileKey.row}`);
            }
            this.finish();
        }
        return true;
    }
    get isFinished() {
        return this.m_isFinished;
    }
    dispose() {
        this.m_decodedTile = undefined;
    }
    reset() {
        this.m_decodedTile = undefined;
        this.m_isFinished = false;
        this.m_availableGeometryKinds = undefined;
        this.m_geometryKindsLoaded.clear();
        this.m_currentPhaseIndex = 0;
    }
    /**
     * Increment the current phase to activate the next phase of geometries.
     *
     * @returns {(number | undefined)} The index into the now active current pase, or `undefined` if
     *      the last phase has been reached.
     */
    nextPhase() {
        if (this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length) {
            this.m_currentPhaseIndex++;
        }
        return this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length
            ? this.m_currentPhaseIndex
            : undefined;
    }
    /**
     * Create all geometries of the specified [[GeometryKind]] `kindToCreate`.
     *
     * @param {TileGeometryCreator} geometryCreator
     * @param {GeometryKind} kindToCreate
     */
    createKind(geometryCreator, kindToCreate) {
        if (this.m_geometryKindsLoaded.has(kindToCreate)) {
            return;
        }
        this.m_geometryKindsLoaded.add(kindToCreate);
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        if (decodedTile !== undefined) {
            const filter = (technique) => {
                if (technique.enabled === false) {
                    return false;
                }
                const techniqueKind = technique.kind;
                // All kinds are allowed, except those which are explicitly disabled.
                if (kindToCreate === harp_datasource_protocol_1.GeometryKind.All) {
                    return true;
                }
                if (techniqueKind instanceof Set) {
                    const techniqueKinds = techniqueKind;
                    // Check if that technique fits the expected kindToCreate.
                    return techniqueKinds.has(kindToCreate);
                }
                else {
                    return techniqueKind === kindToCreate;
                }
            };
            geometryCreator.createObjects(tile, decodedTile, filter);
            const textFilter = (technique) => {
                if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                    !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                    !harp_datasource_protocol_1.isTextTechnique(technique)) {
                    return false;
                }
                return filter(technique);
            };
            // TextElements do not get their geometry created by Tile, but are managed on a
            // higher level.
            geometryCreator.createTextElements(tile, decodedTile, textFilter);
            geometryCreator.preparePois(tile, decodedTile);
        }
    }
    finish() {
        this.m_decodedTile = undefined;
        this.m_tile.loadingFinished();
        this.m_tile.removeDecodedTile();
        this.m_isFinished = true;
    }
}
exports.PhasedTileGeometryLoader = PhasedTileGeometryLoader;


/***/ }),

/***/ "../harp-mapview/lib/geometry/PhasedTileGeometryManager.ts":
/*!*****************************************************************!*\
  !*** ../harp-mapview/lib/geometry/PhasedTileGeometryManager.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const PhasedTileGeometryLoader_1 = __webpack_require__(/*! ./PhasedTileGeometryLoader */ "../harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts");
const TileGeometryManager_1 = __webpack_require__(/*! ./TileGeometryManager */ "../harp-mapview/lib/geometry/TileGeometryManager.ts");
/**
 * The default phases to load geometry.
 */
const DefaultPhases = [
    [harp_datasource_protocol_1.GeometryKind.Background, harp_datasource_protocol_1.GeometryKind.Terrain, harp_datasource_protocol_1.GeometryKind.Area, harp_datasource_protocol_1.GeometryKind.Border],
    [harp_datasource_protocol_1.GeometryKind.Line],
    [harp_datasource_protocol_1.GeometryKind.Building],
    [harp_datasource_protocol_1.GeometryKind.Label],
    [harp_datasource_protocol_1.GeometryKind.All]
];
// FIXME: This should (always) be the first phase, no?
const DefaultBasicGeometryKinds = new harp_datasource_protocol_1.GeometryKindSet(DefaultPhases[0]);
/**
 * Manages the loading of [[Tile]] geometry in phases.
 */
class PhasedTileGeometryManager extends TileGeometryManager_1.TileGeometryManagerBase {
    /**
     * Creates an instance of PhasedTileGeometryManager. Keeps the reference to the [[MapView]].
     *
     * @param {MapView} mapView
     */
    constructor(mapView) {
        super(mapView);
        this.m_maxUpdatedTilePerFrame = 5;
        this.m_loadPhaseDefinitions = DefaultPhases;
        this.m_basicGeometryKinds = DefaultBasicGeometryKinds;
    }
    initTile(tile) {
        if (tile.dataSource.useGeometryLoader) {
            tile.tileGeometryLoader = new PhasedTileGeometryLoader_1.PhasedTileGeometryLoader(tile, this.m_loadPhaseDefinitions, this.m_basicGeometryKinds);
        }
    }
    updateTiles(tiles) {
        let needUpdate = this.mapView.isDynamicFrame
            ? this.updateSomeTiles(tiles)
            : this.updateAllTilesTogether(tiles);
        // updateTileObjectVisibility() has always to be called.
        needUpdate = this.updateTileObjectVisibility(tiles) || needUpdate;
        if (needUpdate || !this.checkTilesFinished(tiles)) {
            this.mapView.update();
        }
    }
    checkTilesFinished(tiles) {
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined && !phasedGeometryLoader.allGeometryLoaded) {
                return false;
            }
        }
        return true;
    }
    /**
     * Update the tiles during dynamic frames. Number of tiles to update may be limited.
     *
     * @param {Tile[]} tiles
     */
    updateSomeTiles(tiles) {
        let numTilesUpdated = 0;
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            let limitReached = false;
            if (phasedGeometryLoader !== undefined) {
                if (phasedGeometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined)) {
                    numTilesUpdated++;
                    if (this.m_maxUpdatedTilePerFrame > 0 &&
                        numTilesUpdated >= this.m_maxUpdatedTilePerFrame) {
                        limitReached = true;
                    }
                }
                if (this.m_tileUpdateCallback) {
                    this.m_tileUpdateCallback(tile);
                }
                if (limitReached) {
                    break;
                }
            }
        }
        return numTilesUpdated > 0;
    }
    /**
     * Update the tiles during static frames. Before advancing to the next phase, any tiles lagging
     * behind are allowed to catch up to their next phase. Only then all tiles will advance to the
     * next phase together.
     *
     * @param {Tile[]} tiles
     */
    updateAllTilesTogether(tiles) {
        let lowestPhase;
        let needUpdate = false;
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined &&
                (lowestPhase === undefined || phasedGeometryLoader.currentPhase < lowestPhase)) {
                lowestPhase = phasedGeometryLoader.currentPhase;
            }
        }
        if (lowestPhase !== undefined && lowestPhase < this.m_loadPhaseDefinitions.length) {
            const nextPhase = lowestPhase + 1;
            needUpdate = this.updateTilesIfNeeded(tiles, nextPhase);
        }
        return needUpdate;
    }
    /**
     * Update the tiles during static frames only if their phase is lower than the `toPhase`.
     *
     * @param {Tile[]} tiles
     */
    updateTilesIfNeeded(tiles, toPhase) {
        let needUpdate = false;
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined) {
                if (phasedGeometryLoader.updateToPhase(toPhase, this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined)) {
                    needUpdate = true;
                }
                if (this.m_tileUpdateCallback) {
                    this.m_tileUpdateCallback(tile);
                }
            }
        }
        return needUpdate;
    }
}
exports.PhasedTileGeometryManager = PhasedTileGeometryManager;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileDataAccessor.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileDataAccessor.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ "../harp-mapview/lib/geometry/TileGeometry.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileDataAccessor");
/**
 * An accessor for all geometries in a tile. This class uses a client-provided [[ITileDataVisitor]]
 * to visit all objects, based on filtering options specified by both, the `TileDataAccessor` and
 * the visitor itself.
 */
class TileDataAccessor {
    /**
     * Constructs a `TileDataAccessor` instance.
     *
     * @param tile The tile to access.
     * @param visitor The visitor.
     * @param options Options for the tile.
     */
    constructor(tile, visitor, options) {
        this.tile = tile;
        this.visitor = visitor;
        this.m_wantsPoints = true;
        this.m_wantsLines = true;
        this.m_wantsAreas = true;
        this.m_wantsObject3D = true;
        const wantsAll = options.wantsAll === true;
        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
        this.m_wantsLines = wantsAll || !(options.wantsLines === false);
        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
    }
    /**
     * Calls the visitor on all objects in the tile.
     */
    visitAll() {
        const objects = this.tile.objects;
        for (const object of objects) {
            this.visitObject(object);
        }
    }
    /**
     * Visits a single object. This function should normally be called during visiting.
     *
     * @param object The object to visit.
     */
    visitObject(object) {
        const featureData = object.userData !== undefined
            ? object.userData.feature
            : undefined;
        // early opt out if there is no feature data, or if the feature data has only a single id
        // and the visitor wants to ignore that featureId
        if (featureData === undefined ||
            (featureData.ids !== undefined &&
                featureData.ids.length === 1 &&
                !this.visitor.wantsFeature(featureData.ids[0]))) {
            return;
        }
        const geometryType = featureData.geometryType;
        if (geometryType === undefined) {
            logger.warn("#visitObject: visiting object failed, no geometryType", object);
            return;
        }
        harp_utils_1.assert(featureData.ids !== undefined, "featureData.ids missing");
        harp_utils_1.assert(Array.isArray(featureData.ids), "featureData.ids is not an array");
        harp_utils_1.assert(featureData.starts !== undefined, "featureData.starts missing");
        harp_utils_1.assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
        if (featureData.ids !== undefined && featureData.starts !== undefined) {
            harp_utils_1.assert(featureData.ids.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
        }
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                if (!this.m_wantsPoints) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                if (!this.m_wantsLines) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                if (!this.m_wantsAreas) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                if (!this.m_wantsObject3D) {
                    return;
                }
                break;
            default:
                logger.warn("#visitObject: invalid geometryType");
        }
        if (object.type !== "Mesh") {
            logger.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
            return;
        }
        const mesh = object;
        this.visitMesh(mesh, featureData);
    }
    /**
     * Gets the `BufferGeometry` from the specified object. This function requires the
     * attribute `position` in `BufferGeometry` to be set.
     *
     * @param object The object from which to get the geometry.
     * @returns the geometry of the object, or `undefined`.
     */
    getBufferGeometry(object) {
        const geometry = object.geometry;
        if (geometry.type !== "BufferGeometry") {
            logger.warn("#visitObject: object does not have BufferGeometry");
            return undefined;
        }
        const bufferGeometry = geometry;
        // we know its a BufferAttribute because it is a BufferGeometry
        const position = bufferGeometry.getAttribute("position");
        if (!position) {
            logger.warn("#visitLines: BufferGeometry has no position attribute");
            return undefined;
        }
        return bufferGeometry;
    }
    /**
     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType The type of geometry.
     * @param object The object for which to access the attributes and geometry.
     * @param bufferGeometry The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
            default:
                logger.warn("#getGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Obtains an accessor for the indexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType The type of geometry.
     * @param object The object for which to access the attributes and geometry.
     * @param bufferGeometry The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            default:
                logger.warn("#getIndexedGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Visit the object.
     *
     * @param meshObject Object of type `Mesh`.
     * @param featureData Dataset stored along with the object.
     */
    visitMesh(meshObject, featureData) {
        const { ids, starts } = featureData;
        const geometryType = featureData.geometryType;
        // make linter happy: we already know that these both are valid
        if (ids === undefined || starts === undefined || geometryType === undefined) {
            return;
        }
        let geometryAccessor;
        for (let featureIndex = 0; featureIndex < ids.length; featureIndex++) {
            const featureId = ids[featureIndex];
            if (!this.visitor.wantsFeature(featureId)) {
                continue;
            }
            const featureStart = starts[featureIndex];
            let featureEnd = -1;
            // lazy creation of accessor, in case featureId was not wanted...
            if (geometryAccessor === undefined) {
                const bufferGeometry = this.getBufferGeometry(meshObject);
                if (bufferGeometry === undefined) {
                    continue;
                }
                if (bufferGeometry.index !== null) {
                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                else {
                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                if (geometryAccessor === undefined) {
                    logger.warn("#visitObject: no accessor geometryType", geometryType);
                    continue;
                }
            }
            featureEnd =
                featureIndex < starts.length - 1
                    ? starts[featureIndex + 1]
                    : geometryAccessor.getCount();
            // setup/update the accessor for the new range of the object
            geometryAccessor.setRange(featureStart, featureEnd);
            switch (geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    this.visitor.visitPoint(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));
                    this.visitor.visitLine(featureId, geometryAccessor);
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    this.visitor.visitArea(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));
                    this.visitor.visitObject3D(featureId, geometryAccessor);
                    break;
                default:
                    logger.warn("#visitObject: invalid geometryType");
            }
        }
    }
}
exports.TileDataAccessor = TileDataAccessor;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometry.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometry.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ "../harp-lines/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometry");
/**
 * Helper function to check if an accessor is of type `ILineAccessor`.
 *
 * @param arg `true` if `arg` is `ILineAccessor`.
 */
function isLineAccessor(arg) {
    /**
     * Get vertices from the object.
     *
     * @param mode Specifies which part of the vertices should be returned.
     */
    return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
exports.isLineAccessor = isLineAccessor;
/**
 * Helper function to check if an accessor is of type `IObject3dAccessor`.
 *
 * @param arg `true` if `arg` is `IObject3dAccessor`.
 */
function isObject3dAccessor(arg) {
    return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
exports.isObject3dAccessor = isObject3dAccessor;
/**
 * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.
 */
class BufferedGeometryAccessorBase {
    constructor(object, geometryType, bufferGeometry) {
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.start = -1;
        this.end = -1;
        this.startCapSize = 0;
        this.endCapSize = 0;
        harp_utils_1.assert(!!object);
        if (bufferGeometry.type !== "BufferGeometry") {
            logger.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong " + "type");
        }
        harp_utils_1.assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        // we know its a BufferAttribute because it is a BufferGeometry
        this.position = this.bufferGeometry.getAttribute("position");
        this.itemSize = this.position.itemSize;
        if (!this.position) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position " +
                "attribute");
        }
        if (this.position.array.constructor !== Float32Array) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: " +
                "unsupported ArrayBuffer");
        }
    }
    /**
     * Get the number of accessible geometries in this buffer.
     *
     * @returns Number of primitives in this geometry.
     */
    getCount() {
        return this.position.count;
    }
    /**
     * Get `renderOrder` of object.
     *
     * @returns `renderOrder` of the object.
     */
    get renderOrder() {
        return this.object.renderOrder;
    }
    setRange(start, end, startCapSize = 0, endCapSize = 0) {
        harp_utils_1.assert(start >= 0);
        harp_utils_1.assert(end >= 0);
        harp_utils_1.assert(start <= end);
        this.start = start;
        this.end = end;
        this.startCapSize = startCapSize;
        this.endCapSize = endCapSize;
    }
    /**
     * Get one or more colors from materials.
     */
    get color() {
        /**
         * TODO: Get color(s) from vertex colors
         */
        const getColor = (material) => {
            const meshMaterial = material;
            if (meshMaterial.type === "MeshBasicMaterial" ||
                meshMaterial.type === "MeshStandardMaterial") {
                return meshMaterial.color;
            }
            else if (meshMaterial.type === "RawShaderMaterial") {
                const rawShaderMaterial = material;
                if (rawShaderMaterial.name === "SolidLineMaterial") {
                    return rawShaderMaterial.uniforms.diffuse.value;
                }
                logger.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
            }
            else {
                logger.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
            }
            return undefined;
        };
        if (Array.isArray(this.object.material)) {
            const results = new Array();
            const materials = this.object.material;
            for (const material of materials) {
                results.push(getColor(material));
            }
            return results;
        }
        else {
            return getColor(this.object.material);
        }
    }
}
exports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;
/**
 * Abstract base class of an accessor for nonindexed geometry.
 */
class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Create an object of type `BufferedGeometryAccessor`
     *
     * @param object - mesh object
     * @param geometryType - type of geometry to be used
     * @param bufferGeometry - which buffer geometry to use
     * @param stride - geometry stride length
     */
    constructor(object, geometryType, bufferGeometry, stride) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.stride = stride;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const positionsArray = this.position.array;
        const start = this.start * this.itemSize;
        const end = this.end * this.itemSize;
        for (let i = start; i < end; i++) {
            positionsArray[i] = 0;
        }
        this.position.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const start = this.start;
        const end = this.end;
        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
    }
    checkSetUp() {
        return (this.position !== undefined &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.position.count &&
            this.start <= this.end);
    }
}
exports.BufferedGeometryAccessor = BufferedGeometryAccessor;
/**
 * Accessor for nonindexed line geometry.
 */
class BufferedGeometryLineAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    get width() {
        //TODO: There is no implementation of such a line, yet...
        harp_utils_1.assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
        return undefined;
    }
}
exports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;
/**
 * Accessor for nonindexed unspecified (`Object3D`) geometry.
 */
class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 1);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isObject3dAccessor() {
        return true;
    }
    getVertices() {
        return super.getVertices();
    }
}
exports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;
/**
 * Abstract base class of indexed geometry.
 */
class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Creates an abstract class `IndexedBufferedGeometryAccessor`.
     *
     * @param object - mesh to be used
     * @param geometryType - type of geometry
     * @param bufferGeometry - geometry used
     * @param start
     * @param end
     */
    constructor(object, geometryType, bufferGeometry, 
    // tslint:disable-next-line:no-unused-variable
    start, 
    // tslint:disable-next-line:no-unused-variable
    end) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.indices = this.bufferGeometry.index.array;
        if (!this.indices) {
            logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no " + "index");
            harp_utils_1.assert(!!this.indices);
        }
        else {
            if (!(this.indices instanceof Uint32Array)) {
                logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index " +
                    "has wrong type");
                harp_utils_1.assert(this.indices instanceof Uint32Array);
            }
        }
    }
    /**
     * Returns number of primitives, which is not known in this base class, so we return the number
     * of indices.
     *
     * @returns The number of indices in the geometry.
     */
    getCount() {
        return this.indices.length;
    }
    checkSetUp() {
        return (!!this.indices &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.indices.length &&
            this.start <= this.end);
    }
}
exports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;
/**
 * Accessor for lines in an indexed geometry.
 */
class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    /**
     * Reconstructs line width from triangulated geometry.
     *
     * @returns Line width.
     */
    get width() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {
            const start = this.start + this.startCapSize;
            const positionArray = this.position.array;
            return harp_lines_1.reconstructLineWidth(positionArray, start);
        }
        return undefined;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const start = this.start;
        const end = this.end;
        for (let i = start; i < end; i++) {
            this.indices[i] = 0;
        }
        this.bufferGeometry.index.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const itemSize = this.itemSize;
        const start = this.start;
        const end = this.end;
        const result = new Float32Array((end - start) * itemSize);
        const positionArray = this.position.array;
        if (itemSize === 2) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
            }
        }
        if (itemSize === 3) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
                result[j + 2] = positionArray[index * itemSize + 2];
            }
        }
        else {
            for (let i = start, j = 0; i < end; i++, j++) {
                const index = this.indices[i];
                for (let k = 0; k < itemSize; k++) {
                    result[j * itemSize + k] = positionArray[index * itemSize + k];
                }
            }
        }
        return result;
    }
}
exports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryCreator.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryCreator.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
// tslint:disable:max-line-length
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ "../harp-datasource-protocol/index-decoder.ts");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ "../harp-mapview/lib/DepthPrePass.ts");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const TextStyleCache_1 = __webpack_require__(/*! ../text/TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
/**
 * The SORT_WEIGHT_PATH_LENGTH constants control how the priority of the labels are computed based
 * on the length of the label strings.
 *
 * Consequently, the [[Technique]]s priority is slightly modified while generating
 * [[TextElement]]s from the [[DecodedTile]], to get a more meaningful priority and stable results.
 */
/**
 * Gives [[TextElement]]s with longer paths a higher priority.
 */
const SORT_WEIGHT_PATH_LENGTH = 0.1;
/**
 * Support class to create geometry for a [[Tile]] from a [[DecodedTile]].
 */
class TileGeometryCreator {
    /**
     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.
     */
    constructor() {
        //
    }
    /**
     * The `instance` of the `TileGeometryCreator`.
     *
     * @returns TileGeometryCreator
     */
    static get instance() {
        return this.m_instance || (this.m_instance = new TileGeometryCreator());
    }
    /**
     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a
     * technique is identified as disabled, its property `enabled` is set to `false`.
     *
     * @param decodedTile The decodedTile containing the actual tile map data.
     * @param enabledKinds Optional [[GeometryKindSet]] used to specify which object kinds should be
     *      created.
     * @param disabledKinds Optional [[GeometryKindSet]] used to filter objects that should not be
     *      created.
     */
    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
        for (const technique of decodedTile.techniques) {
            // Already processed
            if (technique.enabled !== undefined) {
                continue;
            }
            // Turn technique.kind from the style, which may be a string or an array of strings,
            // into a GeometryKindSet.
            if (technique.kind !== undefined) {
                if (Array.isArray(technique.kind)) {
                    technique.kind = new harp_datasource_protocol_1.GeometryKindSet(technique.kind);
                }
                else if (typeof technique.kind !== "string") {
                    index_decoder_1.logger.warn("Technique has unknown type of kind:", technique);
                    technique.kind = undefined;
                }
            }
            // No info about kind, no way to filter it.
            if (technique.kind === undefined ||
                (technique.kind instanceof Set && technique.kind.size === 0)) {
                technique.enabled = true;
                continue;
            }
            technique.enabled =
                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(technique.kind)) ||
                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(technique.kind));
        }
        for (const srcGeometry of decodedTile.geometries) {
            for (const group of srcGeometry.groups) {
                group.createdOffsets = [];
            }
        }
    }
    /**
     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before
     * calling this method.
     *
     * @see [[TileGeometryCreator#initDecodedTile]]
     *
     * @param tile The [[Tile]] to process.
     * @param decodedTile The decodedTile containing the actual tile map data.
     */
    createAllGeometries(tile, decodedTile) {
        tile.clear();
        const filter = (technique) => {
            return technique.enabled !== false;
        };
        this.createObjects(tile, decodedTile, filter);
        const textFilter = (technique) => {
            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                !harp_datasource_protocol_1.isTextTechnique(technique)) {
                return false;
            }
            return filter(technique);
        };
        this.preparePois(tile, decodedTile);
        // TextElements do not get their geometry created by Tile, but are managed on a
        // higher level.
        this.createTextElements(tile, decodedTile, textFilter);
    }
    /**
     * Apply enabled and disabled kinds as a filter.
     *
     * @param {DecodedTile} decodedTile
     * @param {(GeometryKindSet | undefined)} enabledKinds
     * @param {(GeometryKindSet | undefined)} disabledKinds
     */
    processTechniques(decodedTile, enabledKinds, disabledKinds) {
        if (decodedTile === undefined) {
            return;
        }
        for (const technique of decodedTile.techniques) {
            // Make sure that all technique have their geometryKind set, either from the Theme or
            // their default value.
            if (technique.kind === undefined) {
                TileGeometryLoader_1.TileGeometryLoader.setDefaultGeometryKind(technique);
            }
        }
        // Speedup and simplify following code: Test all techniques if they intersect with
        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be
        // ignored hereafter.
        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
    }
    /**
     * Adds a THREE object to the root of the tile. Sets the owning tiles datasource.name and the
     * tileKey in the `userData` property of the object, such that the tile it belongs to can be
     * identified during picking.
     *
     * @param tile The [[Tile]] to add the object to.
     * @param object The object to add to the root of the tile.
     * @param geometryKind The kind of object. Can be used for filtering.
     */
    registerTileObject(tile, object, geometryKind) {
        if (object.userData === undefined) {
            object.userData = {};
        }
        const userData = object.userData;
        userData.tileKey = tile.tileKey;
        userData.dataSource = tile.dataSource.name;
        userData.kind =
            geometryKind instanceof Set
                ? Array.from(geometryKind.values())
                : Array.isArray(geometryKind)
                    ? geometryKind
                    : [geometryKind];
        // Force a visibility check of all objects.
        tile.resetVisibilityCounter();
    }
    /**
     * Splits the text paths that contain sharp corners.
     *
     * @param tile The [[Tile]] to process paths on.
     * @param textPathGeometries The original path geometries that may have defects.
     * @param textFilter: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
        const processedPaths = new Array();
        const MAX_CORNER_ANGLE = Math.PI / 8;
        const newPaths = textPathGeometries.slice();
        // maximum reuse of variables to reduce allocations
        const p0 = new THREE.Vector2();
        const p1 = new THREE.Vector2();
        const previousTangent = new THREE.Vector2();
        while (newPaths.length > 0) {
            const textPath = newPaths.pop();
            if (textPath === undefined) {
                break;
            }
            const technique = decodedTile.techniques[textPath.technique];
            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||
                (textFilter !== undefined && !textFilter(technique))) {
                continue;
            }
            let splitIndex = -1;
            for (let i = 0; i < textPath.path.length - 3; i += 3) {
                p0.set(textPath.path[i], textPath.path[i + 1]);
                p1.set(textPath.path[i + 3], textPath.path[i + 4]);
                const tangent = p1.sub(p0).normalize();
                if (i > 0) {
                    const theta = Math.atan2(previousTangent.x * tangent.y - tangent.x * previousTangent.y, tangent.dot(previousTangent));
                    if (Math.abs(theta) > MAX_CORNER_ANGLE) {
                        splitIndex = i;
                        break;
                    }
                }
                previousTangent.set(tangent.x, tangent.y);
            }
            if (splitIndex > 0) {
                // split off the valid first path points with a clone of the path
                const firstTextPath = {
                    path: textPath.path.slice(0, splitIndex + 3),
                    text: textPath.text,
                    // Used for placement priorities only, can be kept although it could also be
                    // recomputed
                    pathLengthSqr: textPath.pathLengthSqr,
                    technique: textPath.technique,
                    featureId: textPath.featureId
                };
                processedPaths.push(firstTextPath);
                // setup a second part with the rest of the path points and process again
                const secondTextPath = {
                    path: textPath.path.slice(splitIndex),
                    text: textPath.text,
                    // Used for placement priorities only, can be kept although it could also be
                    // recomputed
                    pathLengthSqr: textPath.pathLengthSqr,
                    technique: textPath.technique,
                    featureId: textPath.featureId
                };
                newPaths.push(secondTextPath);
            }
            else {
                processedPaths.push(textPath);
            }
        }
        return processedPaths;
    }
    /**
     * Creates [[TextElement]] objects from the decoded tile and list of materials specified. The
     * priorities of the [[TextElement]]s are updated to simplify label placement.
     *
     * @param tile The [[Tile]] to create the testElements on.
     * @param decodedTile The [[DecodedTile]].
     * @param textFilter: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    createTextElements(tile, decodedTile, textFilter) {
        const mapView = tile.mapView;
        const displayZoomLevel = Math.floor(mapView.zoomLevel);
        if (decodedTile.textPathGeometries !== undefined) {
            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
            // Compute maximum street length (squared). Longer streets should be labelled first,
            // they have a higher chance of being placed in case the number of text elements is
            // limited.
            let maxPathLengthSqr = 0;
            for (const textPath of textPathGeometries) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique.enabled === false || !harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                if (textPath.pathLengthSqr > maxPathLengthSqr) {
                    maxPathLengthSqr = textPath.pathLengthSqr;
                }
            }
            for (const textPath of textPathGeometries) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique.enabled === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const path = [];
                for (let i = 0; i < textPath.path.length; i += 3) {
                    path.push(new THREE.Vector3(textPath.path[i], textPath.path[i + 1], textPath.path[i + 2]));
                }
                // Make sorting stable and make pathLengthSqr a differentiator for placement.
                const priority = (technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, displayZoomLevel)
                    : 0) +
                    (maxPathLengthSqr > 0
                        ? (SORT_WEIGHT_PATH_LENGTH * textPath.pathLengthSqr) / maxPathLengthSqr
                        : 0);
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
                    : technique.fadeFar;
                const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(textPath.text), path, this.getRenderStyle(tile, technique), this.getLayoutStyle(tile, technique), priority, technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, textPath.featureId, technique.style, fadeNear, fadeFar);
                textElement.minZoomLevel =
                    technique.minZoomLevel !== undefined
                        ? technique.minZoomLevel
                        : mapView.minZoomLevel;
                textElement.maxZoomLevel =
                    technique.maxZoomLevel !== undefined
                        ? technique.maxZoomLevel
                        : mapView.maxZoomLevel;
                textElement.distanceScale =
                    technique.distanceScale !== undefined
                        ? technique.distanceScale
                        : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
                textElement.mayOverlap = technique.mayOverlap === true;
                textElement.reserveSpace = technique.reserveSpace !== false;
                textElement.kind = technique.kind;
                // Get the userData for text element picking.
                textElement.userData = textPath.objInfos;
                tile.addTextElement(textElement);
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }
                const technique = decodedTile.techniques[text.technique];
                if (technique.enabled === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);
                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, displayZoomLevel)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
                    : technique.fadeFar;
                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }
                    const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), this.getRenderStyle(tile, technique), this.getLayoutStyle(tile, technique), priority, technique.xOffset || 0.0, technique.yOffset || 0.0, text.featureId, technique.style);
                    textElement.minZoomLevel =
                        technique.minZoomLevel !== undefined
                            ? technique.minZoomLevel
                            : mapView.minZoomLevel;
                    textElement.maxZoomLevel =
                        technique.maxZoomLevel !== undefined
                            ? technique.maxZoomLevel
                            : mapView.maxZoomLevel;
                    textElement.mayOverlap = technique.mayOverlap === true;
                    textElement.reserveSpace = technique.reserveSpace !== false;
                    textElement.kind = technique.kind;
                    textElement.fadeNear = fadeNear;
                    textElement.fadeFar = fadeFar;
                    if (text.objInfos !== undefined) {
                        // Get the userData for text element picking.
                        textElement.userData = text.objInfos[i];
                    }
                    tile.addTextElement(textElement);
                }
            }
        }
    }
    /**
     * Creates `Tile` objects from the decoded tile and list of materials specified.
     *
     * @param tile The [[Tile]] to create the geometry on.
     * @param decodedTile The [[DecodedTile]].
     * @param techniqueFilter: Optional filter. Should return true for any technique that is
     *      applicable.
     */
    createObjects(tile, decodedTile, techniqueFilter) {
        const materials = [];
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const displayZoomLevel = Math.floor(mapView.zoomLevel);
        const objects = tile.objects;
        for (const srcGeometry of decodedTile.geometries) {
            const groups = srcGeometry.groups;
            const groupCount = groups.length;
            for (let groupIndex = 0; groupIndex < groupCount;) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (group.createdOffsets.indexOf(tile.offset) !== -1 ||
                    technique.enabled === false ||
                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {
                    continue;
                }
                let count = group.count;
                group.createdOffsets.push(tile.offset);
                // compress consecutive groups
                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }
                    count += groups[groupIndex].count;
                    // Mark this group as created, so it does not get processed again.
                    groups[groupIndex].createdOffsets.push(tile.offset);
                }
                const ObjectCtor = DecodedTileHelpers_1.getObjectConstructor(technique);
                if (ObjectCtor === undefined) {
                    continue;
                }
                let material = materials[techniqueIndex];
                if (material === undefined) {
                    const onMaterialUpdated = (texture) => {
                        dataSource.requestUpdate();
                        if (texture !== undefined) {
                            tile.addOwnedTexture(texture);
                        }
                    };
                    material = DecodedTileHelpers_1.createMaterial({
                        technique,
                        level: displayZoomLevel,
                        fog: mapView.scene.fog !== null
                    }, onMaterialUpdated);
                    if (material === undefined) {
                        continue;
                    }
                    materials[techniqueIndex] = material;
                }
                // Modify the standard textured shader to support height-based coloring.
                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
                }
                const bufferGeometry = new THREE.BufferGeometry();
                srcGeometry.vertexAttributes.forEach((vertexAttribute) => {
                    const buffer = DecodedTileHelpers_1.getBufferAttribute(vertexAttribute);
                    bufferGeometry.addAttribute(vertexAttribute.name, buffer);
                });
                if (srcGeometry.interleavedVertexAttributes !== undefined) {
                    srcGeometry.interleavedVertexAttributes.forEach((attr) => {
                        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(attr.type);
                        const buffer = new THREE.InterleavedBuffer(new ArrayCtor(attr.buffer), attr.stride);
                        attr.attributes.forEach((interleavedAttr) => {
                            const attribute = new THREE.InterleavedBufferAttribute(buffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
                            bufferGeometry.addAttribute(interleavedAttr.name, attribute);
                        });
                    });
                }
                if (srcGeometry.index) {
                    bufferGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.index));
                }
                if (!bufferGeometry.getAttribute("normal") && harp_datasource_protocol_1.needsVertexNormals(technique)) {
                    bufferGeometry.computeVertexNormals();
                }
                bufferGeometry.addGroup(start, count);
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique) || harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
                    const lineMaterial = material;
                    lineMaterial.uniforms.opacity.value = material.opacity;
                    if (technique.clipping !== false &&
                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                        const tileSize = lineMaterial.uniforms.tileSize;
                        const size = new THREE.Vector3();
                        tile.boundingBox.getSize(size);
                        tileSize.value.x = size.x;
                        tileSize.value.y = size.y;
                        lineMaterial.defines.TILE_CLIP = 1;
                    }
                    if (bufferGeometry.getAttribute("color")) {
                        lineMaterial.defines.USE_COLOR = 1;
                    }
                }
                // Add polygon offset to the extruded buildings and to the fill area to avoid depth
                // problems when rendering edges.
                const hasExtrudedOutlines = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && srcGeometry.edgeIndex !== undefined;
                const hasFillOutlines = harp_datasource_protocol_1.isFillTechnique(technique) && srcGeometry.edgeIndex !== undefined;
                if (hasExtrudedOutlines || hasFillOutlines) {
                    material.polygonOffset = true;
                    material.polygonOffsetFactor = 0.75;
                    material.polygonOffsetUnits = 4.0;
                }
                // Add the solid line outlines as a separate object.
                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;
                const object = new ObjectCtor(bufferGeometry, material);
                object.frustumCulled = false;
                object.renderOrder = technique.renderOrder;
                if (group.renderOrderOffset !== undefined) {
                    object.renderOrder += group.renderOrderOffset;
                }
                if (srcGeometry.uuid !== undefined) {
                    object.userData.geometryId = srcGeometry.uuid;
                }
                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
                    technique.enablePicking !== undefined) {
                    // tslint:disable-next-line:max-line-length
                    object.enableRayTesting = technique.enablePicking;
                }
                if (harp_datasource_protocol_1.isLineTechnique(technique) ||
                    (harp_datasource_protocol_1.isSegmentsTechnique(technique) &&
                        technique.color !== undefined &&
                        harp_datasource_protocol_1.isInterpolatedProperty(technique.color))) {
                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, false, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        lineMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel));
                    });
                }
                // Lines renderOrder fix: Render them as transparent objects, but make sure they end
                // up in the opaque rendering queue (by disabling transparency onAfterRender, and
                // enabling it onBeforeRender).
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique) || harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, true, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        const unitFactor = technique.metricUnit === "Pixel" ? mapView.pixelToWorld : 1.0;
                        if (technique.color !== undefined) {
                            lineMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel));
                        }
                        lineMaterial.lineWidth =
                            harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, mapView.zoomLevel, mapView.pixelToWorld) *
                                unitFactor *
                                0.5;
                        // Do the same for dashSize and gapSize for dashed lines.
                        if (harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
                            const dashedLineMaterial = lineMaterial;
                            if (technique.dashSize !== undefined) {
                                dashedLineMaterial.dashSize =
                                    harp_datasource_protocol_1.getPropertyValue(technique.dashSize, mapView.zoomLevel, mapView.pixelToWorld) *
                                        unitFactor *
                                        0.5;
                            }
                            if (technique.gapSize !== undefined) {
                                dashedLineMaterial.gapSize =
                                    harp_datasource_protocol_1.getPropertyValue(technique.gapSize, mapView.zoomLevel, mapView.pixelToWorld) *
                                        unitFactor *
                                        0.5;
                            }
                        }
                    });
                }
                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                    // extruded lines are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined ||
                        harp_datasource_protocol_1.isInterpolatedProperty(technique.color)) {
                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, true, true, technique.color !== undefined && harp_datasource_protocol_1.isInterpolatedProperty(technique.color)
                            ? (renderer, mat) => {
                                const extrudedMaterial = mat;
                                extrudedMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel));
                            }
                            : undefined);
                    }
                }
                this.addFeatureData(srcGeometry, technique, object);
                this.addGeometryObjInfos(tile, srcGeometry, technique, object);
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {
                    // filled polygons are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    const hasDynamicColor = (technique.color !== undefined &&
                        harp_datasource_protocol_1.isInterpolatedProperty(technique.color)) ||
                        (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                            harp_datasource_protocol_1.isInterpolatedProperty(technique.emissive));
                    if (technique.fadeFar !== undefined || hasDynamicColor) {
                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, fadingParams.fadeNear, fadingParams.fadeFar, true, true, hasDynamicColor
                            ? (renderer, mat) => {
                                const polygonMaterial = mat;
                                polygonMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(technique.color, mapView.zoomLevel));
                                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                                    technique.emissive !== undefined) {
                                    const standardMat = mat;
                                    standardMat.emissive.set(harp_datasource_protocol_1.getPropertyValue(technique.emissive, mapView.zoomLevel));
                                }
                            }
                            : undefined);
                    }
                }
                const extrudedObjects = [];
                const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
                let extrusionAnimationEnabled = false;
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    animatedExtrusionHandler !== undefined) {
                    let animateExtrusionValue = technique.animateExtrusion;
                    if (animateExtrusionValue !== undefined) {
                        animateExtrusionValue =
                            typeof animateExtrusionValue === "boolean"
                                ? animateExtrusionValue
                                : typeof animateExtrusionValue === "number"
                                    ? animateExtrusionValue !== 0
                                    : false;
                    }
                    extrusionAnimationEnabled =
                        animateExtrusionValue !== undefined &&
                            animatedExtrusionHandler.forceEnabled === false
                            ? animateExtrusionValue
                            : animatedExtrusionHandler.enabled;
                }
                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && DepthPrePass_1.isRenderDepthPrePassEnabled(technique);
                if (renderDepthPrePass) {
                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);
                    objects.push(depthPassMesh);
                    if (extrusionAnimationEnabled) {
                        extrudedObjects.push({
                            object: depthPassMesh,
                            materialFeature: true
                        });
                    }
                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);
                }
                this.registerTileObject(tile, object, technique.kind);
                objects.push(object);
                // Add the extruded building edges as a separate geometry.
                if (hasExtrudedOutlines) {
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.addAttribute("position", bufferGeometry.getAttribute("position"));
                    const colorAttribute = bufferGeometry.getAttribute("color");
                    if (colorAttribute !== undefined) {
                        edgeGeometry.addAttribute("color", colorAttribute);
                    }
                    const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                    if (extrusionAttribute !== undefined) {
                        edgeGeometry.addAttribute("extrusionAxis", extrusionAttribute);
                    }
                    edgeGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));
                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(displayZoomLevel, extrudedPolygonTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    // Set the correct render order.
                    edgeObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false, false, extrudedPolygonTechnique.lineColor !== undefined &&
                        harp_datasource_protocol_1.isInterpolatedProperty(extrudedPolygonTechnique.lineColor)
                        ? (renderer, mat) => {
                            edgeMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(extrudedPolygonTechnique.lineColor, mapView.zoomLevel));
                        }
                        : undefined);
                    if (extrusionAnimationEnabled) {
                        extrudedObjects.push({
                            object: edgeObj,
                            materialFeature: false
                        });
                    }
                    this.registerTileObject(tile, edgeObj, technique.kind);
                    objects.push(edgeObj);
                }
                // animate the extrusion of buildings
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                    extrudedObjects.push({
                        object,
                        materialFeature: true
                    });
                    const extrusionAnimationDuration = technique.animateExtrusionDuration !== undefined &&
                        animatedExtrusionHandler.forceEnabled === false
                        ? technique.animateExtrusionDuration
                        : animatedExtrusionHandler.duration;
                    tile.animatedExtrusionTileHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler(tile, extrudedObjects, extrusionAnimationDuration);
                    mapView.animatedExtrusionHandler.add(tile.animatedExtrusionTileHandler);
                }
                // Add the fill area edges as a separate geometry.
                if (hasFillOutlines) {
                    const outlineGeometry = new THREE.BufferGeometry();
                    outlineGeometry.addAttribute("position", bufferGeometry.getAttribute("position"));
                    outlineGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));
                    const fillTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(displayZoomLevel, fillTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                    outlineObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, fadingParams.lineFadeNear, fadingParams.lineFadeFar, true, false, fillTechnique.lineColor !== undefined &&
                        harp_datasource_protocol_1.isInterpolatedProperty(fillTechnique.lineColor)
                        ? (renderer, mat) => {
                            const edgeMaterial = mat;
                            edgeMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(fillTechnique.lineColor, mapView.zoomLevel));
                        }
                        : undefined);
                    this.registerTileObject(tile, outlineObj, technique.kind);
                    objects.push(outlineObj);
                }
                // Add the fill area edges as a separate geometry.
                if (hasSolidLinesOutlines) {
                    const outlineTechnique = technique;
                    const outlineMaterial = material.clone();
                    const outlineColor = ColorCache_1.ColorCache.instance.getColor(outlineTechnique.secondaryColor !== undefined
                        ? harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryColor, displayZoomLevel)
                        : "0x000000");
                    outlineMaterial.uniforms.diffuse.value = outlineColor;
                    const outlineObj = new ObjectCtor(bufferGeometry, outlineMaterial);
                    outlineObj.renderOrder =
                        outlineTechnique.secondaryRenderOrder !== undefined
                            ? outlineTechnique.secondaryRenderOrder
                            : technique.renderOrder - 0.0000001;
                    if (group.renderOrderOffset !== undefined) {
                        outlineObj.renderOrder += group.renderOrderOffset;
                    }
                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, fadingParams.fadeNear, fadingParams.fadeFar, true, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        const unitFactor = outlineTechnique.metricUnit === "Pixel"
                            ? mapView.pixelToWorld
                            : 1.0;
                        if (outlineTechnique.secondaryColor !== undefined) {
                            lineMaterial.color.set(harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryColor, mapView.zoomLevel));
                        }
                        if (outlineTechnique.secondaryWidth !== undefined) {
                            lineMaterial.lineWidth =
                                harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryWidth, mapView.zoomLevel, mapView.pixelToWorld) *
                                    unitFactor *
                                    0.5;
                        }
                    });
                    this.registerTileObject(tile, outlineObj, technique.kind);
                    objects.push(outlineObj);
                }
            }
        }
    }
    /**
     * Prepare the [[Tile]]s pois. Uses the [[PoiManager]] in [[MapView]].
     */
    preparePois(tile, decodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            tile.mapView.poiManager.addPois(tile, decodedTile);
        }
    }
    /**
     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param technique Label's technique.
     * @param techniqueIdx Label's technique index.
     */
    getRenderStyle(tile, technique) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const zoomLevel = mapView.zoomLevel;
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSource.name, technique, Math.floor(zoomLevel));
        let renderStyle = mapView.textRenderStyleCache.get(cacheId);
        if (renderStyle === undefined) {
            const defaultRenderParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.defaultStyle.renderParams
                : {
                    fontSize: {
                        unit: harp_text_canvas_1.FontUnit.Pixel,
                        size: 32,
                        backgroundSize: 8
                    }
                };
            if (technique.color !== undefined) {
                const hexColor = harp_datasource_protocol_1.getPropertyValue(technique.color, Math.floor(zoomLevel));
                TileGeometryCreator.m_colorMap.set(cacheId, ColorCache_1.ColorCache.instance.getColor(hexColor));
            }
            if (technique.backgroundColor !== undefined) {
                const hexBgColor = harp_datasource_protocol_1.getPropertyValue(technique.backgroundColor, Math.floor(zoomLevel));
                TileGeometryCreator.m_colorMap.set(cacheId + "_bg", ColorCache_1.ColorCache.instance.getColor(hexBgColor));
            }
            const renderParams = {
                fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: technique.size !== undefined
                        ? harp_datasource_protocol_1.getPropertyValue(technique.size, Math.floor(zoomLevel))
                        : defaultRenderParams.fontSize.size,
                    backgroundSize: technique.backgroundSize !== undefined
                        ? harp_datasource_protocol_1.getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel))
                        : defaultRenderParams.fontSize.backgroundSize
                },
                fontStyle: technique.fontStyle === "Regular" ||
                    technique.fontStyle === "Bold" ||
                    technique.fontStyle === "Italic" ||
                    technique.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                    : defaultRenderParams.fontStyle,
                fontVariant: technique.fontVariant === "Regular" ||
                    technique.fontVariant === "AllCaps" ||
                    technique.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                    : defaultRenderParams.fontVariant,
                rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
                color: harp_utils_1.getOptionValue(TileGeometryCreator.m_colorMap.get(cacheId), defaultRenderParams.color),
                backgroundColor: harp_utils_1.getOptionValue(TileGeometryCreator.m_colorMap.get(cacheId + "_bg"), defaultRenderParams.backgroundColor),
                opacity: technique.opacity !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.opacity, Math.floor(zoomLevel))
                    : defaultRenderParams.opacity,
                backgroundOpacity: technique.backgroundOpacity !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.backgroundOpacity, Math.floor(zoomLevel))
                    : technique.backgroundColor !== undefined &&
                        (technique.backgroundSize !== undefined &&
                            harp_datasource_protocol_1.getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel)) > 0)
                        ? 1.0 // make label opaque when backgroundColor and backgroundSize are set
                        : defaultRenderParams.backgroundOpacity
            };
            const themeRenderParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .renderParams
                : {};
            renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, themeRenderParams, renderParams));
            mapView.textRenderStyleCache.set(cacheId, renderStyle);
        }
        return renderStyle;
    }
    /**
     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param tile The [[Tile]] to process.
     * @param technique Label's technique.
     */
    getLayoutStyle(tile, technique) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const zoomLevel = mapView.zoomLevel;
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSource.name, technique, Math.floor(zoomLevel));
        let layoutStyle = mapView.textLayoutStyleCache.get(cacheId);
        if (layoutStyle === undefined) {
            const defaultLayoutParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.defaultStyle.layoutParams
                : {};
            const layoutParams = {
                tracking: harp_utils_1.getOptionValue(technique.tracking, defaultLayoutParams.tracking),
                leading: harp_utils_1.getOptionValue(technique.leading, defaultLayoutParams.leading),
                maxLines: harp_utils_1.getOptionValue(technique.maxLines, defaultLayoutParams.maxLines),
                lineWidth: harp_utils_1.getOptionValue(technique.lineWidth, defaultLayoutParams.lineWidth),
                canvasRotation: harp_utils_1.getOptionValue(technique.canvasRotation, defaultLayoutParams.canvasRotation),
                lineRotation: harp_utils_1.getOptionValue(technique.lineRotation, defaultLayoutParams.lineRotation),
                wrappingMode: technique.wrappingMode === "None" ||
                    technique.wrappingMode === "Character" ||
                    technique.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[technique.wrappingMode]
                    : defaultLayoutParams.wrappingMode,
                horizontalAlignment: technique.hAlignment === "Left" ||
                    technique.hAlignment === "Center" ||
                    technique.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[technique.hAlignment]
                    : defaultLayoutParams.horizontalAlignment,
                verticalAlignment: technique.vAlignment === "Above" ||
                    technique.vAlignment === "Center" ||
                    technique.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[technique.vAlignment]
                    : defaultLayoutParams.verticalAlignment
            };
            const themeLayoutParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .layoutParams
                : {};
            layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, themeLayoutParams, layoutParams));
            mapView.textLayoutStyleCache.set(cacheId, layoutStyle);
        }
        return layoutStyle;
    }
    /**
     * Creates and add a background plane for the tile.
     */
    addGroundPlane(tile) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const projection = tile.projection;
        const color = mapView.clearColor;
        const tmpV = new THREE.Vector3();
        if (tile.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const { east, west, north, south } = tile.geoBox;
            const sourceProjection = dataSource.getTilingScheme().projection;
            const g = new THREE.BufferGeometry();
            const posAttr = new THREE.BufferAttribute(new Float32Array([
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), tmpV)
                    .toArray()
            ]), 3);
            g.addAttribute("position", posAttr);
            g.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
            const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.Math.degToRad(10), sourceProjection);
            modifier.modify(g);
            for (let i = 0; i < posAttr.array.length; i += 3) {
                tmpV.set(posAttr.array[i], posAttr.array[i + 1], posAttr.array[i + 2]);
                projection.reprojectPoint(sourceProjection, tmpV, tmpV);
                tmpV.sub(tile.center);
                posAttr.array[i] = tmpV.x;
                posAttr.array[i + 1] = tmpV.y;
                posAttr.array[i + 2] = tmpV.z;
            }
            posAttr.needsUpdate = true;
            const material = new harp_materials_1.MapMeshBasicMaterial({
                color,
                visible: true,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(g, material);
            mesh.renderOrder = Number.MIN_SAFE_INTEGER;
            this.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background);
            tile.objects.push(mesh);
        }
        else {
            // Add a ground plane to the tile.
            tile.boundingBox.getSize(tmpV);
            const groundPlane = this.createPlane(tmpV.x, tmpV.y, tile.center, color, true);
            this.registerTileObject(tile, groundPlane, harp_datasource_protocol_1.GeometryKind.Background);
            tile.objects.push(groundPlane);
        }
    }
    setupTerrainMaterial(technique, material, terrainColor) {
        if (technique.displacementMap === undefined) {
            // Render terrain using the given color.
            const stdMaterial = material;
            stdMaterial.color.set(terrainColor);
            return;
        }
        // Render terrain using height-based colors.
        material.onBeforeCompile = (shader) => {
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
            // We remove the displacement map from manipulating the vertices, it is
            // however still required for the pixel shader, so it can't be directly
            // removed.
            shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
        };
        material.displacementMap.needsUpdate = true;
    }
    /**
     * Create a simple flat plane for a [[Tile]].
     *
     * @param {number} width Width of plane.
     * @param {number} height Height of plane.
     * @param {THREE.Vector3} planeCenter Center of plane.
     * @param {number} colorHex Color of the plane mesh.
     * @param {boolean} isVisible `True` to make the mesh visible.
     * @returns {THREE.Mesh} The created plane.
     */
    createPlane(width, height, planeCenter, colorHex, isVisible) {
        const geometry = new THREE.PlaneGeometry(width, height, 1);
        // TODO cache the material HARP-4207
        const material = new harp_materials_1.MapMeshBasicMaterial({
            color: colorHex,
            visible: isVisible,
            depthWrite: false
        });
        const plane = new THREE.Mesh(geometry, material);
        plane.position.copy(planeCenter);
        // Render before everything else
        plane.renderOrder = Number.MIN_SAFE_INTEGER;
        return plane;
    }
    /**
     * Pass the feature data on to the object, so it can be used in picking
     * `MapView.intersectMapObjects()`. Do not pass the feature data if the technique is a
     * dashed-line or a solid-line, because the line picking functionality for the lines is not
     * object based, but tile based.
     *
     * @param srcGeometry The original [[Geometry]].
     * @param technique The corresponding [[Technique]].
     * @param object The object to pass info to.
     */
    addFeatureData(srcGeometry, technique, object) {
        if (((srcGeometry.featureIds !== undefined && srcGeometry.featureIds.length > 0) ||
            harp_datasource_protocol_1.isCirclesTechnique(technique) ||
            harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
            !harp_datasource_protocol_1.isSolidLineTechnique(technique) &&
            !harp_datasource_protocol_1.isDashedLineTechnique(technique)) {
            const featureData = {
                geometryType: srcGeometry.type,
                ids: srcGeometry.featureIds,
                starts: srcGeometry.featureStarts
            };
            object.userData.feature = featureData;
            if (srcGeometry.objInfos !== undefined) {
                object.userData.feature.objInfos = srcGeometry.objInfos;
            }
        }
    }
    addGeometryObjInfos(tile, srcGeometry, technique, object) {
        if (srcGeometry.objInfos === undefined || Object.keys(object.userData).length > 0) {
            return;
        }
        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
            const displacementMap = srcGeometry.objInfos[0];
            const tileDisplacementMap = {
                tileKey: tile.tileKey,
                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),
                displacementMap
            };
            object.userData = tileDisplacementMap;
        }
        else {
            object.userData = srcGeometry.objInfos;
        }
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getFadingParams(displayZoomLevel, technique) {
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        return {
            fadeNear,
            fadeFar
        };
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getPolygonFadingParams(displayZoomLevel, technique) {
        let color;
        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
        if (technique.lineColor !== undefined) {
            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, displayZoomLevel);
            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                const extrudedPolygonTechnique = technique;
                colorMix =
                    extrudedPolygonTechnique.lineColorMix !== undefined
                        ? extrudedPolygonTechnique.lineColorMix
                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
            }
        }
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        const lineFadeNear = technique.lineFadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, displayZoomLevel)
            : fadeNear;
        const lineFadeFar = technique.lineFadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, displayZoomLevel)
            : fadeFar;
        if (color === undefined) {
            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;
        }
        return {
            color,
            colorMix,
            fadeNear,
            fadeFar,
            lineFadeNear,
            lineFadeFar
        };
    }
}
/**
 * Cache for named colors.
 */
TileGeometryCreator.m_colorMap = new Map();
exports.TileGeometryCreator = TileGeometryCreator;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryLoader.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryLoader.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "../harp-mapview/lib/Statistics.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
var TileGeometryLoader;
(function (TileGeometryLoader) {
    /**
     * Make sure that all technique have their geometryKind set, either from the theme or their
     * default value.
     *
     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.
     *
     * @param {DecodedTile} decodedTile
     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.
     */
    function prepareDecodedTile(decodedTile) {
        const foundSet = new harp_datasource_protocol_1.GeometryKindSet();
        for (const technique of decodedTile.techniques) {
            let geometryKind = technique.kind;
            // Set default kind based on technique.
            if (geometryKind === undefined) {
                geometryKind = setDefaultGeometryKind(technique);
            }
            if (Array.isArray(geometryKind)) {
                geometryKind = new harp_datasource_protocol_1.GeometryKindSet(geometryKind);
            }
            if (geometryKind instanceof Set) {
                for (const kind of geometryKind) {
                    foundSet.add(kind);
                }
            }
            else {
                foundSet.add(geometryKind);
            }
        }
        return foundSet;
    }
    TileGeometryLoader.prepareDecodedTile = prepareDecodedTile;
    /**
     * Make sure that the technique has its geometryKind set, either from the theme or their default
     * value.
     *
     * @param {Technique} technique
     */
    function setDefaultGeometryKind(technique) {
        let geometryKind = technique.kind;
        // Set default kind based on technique.
        if (geometryKind === undefined) {
            if (harp_datasource_protocol_1.isFillTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Area;
            }
            else if (harp_datasource_protocol_1.isLineTechnique(technique) ||
                harp_datasource_protocol_1.isDashedLineTechnique(technique) ||
                harp_datasource_protocol_1.isSolidLineTechnique(technique) ||
                harp_datasource_protocol_1.isSegmentsTechnique(technique) ||
                harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Line;
            }
            else if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Building;
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique) ||
                harp_datasource_protocol_1.isLineMarkerTechnique(technique) ||
                harp_datasource_protocol_1.isTextTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Label;
            }
            else {
                geometryKind = harp_datasource_protocol_1.GeometryKind.All;
            }
            technique.kind = geometryKind;
        }
        return geometryKind;
    }
    TileGeometryLoader.setDefaultGeometryKind = setDefaultGeometryKind;
})(TileGeometryLoader = exports.TileGeometryLoader || (exports.TileGeometryLoader = {}));
/**
 * Simplest implementation of a [[TileGeometryLoader]]. It loads all geometry in a single step.
 */
class SimpleTileGeometryLoader {
    constructor(m_tile) {
        this.m_tile = m_tile;
        this.m_isFinished = false;
    }
    get tile() {
        return this.m_tile;
    }
    get isFinished() {
        return this.m_isFinished;
    }
    get basicGeometryLoaded() {
        return this.m_tile.hasGeometry;
    }
    get allGeometryLoaded() {
        return this.m_isFinished;
    }
    /**
     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and
     * prepares its content for later processing in the 'updateXXX' methods.
     *
     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to
     *      this tile.
     * @returns {DecodedTile} The processed decoded tile.
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        if (this.m_decodedTile !== undefined) {
            this.m_availableGeometryKinds = TileGeometryLoader.prepareDecodedTile(this.m_decodedTile);
        }
        return this.m_decodedTile;
    }
    get availableGeometryKinds() {
        return this.m_availableGeometryKinds;
    }
    update(enabledKinds, disabledKinds) {
        const tile = this.tile;
        // First time this tile is handled:
        if (this.m_decodedTile === undefined && tile.decodedTile !== undefined) {
            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile.decodedTile, enabledKinds, disabledKinds);
            this.setDecodedTile(tile.decodedTile);
            this.prepareForRender(enabledKinds, disabledKinds);
            this.finish();
        }
    }
    dispose() {
        this.m_decodedTile = undefined;
    }
    reset() {
        this.m_decodedTile = undefined;
        this.m_isFinished = false;
        if (this.m_availableGeometryKinds !== undefined) {
            this.m_availableGeometryKinds.clear();
        }
        if (this.m_timeout !== undefined) {
            clearTimeout(this.m_timeout);
        }
    }
    finish() {
        this.m_tile.loadingFinished();
        this.m_tile.removeDecodedTile();
        this.m_isFinished = true;
        this.m_timeout = undefined;
    }
    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare geometry.
     */
    prepareForRender(enabledKinds, disabledKinds) {
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        this.m_decodedTile = undefined;
        if (decodedTile === undefined || tile.disposed || !tile.isVisible) {
            return;
        }
        this.m_timeout = setTimeout(() => {
            const stats = Statistics_1.PerformanceStatistics.instance;
            // If the tile has become invisible while being loaded, for example by moving the
            // camera, the tile is not finished and its geometry is not created. This is an
            // optimization for fast camera movements and zooms.
            if (!tile.isVisible) {
                // Dispose the tile from the visible set, so it can be reloaded properly next time
                // it is needed.
                tile.mapView.visibleTileSet.disposeTile(tile);
                if (stats.enabled) {
                    stats.currentFrame.addMessage(
                    // tslint:disable-next-line: max-line-length
                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`);
                }
                return;
            }
            let now = 0;
            if (stats.enabled) {
                now = harp_utils_1.PerformanceTimer.now();
            }
            const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
            geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
            geometryCreator.createAllGeometries(tile, decodedTile);
            if (stats.enabled) {
                const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;
                const currentFrame = stats.currentFrame;
                currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined
                    ? decodedTile.textPathGeometries.length
                    : 0);
                currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);
            }
            this.finish();
            tile.dataSource.requestUpdate();
        }, 0);
    }
}
exports.SimpleTileGeometryLoader = SimpleTileGeometryLoader;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryManager.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryManager.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
/**
 * Base class for all [[TileGeometryManager]]s. Handles visibility as well as enabling/disabling of
 * kinds of geometry [[GeometryKind]].
 */
class TileGeometryManagerBase {
    /**
     * Creates an instance of `TileGeometryManagerBase` with a reference to the [[MapView]].
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.enableFilterByKind = true;
        this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.hiddenKinds = new harp_datasource_protocol_1.GeometryKindSet();
        /**
         * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the
         * visibility of the kinds is applied to their geometries.
         */
        this.m_visibilityCounter = 1;
    }
    get enabledGeometryKinds() {
        return this.enabledKinds;
    }
    set enabledGeometryKinds(kinds) {
        this.enabledKinds = kinds;
    }
    get disabledGeometryKinds() {
        return this.disabledKinds;
    }
    set disabledGeometryKinds(kinds) {
        this.disabledKinds = kinds;
    }
    get hiddenGeometryKinds() {
        return this.hiddenKinds;
    }
    set hiddenGeometryKinds(kinds) {
        this.hiddenKinds = kinds;
        this.incrementVisibilityCounter();
    }
    get visibilityCounter() {
        return this.m_visibilityCounter;
    }
    clear() {
        this.enabledKinds.clear();
        this.disabledKinds.clear();
        this.hiddenKinds.clear();
    }
    enableKind(kind, addOrRemoveToEnabledSet = true) {
        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);
    }
    disableKind(kind, addOrRemoveToDisabledSet = true) {
        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);
    }
    hideKind(kind, addOrRemoveToHiddenSet = true) {
        let visibilityHasChanged = false;
        if (Array.isArray(kind)) {
            for (const oneKind of kind) {
                visibilityHasChanged =
                    visibilityHasChanged ||
                        this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
            }
        }
        else if (kind instanceof Set) {
            const kindSet = kind;
            for (const oneKind of kindSet) {
                visibilityHasChanged =
                    visibilityHasChanged ||
                        this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
            }
        }
        else if (kind !== undefined) {
            visibilityHasChanged =
                visibilityHasChanged ||
                    this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);
        }
        // Will be evaluated in the next update()
        if (visibilityHasChanged) {
            this.incrementVisibilityCounter();
        }
    }
    getAvailableKinds(tiles) {
        const visibleKinds = new harp_datasource_protocol_1.GeometryKindSet();
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                const tileKinds = geometryLoader.availableGeometryKinds;
                if (tileKinds !== undefined) {
                    for (const kind of tileKinds) {
                        visibleKinds.add(kind);
                    }
                }
            }
        }
        return visibleKinds;
    }
    /**
     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified
     * tiles.
     *
     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.
     */
    updateTileObjectVisibility(tiles) {
        let needUpdate = false;
        for (const tile of tiles) {
            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {
                continue;
            }
            tile.visibilityCounter = this.visibilityCounter;
            for (const object of tile.objects) {
                const geometryKind = object.userData !== undefined ? object.userData.kind : undefined;
                if (geometryKind !== undefined) {
                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));
                    needUpdate = needUpdate || object.visible !== nowVisible;
                    object.visible = nowVisible;
                }
            }
        }
        return needUpdate;
    }
    setTileUpdateCallback(callback) {
        this.m_tileUpdateCallback = callback;
    }
    incrementVisibilityCounter() {
        return ++this.m_visibilityCounter;
    }
    /**
     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    enableDisableKinds(set, kind, addToSet) {
        if (Array.isArray(kind)) {
            for (const oneKind of kind) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind instanceof Set) {
            const kindSet = kind;
            for (const oneKind of kindSet) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind !== undefined) {
            this.addRemove(set, kind, addToSet);
        }
    }
    /**
     * Add or remove a single kind from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    addRemove(kindsSet, kind, addToSet) {
        if (addToSet) {
            if (!kindsSet.has(kind)) {
                kindsSet.add(kind);
                return true;
            }
        }
        else {
            if (kindsSet.has(kind)) {
                kindsSet.delete(kind);
                return true;
            }
        }
        return false;
    }
}
exports.TileGeometryManagerBase = TileGeometryManagerBase;
/**
 * Implements the simplest for of [[TileGeometryManager]]. Uses a [[SimpleTileGeometryLoader]] to
 * load the geometries of the [[Tile]].
 */
class SimpleTileGeometryManager extends TileGeometryManagerBase {
    /**
     * Creates an instance of `SimpleTileGeometryManager` with a reference to the [[MapView]].
     */
    constructor(mapView) {
        super(mapView);
    }
    initTile(tile) {
        if (tile.dataSource.useGeometryLoader) {
            tile.tileGeometryLoader = new TileGeometryLoader_1.SimpleTileGeometryLoader(tile);
        }
    }
    updateTiles(tiles) {
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                geometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined);
                if (this.m_tileUpdateCallback) {
                    this.m_tileUpdateCallback(tile);
                }
            }
        }
        // If the visibility status of the kinds changed since the last update, the new visibility
        // status is applied (again).
        if (this.updateTileObjectVisibility(tiles)) {
            this.mapView.update();
        }
    }
}
exports.SimpleTileGeometryManager = SimpleTileGeometryManager;


/***/ }),

/***/ "../harp-mapview/lib/geometry/overlayOnElevation.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/overlayOnElevation.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
function overlayObject(object, displacementMap) {
    if (!object.userData || !object.userData.kind) {
        return;
    }
    if (!object.userData.kind.find((kind) => {
        return kind !== harp_datasource_protocol_1.GeometryKind.All && kind !== harp_datasource_protocol_1.GeometryKind.Terrain;
    })) {
        return;
    }
    if (object instanceof THREE.Mesh && "displacementMap" in object.material) {
        object.material.displacementMap = displacementMap;
    }
}
/**
 * Overlays the geometry in the given tile on top of elevation data if available.
 *
 * @param tile The tile whose geometry will be overlaid.
 */
function overlayOnElevation(tile) {
    const elevationProvider = tile.mapView.elevationProvider;
    if (elevationProvider === undefined || tile.objects.length === 0) {
        return;
    }
    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);
    if (displacementMap === undefined) {
        return;
    }
    for (const object of tile.objects) {
        overlayObject(object, displacementMap.texture);
    }
}
exports.overlayOnElevation = overlayOnElevation;


/***/ }),

/***/ "../harp-mapview/lib/image/Image.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/image/Image.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ImageItem;
(function (ImageItem) {
    /**
     * Missing Typedoc
     */
    function isLoading(imageItem) {
        return imageItem.loadingPromise !== undefined;
    }
    ImageItem.isLoading = isLoading;
})(ImageItem = exports.ImageItem || (exports.ImageItem = {}));


/***/ }),

/***/ "../harp-mapview/lib/image/ImageCache.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/image/ImageCache.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("ImageCache");
/**
 * Combines an [[ImageItem]] with a list of [[MapViews]] that reference it.
 */
class ImageCacheItem {
    /**
     * Instantiates `ImageCacheItem`.
     *
     * @param imageItem The [[ImageItem]] referenced by the associated [[MapView]]s instances.
     * @param mapView An optional first [[MapView]] referencing the [[ImageItem]].
     */
    constructor(imageItem, mapView) {
        this.imageItem = imageItem;
        /**
         * The list of [[MapView]]s referencing the [[ImageItem]].
         */
        this.mapViews = [];
        if (mapView !== undefined) {
            this.mapViews.push(mapView);
        }
    }
}
/**
 * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This
 * allows to have an image loaded only once for multiple views. THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding satistics for memory footprint as well.
 */
class ImageCache {
    constructor() {
        this.m_images = new Map();
    }
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance() {
        if (ImageCache.m_instance === undefined) {
            ImageCache.m_instance = new ImageCache();
        }
        return ImageCache.m_instance;
    }
    /**
     * Dispose the singleton object. Not normally implemented for singletons, but good for
     * debugging.
     */
    static dispose() {
        ImageCache.m_instance = undefined;
    }
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param mapView Specifiy which [[MapView]] requests the image.
     * @param url URL of image.
     * @param imageData Optional [ImageData]] containing the image content.
     */
    registerImage(mapView, url, imageData) {
        let imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        const mapViews = [];
        if (mapView !== undefined) {
            mapViews.push(mapView);
        }
        imageCacheItem = {
            imageItem: {
                url,
                imageData,
                loaded: false
            },
            mapViews
        };
        this.m_images.set(url, imageCacheItem);
        return imageCacheItem.imageItem;
    }
    /**
     * Add an image definition, and optionally start loading the content.
     *
     * @param mapView [[MapView]] requesting the image.
     * @param url URL of image.
     * @param startLoading Optional flag. If `true` the image will be loaded in the background.
     */
    addImage(mapView, url, startLoading = true) {
        const imageItem = this.registerImage(mapView, url, undefined);
        if (imageItem !== undefined && startLoading === true) {
            return this.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find [[ImageItem]] for the specified URL.
     *
     * @param url URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url) {
        const imageItem = this.m_images.get(url);
        if (imageItem !== undefined) {
            return imageItem.imageItem;
        }
        return undefined;
    }
    /**
     * Clear all [[ImageItem]]s belonging to a [[MapView]]. May remove cached items if no
     * [[MapView]] are registered anymore.
     *
     * @param mapView MapView to remove all [[ImageItem]]s from.
     */
    clear(mapView) {
        const itemsToRemove = [];
        this.m_images.forEach(imageItem => {
            const mapViewIndex = imageItem.mapViews.indexOf(mapView);
            if (mapViewIndex >= 0) {
                imageItem.mapViews.splice(mapViewIndex, 1);
            }
            if (imageItem.mapViews.length === 0) {
                itemsToRemove.push(imageItem.imageItem.url);
            }
        });
        for (const keyToDelete of itemsToRemove) {
            this.m_images.delete(keyToDelete);
        }
    }
    /**
     * Clear all [[ImageItem]]s from all [[MapView]]s.
     */
    clearAll() {
        this.m_images = new Map();
    }
    /**
     * Returns the number of all cached [[ImageItem]]s.
     */
    get size() {
        return this.m_images.size;
    }
    /**
     * Load an [[ImageItem]]. If the loading process is already running, it returns the current
     * promise.
     *
     * @param imageItem `ImageItem` containing the URL to load image from.
     * @returns An [[ImageItem]] if the image has already been loaded, a promise otherwise.
     */
    loadImage(imageItem) {
        if (imageItem.imageData !== undefined) {
            return imageItem;
        }
        if (imageItem.loadingPromise !== undefined) {
            return imageItem.loadingPromise;
        }
        const imageLoader = new THREE.ImageLoader();
        imageItem.loadingPromise = new Promise(resolve => {
            logger.log(`Loading image: ${imageItem.url}`);
            imageLoader.load(imageItem.url, image => {
                logger.log(`... finished loading image: ${imageItem.url}`);
                this.renderImage(imageItem, image)
                    .then(() => {
                    imageItem.loadingPromise = undefined;
                    resolve(imageItem);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }, 
            // Loading events no longer supported
            undefined, errorEvent => {
                logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);
                imageItem.loadingPromise = undefined;
                resolve(undefined);
            });
        });
        return imageItem.loadingPromise;
    }
    /**
     * Find the cached [[ImageItem]] by URL.
     *
     * @param url URL of image.
     */
    findImageCacheItem(url) {
        return this.m_images.get(url);
    }
    /**
     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a
     * [[HTMLCanvasElement]].
     *
     * @param imageItem [[ImageItem]] to assign image data to.
     * @param image [[HTMLImageElement]] to
     */
    renderImage(imageItem, image) {
        return new Promise((resolve, reject) => {
            // use createImageBitmap if it is available. It should be available in webworkers as
            // well
            if (typeof createImageBitmap === "function") {
                const options = {
                    premultiplyAlpha: "default",
                    imageOrientation: "flipY"
                };
                logger.log(`Creating bitmap image: ${imageItem.url}`);
                createImageBitmap(image, 0, 0, image.width, image.height, options)
                    .then(imageBitmap => {
                    logger.log(`... finished creating bitmap image: ${imageItem.url}`);
                    imageItem.loadingPromise = undefined;
                    imageItem.imageData = imageBitmap;
                    imageItem.loaded = true;
                    resolve(imageBitmap);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }
            else {
                try {
                    if (typeof document === "undefined") {
                        logger.error("Error: document is not available, cannot generate image");
                        reject(new Error("ImageCache#renderImage: document is not available, cannot " +
                            "render image to create texture"));
                    }
                    // TODO: Extract the rendering to the canvas part and make it configurable for
                    // the client, so it does not rely on the `document`.
                    // use the image, e.g. draw part of it on a canvas
                    const canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const context = canvas.getContext("2d");
                    if (context !== null) {
                        logger.log(
                        // tslint:disable-next-line: max-line-length
                        `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`);
                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, image.width, image.height);
                        imageItem.imageData = imageData;
                        imageItem.loaded = true;
                        resolve(imageData);
                    }
                    else {
                        logger.error(`renderImage: no context found`);
                        reject(new Error(`ImageCache#renderImage: no context found`));
                    }
                }
                catch (ex) {
                    logger.error(`renderImage failed: ${ex}`);
                    imageItem.imageData = undefined;
                    imageItem.loaded = true;
                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));
                }
            }
        });
    }
}
exports.ImageCache = ImageCache;


/***/ }),

/***/ "../harp-mapview/lib/image/MapViewImageCache.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/image/MapViewImageCache.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ImageCache_1 = __webpack_require__(/*! ./ImageCache */ "../harp-mapview/lib/image/ImageCache.ts");
/**
 * Cache images wrapped into [[ImageItem]]s for a [[MapView]]. An image may have multiple names in
 * a theme, the `MapViewImageCache` will take care of that. Registering multiple images with the
 * same name is invalid.
 *
 * The `MapViewImageCache` uses a global [[ImageCache]] to actually store (and generate) the
 * image data.
 */
class MapViewImageCache {
    /**
     * The constructor for `MapViewImageCache`.
     *
     * @param mapView a [[MapView]] instance.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Register an existing image by name.
     *
     * @param name Name of the image from [[Theme]].
     * @param url URL of image.
     * @param image Optional [[ImageData]] of image.
     */
    registerImage(name, url, image) {
        if (name !== undefined) {
            if (this.hasName(name)) {
                throw new Error("duplicate name in cache");
            }
            const oldNames = this.m_url2Name.get(url);
            if (oldNames !== undefined) {
                if (oldNames.indexOf(name) < 0) {
                    oldNames.push(name);
                }
            }
            else {
                this.m_url2Name.set(url, [name]);
            }
            this.m_name2Url.set(name, url);
        }
        const imageItem = ImageCache_1.ImageCache.instance.findImage(url);
        if (imageItem === undefined) {
            return ImageCache_1.ImageCache.instance.registerImage(this.mapView, url, image);
        }
        return imageItem;
    }
    /**
     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]
     * will be stored in the [[ImageItem]].
     *
     * @param name Name of image from [[Theme]].
     * @param url URL of image.
     * @param startLoading Optional. Pass `true` to start loading the image in the background.
     */
    addImage(name, url, startLoading = true) {
        const imageItem = this.registerImage(name, url, undefined);
        if (startLoading === true) {
            return ImageCache_1.ImageCache.instance.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find [[ImageItem]] by its name.
     *
     * @param name Name of image.
     */
    findImageByName(name) {
        const url = this.m_name2Url.get(name);
        if (url === undefined) {
            return undefined;
        }
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Find [[ImageItem]] by URL.
     *
     * @param url Url of image.
     */
    findImageByUrl(url) {
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Load an [[ImageItem]]. Returns a promise or a loaded [[ImageItem]].
     *
     * @param imageItem ImageItem to load.
     */
    loadImage(imageItem) {
        return ImageCache_1.ImageCache.instance.loadImage(imageItem);
    }
    /**
     * Remove all [[ImageItem]]s from the cache. Also removes all [[ImageItem]]s that belong to this
     * [[MapView]] from the global [[ImageCache]].
     */
    clear() {
        ImageCache_1.ImageCache.instance.clear(this.mapView);
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Returns number of image names stored in the cache.
     */
    get numberOfNames() {
        return this.m_name2Url.size;
    }
    /**
     * Returns number of image URLs in the cache.
     */
    get numberOfUrls() {
        return this.m_url2Name.size;
    }
    /**
     * Return `true` if an image with the given name is known.
     *
     * @param name Name of the image.
     */
    hasName(name) {
        return this.m_name2Url.get(name) !== undefined;
    }
    /**
     * Return `true` if an image with the given URL is known.
     * @param url URL of image.
     */
    hasUrl(url) {
        return this.m_url2Name.get(url) !== undefined;
    }
    /**
     * Return the names under which an image with the given URL is saved.
     */
    findNames(url) {
        return this.m_url2Name.get(url);
    }
}
exports.MapViewImageCache = MapViewImageCache;


/***/ }),

/***/ "../harp-mapview/lib/poi/BoxBuffer.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/poi/BoxBuffer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ "../harp-mapview/lib/poi/PixelPicker.ts");
/**
 * Initial number of boxes in BoxBuffer.
 */
const START_BOX_BUFFER_SIZE = 0;
/**
 * Maximum number of boxes in BoxBuffer.
 */
const MAX_BOX_BUFFER_SIZE = 32 * 1024;
/**
 * Number of vertices per box/glyph element: 4 corners.
 */
const NUM_VERTICES_PER_ELEMENT = 4;
/**
 * Number of indices added per box/glyph: 2 triangles, 6 indices.
 */
const NUM_INDICES_PER_ELEMENT = 6;
/**
 * Number of values per position.
 */
const NUM_POSITION_VALUES_PER_VERTEX = 3;
/**
 * Number of values per color.
 */
const NUM_COLOR_VALUES_PER_VERTEX = 4;
/**
 * Number of values per UV.
 */
const NUM_UV_VALUES_PER_VERTEX = 4;
/**
 * Number of values per index.
 */
const NUM_INDEX_VALUES_PER_VERTEX = 1;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and
 * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.
 */
class BoxBufferMesh extends THREE.Mesh {
    constructor(geometry, material) {
        super(geometry, material);
        this.type = "BoxBufferMesh";
    }
    /**
     * A mesh that has no positions and indices set is defined to be empty.
     *
     * @returns `True` if no indices have been added to the mesh.
     */
    get isEmpty() {
        return this.geometry !== undefined
            ? this.geometry.index.count === 0
            : true;
    }
}
exports.BoxBufferMesh = BoxBufferMesh;
/**
 * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-
 * aligned boxes, like POIs.
 */
class BoxBuffer {
    /**
     * Creates a new `BoxBuffer`.
     *
     * @param material Material to be used for [[Mesh]] of this `BoxBuffer`.
     * @param renderOrder Optional renderOrder of this buffer.
     * @param startElementCount Initial number of elements this `BoxBuffer` can hold.
     * @param maxElementCount Maximum number of elements this `BoxBuffer` can hold.
     */
    constructor(material, renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, maxElementCount = MAX_BOX_BUFFER_SIZE) {
        this.material = material;
        this.renderOrder = renderOrder;
        this.startElementCount = startElementCount;
        this.maxElementCount = maxElementCount;
        this.m_size = 0;
        this.resizeBuffer(startElementCount);
        this.pickInfos = new Array();
    }
    /**
     * Duplicate this `BoxBuffer` with same material and renderOrder.
     *
     * @returns A clone of this `BoxBuffer`.
     */
    clone() {
        return new BoxBuffer(this.material, this.renderOrder);
    }
    /**
     * Dispose of the geometry.
     */
    dispose() {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
            this.geometry = undefined;
        }
        this.internalMesh = undefined;
    }
    /**
     * Return the current number of elements the buffer can hold.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Clear's the `BoxBuffer` attribute buffers.
     */
    reset() {
        if (this.positionAttribute !== undefined) {
            this.positionAttribute.count = 0;
            this.colorAttribute.count = 0;
            this.uvAttribute.count = 0;
            this.indexAttribute.count = 0;
            this.pickInfos.length = 0;
        }
    }
    /**
     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer
     * can only add the glyph by increasing the buffer size, the resize() method is called, which
     * will then create a new geometry for the mesh.
     *
     * @param glyphCount Number of glyphs to be added to the buffer.
     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.
     */
    canAddElements(glyphCount = 1) {
        const indexAttribute = this.indexAttribute;
        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=
            indexAttribute.array.length) {
            // Too many elements for the current buffer, check if we can resize the buffer.
            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {
                return false;
            }
            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);
            this.resize(newSize);
        }
        return true;
    }
    /**
     * Returns this `BoxBuffer`'s attribute [[State]].
     */
    saveState() {
        const state = {
            positionAttributeCount: this.positionAttribute.count,
            colorAttributeCount: this.colorAttribute.count,
            uvAttributeCount: this.uvAttribute.count,
            indexAttributeCount: this.indexAttribute.count,
            pickInfoCount: this.pickInfos.length
        };
        return state;
    }
    /**
     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.
     *
     * @param state [[State]] struct describing a previous attribute state.
     */
    restoreState(state) {
        this.positionAttribute.count = state.positionAttributeCount;
        this.colorAttribute.count = state.colorAttributeCount;
        this.uvAttribute.count = state.uvAttributeCount;
        this.indexAttribute.count = state.indexAttributeCount;
        this.pickInfos.length = state.pickInfoCount;
    }
    /**
     * Adds a new box to this `BoxBuffer`.
     *
     * @param screenBox [[Math2D.Box]] holding screen coordinates for this box.
     * @param uvBox [[Math2D.UvBox]] holding uv coordinates for this box.
     * @param color Box's color.
     * @param opacity Box's opacity.
     * @param distance Box's distance to camera.
     * @param pickInfo Box's picking information.
     */
    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
        if (!this.canAddElements()) {
            return false;
        }
        const { s0, t0, s1, t1 } = uvBox;
        const { x, y, w, h } = screenBox;
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        const a = Math.round(opacity * 255);
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        const baseVertex = positionAttribute.count;
        const baseIndex = indexAttribute.count;
        positionAttribute.setXYZ(baseVertex, x, y, distance);
        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
        colorAttribute.setXYZW(baseVertex, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
        uvAttribute.setXY(baseVertex, s0, t0);
        uvAttribute.setXY(baseVertex + 1, s1, t0);
        uvAttribute.setXY(baseVertex + 2, s0, t1);
        uvAttribute.setXY(baseVertex + 3, s1, t1);
        indexAttribute.setX(baseIndex, baseVertex);
        indexAttribute.setX(baseIndex + 1, baseVertex + 1);
        indexAttribute.setX(baseIndex + 2, baseVertex + 2);
        indexAttribute.setX(baseIndex + 3, baseVertex + 2);
        indexAttribute.setX(baseIndex + 4, baseVertex + 1);
        indexAttribute.setX(baseIndex + 5, baseVertex + 3);
        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
        indexAttribute.count += NUM_INDICES_PER_ELEMENT;
        this.pickInfos.push(pickInfo);
        return true;
    }
    /**
     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute
     * data.
     */
    updateBufferGeometry() {
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        if (positionAttribute.count > 0) {
            positionAttribute.needsUpdate = true;
            positionAttribute.updateRange.offset = 0;
            positionAttribute.updateRange.count =
                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (colorAttribute.count > 0) {
            colorAttribute.needsUpdate = true;
            colorAttribute.updateRange.offset = 0;
            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (uvAttribute.count > 0) {
            uvAttribute.needsUpdate = true;
            uvAttribute.updateRange.offset = 0;
            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (indexAttribute.count > 0) {
            indexAttribute.needsUpdate = true;
            indexAttribute.updateRange.offset = 0;
            indexAttribute.updateRange.count = indexAttribute.count;
        }
        if (this.geometry !== undefined) {
            this.geometry.clearGroups();
            this.geometry.addGroup(0, this.indexAttribute.count);
        }
    }
    /**
     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce
     * footprint.
     */
    cleanUp() {
        // If there is nothing in this buffer, resize it, it may never be used again.
        if (this.indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
            this.clearAttributes();
        }
    }
    /**
     * Determine if the mesh is empty.
     */
    get isEmpty() {
        return this.internalMesh.isEmpty;
    }
    /**
     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are
     * resized. The mesh, once created, will not change, so it can always be added to the scene.
     */
    get mesh() {
        if (this.internalMesh === undefined) {
            this.resize();
        }
        return this.internalMesh;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * boxes are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     * @param imageData Image data to test if the pixel is transparent
     */
    pickBoxes(screenPosition, pickCallback, imageData) {
        const n = this.pickInfos.length;
        const pickInfos = this.pickInfos;
        const positions = this.positionAttribute;
        const screenX = screenPosition.x;
        const screenY = screenPosition.y;
        const canvas = document.createElement("canvas");
        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {
            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
            const minX = positions.getX(positionIndex);
            if (screenX < minX) {
                continue;
            }
            const maxX = positions.getX(positionIndex + 1);
            if (screenX > maxX) {
                continue;
            }
            const minY = positions.getY(positionIndex);
            if (screenY < minY) {
                continue;
            }
            const maxY = positions.getY(positionIndex + 2);
            if (screenY > maxY) {
                continue;
            }
            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);
            if (imageData !== undefined &&
                pickInfos[pickInfoIndex].poiInfo !== undefined &&
                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&
                this.isPixelTransparent(imageData, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, canvas)) {
                continue;
            }
            if (pickInfos[pickInfoIndex] !== undefined) {
                pickCallback(pickInfos[pickInfoIndex]);
            }
        }
    }
    /**
     * Creates a new [[Geometry]] object from all the attribute data stored in this `BoxBuffer`.
     * The [[Mesh]] object may be created if it is not initialized already.
     *
     * @param newSize Optional number of elements to resize the buffer to.
     * @param forceResize Optional flag to force a resize even if new size is smaller than before.
     */
    resize(newSize, forceResize) {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
        }
        this.geometry = new THREE.BufferGeometry();
        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {
            this.resizeBuffer(newSize);
        }
        this.geometry.addAttribute("position", this.positionAttribute);
        this.geometry.addAttribute("color", this.colorAttribute);
        this.geometry.addAttribute("uv", this.uvAttribute);
        this.geometry.setIndex(this.indexAttribute);
        this.geometry.addGroup(0, this.indexAttribute.count);
        if (this.internalMesh === undefined) {
            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);
            this.internalMesh.renderOrder = this.renderOrder;
        }
        else {
            this.internalMesh.geometry = this.geometry;
        }
        return this.internalMesh;
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.
     *
     * @param info The info object to increment with the values from this `BoxBuffer`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +
            this.uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    /**
     * Check if a pixel is transparent or not.
     *
     * @param imageData Data containing the pixels.
     * @param xScreenPos X position of the pixel.
     * @param yScreenPos Y position of the pixel.
     * @param box Bounding box of the image in screen coordinates.
     * @param uvBox Uv box referred to the given bounding box.
     * @param canvas Canvas element that will be used to draw the image, in case the imageData is an
     *      ImageBitmap
     */
    isPixelTransparent(imageData, xScreenPos, yScreenPos, box, uvBox, canvas) {
        let pixelIsTransparent = false;
        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);
        const imageWidth = imageData.width;
        const x = imageWidth * u;
        const imageHeight = imageData.height;
        const y = imageHeight * v;
        const pixel = PixelPicker_1.getPixelFromImage(x, y, imageData, canvas);
        if (pixel !== undefined && pixel[3] === 0) {
            pixelIsTransparent = true;
        }
        return pixelIsTransparent;
    }
    /**
     * Remove current attributes and arrays. Minimizes memory footprint.
     */
    clearAttributes() {
        this.positionAttribute = undefined;
        this.colorAttribute = undefined;
        this.uvAttribute = undefined;
        this.indexAttribute = undefined;
        this.resize(START_BOX_BUFFER_SIZE, true);
    }
    /**
     * Resize the attribute buffers. New value must be larger than the previous one.
     *
     * @param newSize New number of elements in the buffer. Number has to be larger than the
     *      previous size.
     */
    resizeBuffer(newSize) {
        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {
            const positionAttributeCount = this.positionAttribute.count;
            newPositionArray.set(this.positionAttribute.array);
            this.positionAttribute.setArray(newPositionArray);
            this.positionAttribute.count = positionAttributeCount;
        }
        else {
            this.positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
            this.positionAttribute.count = 0;
            this.positionAttribute.setDynamic(true);
        }
        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
        if (this.colorAttribute !== undefined) {
            const colorAttributeCount = this.colorAttribute.count;
            newColorArray.set(this.colorAttribute.array);
            this.colorAttribute.setArray(newColorArray);
            this.colorAttribute.count = colorAttributeCount;
        }
        else {
            this.colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
            this.colorAttribute.count = 0;
            this.colorAttribute.setDynamic(true);
        }
        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
        if (this.uvAttribute !== undefined) {
            const uvAttributeCount = this.uvAttribute.count;
            newUvArray.set(this.uvAttribute.array);
            this.uvAttribute.setArray(newUvArray);
            this.uvAttribute.count = uvAttributeCount;
        }
        else {
            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
            this.uvAttribute.count = 0;
            this.uvAttribute.setDynamic(true);
        }
        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
        const newIndexArray = numIndexValues > 65535
            ? new Uint32Array(numIndexValues)
            : new Uint16Array(numIndexValues);
        if (this.indexAttribute !== undefined) {
            const indexAttributeCount = this.indexAttribute.count;
            newIndexArray.set(this.indexAttribute.array);
            this.indexAttribute.setArray(newIndexArray);
            this.indexAttribute.count = indexAttributeCount;
        }
        else {
            this.indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
            this.indexAttribute.count = 0;
            this.indexAttribute.setDynamic(true);
        }
        this.m_size = newSize;
    }
}
exports.BoxBuffer = BoxBuffer;


/***/ }),

/***/ "../harp-mapview/lib/poi/PixelPicker.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/poi/PixelPicker.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * It returns an array containing the channel colors for the pixel at the given coordinates.
 *
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param imageData Data containing the pixels.
 * @param canvas Canvas element that will be used to draw the image, in case the imageData is an
 * ImageBitmap
 */
function getPixelFromImage(xPos, yPos, imageData, canvas) {
    let pickedColor;
    const isImageBitmap = (imgData) => {
        return imgData.close !== undefined;
    };
    if (isImageBitmap(imageData)) {
        if (canvas === undefined) {
            canvas = document.createElement("canvas");
        }
        pickedColor = getPixelFromImageBitmap(imageData, xPos, yPos, canvas);
    }
    else {
        const pixelsData = imageData;
        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);
        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);
    }
    return pickedColor;
}
exports.getPixelFromImage = getPixelFromImage;
/**
 * Given the x and y position in screen coordinates inside the target box, it map them to the UV
 * coordinates.
 * @param screenX X value in screen coordinates.
 * @param screenY Y value in screen coordinates.
 * @param box Bounding box in screen coordinates.
 * @param uvBox Uv box referred to the given bounding box.
 */
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
    const minX = box.x;
    const maxX = box.x + box.w;
    const minY = box.y;
    const maxY = box.y + box.h;
    const u = harp_utils_1.MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);
    const v = harp_utils_1.MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);
    return { u, v };
}
exports.screenToUvCoordinates = screenToUvCoordinates;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image Bitmap image in which the pixels are stored.
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param canvas HTML Canvas element on which the image is drawn.
 */
function getPixelFromImageBitmap(image, xPos, yPos, canvas) {
    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {
        return undefined;
    }
    let pixelData;
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext("2d");
    if (context !== null) {
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        pixelData = context.getImageData(xPos, yPos, 1, 1).data;
    }
    return pixelData;
}
exports.getPixelFromImageBitmap = getPixelFromImageBitmap;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image Image data in which the pixels are stored.
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param stride The stride value of the image data.
 */
function getPixelFromImageData(imgData, xPos, yPos, stride) {
    const getPixel = (imageData, index, strd) => {
        const i = index * strd;
        const d = imageData.data;
        const pixel = new Uint8ClampedArray(strd);
        for (let s = 0; s < strd; s++) {
            pixel[0] = d[i + s];
        }
        return pixel;
    };
    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
        return undefined;
    }
    return getPixel(imgData, yPos * imgData.width + xPos, stride);
}
exports.getPixelFromImageData = getPixelFromImageData;


/***/ }),

/***/ "../harp-mapview/lib/poi/Poi.ts":
/*!**************************************!*\
  !*** ../harp-mapview/lib/poi/Poi.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This enum defines the possible origin points for an image.
 */
var ImageOrigin;
(function (ImageOrigin) {
    ImageOrigin[ImageOrigin["TopLeft"] = 0] = "TopLeft";
    ImageOrigin[ImageOrigin["BottomLeft"] = 1] = "BottomLeft";
})(ImageOrigin = exports.ImageOrigin || (exports.ImageOrigin = {}));
/**
 * Defines a part (or all) of an image as a texture.
 */
class IconTexture {
    /**
     * The constructor of an `IconTexture`.
     *
     * @param image An [[ImageItem]] instance.
     * @param options The rendering parameters.
     */
    constructor(image) {
        this.image = image;
    }
}
exports.IconTexture = IconTexture;
// export enum TextAlign {
//     Center,
//     Left,
//     Right,
//     // ??? expands lines to have same length.
//     Justify
// }
// export interface LayoutOptions {
//     paddingH?: number;
//     paddingV: number;
//     transFormCenterX?: number;
//     transFormCenterY?: number;
//     rotation?: number;
//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */
//     rotationEnlargesBox: boolean;
// }
// export interface TextOptions {
//     bgColor?: THREE.Color;
//     wrapWords?: boolean;
//     maxNumLines?: number;
//     maxWidth?: number;
//     /** Replace with ellipsis if wider than maxWidth. */
//     addEllipsis?: boolean;
//     /** Handle right-to-left texts */
//     isRightToLeft?: boolean;
//     textAlignH?: AlignH; // = AlignH.Center;
//     textAlignV?: AlignV; // = AlignV.Center;
// }
// export class IconLabel {
//     constructor(text: string, options: LayoutOptions | TextOptions) {}
//     /**
//      * Setup a box with size and padding.
//      *
//      * @param box Target box to set up.
//      */
//     getBox(box: THREE.Box2) {}
//     /**
//      * Compute width and height from text and font.
//      */
//     computeBox() {}
//     /**
//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.
//      */
//     prepareRendering() {}
// }
// export enum AlignH {
//     Center,
//     Left,
//     Right
// }
// export enum AlignV {
//     Center,
//     Top,
//     Bottom
// }
// export enum AnchorTarget {
//     /** Anchor point relative to Icon */
//     Icon,
//     /** Anchor point is transform center of icon */
//     IconCenter,
//     /** Anchor point relative to Icon including padding */
//     IconBox,
//     /** Anchor point relative to Label */
//     Label,
//     /** Anchor point relative to combination of Icon and Label */
//     Box
// }
// export class AnchorPosition {
//     targetH: AnchorTarget = AnchorTarget.Icon;
//     targetV: AnchorTarget = AnchorTarget.Icon;
//     alignH: AlignH = AlignH.Center;
//     alignV: AlignV = AlignV.Center;
// }
// export enum IconPinMode {
//     /** Pinned down, anchor point is the same at all angles. */
//     PinDown,
//     /**
//      * Icon stands up. "StreetLevel"-style. The anchor point moves to the bottom of the icon when
//      * the view direction gets parallel to the ground.
//      */
//     StandUp
// }
// export interface IconScaleOptions {
//     depthScale?: boolean;
//     minimumScale?: number;
// }
// export interface IconOptions {
//     useScreenSpace?: boolean; // = true
//     priority?: number;
//     scaleOptions?: IconScaleOptions;
//     /** Optional offset in screen space */
//     screenOffsetX?: number;
//     screenOffsetY?: number;
//     /** Optional 3D height above terrain. */
//     heightAboveGround?: number;
// }
// export class SimplePoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image ?: IconTexture,
//         options ?: IconOptions
//     ) { }
// }
// export class PoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image?: IconTexture,
//         readonly label?: IconLabel,
//         options?: IconOptions
//     ) {}
// }
// export interface PoiOptions {
//     featureId?: number;
//     minZoomLevel?: number;
// }
// export class SimplePoi {
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
// }
// export class Poi {
//     /** store multiple icons, one for every LOD */
//     private m_icons: PoiIcon[] = [];
//     private m_lod = 0;
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(icon: PoiIcon, options?: PoiOptions) {
//         this.m_icons.push(icon);
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
//     icon(): PoiIcon | undefined {
//         return this.m_icons[this.m_lod];
//     }
//     /**
//      * Select the level of detail that should be used.
//      *
//      * @param levelOfDetail Level of detail to render.
//      */
//     selectIcon(levelOfDetail: number) {}
// }


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiManager.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiManager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const TextStyleCache_1 = __webpack_require__(/*! ../text/TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiManager");
/**
 * POI manager class, responsible for loading the [[PoiGeometry]] objects from the [[DecodedTile]],
 * and preparing them for rendering. Also loads and manages the texture atlases for the icons.
 */
class PoiManager {
    /**
     * The constructor of the `PoiManager`.
     *
     * @param mapView The [[MapView]] instance that should display the POIs.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_imageTextures = new Map();
        this.m_poiShieldGroups = new Map();
        this.m_colorMap = new Map();
    }
    /**
     * Warn about a missing POI table name, but only once.
     * @param poiTableName POI mapping table name.
     * @param poiTable POI table instance.
     */
    static notifyMissingPoiTable(poiTableName, poiTable) {
        if (poiTableName === undefined) {
            poiTableName = "undefined";
        }
        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {
            PoiManager.m_missingPoiTableName.set(poiTableName, true);
            if (poiTable !== undefined && !poiTable.loadedOk) {
                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);
            }
            else {
                logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);
            }
        }
    }
    /**
     * Warn about a missing POI name, but only once.
     * @param poiName name of POI.
     * @param poiTableName POI mapping table name.
     */
    static notifyMissingPoi(poiName, poiTableName) {
        if (poiName === undefined) {
            poiName = "undefined";
        }
        const key = `${poiTableName}[${poiName}]`;
        if (PoiManager.m_missingPoiName.get(key) === undefined) {
            PoiManager.m_missingPoiName.set(key, true);
            logger.warn(`updatePoiFromPoiTable: ` +
                `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);
        }
    }
    /**
     * Add all POIs from a decoded tile and store them as [[TextElement]]s in the [[Tile]].
     *
     * Also handles LineMarkers, which is a recurring marker along a line (road).
     *
     * @param tile Tile to add POIs to.
     * @param decodedTile DecodedTile containing the raw [[PoiGeometry]] objects describing the
     *  POIs.
     */
    addPois(tile, decodedTile) {
        const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);
        for (const poiGeometry of poiGeometries) {
            harp_utils_1.assert(poiGeometry.technique !== undefined);
            const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);
            const technique = decodedTile.techniques[techniqueIndex];
            if (technique.enabled === false ||
                (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique))) {
                continue;
            }
            // The POI may be in the data, and there may be a Technique, but the technique may
            // specify to not show it.
            if (technique.showOnMap === false) {
                continue;
            }
            const positions = new THREE.BufferAttribute(new Float32Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
            if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {
                this.addLineMarker(tile, poiGeometry, technique, positions);
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique)) {
                this.addPoi(tile, poiGeometry, technique, techniqueIndex, positions);
            }
        }
    }
    /**
     * Load the texture atlas that defines the segments of the texture that should be used for
     * specific icons. Creates an [[ImageTexture]] for every element in the atlas, such that it can
     * be addressed in the theme file.
     *
     * @param imageName Name of the image from the theme (NOT the url!).
     * @param atlas URL of the JSON file defining the texture atlas.
     */
    addTextureAtlas(imageName, atlas) {
        fetch(atlas)
            .then(response => {
            if (!response.ok) {
                throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);
            }
            return response.json();
        })
            .then((jsonAtlas) => {
            if (jsonAtlas === undefined) {
                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);
                return;
            }
            try {
                logger.log(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);
                for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {
                    const imageTextureDef = jsonAtlas[textureName];
                    const imageTexture = {
                        name: textureName,
                        image: imageName,
                        xOffset: imageTextureDef.x,
                        yOffset: imageTextureDef.y,
                        width: imageTextureDef.width,
                        height: imageTextureDef.height
                    };
                    this.addImageTexture(imageTexture);
                }
            }
            catch (ex) {
                logger.error(`addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`);
            }
            this.mapView.update();
        })
            .catch((reason) => {
            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);
        });
    }
    /**
     * Add an [[ImageTexture]] such that it is available as a named entity for techniques in theme
     * files.
     *
     * @param imageTexture [[ImageTexture]] that should be available for POIs.
     */
    addImageTexture(imageTexture) {
        if (imageTexture.name === undefined) {
            logger.error("addImageTexture: Name required", imageTexture);
            return;
        }
        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {
            logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);
        }
        this.m_imageTextures.set(imageTexture.name, imageTexture);
    }
    /**
     * Return the [[ImageTexture]] registered under the specified name.
     *
     * @param name Name of the [[ImageTexture]].
     */
    getImageTexture(name) {
        return this.m_imageTextures.get(name);
    }
    /**
     * Update the [[TextElement]] with the information taken from the [[PoiTable]] which is
     * referenced in the [[PoiInfo]] of the pointLabel.
     *
     * If the requested [[PoiTable]] is not available yet, the function returns `false`.
     * If the [[PoiTable]] is not defined, or if the references POI has no entry in
     * the [[PoiTable]], no action is taken, and the function returns `false`.
     *
     * If the [[PoiTable]] has been processed, it returns `true`, indicating that this function
     * doesn't have to be called again.
     *
     * @param pointLabel The [[TextElement]] to update.
     *
     * @returns `true` if the [[PoiTable]] has been processed, and the function does not have to be
     *          called again.
     */
    updatePoiFromPoiTable(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is
        // not possible, such as table key is not defined.
        if (poiInfo === undefined ||
            poiInfo.poiTableName === undefined ||
            poiInfo.poiName === undefined) {
            return true;
        }
        // Try to acquire PoiTable
        const poiTableName = poiInfo.poiTableName;
        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
        // Check if PoiTable is found, but its still loading.
        if (poiTable !== undefined && poiTable.isLoading) {
            // The PoiTable is still loading, we have to try again.
            return false;
        }
        // PoiTable not found or can not be loaded.
        if (poiTable === undefined || !poiTable.loadedOk) {
            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
            return true;
        }
        // Try to acquire PoiTableEntry.
        const poiName = poiInfo.poiName;
        const poiTableEntry = poiTable.getEntry(poiName);
        if (poiTableEntry === undefined) {
            PoiManager.notifyMissingPoi(poiName, poiTableName);
            return true;
        }
        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {
            poiInfo.imageTextureName = harp_datasource_protocol_1.composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);
        }
        pointLabel.visible =
            poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;
        pointLabel.priority =
            poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;
        poiInfo.iconMinZoomLevel =
            poiTableEntry.iconMinLevel !== undefined
                ? poiTableEntry.iconMinLevel
                : poiInfo.iconMinZoomLevel;
        poiInfo.iconMaxZoomLevel =
            poiTableEntry.iconMaxLevel !== undefined
                ? poiTableEntry.iconMaxLevel
                : poiInfo.iconMaxZoomLevel;
        poiInfo.textMinZoomLevel =
            poiTableEntry.textMinLevel !== undefined
                ? poiTableEntry.textMinLevel
                : poiInfo.textMinZoomLevel;
        poiInfo.textMaxZoomLevel =
            poiTableEntry.textMaxLevel !== undefined
                ? poiTableEntry.textMaxLevel
                : poiInfo.textMaxZoomLevel;
        pointLabel.updateMinMaxZoomLevelsFromPoiInfo();
        return true;
    }
    /**
     * Clear internal state. Applicable when switching themes.
     */
    clear() {
        this.m_imageTextures.clear();
        this.m_poiShieldGroups.clear();
    }
    /**
     * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers
     * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken
     * care of later that not too many of them are rendered (obey `minDistance` attribute).
     */
    addLineMarker(tile, poiGeometry, technique, positions) {
        let imageTextureName = technique.imageTexture !== undefined
            ? harp_datasource_protocol_1.composeTechniqueTextureName(technique.imageTexture, technique)
            : undefined;
        let text = "";
        let userData;
        if (poiGeometry.stringCatalog !== undefined) {
            harp_utils_1.assert(poiGeometry.texts.length > 0);
            text = poiGeometry.stringCatalog[poiGeometry.texts[0]] || "";
            userData = poiGeometry.objInfos ? poiGeometry.objInfos[0] : undefined;
            if (poiGeometry.imageTextures !== undefined) {
                harp_utils_1.assert(poiGeometry.imageTextures.length > 0);
                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];
            }
        }
        // let the combined image texture name (name of image in atlas, not the URL) and
        // text of the shield be the group key, at worst scenario it may be:
        // "undefined-"
        const groupKey = String(imageTextureName) + "-" + text;
        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
        if (shieldGroupIndex === undefined) {
            shieldGroupIndex = this.m_poiShieldGroups.size;
            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
        }
        // Debugging help to identify the group of a shield :
        // text = groupKey + ": " + text;
        const positionArray = [];
        for (let i = 0; i < positions.count; i += 3) {
            const x = positions.getX(i);
            const y = positions.getY(i);
            const z = positions.getZ(i);
            positionArray.push(new THREE.Vector3(x, y, z));
        }
        const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, undefined, // TBD for road shields
        undefined, shieldGroupIndex, poiGeometry.featureId, positionArray, undefined, undefined, userData);
        // If the poi icon is rendered, the label that shows text should also be rendered.
        // The distance rule of the icon should apply, not the one for text (only) labels.
        textElement.ignoreDistance = false;
        tile.addTextElement(textElement);
    }
    /**
     * Create and add POI [[TextElement]]s to tile with a series of positions.
     */
    addPoi(tile, poiGeometry, technique, techniqueIdx, positions) {
        if (poiGeometry.stringCatalog === undefined) {
            return;
        }
        const techniqueTextureName = technique.imageTexture !== undefined
            ? harp_datasource_protocol_1.composeTechniqueTextureName(technique.imageTexture, technique)
            : undefined;
        const poiTechnique = technique;
        const poiTableName = poiTechnique.poiTable;
        let poiName = poiTechnique.poiName;
        for (let i = 0; i < positions.count; ++i) {
            const x = positions.getX(i);
            const y = positions.getY(i);
            const z = positions.getZ(i);
            harp_utils_1.assert(poiGeometry.texts.length > i);
            let imageTextureName = techniqueTextureName;
            const text = poiGeometry.stringCatalog[poiGeometry.texts[i]] || "";
            const userData = poiGeometry.objInfos ? poiGeometry.objInfos[i] : undefined;
            if (poiGeometry.imageTextures !== undefined && poiGeometry.imageTextures[i] >= 0) {
                harp_utils_1.assert(poiGeometry.imageTextures.length > i);
                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];
            }
            if (poiTableName !== undefined) {
                // The POI name to be used is taken from the data, since it will
                // specify the name of the texture to use.
                // The POI name in the technique may override the POI name from the
                // data.
                poiName =
                    poiTechnique.poiName === undefined ? imageTextureName : poiTechnique.poiName;
                imageTextureName = undefined;
            }
            const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, 0, poiGeometry.featureId, x, y, z, userData);
            tile.addTextElement(textElement);
        }
    }
    /**
     * Create the [[TextElement]] for a POI. Even if the POI has no text, it is required that there
     * is a [[TextElement]], since POIs are hooked onto [[TextElement]]s for sorting.(Sorted by
     * priority attribute).
     */
    checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, shieldGroupIndex, featureId, x, y, z, userData) {
        const priority = technique.priority !== undefined ? technique.priority : 0;
        const positions = Array.isArray(x) ? x : new THREE.Vector3(x, y, z);
        const displayZoomLevel = this.mapView.zoomLevel;
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)
            : technique.fadeNear;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)
            : technique.fadeFar;
        const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), positions, this.getRenderStyle(tile.dataSource.name, technique), this.getLayoutStyle(tile.dataSource.name, technique), harp_datasource_protocol_1.getPropertyValue(priority, displayZoomLevel), technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar);
        textElement.mayOverlap = technique.textMayOverlap === true;
        textElement.reserveSpace = technique.textReserveSpace !== false;
        textElement.alwaysOnTop = technique.alwaysOnTop === true;
        textElement.userData = userData;
        // imageTextureName may be undefined if a poiTable is used.
        if (imageTextureName === undefined && poiTableName !== undefined) {
            imageTextureName = "";
        }
        else if (imageTextureName !== undefined && poiTableName !== undefined) {
            logger.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
        }
        if (imageTextureName !== undefined) {
            const textIsOptional = technique.textIsOptional === true;
            const iconIsOptional = technique.iconIsOptional !== false;
            const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
            const iconMayOverlap = technique.iconMayOverlap === undefined
                ? textElement.textMayOverlap
                : technique.iconMayOverlap === true;
            const iconReserveSpace = technique.iconReserveSpace === undefined
                ? textElement.textReservesSpace
                : technique.iconReserveSpace !== false;
            textElement.poiInfo = {
                technique,
                imageTextureName,
                poiTableName,
                poiName,
                shieldGroupIndex,
                textElement,
                textIsOptional,
                iconIsOptional,
                renderTextDuringMovements,
                mayOverlap: iconMayOverlap,
                reserveSpace: iconReserveSpace,
                featureId,
                iconMinZoomLevel: technique.iconMinZoomLevel,
                iconMaxZoomLevel: technique.iconMaxZoomLevel,
                textMinZoomLevel: technique.textMinZoomLevel,
                textMaxZoomLevel: technique.textMaxZoomLevel
            };
            textElement.updateMinMaxZoomLevelsFromPoiInfo();
        }
        else {
            // Select the smaller/larger one of the two min/max values, because the TextElement
            // is a container for both.
            if (textElement.minZoomLevel === undefined) {
                textElement.minZoomLevel = technique.textMinZoomLevel;
            }
            if (textElement.maxZoomLevel === undefined) {
                textElement.maxZoomLevel = technique.textMaxZoomLevel;
            }
        }
        textElement.distanceScale =
            technique.distanceScale !== undefined
                ? technique.distanceScale
                : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
        return textElement;
    }
    getRenderStyle(dataSourceName, technique) {
        const mapView = this.mapView;
        const zoomLevel = mapView.zoomLevel;
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSourceName, technique, Math.floor(zoomLevel));
        let renderStyle = mapView.textRenderStyleCache.get(cacheId);
        if (renderStyle === undefined) {
            const defaultRenderParams = mapView.textElementsRenderer.defaultStyle.renderParams;
            if (technique.color !== undefined) {
                const hexColor = harp_datasource_protocol_1.getPropertyValue(technique.color, Math.floor(zoomLevel));
                this.m_colorMap.set(cacheId, ColorCache_1.ColorCache.instance.getColor(hexColor));
            }
            if (technique.backgroundColor !== undefined) {
                const hexBgColor = harp_datasource_protocol_1.getPropertyValue(technique.backgroundColor, Math.floor(zoomLevel));
                this.m_colorMap.set(cacheId + "_bg", ColorCache_1.ColorCache.instance.getColor(hexBgColor));
            }
            const renderParams = {
                fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: technique.size !== undefined
                        ? harp_datasource_protocol_1.getPropertyValue(technique.size, Math.floor(zoomLevel))
                        : defaultRenderParams.fontSize.size,
                    backgroundSize: technique.backgroundSize !== undefined
                        ? harp_datasource_protocol_1.getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel))
                        : defaultRenderParams.fontSize.backgroundSize
                },
                fontStyle: technique.fontStyle === "Regular" ||
                    technique.fontStyle === "Bold" ||
                    technique.fontStyle === "Italic" ||
                    technique.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                    : defaultRenderParams.fontStyle,
                fontVariant: technique.fontVariant === "Regular" ||
                    technique.fontVariant === "AllCaps" ||
                    technique.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                    : defaultRenderParams.fontVariant,
                rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
                color: harp_utils_1.getOptionValue(this.m_colorMap.get(cacheId), defaultRenderParams.color),
                backgroundColor: harp_utils_1.getOptionValue(this.m_colorMap.get(cacheId + "_bg"), defaultRenderParams.backgroundColor),
                opacity: technique.opacity !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.opacity, Math.floor(zoomLevel))
                    : defaultRenderParams.opacity,
                backgroundOpacity: technique.backgroundOpacity !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.backgroundOpacity, Math.floor(zoomLevel))
                    : technique.backgroundColor !== undefined &&
                        (technique.backgroundSize !== undefined &&
                            harp_datasource_protocol_1.getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel)) > 0)
                        ? 1.0 // make label opaque when backgroundColor and backgroundSize are set
                        : defaultRenderParams.backgroundOpacity
            };
            const themeRenderParams = mapView.textElementsRenderer !== undefined
                ? mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .renderParams
                : {};
            renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, themeRenderParams, renderParams));
            mapView.textRenderStyleCache.set(cacheId, renderStyle);
        }
        return renderStyle;
    }
    getLayoutStyle(dataSourceName, technique) {
        const cacheId = TextStyleCache_1.computeStyleCacheId(dataSourceName, technique, Math.floor(this.mapView.zoomLevel));
        let layoutStyle = this.mapView.textLayoutStyleCache.get(cacheId);
        if (layoutStyle === undefined) {
            const defaultLayoutParams = this.mapView.textElementsRenderer.defaultStyle
                .layoutParams;
            const layoutParams = {
                tracking: harp_utils_1.getOptionValue(technique.tracking, defaultLayoutParams.tracking),
                leading: harp_utils_1.getOptionValue(technique.leading, defaultLayoutParams.leading),
                maxLines: harp_utils_1.getOptionValue(technique.maxLines, defaultLayoutParams.maxLines),
                lineWidth: harp_utils_1.getOptionValue(technique.lineWidth, defaultLayoutParams.lineWidth),
                canvasRotation: harp_utils_1.getOptionValue(technique.canvasRotation, defaultLayoutParams.canvasRotation),
                lineRotation: harp_utils_1.getOptionValue(technique.lineRotation, defaultLayoutParams.lineRotation),
                wrappingMode: technique.wrappingMode === "None" ||
                    technique.wrappingMode === "Character" ||
                    technique.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[technique.wrappingMode]
                    : defaultLayoutParams.wrappingMode,
                horizontalAlignment: technique.hAlignment === "Left" ||
                    technique.hAlignment === "Center" ||
                    technique.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[technique.hAlignment]
                    : defaultLayoutParams.horizontalAlignment,
                verticalAlignment: technique.vAlignment === "Above" ||
                    technique.vAlignment === "Center" ||
                    technique.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[technique.vAlignment]
                    : defaultLayoutParams.verticalAlignment
            };
            const themeLayoutParams = this.mapView.textElementsRenderer !== undefined
                ? this.mapView.textElementsRenderer.getTextElementStyle(technique.style)
                    .layoutParams
                : {};
            layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, themeLayoutParams, layoutParams));
            this.mapView.textLayoutStyleCache.set(cacheId, layoutStyle);
        }
        return layoutStyle;
    }
}
// Keep track of the missing POI table names, but only warn once.
PoiManager.m_missingPoiTableName = new Map();
PoiManager.m_missingPoiName = new Map();
exports.PoiManager = PoiManager;


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiRenderer.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiRenderer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ "../harp-mapview/lib/poi/BoxBuffer.ts");
const Poi_1 = __webpack_require__(/*! ./Poi */ "../harp-mapview/lib/poi/Poi.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiRenderer");
const INVALID_RENDER_BATCH = -1;
const tempPos = new THREE.Vector3(0);
/**
 * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the
 * same icon image ([[ImageTexture]]). If the image is the same, all the objects in this batch can
 * share the same material, which makes them renderable in the same draw call, whatever the number
 * of actual objects (WebGL limits apply!).
 *
 * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon
 * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.
 */
class PoiRenderBufferBatch {
    /**
     * Create the `PoiRenderBufferBatch`.
     *
     * @param mapView The [[MapView]] instance.
     * @param scene The three.js scene to add the POIs to.
     * @param imageItem The icon that will have his material shared.
     * @param renderOrder RenderOrder of the batch geometry's [[Mesh]].
     */
    constructor(mapView, scene, imageItem, renderOrder) {
        this.mapView = mapView;
        this.scene = scene;
        this.imageItem = imageItem;
        this.renderOrder = renderOrder;
        this.color = ColorCache_1.ColorCache.instance.getColor("#000000");
    }
    /**
     * Initialize with the [[ImageTexture]]. Loads the image and sets up the icon size, the texture
     * coordinates and material of the batch. Since image loading is done asynchronously, this
     * batch cannot be rendered right away. MapView#update is being triggered if it loaded
     * successfully.
     */
    init() {
        if (this.boxBuffer === undefined) {
            this.setup();
        }
    }
    /**
     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.
     */
    reset() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.reset();
    }
    /**
     * Update the geometry with all the added boxes during the frame.
     */
    update() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.updateBufferGeometry();
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the
     * `PoiRenderBufferBatch`.
     *
     * @param info The info object to increment with the values from this `PoiRenderBufferBatch`.
     */
    updateMemoryUsage(info) {
        if (this.boxBuffer !== undefined) {
            this.boxBuffer.updateMemoryUsage(info);
        }
    }
    /**
     * Setup texture and material for the batch.
     */
    setup() {
        const bilinear = true;
        // Texture images should be generated with premultiplied alpha
        const premultipliedAlpha = true;
        const iconTexture = new Poi_1.IconTexture(this.imageItem);
        const texture = new THREE.Texture(iconTexture.image.imageData, THREE.UVMapping, undefined, undefined, bilinear ? THREE.LinearFilter : THREE.NearestFilter, bilinear ? THREE.LinearFilter : THREE.NearestFilter, THREE.RGBAFormat);
        texture.needsUpdate = true;
        texture.premultiplyAlpha = premultipliedAlpha;
        texture.generateMipmaps = false; // not needed, always rendered in full size
        this.m_material = new harp_materials_1.IconMaterial({
            map: texture
        });
        this.boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, this.renderOrder);
        const mesh = this.boxBuffer.mesh;
        mesh.frustumCulled = false;
        this.scene.add(mesh);
        this.mapView.update();
    }
}
/**
 * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.
 */
class PoiRenderBuffer {
    /**
     * Create the `PoiRenderBuffer`.
     *
     * @param mapView The [[MapView]] to be rendered to.
     * @param textCanvas The [[TextCanvas]] to which scenes this `PoiRenderBuffer` adds geometry to.
     * The actual scene a [[TextElement]] is added to is specified by the renderOrder of the
     * [[TextElement]].
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        this.batches = [];
        this.m_batchMap = new Map();
    }
    /**
     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.
     *
     * @param poiInfo Describes the POI icon.
     */
    registerPoi(poiInfo) {
        const { imageItem, imageTexture, imageTextureName } = poiInfo;
        if (imageItem === undefined ||
            imageTextureName === undefined ||
            imageTexture === undefined) {
            // No image -> invisible -> ignore
            return INVALID_RENDER_BATCH;
        }
        const renderOrder = poiInfo.renderOrder;
        // There is a batch for every ImageDefinition, which could be a texture atlas with many
        // ImageTextures in it.
        const batchKey = imageTexture.image;
        let batchSet = this.m_batchMap.get(batchKey);
        let mappedIndex;
        let bufferBatch;
        if (batchSet === undefined) {
            batchSet = new Map();
            this.m_batchMap.set(batchKey, batchSet);
        }
        mappedIndex = batchSet.get(renderOrder);
        if (mappedIndex !== undefined) {
            return mappedIndex;
        }
        mappedIndex = this.batches.length;
        let layer = this.textCanvas.getLayer(renderOrder);
        if (layer === undefined) {
            this.textCanvas.addText("", tempPos, { layer: renderOrder });
            layer = this.textCanvas.getLayer(renderOrder);
        }
        bufferBatch = new PoiRenderBufferBatch(this.mapView, layer.storage.scene, imageItem, renderOrder);
        bufferBatch.init();
        batchSet.set(renderOrder, mappedIndex);
        this.batches.push(bufferBatch);
        return mappedIndex;
    }
    /**
     * Render a POI image at the specified location.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenBox Box to render icon into in 2D coordinates.
     * @param opacity Opacity of icon to allow fade in/out.
     */
    addPoi(poiInfo, screenBox, opacity) {
        const batchIndex = this.registerPoi(poiInfo);
        harp_utils_1.assert(batchIndex >= 0);
        if (batchIndex < 0) {
            return INVALID_RENDER_BATCH;
        }
        harp_utils_1.assert(poiInfo.uvBox !== undefined);
        if (this.batches[batchIndex].boxBuffer === undefined) {
            this.batches[batchIndex].init();
        }
        this.batches[batchIndex].boxBuffer.addBox(screenBox, poiInfo.uvBox, this.batches[batchIndex].color, opacity, poiInfo.textElement.renderDistance, poiInfo.textElement);
        return batchIndex;
    }
    /**
     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid
     * if the imageTexture could not be found
     *
     * @param index Index into batch array.
     */
    getBatch(index) {
        if (index >= 0) {
            harp_utils_1.assert(index < this.batches.length);
            return this.batches[index];
        }
        // may be invalid if the imageTexture could not be found
        return undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        for (const batch of this.batches) {
            batch.reset();
        }
    }
    /**
     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.
     */
    update() {
        for (const batch of this.batches) {
            batch.update();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[PoiInfo]]s are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        for (const batch of this.batches) {
            if (batch.boxBuffer === undefined) {
                batch.init();
            }
            batch.boxBuffer.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.
     *
     * @param info The info object to increment with the values from this `PoiRenderBuffer`.
     */
    updateMemoryUsage(info) {
        for (const batch of this.batches) {
            if (batch.imageItem.imageData !== undefined) {
                const imageBytes = batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;
                info.heapSize += imageBytes;
                info.gpuSize += imageBytes;
            }
            if (batch.boxBuffer !== undefined) {
                batch.boxBuffer.updateMemoryUsage(info);
            }
        }
    }
}
/**
 * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being
 * rendered.
 */
class PoiRenderer {
    /**
     * Create the `PoiRenderer` for the specified [[MapView]].
     *
     * @param mapView The MapView to be rendered to.
     * @param textCanvas The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to
     * the different layers of this [[TextCanvas]] based on renderOrder.
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        // temporary variable to save allocations
        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();
        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);
    }
    /**
     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a
     * `poiRenderBatch` is assigned, the POI is ready to be rendered.
     *
     * @param pointLabel TextElement with PoiInfo for rendering the POI icon.
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    prepareRender(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined) {
            return false;
        }
        if (poiInfo.poiRenderBatch === undefined) {
            this.preparePoi(pointLabel);
        }
        return poiInfo.poiRenderBatch !== undefined;
    }
    /**
     * Compute screen box for icon. It is required that `prepareRender` has been successfully called
     * before `isSpaceAvailable` may be called.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D).
     * @param scale Scale to apply to icon.
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     *
     * @returns `True` if box is visible on screen.
     */
    computeScreenBox(poiInfo, screenPosition, scale, screenCollisions, tempScreenBox) {
        if (!this.computeIconScreenBox(poiInfo, screenPosition, scale, tempScreenBox)) {
            return false;
        }
        return screenCollisions.isVisible(tempScreenBox);
    }
    /**
     * Check if the space for the icon is available. It is required that `prepareRender` has been
     * successfully called before `isSpaceAvailable` may be called.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D).
     * @param scale Scale to apply to icon.
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    isSpaceAvailable(screenCollisions, tempScreenBox) {
        return !screenCollisions.isAllocated(tempScreenBox);
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        this.m_renderBuffer.reset();
    }
    /**
     * Render the icon.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D):
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     * @param scale Scaling factor to apply to text and icon.
     * @param allocateScreenSpace If `true` screen space will be allocated for the icon.
     * @param opacity Opacity of icon to allow fade in/out.
     */
    renderPoi(poiInfo, screenPosition, screenCollisions, scale, allocateScreenSpace, opacity) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        if (this.computeIconScreenBox(poiInfo, screenPosition, scale, this.m_tempScreenBox)) {
            if (allocateScreenSpace) {
                screenCollisions.allocate(this.m_tempScreenBox);
            }
            this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, opacity);
        }
    }
    /**
     * Return 'true' if the POI has been successfully prepared for rendering.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     */
    poiIsRenderable(poiInfo) {
        return poiInfo.poiRenderBatch !== undefined;
    }
    /**
     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.
     */
    update() {
        this.m_renderBuffer.update();
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[PoiInfo]]s are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.
     *
     * @param info The info object to increment with the values from this `PoiRenderer`.
     */
    getMemoryUsage(info) {
        this.m_renderBuffer.updateMemoryUsage(info);
    }
    /**
     * Compute the screen rectangle from the screen position.
     */
    computeIconScreenBox(poiInfo, screenPosition, scale, 
    /* out */ screenBox) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        const batch = this.m_renderBuffer.getBatch(poiInfo.poiRenderBatch);
        if (batch === undefined) {
            return false;
        }
        const width = poiInfo.computedWidth * scale;
        const height = poiInfo.computedHeight * scale;
        const technique = poiInfo.technique;
        const centerX = screenPosition.x + (technique.iconXOffset !== undefined ? technique.iconXOffset : 0);
        const centerY = screenPosition.y + (technique.iconYOffset !== undefined ? technique.iconYOffset : 0);
        screenBox.x = centerX - width / 2;
        screenBox.y = centerY - height / 2;
        screenBox.w = width;
        screenBox.h = height;
        return true;
    }
    /**
     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading
     * of the actual image.
     */
    preparePoi(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined || !pointLabel.visible) {
            return;
        }
        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {
            // Already set up, nothing to be done here.
            return;
        }
        if (poiInfo.poiTableName !== undefined) {
            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {
                // Remove poiTableName to mark this POI as processed.
                poiInfo.poiTableName = undefined;
                if (!pointLabel.visible) {
                    // PoiTable set this POI to not visible.
                    return;
                }
            }
            else {
                // PoiTable has not been loaded, but is required to determine visibility.
                return;
            }
        }
        const imageTextureName = poiInfo.imageTextureName;
        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);
        if (imageTexture === undefined) {
            // Warn about a missing texture, but only once.
            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {
                PoiRenderer.m_missingTextureName.set(imageTextureName, true);
                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);
            }
            poiInfo.isValid = false;
            return;
        }
        const imageDefinition = imageTexture.image;
        let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);
        if (imageItem === undefined) {
            logger.error(`init: No imageItem found with name '${imageDefinition}'`);
            poiInfo.isValid = false;
            return;
        }
        if (!imageItem.loaded) {
            if (imageItem.loadingPromise !== undefined) {
                // already being loaded, will be rendered once available
                return;
            }
            const imageUrl = imageItem.url;
            const loading = this.mapView.imageCache.loadImage(imageItem);
            if (loading instanceof Promise) {
                loading
                    .then(loadedImageItem => {
                    if (loadedImageItem === undefined) {
                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);
                        return;
                    }
                    this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem);
                })
                    .catch(error => {
                    logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);
                    poiInfo.isValid = false;
                });
                return;
            }
            else {
                imageItem = loading;
            }
        }
        this.setupPoiInfo(poiInfo, imageTexture, imageItem);
    }
    /**
     * Setup texture and material for the batch.
     *
     * @param poiInfo [[PoiInfo]] to initialize.
     * @param imageTexture Shared [[ImageTexture]], defines used area in atlas.
     * @param imageItem Shared [[ImageItem]], contains cached image for texture.
     */
    setupPoiInfo(poiInfo, imageTexture, imageItem) {
        harp_utils_1.assert(poiInfo.uvBox === undefined);
        if (imageItem === undefined || imageItem.imageData === undefined) {
            logger.error("setupPoiInfo: No imageItem/imageData found");
            // invalid render batch number
            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;
            poiInfo.isValid = false;
            return;
        }
        const technique = poiInfo.technique;
        const imageWidth = imageItem.imageData.width;
        const imageHeight = imageItem.imageData.height;
        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        let minS = 0;
        let maxS = 1;
        let minT = 0;
        let maxT = 1;
        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;
        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;
        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;
        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;
        minS = xOffset / imageWidth;
        maxS = (xOffset + width) / imageWidth;
        const flipY = true;
        if (flipY) {
            minT = (imageHeight - yOffset) / imageHeight;
            maxT = (imageHeight - yOffset - height) / imageHeight;
        }
        else {
            minT = yOffset / imageHeight;
            maxT = (yOffset + height) / imageHeight;
        }
        // minS += 0.5 / imageWidth;
        // maxS += 0.5 / imageWidth;
        // minT += 0.5 / imageHeight;
        // maxT += 0.5 / imageHeight;
        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.
        if (technique.screenWidth !== undefined) {
            iconScaleV = iconScaleH = technique.screenWidth / imageWidth;
        }
        if (technique.screenHeight !== undefined) {
            iconScaleV = technique.screenHeight / imageHeight;
            if (technique.screenWidth === undefined) {
                iconScaleH = iconScaleV;
            }
        }
        // compute stored values in imageTexture
        poiInfo.computedWidth = iconWidth * iconScaleH;
        poiInfo.computedHeight = iconHeight * iconScaleV;
        poiInfo.uvBox = {
            s0: minS,
            t0: maxT,
            s1: maxS,
            t1: minT
        };
        poiInfo.imageItem = imageItem;
        poiInfo.imageTexture = imageTexture;
        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);
        poiInfo.isValid = true;
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
    }
}
// keep track of the missing textures, but only warn once
PoiRenderer.m_missingTextureName = new Map();
exports.PoiRenderer = PoiRenderer;


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiTableManager.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/poi/PoiTableManager.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiTable");
/**
 * Class to store and maintain individual POI information for the [[PoiTable]].
 */
class PoiTableEntry {
    /**
     * Verify that the JSON description of the POI table entry is valid.
     *
     * @param jsonEntry JSON description of the POI table entry.
     *
     * @returns `true` if the `jsonEntry` is valid.
     */
    static verifyJSON(jsonEntry) {
        let isOK = typeof jsonEntry.name === "string" &&
            jsonEntry.name.length > 0 &&
            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&
            (jsonEntry.stackMode === undefined ||
                jsonEntry.stackMode === "yes" ||
                jsonEntry.stackMode === "no" ||
                jsonEntry.stackMode === "parent") &&
            (jsonEntry.visible === undefined || typeof jsonEntry.visible === "boolean") &&
            (jsonEntry.priority === undefined || typeof jsonEntry.priority === "number") &&
            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === "number") &&
            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === "number") &&
            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === "number") &&
            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === "number");
        if (isOK && jsonEntry.altNames !== undefined) {
            const altNames = jsonEntry.altNames;
            for (const str in altNames) {
                if (typeof str !== "string") {
                    isOK = false;
                    break;
                }
            }
        }
        return isOK;
    }
    /**
     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has
     * been verified with [[PoiTableEntry#verifyJSON]].
     *
     * @param jsonEntry JSON description of the POI table entry. Expected to have been verified with
     *          [[PoiTableEntry#verifyJSON]].
     */
    setup(jsonEntry) {
        this.name = jsonEntry.name;
        this.altNames = jsonEntry.altNames;
        this.iconName = jsonEntry.iconName;
        this.visible = jsonEntry.visible;
        this.priority = jsonEntry.priority;
        this.iconMinLevel = jsonEntry.iconMinLevel;
        this.iconMaxLevel = jsonEntry.iconMaxLevel;
        this.textMinLevel = jsonEntry.textMinLevel;
        this.textMaxLevel = jsonEntry.textMaxLevel;
        switch (jsonEntry.stackMode) {
            case "yes":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;
                break;
            case "no":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;
                break;
            case "parent":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;
                break;
            default:
        }
    }
}
/**
 * The `PoiTable` stores individual information for each POI type. If a [[TextElement]] has a
 * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the
 * TextElement and its icon are read from the PoiTable.
 *
 * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the
 * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key
 * to look up the POIs in the [[PoiTable]].
 *
 * On the side of the [[PoiTable]], the key to look up the PoiTableEntry is either the property
 * "name" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names
 * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to
 * `true`, the `altNames` will be used.
 */
class PoiTable {
    /**
     * Creates an instance of PoiTable.
     *
     * @param {string} name Name of the `PoiTable`. Must be unique.
     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`
     *          to find a [[PoiTableEntry]] in the table.
     */
    constructor(name, useAltNamesForKey) {
        this.name = name;
        this.useAltNamesForKey = useAltNamesForKey;
        /**
         * Stores the list of [[PoiTableEntry]]s.
         */
        this.poiList = new Array();
        /**
         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for
         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of
         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.
         * Value assigned to key it is the index to [[poiList]] array which contain actual
         * [[PoiTabelEntry]] objects.
         */
        this.poiDict = new Map();
        this.m_isLoading = false;
        this.m_loadedOk = undefined;
    }
    /**
     * Returns `true` if the table is currently being loaded, `false` otherwise.
     *
     * @readonly
     */
    get isLoading() {
        return this.m_isLoading;
    }
    /**
     * Returns `true` if the table has been loaded correctly, `false` otherwise.
     *
     * @readonly
     */
    get loadedOk() {
        return this.m_loadedOk === true;
    }
    /**
     * Gets [[PoiTableEntry]] for poi name specified.
     *
     * @param poiName poi name or one of its alternative names if [[useAltNamesForKey]] is
     * set to `true`.
     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.
     */
    getEntry(poiName) {
        const entryIdx = this.poiDict.get(poiName);
        if (entryIdx !== undefined) {
            if (entryIdx < this.poiList.length) {
                return this.poiList[entryIdx];
            }
            else {
                throw new Error("Poi table entry index out of stored list!");
            }
        }
        return undefined;
    }
    /**
     * Start to load the PoiTable from the specified URL. Can only be called once per table.
     *
     * @param {string} poiTableUrl URL that points to the JSON file.
     *
     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and
     *          the `PoiTable` has been set up.
     */
    load(poiTableUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.m_loadedOk !== undefined) {
                // Only load once.
                return true;
            }
            this.m_loadedOk = false;
            const response = yield fetch(poiTableUrl);
            if (!response.ok) {
                throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);
            }
            const jsonPoiTable = (yield response.json());
            if (jsonPoiTable === undefined) {
                logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);
                return true;
            }
            this.startLoading();
            try {
                logger.log(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);
                if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {
                    for (const tableEntry of jsonPoiTable.poiList) {
                        if (PoiTableEntry.verifyJSON(tableEntry)) {
                            const newPoiEntry = new PoiTableEntry();
                            newPoiEntry.setup(tableEntry);
                            const entryIdx = this.poiList.push(newPoiEntry) - 1;
                            if (!this.useAltNamesForKey) {
                                // Use actual name of entry as the key
                                if (newPoiEntry.name === undefined) {
                                    logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                        `. No name set in entry: ${tableEntry}.`);
                                }
                                else {
                                    this.poiDict.set(newPoiEntry.name, entryIdx);
                                }
                            }
                            else {
                                if (newPoiEntry.altNames !== undefined &&
                                    newPoiEntry.altNames.length > 0) {
                                    // Use the list of alternative names as keys.
                                    for (const altName of newPoiEntry.altNames) {
                                        this.poiDict.set(altName, entryIdx);
                                    }
                                }
                                else {
                                    logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                        `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);
                                }
                            }
                        }
                        else {
                            logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);
                        }
                    }
                }
                this.m_loadedOk = true;
                this.finishedLoading();
            }
            catch (ex) {
                logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);
                this.m_loadedOk = false;
                this.finishedLoading();
                return false;
            }
            return true;
        });
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishedLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTable = PoiTable;
/**
 * The `PoiTableManager` manages the list of [[PoiTables]] that can be defined in the [[Theme]]
 * file.
 */
class PoiTableManager {
    /**
     * Creates an instance of PoiTableManager.
     * @param {MapView} mapView Owning [[MapView]].
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_isLoading = false;
        this.m_poiTables = new Map();
    }
    /**
     * Load the [[PoiTable]]s that are stored in the [[MapView]]s [[Theme]]. Note that duplicate
     * names of [[PoiTable]]s in the [[Theme]] will lead to inaccessible [[PoiTable]]s.
     *
     * @param {Theme} theme [[Theme]] containing all [[PoiTable]]s to load.
     *
     * @returns {Promise<void>} Resolved once all the [[PoiTable]]s in the [[Theme]] have been
     *          loaded.
     */
    loadPoiTables(theme) {
        return __awaiter(this, void 0, void 0, function* () {
            const finished = new Promise(resolve => {
                this.clear();
                // Add the POI tables defined in the theme.
                if (theme.poiTables !== undefined) {
                    this.startLoading();
                    // Gather promises to signal the success of having loaded them all
                    const loadPromises = new Array();
                    // Ensure that all resources referenced in theme by relative URLs are in fact
                    // relative to theme.
                    const themeUrl = theme.url;
                    const childUrlResolver = themeUrl === undefined
                        ? undefined
                        : harp_utils_1.composeUrlResolvers((childUrl) => harp_utils_1.resolveReferenceUrl(themeUrl, childUrl), harp_utils_1.defaultUrlResolver);
                    theme.poiTables.forEach((poiTableRef) => {
                        if (poiTableRef !== undefined &&
                            poiTableRef.name !== undefined &&
                            typeof poiTableRef.name === "string") {
                            const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
                            if (poiTableRef.url !== undefined && typeof poiTableRef.url === "string") {
                                this.addTable(poiTable);
                                const tableUrl = childUrlResolver === undefined
                                    ? poiTableRef.url
                                    : childUrlResolver(poiTableRef.url);
                                loadPromises.push(poiTable.load(tableUrl));
                            }
                            else {
                                logger.error(`POI table definition has no valid url: ${poiTableRef}`);
                            }
                        }
                        else {
                            logger.error(`POI table definition has no valid name: ${poiTableRef}`);
                        }
                    });
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            this.finishLoading();
                            resolve();
                        });
                    }
                    else {
                        this.finishLoading();
                        resolve();
                    }
                }
                else {
                    this.finishLoading();
                    resolve();
                }
            });
            return finished;
        });
    }
    /**
     * Clear the list of [[PoiTable]]s.
     */
    clear() {
        this.m_poiTables = new Map();
    }
    /**
     * Return the map of [[PoiTable]]s.
     */
    get poiTables() {
        return this.m_poiTables;
    }
    /**
     * Manually add a [[PoiTable]]. Normally, the [[PoiTables]]s are specified in the [[Theme]].
     * Ensure that the name is unique.
     */
    addTable(poiTable) {
        this.m_poiTables.set(poiTable.name, poiTable);
    }
    /**
     * Retrieve a [[PoiTable]] by name.
     *
     * @param {(string | undefined)} poiTableName Name of the [[PoiTable]].
     *
     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`
     *          otherwise.
     */
    getPoiTable(poiTableName) {
        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);
    }
    /**
     * Return `true` if the [[PoiTable]]s have finished loading.
     *
     * @readonly
     */
    get finishedLoading() {
        return !this.m_isLoading;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTableManager = PoiTableManager;


/***/ }),

/***/ "../harp-mapview/lib/text/SimplePath.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/text/SimplePath.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * @hidden
 */
class SimpleLineCurve extends THREE.LineCurve {
    constructor(v1, v2) {
        super(v1, v2);
    }
    getLengths() {
        if (this.m_lengths === undefined) {
            this.m_lengths = [0, this.v2.distanceTo(this.v1)];
        }
        return this.m_lengths;
    }
}
exports.SimpleLineCurve = SimpleLineCurve;
/**
 * @hidden
 */
class PathParam {
    constructor(path, index, t) {
        this.path = path;
        this.index = index;
        this.t = t;
    }
    get curve() {
        return this.path.curves[this.index];
    }
    get point() {
        if (this.m_point === undefined) {
            this.m_point = this.curve.getPoint(this.t);
        }
        return this.m_point;
    }
}
exports.PathParam = PathParam;
/**
 * @hidden
 */
class SimplePath extends THREE.Path {
    constructor() {
        super();
    }
    getLengths() {
        if (this.m_cache) {
            return this.m_cache;
        }
        let sum = 0;
        const lengths = new Array();
        lengths.push(0);
        this.curves.forEach(curve => {
            const lineCurve = curve;
            sum += lineCurve.v1.distanceTo(lineCurve.v2);
            lengths.push(sum);
        });
        this.m_cache = lengths;
        return lengths;
    }
    getParamAt(t) {
        const distance = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        for (let index = 0; index < curveLengths.length; ++index) {
            if (curveLengths[index] < distance) {
                continue;
            }
            const diff = curveLengths[index] - distance;
            const curve = this.curves[index];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return new PathParam(this, index, u);
        }
        return null;
    }
}
exports.SimplePath = SimplePath;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElement.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/TextElement.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * State of fading.
 */
var FadingState;
(function (FadingState) {
    FadingState[FadingState["Undefined"] = 0] = "Undefined";
    FadingState[FadingState["FadingIn"] = 1] = "FadingIn";
    FadingState[FadingState["FadedIn"] = 2] = "FadedIn";
    FadingState[FadingState["FadingOut"] = -1] = "FadingOut";
    FadingState[FadingState["FadedOut"] = -2] = "FadedOut";
})(FadingState = exports.FadingState || (exports.FadingState = {}));
/**
 * State of loading.
 */
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["Requested"] = 0] = "Requested";
    LoadingState[LoadingState["Loaded"] = 1] = "Loaded";
    LoadingState[LoadingState["Initialized"] = 2] = "Initialized";
})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));
/**
 * Time to fade in/fade out the labels in milliseconds.
 */
exports.DEFAULT_FADE_TIME = 800;
/**
 * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements
 * in and out, to compute the opacity.
 *
 * @hidden
 */
class RenderState {
    /**
     * Create a `RenderState`.
     *
     * @param state Fading state.
     * @param value Current fading value [0..1].
     * @param startTime Time stamp the fading started.
     * @param opacity Computed opacity depending on value.
     * @param lastFrameNumber Latest frame the elements was rendered, allows to detect some less
     *                        obvious states, like popping up after being hidden.
     * @param fadingTime Time used to fade in or out.
     */
    constructor(state = FadingState.Undefined, value = 0.0, startTime = 0, opacity = 1.0, lastFrameNumber = Number.MIN_SAFE_INTEGER, fadingTime = exports.DEFAULT_FADE_TIME) {
        this.state = state;
        this.value = value;
        this.startTime = startTime;
        this.opacity = opacity;
        this.lastFrameNumber = lastFrameNumber;
        this.fadingTime = fadingTime;
    }
    /**
     * Reset existing `RenderState` to appear like a fresh state.
     */
    reset() {
        this.state = FadingState.Undefined;
        this.value = 0.0;
        this.startTime = 0.0;
        this.opacity = 1.0;
        this.lastFrameNumber = Number.MIN_SAFE_INTEGER;
    }
    /**
     * @returns `true` if element is either fading in or fading out.
     */
    isFading() {
        const fading = this.state === FadingState.FadingIn || this.state === FadingState.FadingOut;
        return fading;
    }
    /**
     * @returns `true` if element is fading in.
     */
    isFadingIn() {
        const fadingIn = this.state === FadingState.FadingIn;
        return fadingIn;
    }
    /**
     * @returns `true` if element is fading out.
     */
    isFadingOut() {
        const fadingOut = this.state === FadingState.FadingOut;
        return fadingOut;
    }
    /**
     * @returns `true` if element is done with fading in.
     */
    isFadedIn() {
        const fadedIn = this.state === FadingState.FadedIn;
        return fadedIn;
    }
    /**
     * @returns `true` if element is done with fading out.
     */
    isFadedOut() {
        const fadedOut = this.state === FadingState.FadedOut;
        return fadedOut;
    }
    /**
     * @returns `true` if element is either faded in, is fading in or is fading out.
     */
    isVisible() {
        const visible = this.state === FadingState.FadingIn ||
            this.state === FadingState.FadedIn ||
            this.state === FadingState.FadingOut;
        return visible;
    }
}
exports.RenderState = RenderState;
/**
 * `TextElement` is used to create 2D text elements (for example, labels).
 */
class TextElement {
    /**
     * Creates a new `TextElement`.
     *
     * @param text The text to display.
     * @param points The position in world coordinates or a list of points in world coordinates for
     *              a curved text.
     * @param renderParams `TextElement` text rendering parameters.
     * @param layoutParams `TextElement` text layout parameters.
     * @param priority The priority of the `TextElement. Elements with the highest priority get
     *              placed first, elements with priority of `0` are placed last, elements with a
     *              negative value are always rendered, ignoring priorities and allowing
     *              overrides.
     * @param xOffset Optional X offset of this `TextElement` in screen coordinates.
     * @param yOffset Optional Y offset of this `TextElement` in screen coordinates.
     * @param featureId Optional number to identify feature (originated from `OmvDataSource`).
     * @param fadeNear Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label starts fading out (opacity decreases).
     * @param fadeFar Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label becomes transparent. A value of <= 0.0 disables fading.
     */
    constructor(text, points, renderParams, layoutParams, priority = 0, xOffset, yOffset, featureId, style, fadeNear, fadeFar) {
        this.text = text;
        this.points = points;
        this.renderParams = renderParams;
        this.layoutParams = layoutParams;
        this.priority = priority;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.featureId = featureId;
        this.style = style;
        this.fadeNear = fadeNear;
        this.fadeFar = fadeFar;
        /**
         * Determines visibility. If set to `false`, it will not be rendered.
         */
        this.visible = true;
        /**
         * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.
         */
        this.distanceScale = 0.5;
        /**
         * If specified, determines the render order between `TextElement`s. The number different
         * renderOrders should be as small as possible, because every specific `renderOrder` may result
         * in one or more draw calls.
         *
         * TextElements with the same integer `renderOrder` will be rendered in the same batch.
         *
         * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other
         * map elements.
         *
         * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a
         * lower `renderOrder`.
         */
        this.renderOrder = 0;
        /**
         * @hidden
         * Used during sorting.
         */
        this.sortPriority = 0;
        if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {
            this.renderStyle = renderParams;
        }
        if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {
            this.layoutStyle = layoutParams;
        }
    }
    /**
     * The position of this text element in world coordinates or the first point of the path used to
     * render a curved text.
     */
    get position() {
        if (this.points instanceof Array) {
            const p = this.points[0];
            return p;
        }
        return this.points;
    }
    /**
     * The list of points in world coordinates used to render the text along a path or `undefined`.
     */
    get path() {
        if (this.points instanceof Array) {
            return this.points;
        }
        return undefined;
    }
    /**
     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.
     *
     * @default `false`
     */
    get textMayOverlap() {
        return this.mayOverlap === true;
    }
    set textMayOverlap(mayOverlap) {
        this.mayOverlap = mayOverlap;
    }
    /**
     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not
     * be able to overlap.
     *
     * @default `true`
     */
    get textReservesSpace() {
        return this.reserveSpace !== false;
    }
    set textReservesSpace(reserveSpace) {
        this.reserveSpace = reserveSpace;
    }
    /**
     * Determine if the `TextElement` is a line marker.
     *
     * @returns `true` if this `TextElement` is a line marker.
     */
    get isLineMarker() {
        return (this.points !== undefined &&
            (this.m_poiInfo !== undefined && harp_datasource_protocol_1.isLineMarkerTechnique(this.m_poiInfo.technique)));
    }
    /**
     * Return the last distance that has been computed for sorting during placement. This may not be
     * the actual distance if the camera is moving, as the distance is computed only during
     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.
     *
     * @returns 0 or negative distance to camera.
     */
    get renderDistance() {
        return this.alwaysOnTop === true
            ? 0
            : this.currentViewDistance !== undefined
                ? -this.currentViewDistance
                : 0;
    }
    /**
     * Contains additional information about icon to be rendered along with text.
     */
    get poiInfo() {
        return this.m_poiInfo;
    }
    set poiInfo(poiInfo) {
        this.m_poiInfo = poiInfo;
        if (poiInfo !== undefined) {
            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;
            poiInfo.renderOrder = poiRenderOrder;
        }
    }
    /**
     * Update the minZoomLevel and maxZoomLevel from the values set in [[PoiInfo]].
     * Selects the smaller/larger one of the two min/max values for icon and text, because the
     * TextElement is a container for both.
     */
    updateMinMaxZoomLevelsFromPoiInfo() {
        if (this.poiInfo !== undefined) {
            if (this.minZoomLevel === undefined) {
                this.minZoomLevel = harp_utils_1.MathUtils.min2(this.poiInfo.iconMinZoomLevel, this.poiInfo.textMinZoomLevel);
            }
            if (this.maxZoomLevel === undefined) {
                this.maxZoomLevel = harp_utils_1.MathUtils.max2(this.poiInfo.iconMaxZoomLevel, this.poiInfo.textMaxZoomLevel);
            }
        }
    }
}
exports.TextElement = TextElement;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementsRenderer.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementsRenderer.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const DebugContext_1 = __webpack_require__(/*! ../DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const PickHandler_1 = __webpack_require__(/*! ../PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ "../harp-mapview/lib/poi/PoiRenderer.ts");
const SimplePath_1 = __webpack_require__(/*! ./SimplePath */ "../harp-mapview/lib/text/SimplePath.ts");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts");
const DEFAULT_STYLE_NAME = "default";
const DEFAULT_FONT_CATALOG_NAME = "default";
const MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME = Infinity;
const MIN_GLYPH_COUNT = 1024;
const MAX_GLYPH_COUNT = 32768;
/**
 * Default number of labels/POIs rendered in the scene
 */
const DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;
/**
 * Default distance scale. Will be applied if distanceScale is not defined in the technique.
 * Defines the scale that will be applied to labeled icons (icon and text) in the distance.
 */
exports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
/**
 * Number of elements that are put into second queue. This second chance queue is used to render
 * TextElements that have not been on screen before. This is a quick source for elements that can
 * appear when the camera moves a bit, before new elements are placed.
 */
const DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;
/**
 * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the
 * far plane (1.0). May be synchronized with fog value ?
 */
const DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;
/**
 * Minimum scaling factor that may be applied to labels when their are distant from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;
/**
 * Maximum scaling factor that may be applied to labels due to their distance from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;
/**
 * Maximum number of recommended labels. If more labels are encountered, the "overloaded" mode is
 * set, which modifies the behavior of label placement and rendering, trying to keep delivering an
 * interactive performance. The overloaded mode should not be activated if the [[MapView]] is
 * rendering a static image (camera not moving and no animation running).
 */
const OVERLOAD_LABEL_LIMIT = 20000;
/**
 * If "overloaded" is `true`:
 *
 * Default number of labels/POIs placed in the scene. They are rendered only if they fit. If the
 * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_PLACED_LABEL_LIMIT = 100;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_PLACEMENT_TIME_LIMIT = 5;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_RENDER_TIME_LIMIT = 10;
/**
 * Minimum number of pixels per character. Used during estimation if there is enough screen space
 * available to render a text.
 */
const MIN_AVERAGE_CHAR_WIDTH = 5;
// Development flag: Enable debug print.
const PRINT_LABEL_DEBUG_INFO = false;
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsRenderer");
const tempBox = new THREE.Box2();
const tempBoxes = [];
const tempBox2D = new harp_utils_1.Math2D.Box();
const tempPosition = new THREE.Vector3();
const tempPoiPosition = new THREE.Vector3(0, 0, 0);
const tempScreenPosition = new THREE.Vector2();
const tempPoiScreenPosition = new THREE.Vector2();
class TileTextElements {
    constructor(tile, textElements) {
        this.tile = tile;
        this.textElements = textElements;
    }
}
class TextElementLists {
    constructor(priority, textElementLists) {
        this.priority = priority;
        this.textElementLists = textElementLists;
    }
    /**
     * Sum up the number of elements in all lists.
     */
    count() {
        let n = 0;
        for (const list of this.textElementLists) {
            n += list.textElements.length;
        }
        return n;
    }
}
/**
 * @hidden
 *
 * Internal class to manage all text rendering.
 */
class TextElementsRenderer {
    /**
     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as
     * a preprocessing step, which is not done every frame, and also renders the placed
     * [[TextElement]]s every frame.
     *
     * @param m_mapView MapView to render into
     * @param m_screenCollisions General 2D screen occlusion management, may be shared between
     *     instances.
     * @param m_screenProjector Projects 3D coordinates into screen space.
     * @param m_minNumGlyphs Minimum number of glyphs (per-layer). Controls the size of internal
     * buffers.
     * @param m_maxNumGlyphs Maximum number of glyphs (per-layer). Controls the size of internal
     * buffers.
     * @param m_theme Theme defining  text styles.
     * @param m_maxNumVisibleLabels Maximum number of visible [[TextElement]]s.
     * @param m_numSecondChanceLabels Number of [[TextElement]] that will be rendered again.
     * @param m_maxDistanceRatioForTextLabels Maximum distance for pure [[TextElement]], at which
     *          it should still be rendered, expressed as a fraction of the distance between
     *          the near and far plane [0, 1.0]. Defaults to
     *          [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].
     * @param m_maxDistanceRatioForPoiLabels Maximum distance for [[TextElement]] with icon,
     *          expressed as a fraction of the distance between the near and far plane [0, 1.0].
     *          Defaults to [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].
     * @param m_labelDistanceScaleMin Minimum scale factor that may be applied to [[TextElement]]s
     *          due to its disctance from focus point. Defaults to `0.7`.
     * @param m_labelDistanceScaleMax Maximum scale factor that may be applied to [[TextElement]]s
     *          due to its distance from focus point. Defaults to `1.5`.
     */
    constructor(m_mapView, m_screenCollisions, m_screenProjector, m_minNumGlyphs, m_maxNumGlyphs, m_theme, m_maxNumVisibleLabels, m_numSecondChanceLabels, m_labelDistanceScaleMin, m_labelDistanceScaleMax, m_maxDistanceRatioForTextLabels, m_maxDistanceRatioForPoiLabels) {
        this.m_mapView = m_mapView;
        this.m_screenCollisions = m_screenCollisions;
        this.m_screenProjector = m_screenProjector;
        this.m_minNumGlyphs = m_minNumGlyphs;
        this.m_maxNumGlyphs = m_maxNumGlyphs;
        this.m_theme = m_theme;
        this.m_maxNumVisibleLabels = m_maxNumVisibleLabels;
        this.m_numSecondChanceLabels = m_numSecondChanceLabels;
        this.m_labelDistanceScaleMin = m_labelDistanceScaleMin;
        this.m_labelDistanceScaleMax = m_labelDistanceScaleMax;
        this.m_maxDistanceRatioForTextLabels = m_maxDistanceRatioForTextLabels;
        this.m_maxDistanceRatioForPoiLabels = m_maxDistanceRatioForPoiLabels;
        this.m_initializedTextElementCount = 0;
        this.m_textRenderers = [];
        this.m_textStyles = new Map();
        this.m_defaultStyle = {
            name: DEFAULT_STYLE_NAME,
            fontCatalog: DEFAULT_FONT_CATALOG_NAME,
            renderParams: this.m_mapView.textRenderStyleCache.get(TextStyleCache_1.DEFAULT_TEXT_STYLE_CACHE_ID).params,
            layoutParams: this.m_mapView.textLayoutStyleCache.get(TextStyleCache_1.DEFAULT_TEXT_STYLE_CACHE_ID).params
        };
        this.m_lastRenderedTextElements = [];
        this.m_secondChanceTextElements = [];
        this.m_tmpVector = new THREE.Vector2();
        this.m_overloaded = false;
        this.m_catalogsLoading = 0;
        if (this.m_minNumGlyphs === undefined) {
            this.m_minNumGlyphs = MIN_GLYPH_COUNT;
        }
        if (this.m_maxNumGlyphs === undefined) {
            this.m_maxNumGlyphs = MAX_GLYPH_COUNT;
        }
        if (this.m_maxNumVisibleLabels === undefined) {
            this.m_maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;
        }
        if (this.m_numSecondChanceLabels === undefined) {
            this.m_numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;
        }
        if (this.m_labelDistanceScaleMin === undefined) {
            this.m_labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;
        }
        if (this.m_labelDistanceScaleMax === undefined) {
            this.m_labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;
        }
        if (this.m_maxDistanceRatioForTextLabels === undefined) {
            this.m_maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
        }
        if (this.m_maxDistanceRatioForPoiLabels === undefined) {
            this.m_maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
        }
        this.initializeDefaultAssets();
        this.initializeTextCanvases();
    }
    /**
     * Render the text using the specified camera into the current canvas.
     *
     * @param camera Orthographic camera to use.
     */
    renderText(camera) {
        const debugGlyphs = DebugContext_1.debugContext.getValue("DEBUG_GLYPHS");
        if (debugGlyphs !== undefined &&
            this.m_debugGlyphTextureCacheMesh !== undefined &&
            this.m_debugGlyphTextureCacheWireMesh !== undefined) {
            this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
            this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
        }
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.render(camera);
        }
    }
    /**
     * Reset internal state at the beginning of a frame.
     */
    reset() {
        this.m_screenCollisions.reset();
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.clear();
            textRenderer.poiRenderer.reset();
        }
        this.m_initializedTextElementCount = 0;
    }
    /**
     * Update the geometries at the end of a frame before rendering them.
     */
    update() {
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.poiRenderer.update();
        }
    }
    /**
     * Visit all visible tiles and place their text labels and POI icons. The placement of
     * [[TextElement]]s is a time consuming process, and cannot be done every frame, but should only
     * be done when the camera moved (a lot) of whenever the set of visible tiles change.
     *
     * The actually rendered [[TextElement]]s are stored internally until the next placement is done
     * to speed up rendering when no camera movement was detected.
     */
    placeAllTileLabels() {
        this.placeAllLabels();
    }
    /**
     * Notify `TextElementsRenderer` that the camera has started a movement.
     */
    movementStarted() {
        // Nothing to do (yet)
    }
    /**
     * Notify `TextElementsRenderer` that the camera has finished its movement.
     */
    movementFinished() {
        this.placeAllLabels();
    }
    /**
     * Default [[TextElementStyle]] used to render [[TextElement]]s.
     */
    get defaultStyle() {
        return this.m_defaultStyle;
    }
    /**
     * Is `true` if number of [[TextElement]]s in visible tiles is larger than the recommended
     * number `OVERLOAD_LABEL_LIMIT`.
     */
    get overloaded() {
        return this.m_overloaded;
    }
    /**
     * Render the user [[TextElement]]s.
     *
     * @param time Current time for animations.
     * @param frameNumber Integer number incremented every frame.
     */
    renderUserTextElements(time, frameNumber) {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        const zoomLevel = this.m_mapView.zoomLevel;
        // Render the user POIs first
        renderList.forEach(renderListEntry => {
            for (const tile of renderListEntry.visibleTiles) {
                for (const textElement of tile.userTextElements) {
                    // update distance
                    textElement.tileCenter = tile.center;
                    this.updateViewDistance(this.m_mapView.worldCenter, textElement);
                }
                this.renderTextElements(tile.userTextElements, time, frameNumber, zoomLevel);
            }
        });
    }
    /**
     * Re-render the previously placed [[TextElement]]s.
     *
     * @param time Current time for animations.
     * @param frameNumber Integer number incremented every frame.
     */
    renderAllTileText(time, frameNumber) {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        const zoomLevel = this.m_mapView.zoomLevel;
        this.checkIfOverloaded();
        if (this.m_lastRenderedTextElements.length === 0) {
            const renderStartTime = this.overloaded && this.m_mapView.isDynamicFrame
                ? harp_utils_1.PerformanceTimer.now()
                : undefined;
            // Nothing has been rendered before, process the list of placed labels in all tiles.
            renderList.forEach(renderListEntry => {
                this.renderTileList(renderListEntry.renderedTiles, time, frameNumber, zoomLevel, renderStartTime, this.m_lastRenderedTextElements, this.m_secondChanceTextElements);
            });
        }
        else {
            //TODO: Avoid list allocation
            const allRenderableTextElements = this.m_lastRenderedTextElements.concat(this.m_secondChanceTextElements);
            this.renderTextElements(allRenderableTextElements, time, frameNumber, zoomLevel);
        }
    }
    /**
     * Render the [[TextElement]]s that are not part of the scene, but the overlay. Useful if a UI
     * with text or just plain information in the canvas itself should be presented to the user,
     * instead of using an HTML layer.
     *
     * @param textElements List of [[TextElement]]s in the overlay.
     */
    renderOverlay(textElements) {
        if (textElements === undefined || textElements.length === 0) {
            return;
        }
        this.renderOverlayTextElements(textElements);
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[TextElement]]s are found, the order of the results is unspecified.
     *
     * Note: [[TextElement]]s with identical `featureId` or identical `userData` will only appear
     * once in the list `pickResults`.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickResults Array filled with pick results.
     */
    pickTextElements(screenPosition, pickResults) {
        const pickHandler = (pickData, pickObjectType) => {
            const textElement = pickData;
            if (textElement === undefined) {
                return;
            }
            let isDuplicate = false;
            if (textElement.featureId !== undefined) {
                isDuplicate = pickResults.some(pickResult => {
                    return (pickResult !== undefined &&
                        pickObjectType === pickResult.type &&
                        ((pickResult.featureId !== undefined &&
                            pickResult.featureId === textElement.featureId) ||
                            (pickResult.userData !== undefined &&
                                pickResult.userData === textElement.userData)));
                });
                if (!isDuplicate) {
                    const pickResult = {
                        type: pickObjectType,
                        point: screenPosition,
                        distance: 0,
                        featureId: textElement.featureId,
                        userData: textElement.userData,
                        text: textElement.text
                    };
                    pickResults.push(pickResult);
                }
            }
        };
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.pickText(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Text);
            });
            textRenderer.poiRenderer.pickTextElements(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Icon);
            });
        }
    }
    /**
     * Retrieves a [[TextElementStyle]] for [[Theme]]'s [[TextStyle]] id.
     */
    getTextElementStyle(styleId) {
        let result;
        if (styleId === undefined) {
            result = this.m_defaultStyle;
        }
        else {
            result = this.m_textStyles.get(styleId);
            if (result === undefined) {
                result = this.m_defaultStyle;
            }
        }
        return result;
    }
    /**
     * `true` if font catalogs are ready, that means all font catalogs are initialized.
     */
    get ready() {
        return this.m_catalogsLoading === 0 && this.m_textRenderers.length > 0;
    }
    /**
     * `true` if any resource used by any `FontCatalog` is still loading.
     */
    get loading() {
        let isLoading = this.m_catalogsLoading > 0;
        for (const textRenderer of this.m_textRenderers) {
            isLoading = isLoading || textRenderer.textCanvas.fontCatalog.isLoading;
        }
        return isLoading;
    }
    /**
     * Reset the current text render states of all visible tiles. All [[TextElement]]s will fade in
     * after that as if they have just been added.
     */
    clearRenderStates() {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        renderList.forEach(renderListEntry => {
            for (const tile of renderListEntry.visibleTiles) {
                // Reset the render states, handle them as if they were just added to the tile.
                tile.userTextElements.forEach(textElement => {
                    textElement.iconRenderState = undefined;
                    textElement.textRenderState = undefined;
                });
                tile.textElementGroups.forEach(textElement => {
                    textElement.iconRenderState = undefined;
                    textElement.textRenderState = undefined;
                });
            }
        });
    }
    /**
     * Return memory used by all objects managed by `TextElementsRenderer`.
     *
     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.
     */
    getMemoryUsage() {
        const memoryUsage = {
            heapSize: 0,
            gpuSize: 0
        };
        for (const renderer of this.m_textRenderers) {
            renderer.textCanvas.getMemoryUsage(memoryUsage);
            renderer.poiRenderer.getMemoryUsage(memoryUsage);
        }
        return memoryUsage;
    }
    initializeDefaultAssets() {
        // Initialize default font catalog.
        if (this.m_theme.fontCatalogs === undefined ||
            (Array.isArray(this.m_theme.fontCatalogs) && this.m_theme.fontCatalogs.length === 0)) {
            this.m_theme.fontCatalogs = [
                {
                    name: DEFAULT_FONT_CATALOG_NAME,
                    url: this.m_mapView.defaultFontCatalog
                }
            ];
        }
        const fontCatalogs = this.m_theme.fontCatalogs;
        let defaultFontCatalogName;
        if (fontCatalogs.length > 0) {
            for (const fontCatalog of fontCatalogs) {
                if (fontCatalog.name !== undefined) {
                    defaultFontCatalogName = fontCatalog.name;
                    break;
                }
            }
            if (defaultFontCatalogName === undefined) {
                defaultFontCatalogName = DEFAULT_FONT_CATALOG_NAME;
                fontCatalogs[0].name = defaultFontCatalogName;
            }
        }
        // Initialize default text style.
        if (this.m_theme.textStyles === undefined) {
            this.m_theme.textStyles = [];
        }
        const styles = this.m_theme.textStyles;
        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);
        if (themedDefaultStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(themedDefaultStyle, DEFAULT_STYLE_NAME);
        }
        else if (this.m_theme.defaultTextStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(this.m_theme.defaultTextStyle, DEFAULT_STYLE_NAME);
        }
        else if (styles.length > 0) {
            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);
        }
        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;
    }
    createTextElementStyle(style, styleName) {
        return {
            name: styleName,
            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, DEFAULT_FONT_CATALOG_NAME),
            renderParams: {
                fontName: style.fontName,
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: 32,
                    backgroundSize: style.backgroundSize || 8
                },
                fontStyle: style.fontStyle === "Regular" ||
                    style.fontStyle === "Bold" ||
                    style.fontStyle === "Italic" ||
                    style.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[style.fontStyle]
                    : undefined,
                fontVariant: style.fontVariant === "Regular" ||
                    style.fontVariant === "AllCaps" ||
                    style.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[style.fontVariant]
                    : undefined,
                rotation: style.rotation,
                color: style.color !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.color)
                    : undefined,
                backgroundColor: style.backgroundColor !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)
                    : undefined,
                opacity: style.opacity,
                backgroundOpacity: style.backgroundOpacity
            },
            layoutParams: {
                tracking: style.tracking,
                leading: style.leading,
                maxLines: style.maxLines,
                lineWidth: style.lineWidth,
                canvasRotation: style.canvasRotation,
                lineRotation: style.lineRotation,
                wrappingMode: style.wrappingMode === "None" ||
                    style.wrappingMode === "Character" ||
                    style.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]
                    : harp_text_canvas_1.WrappingMode.Word,
                verticalAlignment: style.vAlignment === "Above" ||
                    style.vAlignment === "Center" ||
                    style.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[style.vAlignment]
                    : harp_text_canvas_1.VerticalAlignment.Center,
                horizontalAlignment: style.hAlignment === "Left" ||
                    style.hAlignment === "Center" ||
                    style.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[style.hAlignment]
                    : harp_text_canvas_1.HorizontalAlignment.Center
            }
        };
    }
    initializeTextCanvases() {
        const promises = [];
        this.m_theme.fontCatalogs.forEach(fontCatalogConfig => {
            this.m_catalogsLoading += 1;
            const fontCatalogPromise = harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)
                .then((loadedFontCatalog) => {
                const loadedTextCanvas = new harp_text_canvas_1.TextCanvas({
                    renderer: this.m_mapView.renderer,
                    fontCatalog: loadedFontCatalog,
                    minGlyphCount: this.m_minNumGlyphs,
                    maxGlyphCount: this.m_maxNumGlyphs
                });
                this.m_textRenderers.push({
                    fontCatalog: fontCatalogConfig.name,
                    textCanvas: loadedTextCanvas,
                    poiRenderer: new PoiRenderer_1.PoiRenderer(this.m_mapView, loadedTextCanvas)
                });
            })
                .catch((error) => {
                logger.error("Failed to load FontCatalog: ", error);
            })
                .finally(() => {
                this.m_catalogsLoading -= 1;
            });
            promises.push(fontCatalogPromise);
        });
        Promise.all(promises).then(() => {
            this.initializeTextElementStyles();
            const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;
            // Initialize glyph-debugging mesh.
            const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
            const material = new THREE.MeshBasicMaterial({
                transparent: true,
                depthWrite: false,
                depthTest: false,
                map: defaultFontCatalog.texture
            });
            this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);
            this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;
            this.m_debugGlyphTextureCacheMesh.visible = false;
            this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
            const wireframe = new THREE.WireframeGeometry(planeGeometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({
                transparent: true,
                color: 0x999999,
                depthWrite: false,
                depthTest: false
            });
            this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
            this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
            this.m_debugGlyphTextureCacheWireMesh.visible = false;
            this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
            this.m_textRenderers[0].textCanvas
                .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)
                .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
            this.m_mapView.update();
        });
    }
    initializeTextElementStyles() {
        // Find the default TextCanvas and PoiRenderer.
        let defaultTextCanvas;
        this.m_textRenderers.forEach(textRenderer => {
            if (defaultTextCanvas === undefined) {
                defaultTextCanvas = textRenderer.textCanvas;
            }
        });
        const defaultPoiRenderer = new PoiRenderer_1.PoiRenderer(this.m_mapView, defaultTextCanvas);
        // Initialize default text style.
        if (this.m_defaultStyle.fontCatalog !== undefined) {
            const styledTextRenderer = this.m_textRenderers.find(textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog);
            this.m_defaultStyle.textCanvas =
                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;
            this.m_defaultStyle.poiRenderer =
                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;
        }
        if (this.m_defaultStyle.textCanvas === undefined) {
            if (this.m_defaultStyle.fontCatalog !== undefined) {
                logger.warn(`FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${this.m_defaultStyle.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
            }
            this.m_defaultStyle.textCanvas = defaultTextCanvas;
            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;
        }
        // Initialize theme text styles.
        this.m_theme.textStyles.forEach(element => {
            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));
        });
        // tslint:disable-next-line:no-unused-variable
        for (const [name, style] of this.m_textStyles) {
            if (style.textCanvas === undefined) {
                if (style.fontCatalog !== undefined) {
                    const styledTextRenderer = this.m_textRenderers.find(textRenderer => textRenderer.fontCatalog === style.fontCatalog);
                    style.textCanvas =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.textCanvas
                            : undefined;
                    style.poiRenderer =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.poiRenderer
                            : undefined;
                }
                if (style.textCanvas === undefined) {
                    if (style.fontCatalog !== undefined) {
                        logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle '${style.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
                    }
                    style.textCanvas = defaultTextCanvas;
                    style.poiRenderer = defaultPoiRenderer;
                }
            }
        }
    }
    updateViewDistance(worldCenter, textElement) {
        let viewDistance;
        if (Array.isArray(textElement.points) && textElement.points.length > 1) {
            tempPoiPosition.copy(textElement.points[0]).add(textElement.tileCenter);
            const viewDistance0 = worldCenter.distanceTo(tempPoiPosition);
            tempPoiPosition
                .copy(textElement.points[textElement.points.length - 1])
                .add(textElement.tileCenter);
            const viewDistance1 = worldCenter.distanceTo(tempPoiPosition);
            viewDistance = Math.min(viewDistance0, viewDistance1);
        }
        else {
            tempPoiPosition.copy(textElement.position).add(textElement.tileCenter);
            viewDistance = worldCenter.distanceTo(tempPoiPosition);
        }
        textElement.currentViewDistance = viewDistance;
        return viewDistance;
    }
    sortTextElements(textElements, maxViewDistance) {
        const distancePriorityFactor = 0.1;
        const indexPriorityFactor = 0.01 * (1 / textElements.length);
        // Compute the sortPriority once for all elements, because the computation is done more
        // than once per element. Also, make sorting stable by taking the index into the array into
        // account, this is required to get repeatable results for testing.
        for (let i = 0; i < textElements.length; i++) {
            const textElement = textElements[i];
            textElement.sortPriority =
                textElement.priority +
                    i * indexPriorityFactor +
                    distancePriorityFactor -
                    distancePriorityFactor * (textElement.currentViewDistance / maxViewDistance);
        }
        // Do the actual sort based on sortPriority
        textElements.sort((a, b) => {
            return b.sortPriority - a.sortPriority;
        });
    }
    placeAllLabels() {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        const zoomLevel = this.m_mapView.zoomLevel;
        this.checkIfOverloaded();
        const placementStartTime = this.overloaded && this.m_mapView.isDynamicFrame ? harp_utils_1.PerformanceTimer.now() : undefined;
        renderList.forEach(tileList => {
            this.placeTextElements(tileList.dataSource, tileList.storageLevel, zoomLevel, tileList.visibleTiles, placementStartTime);
        });
        this.m_lastRenderedTextElements.length = 0;
        this.m_secondChanceTextElements.length = 0;
    }
    placeTextElements(tileDataSource, storageLevel, zoomLevel, visibleTiles, placementStartTime) {
        const sortedTiles = visibleTiles;
        sortedTiles.sort((a, b) => {
            return a.tileKey.mortonCode() - b.tileKey.mortonCode();
        });
        for (const tile of sortedTiles) {
            this.prepareUserTextElements(tile);
        }
        const sortedGroups = [];
        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
        const textElementGroups = [];
        let numTextElementsPlaced = 0;
        for (const textElementLists of sortedGroups) {
            this.selectTextElementsToPlaceByDistance(zoomLevel, textElementLists, textElementGroups);
            // The value of placementStartTime is set if this.overloaded is true.
            if (placementStartTime !== undefined) {
                // If overloaded and all time is used up, exit early.
                if (OVERLOAD_PLACEMENT_TIME_LIMIT > 0) {
                    const endTime = harp_utils_1.PerformanceTimer.now();
                    const elapsedTime = endTime - placementStartTime;
                    if (elapsedTime > OVERLOAD_PLACEMENT_TIME_LIMIT) {
                        break;
                    }
                }
                // Try not to place too many elements. They will be checked for visibility each
                // frame.
                numTextElementsPlaced += textElementLists.count();
                if (numTextElementsPlaced >= OVERLOAD_PLACED_LABEL_LIMIT) {
                    break;
                }
            }
        }
    }
    /**
     * Process any (new) user [[TextElement]], which has not been placed by the PoiManager, to set
     * it up for rendering.
     *
     * @param tile The Tile to process all user [[TextElements]] of.
     */
    prepareUserTextElements(tile) {
        for (const textElement of tile.userTextElements) {
            textElement.tileCenter = tile.center;
        }
    }
    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
        if (this.m_textRenderers.length === 0 || sortedTiles.length === 0) {
            return;
        }
        const tilesToRender = [];
        for (const tile of sortedTiles) {
            tile.placedTextElements.clear();
            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
                tilesToRender.push(tile);
            }
        }
        const groupedPriorityLists = new Map();
        for (const tile of tilesToRender) {
            for (const group of tile.textElementGroups.groups.values()) {
                if (group.elements.length === 0) {
                    continue;
                }
                const foundGroup = groupedPriorityLists.get(group.priority);
                if (foundGroup === undefined) {
                    groupedPriorityLists.set(group.priority, new TextElementLists(group.priority, [
                        new TileTextElements(tile, group.elements)
                    ]));
                }
                else {
                    foundGroup.textElementLists.push(new TileTextElements(tile, group.elements));
                }
            }
        }
        if (groupedPriorityLists.size === 0) {
            return;
        }
        for (const g of groupedPriorityLists) {
            const lists = g[1];
            sortedGroups.push(lists);
        }
        sortedGroups.sort((a, b) => {
            return b.priority - a.priority;
        });
        const printTextInfo = false;
        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
            let outString = "";
            for (const textElementLists of sortedGroups) {
                let size = 0;
                for (const tileTextElements of textElementLists.textElementLists) {
                    size += tileTextElements.textElements.length;
                }
                outString += `priority ${textElementLists.priority} size: ${size}\n`;
            }
            logger.log(outString);
        }
    }
    getMaxDistance(farDistanceLimitRatio) {
        const farDistance = this.m_mapView.camera.far;
        const maxDistance = farDistance * farDistanceLimitRatio;
        return maxDistance;
    }
    selectTextElementsToPlaceByDistance(zoomLevel, textElementLists, textElementGroups) {
        const farDistanceLimitRatio = Math.max(this.m_maxDistanceRatioForTextLabels, this.m_maxDistanceRatioForPoiLabels);
        const maxDistance = this.getMaxDistance(farDistanceLimitRatio);
        const textElementGroup = [];
        for (const tileTextElements of textElementLists.textElementLists) {
            const tile = tileTextElements.tile;
            const worldOffsetX = this.m_mapView.projection.worldExtent(0, 0).max.x * tile.offset;
            for (const textElement of tileTextElements.textElements) {
                if (!textElement.visible) {
                    continue;
                }
                // If a PoiTable is specified in the technique, the table is required to be
                // loaded before the POI can be rendered.
                if (textElement.poiInfo !== undefined &&
                    textElement.poiInfo.poiTableName !== undefined) {
                    if (this.m_mapView.poiManager.updatePoiFromPoiTable(textElement)) {
                        // Remove poiTableName to mark this POI as processed.
                        textElement.poiInfo.poiTableName = undefined;
                    }
                    else {
                        // PoiTable has not been loaded, but is required to determine
                        // visibility.
                        continue;
                    }
                }
                if (!textElement.visible ||
                    !harp_utils_1.MathUtils.isClamped(zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
                    continue;
                }
                if (textElement.tileCenter === undefined) {
                    textElement.tileCenter = new THREE.Vector3(tile.center.x + worldOffsetX, tile.center.y, tile.center.z);
                }
                else {
                    textElement.tileCenter.set(tile.center.x + worldOffsetX, tile.center.y, tile.center.z);
                }
                // If the distance is greater than allowed, skip it.
                const textDistance = this.updateViewDistance(this.m_mapView.worldCenter, textElement);
                if (this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                    tempPoiPosition.copy(textElement.position).add(textElement.tileCenter);
                    tempPoiPosition.normalize();
                    const cameraDir = new THREE.Vector3();
                    this.m_mapView.camera.getWorldDirection(cameraDir);
                    if (tempPoiPosition.dot(cameraDir) < -0.6 &&
                        textDistance !== undefined &&
                        textDistance <= maxDistance) {
                        tile.placedTextElements.add(textElement);
                    }
                }
                else if (textDistance !== undefined && textDistance <= maxDistance) {
                    tile.placedTextElements.add(textElement);
                }
            }
        }
        textElementGroups.push(textElementGroup);
    }
    renderOverlayTextElements(textElements) {
        if (this.m_textRenderers.length === 0) {
            return;
        }
        const screenSize = this.m_mapView.renderer.getSize(this.m_tmpVector);
        const screenXOrigin = -screenSize.width / 2.0;
        const screenYOrigin = screenSize.height / 2.0;
        const tempAdditionParams = {};
        const tempBufferAdditionParams = {};
        // Place text elements one by one.
        for (const textElement of textElements) {
            // Get the TextElementStyle.
            const textElementStyle = this.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            if (textCanvas === undefined) {
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            const isPathLabel = textElement.path !== undefined && !textElement.isLineMarker;
            // Trigger the glyph load if needed.
            if (textElement.loadingState === undefined) {
                textElement.loadingState = TextElement_1.LoadingState.Requested;
                if (textElement.renderStyle === undefined) {
                    textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, textElementStyle.renderParams, textElement.renderParams));
                }
                if (textElement.layoutStyle === undefined) {
                    textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, textElementStyle.layoutParams, textElement.layoutParams));
                }
                if (textElement.text === "") {
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                }
                else {
                    textCanvas.fontCatalog
                        .loadCharset(textElement.text, textElement.renderStyle)
                        .then(() => {
                        textElement.loadingState = TextElement_1.LoadingState.Loaded;
                        this.m_mapView.update();
                    });
                }
            }
            if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
                if (this.m_initializedTextElementCount < MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME) {
                    textCanvas.textRenderStyle = textElement.renderStyle;
                    textCanvas.textLayoutStyle = textElement.layoutStyle;
                    textElement.glyphCaseArray = [];
                    textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
                    textElement.loadingState = TextElement_1.LoadingState.Initialized;
                    ++this.m_initializedTextElementCount;
                }
            }
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                continue;
            }
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Place text.
            let textPath;
            if (!isPathLabel) {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                tempPosition.x = tempScreenPosition.x;
                tempPosition.y = tempScreenPosition.y;
                tempPosition.z = 0.0;
                tempBufferAdditionParams.position = tempPosition;
                tempAdditionParams.layer = textElement.renderOrder;
                tempAdditionParams.letterCaseArray = textElement.glyphCaseArray;
                tempAdditionParams.pickingData = textElement.userData ? textElement : undefined;
                textCanvas.addText(textElement.glyphs, tempPosition, tempAdditionParams);
            }
            else {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin;
                tempScreenPosition.y = screenYOrigin;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                // Get the screen points that define the label's segments and create a path with
                // them.
                // TODO: Optimize array allocations.
                const screenPoints = [];
                for (const pt of textElement.path) {
                    const pX = tempScreenPosition.x + pt.x * screenSize.width;
                    const pY = tempScreenPosition.y - pt.y * screenSize.height;
                    screenPoints.push(new THREE.Vector2(pX, pY));
                }
                textPath = new SimplePath_1.SimplePath();
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                tempAdditionParams.path = textPath;
                tempAdditionParams.pathOverflow = true;
                tempAdditionParams.layer = textElement.renderOrder;
                tempAdditionParams.letterCaseArray = textElement.glyphCaseArray;
                tempAdditionParams.pickingData = textElement.userData ? textElement : undefined;
                textCanvas.addText(textElement.glyphs, tempPosition, tempAdditionParams);
            }
        }
    }
    getDistanceScalingFactor(label, distance) {
        // Distance scale is based on relation between camera focus point distance and
        // the actual label distance. For labels close to camera look at point the scale
        // remains unchanged, the farther is label from that point the smaller size it is
        // rendered in screen space. This method is unaffected by near and far clipping planes
        // distances, but may be improved by taking FOV into equation or customizing the
        // focus point screen position based on horizont, actual ground, tilt ets.
        let factor = this.m_mapView.lookAtDistance / distance;
        // The label.distanceScale property defines the influence ratio at which
        // distance affects the final scaling of label.
        factor = 1.0 + (factor - 1.0) * label.distanceScale;
        // Preserve the constraints
        factor = Math.max(factor, this.m_labelDistanceScaleMin);
        factor = Math.min(factor, this.m_labelDistanceScaleMax);
        return factor;
    }
    getDistanceFadingFactor(label, cameraFar) {
        let distanceFadeValue = 1.0;
        const textDistance = label.currentViewDistance;
        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {
            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;
            const fadeFar = label.fadeFar;
            if (fadeFar > fadeNear) {
                distanceFadeValue =
                    1.0 -
                        harp_utils_1.MathUtils.clamp((textDistance / cameraFar - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);
            }
        }
        return distanceFadeValue;
    }
    renderTextElements(textElements, time, frameNumber, zoomLevel, renderedTextElements, secondChanceTextElements) {
        if (this.m_textRenderers.length === 0) {
            return 0;
        }
        const currentlyRenderingPlacedElements = renderedTextElements === undefined;
        const printInfo = textElements.length > 5000;
        let numNotVisible = 0;
        let numPathTooSmall = 0;
        let numCannotAdd = 0;
        let numRenderedPoiIcons = 0;
        let numRenderedPoiTexts = 0;
        let numPoiTextsInvisible = 0;
        const maxNumRenderedLabels = this.m_maxNumVisibleLabels;
        const numSecondChanceLabels = this.m_numSecondChanceLabels;
        let numRenderedTextElements = 0;
        const shieldGroups = [];
        const textMaxDistance = this.getMaxDistance(this.m_maxDistanceRatioForTextLabels);
        const poiTextMaxDistance = this.getMaxDistance(this.m_maxDistanceRatioForPoiLabels);
        const cameraIsMoving = this.m_mapView.cameraIsMoving;
        const cameraFar = this.m_mapView.camera.far;
        // Keep track if we need to call another update() on MapView.
        let fadeAnimationRunning = false;
        const tempAdditionParams = {};
        const tempPoiMeasurementParams = {};
        const tempMeasurementParams = {};
        const tempBufferAdditionParams = {};
        const tileGeometryManager = this.m_mapView.tileGeometryManager;
        const hiddenKinds = tileGeometryManager !== undefined ? tileGeometryManager.hiddenGeometryKinds : undefined;
        // Place text elements one by one.
        for (const textElement of textElements) {
            if (!currentlyRenderingPlacedElements &&
                maxNumRenderedLabels >= 0 &&
                numRenderedTextElements >= maxNumRenderedLabels) {
                break;
            }
            // Get the TextElementStyle.
            const textElementStyle = this.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            const poiRenderer = textElementStyle.poiRenderer;
            if (textCanvas === undefined || poiRenderer === undefined) {
                continue;
            }
            // Check if the label should be hidden.
            if (hiddenKinds !== undefined &&
                textElement.kind !== undefined &&
                hiddenKinds.hasOrIntersects(textElement.kind)) {
                continue;
            }
            const isPathLabel = textElement.path !== undefined && !textElement.isLineMarker;
            let screenPoints;
            // For paths, check if the label may fit.
            if (isPathLabel) {
                const screenPointsResult = this.checkForSmallLabels(textElement);
                if (screenPointsResult === undefined) {
                    numNotVisible++;
                    if (textElement.dbgPathTooSmall === true) {
                        numPathTooSmall++;
                    }
                    continue;
                }
                screenPoints = screenPointsResult;
            }
            // Trigger the glyph load if needed.
            if (textElement.loadingState === undefined) {
                textElement.loadingState = TextElement_1.LoadingState.Requested;
                if (textElement.renderStyle === undefined) {
                    textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign({}, textElementStyle.renderParams, textElement.renderParams));
                }
                if (textElement.layoutStyle === undefined) {
                    textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign({}, textElementStyle.layoutParams, textElement.layoutParams));
                }
                if (textElement.text === "") {
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                }
                else {
                    textCanvas.fontCatalog
                        .loadCharset(textElement.text, textElement.renderStyle)
                        .then(() => {
                        textElement.loadingState = TextElement_1.LoadingState.Loaded;
                        this.m_mapView.update();
                    });
                }
            }
            if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
                if (this.m_initializedTextElementCount < MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME) {
                    textCanvas.textRenderStyle = textElement.renderStyle;
                    textCanvas.textLayoutStyle = textElement.layoutStyle;
                    textElement.glyphCaseArray = [];
                    textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
                    if (!isPathLabel) {
                        textElement.bounds = new THREE.Box2();
                        tempPoiMeasurementParams.letterCaseArray = textElement.glyphCaseArray;
                        textCanvas.measureText(textElement.glyphs, textElement.bounds, tempPoiMeasurementParams);
                    }
                    textElement.loadingState = TextElement_1.LoadingState.Initialized;
                    ++this.m_initializedTextElementCount;
                }
            }
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                if (secondChanceTextElements !== undefined &&
                    secondChanceTextElements.length < numSecondChanceLabels) {
                    secondChanceTextElements.push(textElement);
                }
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    ++numCannotAdd;
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Define the point, poi, lineMarker and path label placement functions.
            const addPointLabel = (pointLabel, iconRenderState, textRenderState, position, screenPosition) => {
                // Find the label's original position.
                tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
                tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
                // Offset the label accordingly to alignment (and POI, if any).
                let xOffset = (pointLabel.xOffset || 0.0) *
                    (pointLabel.layoutStyle.horizontalAlignment === harp_text_canvas_1.HorizontalAlignment.Right
                        ? -1.0
                        : 1.0);
                let yOffset = (pointLabel.yOffset || 0.0) *
                    (pointLabel.layoutStyle.verticalAlignment === harp_text_canvas_1.VerticalAlignment.Below
                        ? -1.0
                        : 1.0);
                if (pointLabel.poiInfo !== undefined) {
                    xOffset +=
                        pointLabel.poiInfo.computedWidth *
                            (0.5 + pointLabel.layoutStyle.horizontalAlignment);
                    yOffset +=
                        pointLabel.poiInfo.computedHeight *
                            (0.5 + pointLabel.layoutStyle.verticalAlignment);
                }
                tempScreenPosition.x += xOffset;
                tempScreenPosition.y += yOffset;
                // If we try to place text above their current position, we need to compensate for
                // its bounding box height.
                if (pointLabel.layoutStyle.verticalAlignment === harp_text_canvas_1.VerticalAlignment.Above) {
                    tempScreenPosition.y += -pointLabel.bounds.min.y;
                }
                // Scale the text depending on the label's distance to the camera.
                let textScale = 1.0;
                let distanceScaleFactor = 1.0;
                const textDistance = this.m_mapView.worldCenter.distanceTo(position);
                if (textDistance !== undefined) {
                    if (pointLabel.fadeFar !== undefined &&
                        (pointLabel.fadeFar <= 0.0 || pointLabel.fadeFar * cameraFar < textDistance)) {
                        // The label is farther away than fadeFar value, which means it is totally
                        // transparent.
                        return false;
                    }
                    textElement.currentViewDistance = textDistance;
                    distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance);
                    textScale *= distanceScaleFactor;
                }
                const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, cameraFar);
                // Check if there is need to check for screen space for the label's icon.
                const poiInfo = pointLabel.poiInfo;
                let iconSpaceAvailable = true;
                // Check if icon should be rendered at this zoomLevel
                const renderIcon = poiInfo === undefined ||
                    harp_utils_1.MathUtils.isClamped(zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);
                if (renderIcon && poiInfo !== undefined && poiRenderer.prepareRender(pointLabel)) {
                    if (poiInfo.isValid === false) {
                        return false;
                    }
                    const iconIsVisible = poiRenderer.computeScreenBox(poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_screenCollisions, tempBox2D);
                    if (iconIsVisible) {
                        iconSpaceAvailable = poiRenderer.isSpaceAvailable(this.m_screenCollisions, tempBox2D);
                        // Reserve screen space if necessary, return false if failed:
                        if (
                        // Check if free screen space is available:
                        !iconSpaceAvailable) {
                            if (!iconRenderState.isVisible()) {
                                return false;
                            }
                            else if (!(poiInfo.mayOverlap === true) &&
                                !iconRenderState.isFadingOut()) {
                                this.startFadeOut(iconRenderState, frameNumber, time);
                                if (textRenderState !== undefined && textRenderState.isVisible()) {
                                    this.startFadeOut(textRenderState, frameNumber, time);
                                }
                            }
                        }
                        else {
                            if (iconRenderState.lastFrameNumber < frameNumber - 1 ||
                                iconRenderState.isFadingOut() ||
                                iconRenderState.isFadedOut()) {
                                this.startFadeIn(iconRenderState, frameNumber, time);
                            }
                        }
                    }
                    // If the icon is prepared and valid, but just not visible, try again next time.
                    else {
                        if (secondChanceTextElements !== undefined &&
                            secondChanceTextElements.length < numSecondChanceLabels) {
                            secondChanceTextElements.push(pointLabel);
                        }
                        // Forced making it un-current.
                        iconRenderState.lastFrameNumber = -1;
                        return false;
                    }
                    if (iconRenderState.isFading()) {
                        this.updateFading(iconRenderState, time);
                    }
                }
                // Check if label should be rendered at this zoomLevel
                const renderText = poiInfo === undefined ||
                    zoomLevel === undefined ||
                    harp_utils_1.MathUtils.isClamped(zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);
                // Check if we should render the label's text.
                const doRenderText = 
                // Render if between min/max zoom level
                renderText &&
                    // Do not render if the distance is too great and distance shouldn't be ignored.
                    (pointLabel.ignoreDistance === true ||
                        (pointLabel.currentViewDistance === undefined ||
                            pointLabel.currentViewDistance < poiTextMaxDistance)) &&
                    // Do not render text if POI cannot be rendered and is not optional.
                    (poiInfo === undefined ||
                        poiInfo.isValid === true ||
                        poiInfo.iconIsOptional !== false);
                // Render the label's text...
                if (doRenderText && textElement.text !== "") {
                    // Adjust the label positioning to match its bounding box.
                    tempPosition.x = tempScreenPosition.x;
                    tempPosition.y = tempScreenPosition.y;
                    tempPosition.z = textElement.renderDistance;
                    tempBox2D.x = tempScreenPosition.x + pointLabel.bounds.min.x * textScale;
                    tempBox2D.y = tempScreenPosition.y + pointLabel.bounds.min.y * textScale;
                    tempBox2D.w = (pointLabel.bounds.max.x - pointLabel.bounds.min.x) * textScale;
                    tempBox2D.h = (pointLabel.bounds.max.y - pointLabel.bounds.min.y) * textScale;
                    // TODO: Make the margin configurable
                    tempBox2D.x -= 4 * textScale;
                    tempBox2D.y -= 2 * textScale;
                    tempBox2D.w += 8 * textScale;
                    tempBox2D.h += 4 * textScale;
                    // Check the text visibility.
                    if (!this.m_screenCollisions.isVisible(tempBox2D)) {
                        if (secondChanceTextElements !== undefined &&
                            secondChanceTextElements.length < numSecondChanceLabels) {
                            secondChanceTextElements.push(pointLabel);
                        }
                        numPoiTextsInvisible++;
                        return false;
                    }
                    const textIsOptional = pointLabel.poiInfo !== undefined &&
                        pointLabel.poiInfo.textIsOptional === true;
                    const textIsFadingIn = textRenderState !== undefined && textRenderState.isFadingIn();
                    const textIsFadingOut = textRenderState !== undefined && textRenderState.isFadingOut();
                    const textSpaceAvailable = !this.m_screenCollisions.isAllocated(tempBox2D);
                    const textVisible = pointLabel.textMayOverlap ||
                        textSpaceAvailable ||
                        textIsFadingIn ||
                        textIsFadingOut;
                    if (textVisible) {
                        // Compute the TextBufferObject when we know we're gonna render this label.
                        if (pointLabel.textBufferObject === undefined) {
                            pointLabel.textBufferObject = textCanvas.createTextBufferObject(pointLabel.glyphs);
                        }
                        // Allocate collision info if needed.
                        if (!textIsFadingOut && pointLabel.textReservesSpace) {
                            this.m_screenCollisions.allocate(tempBox2D);
                        }
                        // Do not actually render (just allocate space) if camera is moving and
                        // renderTextDuringMovements is not true.
                        if ((textIsFadingIn ||
                            textIsFadingOut ||
                            !cameraIsMoving ||
                            (poiInfo === undefined ||
                                poiInfo.renderTextDuringMovements === true)) &&
                            !iconRenderState.isFadedOut()) {
                            let textFading = false;
                            if (!iconRenderState.isFadingOut() &&
                                textSpaceAvailable &&
                                iconSpaceAvailable) {
                                textFading = this.checkStartFadeIn(textRenderState, frameNumber, time, true);
                            }
                            else if (textRenderState !== undefined) {
                                if (textRenderState.isFading()) {
                                    this.updateFading(textRenderState, time);
                                    textFading = true;
                                }
                            }
                            fadeAnimationRunning =
                                fadeAnimationRunning || textIsFadingOut || textFading;
                            const opacity = textRenderState !== undefined
                                ? textRenderState.opacity
                                : iconRenderState.opacity;
                            tempBufferAdditionParams.layer = pointLabel.renderOrder;
                            tempBufferAdditionParams.position = tempPosition;
                            tempBufferAdditionParams.scale = textScale;
                            tempBufferAdditionParams.opacity =
                                opacity * distanceFadeFactor * textElement.renderStyle.opacity;
                            tempBufferAdditionParams.backgroundOpacity =
                                tempBufferAdditionParams.opacity *
                                    textElement.renderStyle.backgroundOpacity;
                            tempBufferAdditionParams.pickingData = textElement.userData
                                ? textElement
                                : undefined;
                            textCanvas.addTextBufferObject(pointLabel.textBufferObject, tempBufferAdditionParams);
                        }
                        numRenderedPoiTexts++;
                    }
                    // If the text is not visible nor optional, we won't render the icon neither.
                    else if (!renderIcon || !textIsOptional) {
                        if (pointLabel.poiInfo === undefined || iconRenderState.isVisible()) {
                            if (pointLabel.poiInfo !== undefined) {
                                this.startFadeOut(iconRenderState, frameNumber, time);
                            }
                            if (textRenderState !== undefined && textRenderState.isVisible()) {
                                const iconStartedFadeOut = this.checkStartFadeOut(textRenderState, frameNumber, time);
                                fadeAnimationRunning = fadeAnimationRunning || iconStartedFadeOut;
                            }
                            this.startFadeOut(iconRenderState, frameNumber, time);
                        }
                        else {
                            if (secondChanceTextElements !== undefined &&
                                secondChanceTextElements.length < numSecondChanceLabels) {
                                secondChanceTextElements.push(pointLabel);
                            }
                            numPoiTextsInvisible++;
                            return false;
                        }
                    }
                    // If the label is currently visible, fade it out.
                    else if (textRenderState !== undefined && textRenderState.isVisible()) {
                        const iconStartedFadeOut = this.checkStartFadeOut(textRenderState, frameNumber, time);
                        fadeAnimationRunning = fadeAnimationRunning || iconStartedFadeOut;
                    }
                }
                // ... and render the icon (if any).
                if (renderIcon && poiInfo !== undefined && poiRenderer.poiIsRenderable(poiInfo)) {
                    const iconStartedFadeIn = this.checkStartFadeIn(iconRenderState, frameNumber, time);
                    fadeAnimationRunning = fadeAnimationRunning || iconStartedFadeIn;
                    poiRenderer.renderPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, distanceScaleFactor, poiInfo.reserveSpace !== false, iconRenderState.opacity * distanceFadeFactor);
                    iconRenderState.lastFrameNumber = frameNumber;
                    numRenderedPoiIcons++;
                }
                // Add this label to the list of rendered elements.
                if (renderedTextElements !== undefined) {
                    renderedTextElements.push(pointLabel);
                }
                numRenderedTextElements++;
                return true;
            };
            const addPoiLabel = (poiLabel) => {
                // Calculate the world position of this label.
                tempPosition.copy(poiLabel.position).add(poiLabel.tileCenter);
                // Only process labels frustum-clipped labels
                if (this.m_screenProjector.project(tempPosition, tempScreenPosition) !== undefined) {
                    // Initialize the POI's icon and text render states (fading).
                    if (poiLabel.iconRenderState === undefined) {
                        poiLabel.iconRenderState = new TextElement_1.RenderState();
                        poiLabel.textRenderState = new TextElement_1.RenderState();
                        if (this.m_mapView.fadingDisabled) {
                            // Force fadingTime to zero to keep it from fading in and out.
                            poiLabel.iconRenderState.fadingTime = 0;
                            poiLabel.textRenderState.fadingTime = 0;
                        }
                    }
                    // Add this POI as a point label.
                    addPointLabel(poiLabel, poiLabel.iconRenderState, poiLabel.textRenderState, tempPosition, tempScreenPosition);
                }
            };
            const addLineMarkerLabel = (lineMarkerLabel) => {
                // Early exit if the line marker doesn't have the necessary data.
                const poiInfo = lineMarkerLabel.poiInfo;
                if (lineMarkerLabel.path === undefined ||
                    lineMarkerLabel.path.length === 0 ||
                    !poiRenderer.prepareRender(lineMarkerLabel)) {
                    return;
                }
                // Initialize the shield group for this lineMarker.
                let shieldGroup;
                if (poiInfo.shieldGroupIndex !== undefined) {
                    shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
                    if (shieldGroup === undefined) {
                        shieldGroup = [];
                        shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
                    }
                }
                // Create an individual render state for every individual point of the lineMarker.
                if (lineMarkerLabel.iconRenderStates === undefined) {
                    const renderStates = new Array();
                    lineMarkerLabel.path.forEach(() => {
                        const renderState = new TextElement_1.RenderState();
                        renderState.state = TextElement_1.FadingState.FadingIn;
                        renderState.fadingTime = this.m_mapView.fadingDisabled
                            ? 0
                            : renderState.fadingTime;
                        renderStates.push(renderState);
                    });
                    lineMarkerLabel.iconRenderStates = renderStates;
                }
                const lineTechnique = poiInfo.technique;
                const minDistanceSqr = lineTechnique.minDistance !== undefined
                    ? lineTechnique.minDistance * lineTechnique.minDistance
                    : 0;
                // Process markers (with shield groups).
                if (minDistanceSqr > 0 && shieldGroup !== undefined) {
                    for (let i = 0; i < lineMarkerLabel.path.length; i++) {
                        const point = lineMarkerLabel.path[i];
                        // Calculate the world position of this label.
                        tempPosition.copy(point).add(lineMarkerLabel.tileCenter);
                        // Only process labels frustum-clipped labels
                        if (this.m_screenProjector.project(tempPosition, tempScreenPosition) !==
                            undefined) {
                            // Find a suitable location for the lineMarker to be placed at.
                            let tooClose = false;
                            for (let j = 0; j < shieldGroup.length; j += 2) {
                                const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
                                tooClose = distanceSqr < minDistanceSqr;
                                if (tooClose) {
                                    break;
                                }
                            }
                            // Place it as a point label if it's not to close to other marker in the
                            // same shield group.
                            if (!tooClose) {
                                if (addPointLabel(lineMarkerLabel, lineMarkerLabel.iconRenderStates[i], undefined, tempPosition, tempScreenPosition)) {
                                    shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
                                }
                            }
                        }
                    }
                }
                // Process markers (without shield groups).
                else {
                    for (let i = 0; i < lineMarkerLabel.path.length; i++) {
                        const point = lineMarkerLabel.path[i];
                        // Calculate the world position of this label.
                        tempPosition.copy(point).add(lineMarkerLabel.tileCenter);
                        // Only process labels frustum-clipped labels
                        if (this.m_screenProjector.project(tempPosition, tempScreenPosition) !==
                            undefined) {
                            addPointLabel(lineMarkerLabel, lineMarkerLabel.iconRenderStates[i], undefined, tempPosition, tempScreenPosition);
                        }
                    }
                }
            };
            const addPathLabel = (pathLabel) => {
                // Limit the text rendering of path labels in the far distance.
                if (!(pathLabel.ignoreDistance === true ||
                    pathLabel.currentViewDistance === undefined ||
                    pathLabel.currentViewDistance < textMaxDistance)) {
                    return false;
                }
                if (pathLabel.fadeFar !== undefined &&
                    (pathLabel.fadeFar <= 0.0 ||
                        pathLabel.fadeFar * cameraFar < pathLabel.renderDistance)) {
                    // The label is farther away than fadeFar value, which means it is totally
                    // transparent
                    return false;
                }
                // Compute values common for all glyphs in the label.
                let textScale = textCanvas.textRenderStyle.fontSize.size / 100.0;
                let opacity = textElement.renderStyle.opacity;
                // Get the screen points that define the label's segments and create a path with
                // them.
                let textPath = new THREE.Path();
                tempScreenPosition.copy(screenPoints[0]);
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                // Flip the path if the label is gonna be rendered downwards.
                if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
                    tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
                    textPath = new THREE.Path();
                    for (let i = screenPoints.length - 1; i > 0; --i) {
                        textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));
                    }
                }
                // Update the real rendering distance to have smooth fading and scaling
                this.updateViewDistance(this.m_mapView.worldCenter, pathLabel);
                const textRenderDistance = -pathLabel.renderDistance;
                // Scale the text depending on the label's distance to the camera.
                const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance);
                textScale *= distanceScaleFactor;
                // Scale the path label correctly.
                const prevSize = textCanvas.textRenderStyle.fontSize.size;
                textCanvas.textRenderStyle.fontSize.size = textScale * 100;
                // Recalculate the text bounds for this path label. If measurement fails, the whole
                // label doesn't fit the path and should be discarded.
                tempMeasurementParams.path = textPath;
                tempMeasurementParams.outputCharacterBounds = tempBoxes;
                tempMeasurementParams.letterCaseArray = pathLabel.glyphCaseArray;
                if (!textCanvas.measureText(pathLabel.glyphs, tempBox, tempMeasurementParams)) {
                    textCanvas.textRenderStyle.fontSize.size = prevSize;
                    return false;
                }
                // Perform per-character collision checks.
                for (const charBounds of tempBoxes) {
                    tempBox2D.x = tempScreenPosition.x + charBounds.min.x;
                    tempBox2D.y = tempScreenPosition.y + charBounds.min.y;
                    tempBox2D.w = charBounds.max.x - charBounds.min.x;
                    tempBox2D.h = charBounds.max.y - charBounds.min.y;
                    if (!this.m_screenCollisions.isVisible(tempBox2D) ||
                        (!textElement.textMayOverlap &&
                            this.m_screenCollisions.isAllocated(tempBox2D))) {
                        textCanvas.textRenderStyle.fontSize.size = prevSize;
                        return false;
                    }
                }
                // Fade-in after skipping rendering during movement.
                // NOTE: Shouldn't this only happen once we know the label is gonna be visible?
                if (pathLabel.textRenderState === undefined) {
                    pathLabel.textRenderState = new TextElement_1.RenderState();
                    pathLabel.textRenderState.fadingTime = this.m_mapView.fadingDisabled
                        ? 0
                        : pathLabel.textRenderState.fadingTime;
                }
                if (pathLabel.textRenderState.state === TextElement_1.FadingState.Undefined ||
                    pathLabel.textRenderState.lastFrameNumber < frameNumber - 1) {
                    this.startFadeIn(pathLabel.textRenderState, frameNumber, time);
                }
                const startedFadeIn = this.checkStartFadeIn(pathLabel.textRenderState, frameNumber, time);
                fadeAnimationRunning = fadeAnimationRunning || startedFadeIn;
                if (pathLabel.textRenderState.isFading()) {
                    opacity = pathLabel.textRenderState.opacity * textElement.renderStyle.opacity;
                }
                const prevOpacity = textCanvas.textRenderStyle.opacity;
                const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
                const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, cameraFar);
                textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
                textCanvas.textRenderStyle.backgroundOpacity =
                    textCanvas.textRenderStyle.opacity * textElement.renderStyle.backgroundOpacity;
                tempPosition.z = textElement.renderDistance;
                tempAdditionParams.path = textPath;
                tempAdditionParams.layer = pathLabel.renderOrder;
                tempAdditionParams.letterCaseArray = pathLabel.glyphCaseArray;
                tempAdditionParams.pickingData = textElement.userData ? textElement : undefined;
                textCanvas.addText(pathLabel.glyphs, tempPosition, tempAdditionParams);
                // Allocate collision info if needed.
                if (pathLabel.textReservesSpace) {
                    tempBox2D.x = tempScreenPosition.x + tempBox.min.x;
                    tempBox2D.y = tempScreenPosition.y + tempBox.min.y;
                    tempBox2D.w = tempBox.max.x - tempBox.min.x;
                    tempBox2D.h = tempBox.max.y - tempBox.min.y;
                    this.m_screenCollisions.allocate(tempBox2D);
                }
                // Add this label to the list of rendered elements.
                if (renderedTextElements !== undefined) {
                    renderedTextElements.push(pathLabel);
                }
                numRenderedTextElements++;
                // Restore previous style values for text elements using the same style.
                textCanvas.textRenderStyle.fontSize.size = prevSize;
                textCanvas.textRenderStyle.opacity = prevOpacity;
                textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
                return true;
            };
            // Render a POI...
            if (textElement.path === undefined) {
                addPoiLabel(textElement);
            }
            // ... a line marker...
            else if (textElement.isLineMarker) {
                addLineMarkerLabel(textElement);
            }
            // ... or a path label.
            else {
                addPathLabel(textElement);
            }
        }
        if (PRINT_LABEL_DEBUG_INFO && printInfo) {
            logger.log("textElements.length", textElements.length);
            logger.log("numRenderedTextElements", numRenderedTextElements);
            logger.log("numRenderedPoiIcons", numRenderedPoiIcons);
            logger.log("numRenderedPoiTexts", numRenderedPoiTexts);
            logger.log("numPoiTextsInvisible", numPoiTextsInvisible);
            logger.log("numNotVisible", numNotVisible);
            logger.log("numPathTooSmall", numPathTooSmall);
            logger.log("numCannotAdd", numCannotAdd);
        }
        if (!this.m_mapView.fadingDisabled && fadeAnimationRunning) {
            this.m_mapView.update();
        }
        return numRenderedTextElements;
    }
    checkForSmallLabels(textElement) {
        let indexOfFirstVisibleScreenPoint = -1;
        // Get the screen points that define the label's segments and create a path with
        // them.
        const screenPoints = [];
        let minX = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;
        for (const pt of textElement.path) {
            tempPosition.copy(pt).add(textElement.tileCenter);
            const screenPoint = this.m_screenProjector.project(tempPosition, tempScreenPosition);
            if (screenPoint === undefined) {
                continue;
            }
            screenPoints.push(tempScreenPosition.clone());
            if (screenPoint.x < minX) {
                minX = screenPoint.x;
            }
            if (screenPoint.x > maxX) {
                maxX = screenPoint.x;
            }
            if (screenPoint.y < minY) {
                minY = screenPoint.y;
            }
            if (screenPoint.y > maxY) {
                maxY = screenPoint.y;
            }
            if (indexOfFirstVisibleScreenPoint < 0) {
                const firstIndex = screenPoints.findIndex(p2 => {
                    return this.m_screenCollisions.screenBounds.contains(p2.x, p2.y);
                });
                if (firstIndex >= 0) {
                    indexOfFirstVisibleScreenPoint = firstIndex;
                }
            }
        }
        // TODO: (HARP-3515)
        //      The rendering of a path label that contains just a single point that is not
        //      visible is impossible, which is problematic with long paths.
        //      Fix: Skip/clip the invisible points at beginning and end of the path to get
        //      the visible part of the path.
        // If not a single point is visible, skip the path
        if (indexOfFirstVisibleScreenPoint === -1) {
            return undefined;
        }
        // Check/guess if the screen box can hold a string of that length. It is important
        // to guess that value without measuring the font first to save time.
        const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
        if ((maxX - minX) * (maxX - minX) + (maxY - minY) * (maxY - minY) <
            minScreenSpace * minScreenSpace) {
            textElement.dbgPathTooSmall = true;
            return undefined;
        }
        return screenPoints;
    }
    renderTileList(visibleTiles, time, frameNumber, zoomLevel, renderStartTime, renderedTextElements, secondChanceTextElements) {
        if (this.m_textRenderers.length === 0 || visibleTiles.length === 0) {
            return;
        }
        const consideredTextElements = new harp_utils_1.GroupedPriorityList();
        for (const tile of visibleTiles) {
            consideredTextElements.merge(tile.placedTextElements);
        }
        const maxNumRenderedTextElements = this.m_maxNumVisibleLabels;
        let numRenderedTextElements = 0;
        for (const elementGroup of consideredTextElements.sortedGroups) {
            const textElementsInGroup = elementGroup.elements;
            this.sortTextElements(textElementsInGroup, this.m_mapView.camera.far);
            numRenderedTextElements += this.renderTextElements(textElementsInGroup, time, frameNumber, zoomLevel, renderedTextElements, secondChanceTextElements);
            if (numRenderedTextElements > maxNumRenderedTextElements) {
                break;
            }
            // renderStartTime is set if this.overloaded is true
            if (renderStartTime !== undefined && OVERLOAD_RENDER_TIME_LIMIT > 0) {
                const endTime = harp_utils_1.PerformanceTimer.now();
                const elapsedTime = endTime - renderStartTime;
                if (elapsedTime > OVERLOAD_RENDER_TIME_LIMIT) {
                    return;
                }
            }
        }
    }
    checkIfOverloaded() {
        const renderList = this.m_mapView.visibleTileSet.dataSourceTileList;
        // Count the number of TextElements in the scene to see if we have to switch to
        // "overloadMode".
        let numTextElementsInScene = 0;
        renderList.forEach(renderListEntry => {
            for (const tile of renderListEntry.renderedTiles) {
                numTextElementsInScene += tile.textElementGroups.count();
                numTextElementsInScene += tile.userTextElements.length;
            }
        });
        this.m_overloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
        return this.m_overloaded;
    }
    checkStartFadeIn(renderState, frameNumber, time, forceFadeIn = false) {
        let fadeAnimationStarted = false;
        if (renderState !== undefined) {
            // Fade-in after skipping rendering during movement
            if (forceFadeIn ||
                renderState.state === TextElement_1.FadingState.Undefined ||
                renderState.lastFrameNumber < frameNumber - 1) {
                this.startFadeIn(renderState, frameNumber, time);
            }
            if (renderState.isFading()) {
                this.updateFading(renderState, time);
                fadeAnimationStarted = true;
            }
            renderState.lastFrameNumber = frameNumber;
        }
        return fadeAnimationStarted;
    }
    checkStartFadeOut(renderState, frameNumber, time, forceFadeOut = true) {
        let fadeAnimationStarted = false;
        if (renderState !== undefined) {
            // Fade-in after skipping rendering during movement
            if (forceFadeOut ||
                renderState.state === TextElement_1.FadingState.Undefined ||
                renderState.lastFrameNumber < frameNumber - 1) {
                this.startFadeOut(renderState, frameNumber, time);
            }
            if (renderState.isFading()) {
                this.updateFading(renderState, time);
                fadeAnimationStarted = true;
            }
            renderState.lastFrameNumber = frameNumber;
        }
        return fadeAnimationStarted;
    }
    startFadeIn(renderState, frameNumber, time) {
        if (renderState.lastFrameNumber < frameNumber - 1) {
            renderState.reset();
        }
        if (renderState.state === TextElement_1.FadingState.FadingIn ||
            renderState.state === TextElement_1.FadingState.FadedIn) {
            return;
        }
        if (renderState.state === TextElement_1.FadingState.FadingOut) {
            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            renderState.value = 1.0 - renderState.value;
            renderState.startTime = time - renderState.value * renderState.fadingTime;
        }
        else {
            renderState.startTime = time;
            renderState.value = 0.0;
            renderState.opacity = 0;
        }
        renderState.state = TextElement_1.FadingState.FadingIn;
    }
    startFadeOut(renderState, frameNumber, time) {
        if (renderState.lastFrameNumber < frameNumber - 1) {
            renderState.reset();
        }
        if (renderState.state === TextElement_1.FadingState.FadingOut ||
            renderState.state === TextElement_1.FadingState.FadedOut) {
            return;
        }
        if (renderState.state === TextElement_1.FadingState.FadingIn) {
            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            renderState.startTime = time - renderState.value * renderState.fadingTime;
            renderState.value = 1.0 - renderState.value;
        }
        else {
            renderState.startTime = time;
            renderState.value = 0.0;
            renderState.opacity = 1;
        }
        renderState.state = TextElement_1.FadingState.FadingOut;
    }
    updateFading(renderState, time) {
        if (renderState.state !== TextElement_1.FadingState.FadingIn &&
            renderState.state !== TextElement_1.FadingState.FadingOut) {
            return;
        }
        if (renderState.startTime === 0) {
            renderState.startTime = time;
        }
        const fadingTime = time - renderState.startTime;
        const startValue = renderState.state === TextElement_1.FadingState.FadingIn ? 0 : 1;
        const endValue = renderState.state === TextElement_1.FadingState.FadingIn ? 1 : 0;
        if (fadingTime >= renderState.fadingTime) {
            renderState.value = 1.0;
            renderState.opacity = endValue;
            renderState.state =
                renderState.state === TextElement_1.FadingState.FadingIn
                    ? TextElement_1.FadingState.FadedIn
                    : TextElement_1.FadingState.FadedOut;
        }
        else {
            renderState.value = fadingTime / renderState.fadingTime;
            renderState.opacity = harp_utils_1.MathUtils.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, renderState.value), 0, 1);
        }
    }
}
exports.TextElementsRenderer = TextElementsRenderer;


/***/ }),

/***/ "../harp-mapview/lib/text/TextStyleCache.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/text/TextStyleCache.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
/**
 * [[TextStyle]] id for the default value inside a [[TextRenderStyleCache]] or a
 * [[TextLayoutStyleCache]].
 */
exports.DEFAULT_TEXT_STYLE_CACHE_ID = "Default";
/**
 * Calculates the [[TextStyle]] id that identifies either a [[TextRenderStyle]] or a
 * [[TextLayoutStyle]] inside a [[TextRenderStyleCache]] or a [[TextLayoutStyleCache]],
 * respectively.
 *
 * @param technique Technique defining the [[TextStyle]].
 * @param zoomLevel Zoom level for which to interpret the technique.
 *
 * @returns [[TextStyle]] id.
 */
function computeStyleCacheId(datasourceName, technique, zoomLevel) {
    return `${datasourceName}_${technique._styleSetIndex}_${zoomLevel}`;
}
exports.computeStyleCacheId = computeStyleCacheId;
/**
 * Cache storing [[MapView]]'s [[TextRenderStyle]]s.
 */
class TextRenderStyleCache {
    constructor() {
        this.m_map = new Map();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 32,
                backgroundSize: 8
            },
            color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
            backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
            backgroundOpacity: 0.5
        }));
    }
    get size() {
        return this.m_map.size;
    }
    get(id) {
        return this.m_map.get(id);
    }
    set(id, value) {
        this.m_map.set(id, value);
    }
    clear() {
        this.m_map.clear();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 32,
                backgroundSize: 8
            },
            color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
            backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
            backgroundOpacity: 0.5
        }));
    }
}
exports.TextRenderStyleCache = TextRenderStyleCache;
/**
 * Cache storing [[MapView]]'s [[TextLayoutStyle]]s.
 */
class TextLayoutStyleCache {
    constructor() {
        this.m_map = new Map();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({
            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
        }));
    }
    get size() {
        return this.m_map.size;
    }
    get(id) {
        return this.m_map.get(id);
    }
    set(id, value) {
        this.m_map.set(id, value);
    }
    clear() {
        this.m_map.clear();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({
            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
        }));
    }
}
exports.TextLayoutStyleCache = TextLayoutStyleCache;


/***/ }),

/***/ "../harp-mapview/lib/workers/WorkerBootstrapDefs.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/workers/WorkerBootstrapDefs.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerBootstrapRequest(message) {
    return (message &&
        message.type === "worker-bootstrap-request" &&
        Array.isArray(message.dependencies));
}
exports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;
function isWorkerBootstrapResponse(message) {
    return (message &&
        message.type === "worker-bootstrap-response" &&
        Array.isArray(message.resolvedDependencies));
}
exports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;


/***/ }),

/***/ "../harp-mapview/lib/workers/WorkerLoader.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/workers/WorkerLoader.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ "../harp-mapview/lib/workers/WorkerBootstrapDefs.ts");
const logger = harp_utils_1.LoggerManager.instance.create("WorkerLoader");
/**
 * Set of `Worker` loading and initialization helpers:
 *  - starting Worker from URL with fallback to XHR+blob [[WorkerLoader.startWorker]]
 *  - waiting for proper worker initialization, see [[WorkerLoader.waitWorkerInitialized]]
 */
class WorkerLoader {
    /**
     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.
     * Then waits (using [[waitWorkerInitialized]]) for its successful initialization. In case of
     * error falls back to [[startWorkerBlob]].
     *
     * This method is needed as browsers in general forbid to load worker if it's not on 'same
     * origin' regardless of Content-Security-Policy.
     *
     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows
     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but
     * this may change.
     *
     * Following snippet setups CSP, so workers can be started from blob urls:
     *
     *     <head>
     *         <meta http-equiv="Content-Security-Policy" content="child-src blob:">
     *     </head>
     *
     * Tested on:
     *   * Chrome 67 / Linux, Window, OSX, Android
     *   * Firefox 60 / Linux, Windows, OSX
     *   * Edge 41 / Windows
     *   * Safari 11 / OSX
     *   * Samsung Internet 7.2
     *
     * See
     *  * https://benohead.com/cross-domain-cross-browser-web-workers/
     *  * MapBox
     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658
     *    * https://github.com/mapbox/mapbox-gl-js/issues/559
     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058
     *
     * Findings:
     *
     * * Chrome reports CSP by exception when constructing [[Worker]] instance.
     * * Firefox reports CSP errors when loading in first event:
     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888
     * * Firefox 62, Chrome 67 obeys `<meta http-equiv="Content-Security-Policy">` with
     *   `worker-src blob:` but doesn't obey `worker-src URL` when used
     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported
     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)
     *
     * @param scriptUrl web worker script URL
     */
    static startWorker(scriptUrl) {
        if (scriptUrl.startsWith("blob:")) {
            return this.startWorkerImmediately(scriptUrl);
        }
        if (this.directlyFallbackToBlobBasedLoading) {
            return this.startWorkerBlob(scriptUrl);
        }
        return this.startWorkerImmediately(scriptUrl).catch(error => {
            logger.log("#startWorker: worker construction failed, attempting load with blob");
            this.directlyFallbackToBlobBasedLoading = true;
            return WorkerLoader.startWorkerBlob(scriptUrl);
        });
    }
    /**
     * Start worker, loading it immediately from `scriptUrl`. Waits (using
     * [[waitWorkerInitialized]]) for successful worker start.
     *
     * @param scriptUrl web worker script URL
     */
    static startWorkerImmediately(scriptUrl) {
        try {
            const worker = new Worker(scriptUrl);
            return this.waitWorkerInitialized(worker);
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Start worker "via blob" by first loading worker script code with [[fetch]], creating `Blob`
     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for
     * successful worker start.
     *
     * @param scriptUrl web worker script URL
     */
    static startWorkerBlob(scriptUrl) {
        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {
            return this.startWorkerImmediately(blobUrl);
        });
    }
    /**
     * Fetch script source as `Blob` url.
     *
     * Reuses results, if there are many simultaneous requests.
     *
     * @param scriptUrl web worker script URL
     * @return promise that resolves to url of a `Blob` with script source code
     */
    static fetchScriptSourceToBlobUrl(scriptUrl) {
        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);
        if (loadingPromise !== undefined) {
            return loadingPromise;
        }
        loadingPromise = fetch(scriptUrl)
            .then(response => response.text())
            .catch(error => {
            throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);
        })
            .then(scriptSource => {
            this.sourceLoaderCache.delete(scriptUrl);
            const blob = new Blob([scriptSource], { type: "application/javascript" });
            return URL.createObjectURL(blob);
        });
        this.sourceLoaderCache.set(scriptUrl, loadingPromise);
        return loadingPromise;
    }
    /**
     * Waits for successful Web Worker start.
     *
     * Expects that worker script sends initial message.
     *
     * If first event is `message` then assumes that worker has been loaded sussesfully and promise
     * resolves to `worker` object passed as argument.
     *
     * If first event is 'error', then it is assumed that worker failed to load and promise is
     * rejected.
     *
     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's
     * `dispatchEvent`, so application code can also consume it as confirmation of successful
     * worker initialization.
     *
     * @param worker [[Worker]] instance to be checked
     * @returns `Promise` that resolves to `worker` on success
     */
    static waitWorkerInitialized(worker) {
        return new Promise((resolve, reject) => {
            const firstMessageCallback = (event) => {
                const message = event.data;
                if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {
                    const dependencies = message.dependencies;
                    const resolvedDependencies = [];
                    for (const dependency of dependencies) {
                        const resolved = this.dependencyUrlMapping[dependency];
                        if (!resolved) {
                            reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +
                                ` as needed by worker script.`));
                            return;
                        }
                        resolvedDependencies.push(resolved);
                    }
                    const response = {
                        type: "worker-bootstrap-response",
                        resolvedDependencies
                    };
                    worker.postMessage(response);
                    return;
                }
                worker.removeEventListener("message", firstMessageCallback);
                worker.removeEventListener("error", errorCallback);
                resolve(worker);
                // We've just consumed first message from worker before client has any chance to
                // even call `addEventListener` on it, so here after resolve, we wait next tick and
                // replay message so user has chance to intercept it in its own handler.
                setTimeout(() => {
                    worker.dispatchEvent(event);
                }, 0);
            };
            const errorCallback = (error) => {
                // Error events do not carry any useful information on tested browsers, so we assume
                // that any error before 'firstMessageCallback' as failed Worker initialization.
                worker.removeEventListener("message", firstMessageCallback);
                worker.removeEventListener("error", errorCallback);
                reject(new Error("#waitWorkerInitialized: Error event before first message."));
            };
            worker.addEventListener("message", firstMessageCallback);
            worker.addEventListener("error", errorCallback);
        });
    }
}
WorkerLoader.directlyFallbackToBlobBasedLoading = false;
WorkerLoader.sourceLoaderCache = new Map();
WorkerLoader.dependencyUrlMapping = {};
exports.WorkerLoader = WorkerLoader;


/***/ }),

/***/ "../harp-materials/index.ts":
/*!**********************************!*\
  !*** ../harp-materials/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/CopyMaterial */ "../harp-materials/lib/CopyMaterial.ts"));
__export(__webpack_require__(/*! ./lib/SepiaShader */ "../harp-materials/lib/SepiaShader.ts"));
__export(__webpack_require__(/*! ./lib/VignetteShader */ "../harp-materials/lib/VignetteShader.ts"));
__export(__webpack_require__(/*! ./lib/DashedLineMaterial */ "../harp-materials/lib/DashedLineMaterial.ts"));
__export(__webpack_require__(/*! ./lib/EdgeMaterial */ "../harp-materials/lib/EdgeMaterial.ts"));
__export(__webpack_require__(/*! ./lib/MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ "../harp-materials/lib/HighPrecisionLineMaterial.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ "../harp-materials/lib/HighPrecisionPointMaterial.ts"));
__export(__webpack_require__(/*! ./lib/IconMaterial */ "../harp-materials/lib/IconMaterial.ts"));
__export(__webpack_require__(/*! ./lib/SolidLineMaterial */ "../harp-materials/lib/SolidLineMaterial.ts"));
__export(__webpack_require__(/*! ./lib/CirclePointsMaterial */ "../harp-materials/lib/CirclePointsMaterial.ts"));
__export(__webpack_require__(/*! ./lib/MSAAMaterial */ "../harp-materials/lib/MSAAMaterial.ts"));
__export(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ "../harp-materials/lib/LuminosityHighPassShader.ts"));


/***/ }),

/***/ "../harp-materials/lib/CirclePointsMaterial.ts":
/*!*****************************************************!*\
  !*** ../harp-materials/lib/CirclePointsMaterial.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const vertexShader = `
uniform float size;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
uniform vec3 diffuse;

void main() {
    float alpha = 1.0;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuse, alpha);
}`;
const DEFAULT_CIRCLE_SIZE = 1;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
class CirclePointsMaterial extends THREE.ShaderMaterial {
    /**
     * Constructs a new `CirclePointsMaterial`.
     *
     * @param parameters The constructor's parameters.
     */
    constructor(parameters = {}) {
        parameters.depthTest = false;
        super(parameters);
        this.isCirclePointsMaterial = true;
        this.type = "CirclePointsMaterial";
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
        this.transparent = true;
        this.m_size = parameters.size || DEFAULT_CIRCLE_SIZE;
        this.m_color = new THREE.Color();
        this.uniforms = {
            diffuse: new THREE.Uniform(this.m_color),
            size: new THREE.Uniform(this.m_size)
        };
        this.extensions.derivatives = true;
    }
    /**
     * Gets the circle screen size.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Sets the circle screen size.
     */
    set size(size) {
        this.m_size = size;
        this.uniforms.size.value = size;
        this.needsUpdate = true;
    }
    /**
     * Gets the diffuse.
     */
    get color() {
        return "#" + this.m_color.getHexString();
    }
    /**
     * Sets the diffuse.
     */
    set color(color) {
        this.m_color.set(color);
        this.uniforms.diffuse.value.set(this.m_color);
        this.needsUpdate = true;
    }
}
exports.CirclePointsMaterial = CirclePointsMaterial;


/***/ }),

/***/ "../harp-materials/lib/CopyMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/CopyMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base shader to use for [[MapView]]'s composing passes, like [[MSAAMaterial]].
 */
exports.CopyShader = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
    }`
};
/**
 * The material is used for composing.
 */
class CopyMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `CopyMaterial`.
     *
     * @param uniforms The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            name: "CopyMaterial",
            uniforms,
            vertexShader: exports.CopyShader.vertexShader,
            fragmentShader: exports.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: false,
            blending: THREE.NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.CopyMaterial = CopyMaterial;


/***/ }),

/***/ "../harp-materials/lib/DashedLineMaterial.ts":
/*!***************************************************!*\
  !*** ../harp-materials/lib/DashedLineMaterial.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const SolidLineMaterial_1 = __webpack_require__(/*! ./SolidLineMaterial */ "../harp-materials/lib/SolidLineMaterial.ts");
/**
 * Material designed to render dashed variable-width lines.
 */
class DashedLineMaterial extends SolidLineMaterial_1.SolidLineMaterial {
    /**
     * Constructs a new `DashedLineMaterial`.
     *
     * @param params `DashedLineMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {};
        if (params !== undefined && params.color !== undefined) {
            shaderParams.color = params.color;
        }
        if (params !== undefined && params.lineWidth !== undefined) {
            shaderParams.lineWidth = params.lineWidth;
        }
        if (params !== undefined && params.opacity !== undefined) {
            shaderParams.opacity = params.opacity;
        }
        if (params !== undefined && params.fog !== undefined) {
            shaderParams.fog = params.fog;
        }
        super(shaderParams);
        this.name = "DashedLineMaterial";
        Object.assign(this.uniforms, {
            dashSize: new THREE.Uniform(DashedLineMaterial.DEFAULT_DASH_SIZE),
            gapSize: new THREE.Uniform(DashedLineMaterial.DEFAULT_GAP_SIZE)
        });
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.dashSize !== undefined) {
                this.dashSize = params.dashSize;
            }
            if (params.gapSize !== undefined) {
                this.gapSize = params.gapSize;
            }
            if (params.fog !== undefined) {
                this.fog = params.fog !== null;
            }
        }
    }
    /**
     * Size of the dashed segments.
     */
    get dashSize() {
        return this.uniforms.dashSize.value;
    }
    set dashSize(value) {
        this.uniforms.dashSize.value = value;
    }
    /**
     * Size of the gaps between dashed segments.
     */
    get gapSize() {
        return this.uniforms.gapSize.value;
    }
    set gapSize(value) {
        this.uniforms.gapSize.value = value;
        this.updateDashedFeature();
    }
    updateDashedFeature() {
        this.defines.DASHED_LINE = this.gapSize > 0.0 ? 1 : 0;
    }
}
DashedLineMaterial.DEFAULT_DASH_SIZE = 1.0;
DashedLineMaterial.DEFAULT_GAP_SIZE = 1.0;
exports.DashedLineMaterial = DashedLineMaterial;


/***/ }),

/***/ "../harp-materials/lib/EdgeMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/EdgeMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../../harp-mapview/lib/AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts");
const vertexSource = `
attribute vec3 position;
attribute vec4 color;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 edgeColor;
uniform float edgeColorMix;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {
    #ifdef USE_COLOR
    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);
    #else
    vColor = edgeColor.rgb;
    #endif

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
const fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid
 * colors, vertex colors, color mixing and distance fading.
 */
class EdgeMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `EdgeMaterial`.
     *
     * @param params `EdgeMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {
            name: "EdgeMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),
                fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                extrusionRatio: new THREE.Uniform(AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN)
            },
            depthWrite: false
        };
        super(shaderParams);
        this.transparent = true;
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.colorMix !== undefined) {
                this.colorMix = params.colorMix;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
        }
    }
    /**
     * Edge color.
     */
    get color() {
        return this.uniforms.edgeColor.value;
    }
    set color(value) {
        this.uniforms.edgeColor.value = value;
    }
    /**
     * Color mix value. Mixes between vertexColors and edgeColor.
     */
    get colorMix() {
        return this.uniforms.edgeColorMix.value;
    }
    set colorMix(value) {
        this.uniforms.edgeColorMix.value = value;
        this.updateColorMixFeature();
    }
    updateColorMixFeature() {
        this.defines.USE_COLOR = this.colorMix > 0.0 ? 1 : 0;
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        this.uniforms.fadeFar.value = value;
        const doFade = value !== undefined && value > 0.0;
        if (doFade) {
            this.needsUpdate = this.needsUpdate || this.defines.USE_FADING === undefined;
            this.defines.USE_FADING = "";
        }
        else {
            this.needsUpdate = this.needsUpdate || this.defines.USE_FADING !== undefined;
            delete this.defines.USE_FADING;
        }
    }
    get extrusionRatio() {
        return this.uniforms.extrusionRatio.value;
    }
    set extrusionRatio(value) {
        this.uniforms.extrusionRatio.value = value;
        const doExtrusion = value !== undefined && value >= AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN;
        if (doExtrusion) {
            this.needsUpdate = this.needsUpdate || this.defines.USE_EXTRUSION === undefined;
            this.defines.USE_EXTRUSION = "";
        }
        else {
            this.needsUpdate = this.needsUpdate || this.defines.USE_EXTRUSION !== undefined;
            delete this.defines.USE_EXTRUSION;
        }
    }
}
EdgeMaterial.DEFAULT_COLOR = 0x000000;
EdgeMaterial.DEFAULT_COLOR_MIX = 0.0;
exports.EdgeMaterial = EdgeMaterial;


/***/ }),

/***/ "../harp-materials/lib/HighPrecisionLineMaterial.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/HighPrecisionLineMaterial.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#ifdef USE_COLOR
attribute vec4 color;
varying vec3 vColor;
#endif

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 position;        // high part
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_COLOR
varying vec3 color;
#endif

void main() {
    #ifdef USE_COLOR
    gl_FragColor = vec4( diffuse * vColor, opacity );
    #else
    gl_FragColor = vec4( diffuse, opacity );
    #endif
}`;
/**
 * Material designed to render high precision lines (ideal for position-sensible data).
 */
class HighPrecisionLineMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `HighPrecisionLineMaterial`.
     *
     * @param params `HighPrecisionLineMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = {
            name: "HighPrecisionLineMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),
                opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),
                u_mvp: new THREE.Uniform(new THREE.Matrix4()),
                u_eyepos: new THREE.Uniform(new THREE.Vector3()),
                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
            }
        };
        Object.assign(shaderParams, params);
        super(shaderParams);
        this.type = "HighPrecisionLineMaterial";
        this.isHighPrecisionLineMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
        }
        this.updateTransparencyFeature();
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value = value;
    }
    updateTransparencyFeature() {
        this.transparent = this.opacity < 1.0 ? true : false;
    }
}
HighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;
exports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;


/***/ }),

/***/ "../harp-materials/lib/HighPrecisionPointMaterial.ts":
/*!***********************************************************!*\
  !*** ../harp-materials/lib/HighPrecisionPointMaterial.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform float size;

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);

    // ignore sizeAttenuation for now!
    gl_PointSize = size;
}`;
/**
 * Material designed to render high precision points (ideal for position-sensible data).
 */
class HighPrecisionPointMaterial extends THREE.PointsMaterial {
    /**
     * Constructs a new `HighPrecisionPointMaterial`.
     *
     * @param params `HighPrecisionPointMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = params;
        super(shaderParams);
        this.type = "HighPrecisionPointMaterial";
        this.vertexShader = vertexSource;
        this.fragmentShader = THREE.ShaderChunk.points_frag;
        this.fog = false;
        this.uniforms = {
            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),
            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),
            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),
            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),
            map: new THREE.Uniform(new THREE.Texture()),
            uvTransform: new THREE.Uniform(new THREE.Matrix3()),
            u_mvp: new THREE.Uniform(new THREE.Matrix4()),
            u_eyepos: new THREE.Uniform(new THREE.Vector3()),
            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
        };
        this.isHighPrecisionPointMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.size !== undefined) {
                this.size = params.size;
            }
            if (params.scale !== undefined) {
                this.scale = params.scale;
            }
            if (params.uvTransform !== undefined) {
                this.uvTransform = params.uvTransform;
            }
            if (params.map !== undefined) {
                this.map = params.map;
            }
        }
    }
    /**
     *  Point scale.
     */
    get scale() {
        return this.uniforms.scale.value;
    }
    set scale(value) {
        this.uniforms.scale.value = value;
    }
    /**
     * UV transformation matrix.
     */
    get uvTransform() {
        return this.uniforms.uvTransform.value;
    }
    set uvTransform(value) {
        this.uniforms.uvTransform.value = value;
    }
}
HighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;
HighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;
HighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;
exports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;
function isHighPrecisionPointMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionPointMaterial === true);
}
exports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;


/***/ }),

/***/ "../harp-materials/lib/IconMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/IconMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const vertexSource = `
attribute vec4 position;
attribute vec4 color;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec4 vColor;
varying vec2 vUv;

void main() {
    vUv = uv;
    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform sampler2D map;

varying vec4 vColor;
varying vec2 vUv;

void main() {

    vec4 color = texture2D(map, vUv.xy);
    color *= vColor.a;
    if (color.a < 0.05) {
        discard;
    }
    gl_FragColor = color;
}`;
/**
 * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to
 * apply opacity.
 */
class IconMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `IconMaterial`.
     *
     * @param params `IconMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {
            name: "IconMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                map: new THREE.Uniform(params.map)
            },
            depthTest: true,
            depthWrite: true,
            transparent: true,
            vertexColors: THREE.VertexColors,
            premultipliedAlpha: true,
            blending: THREE.NormalBlending
        };
        super(shaderParams);
    }
    /**
     * Icon texture map/atlas.
     */
    get map() {
        return this.uniforms.map.value;
    }
}
exports.IconMaterial = IconMaterial;


/***/ }),

/***/ "../harp-materials/lib/LuminosityHighPassShader.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/LuminosityHighPassShader.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.
 */
exports.LuminosityHighPassShader = {
    uniforms: {
        tDiffuse: { value: null },
        luminosityThreshold: { value: 1.0 },
        smoothWidth: { value: 1.0 },
        defaultColor: { value: new THREE.Color(0x000000) },
        defaultOpacity: { value: 0.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec3 defaultColor;
    uniform float defaultOpacity;
    uniform float luminosityThreshold;
    uniform float smoothWidth;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        vec3 luma = vec3( 0.299, 0.587, 0.114 );
        float v = dot( texel.xyz, luma );
        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
        gl_FragColor = mix( outputColor, texel, alpha );
    }`
};


/***/ }),

/***/ "../harp-materials/lib/MSAAMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/MSAAMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ "../harp-materials/lib/CopyMaterial.ts");
/**
 * The material to use for the quad of the [[MSAARenderPass]] in the composing.
 */
class MSAAMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `MSAAMaterial`.
     *
     * @param uniforms The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            uniforms,
            vertexShader: CopyMaterial_1.CopyShader.vertexShader,
            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.MSAAMaterial = MSAAMaterial;


/***/ }),

/***/ "../harp-materials/lib/MapMeshMaterials.ts":
/*!*************************************************!*\
  !*** ../harp-materials/lib/MapMeshMaterials.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../../harp-mapview/lib/AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ "../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts");
const FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ "../harp-materials/lib/ShaderChunks/FadingChunks.ts");
/**
 * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
 * [0..cameraFar].
 *
 * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.
 *
 * @param distance Distance from the camera (range: [0, 1]).
 * @param camera Camera applying the perspective projection.
 */
function cameraToWorldDistance(distance, camera) {
    const perspCam = camera;
    return distance * perspCam.far;
}
var DisplacementFeature;
(function (DisplacementFeature) {
    /**
     * Update the internals of the `DisplacementFeature` depending on the value of
     * [[displacementMap]].
     *
     * @param displacementMaterial DisplacementFeature
     */
    function updateDisplacementFeature(displacementMaterial) {
        displacementMaterial.needsUpdate = true;
        if (displacementMaterial.defines === undefined) {
            displacementMaterial.defines = {};
        }
        if (displacementMaterial.displacementMap !== undefined) {
            displacementMaterial.displacementMap.needsUpdate = true;
            // Add this define to differentiate it internally from other MeshBasicMaterial
            displacementMaterial.defines.USE_DISPLACEMENTMAP = "";
        }
    }
    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;
    /**
     * This function should be called on implementors of DisplacementFeature in the
     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to
     * apply displacement maps.
     *
     * @param displacementMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(displacementMaterial, shader) {
        if (displacementMaterial.displacementMap === undefined) {
            return;
        }
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not available for this material, so the fading shader chunks
        // have the #ifdefs commented out.
        // Create the uniforms for the shader (if not already existing), and add the new uniforms
        // to it:
        const uniforms = shader.uniforms;
        uniforms.displacementMap = { value: displacementMaterial.displacementMap };
        uniforms.displacementScale = { value: 1 };
        uniforms.displacementBias = { value: 0 };
        // Append the displacement map chunk to the vertex shader.
        shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", `#include <skinbase_vertex>
#ifndef USE_ENVMAP
    vec3 objectNormal = vec3( normal );
#endif`);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
    }
    DisplacementFeature.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature = exports.DisplacementFeature || (exports.DisplacementFeature = {}));
class DisplacementFeatureMixin {
    getDisplacementMap() {
        return this.m_displacementMap;
    }
    setDisplacementMap(map) {
        this.needsUpdate = this.needsUpdate || map !== this.m_displacementMap;
        this.m_displacementMap = map;
        if (this.needsUpdate) {
            DisplacementFeature.updateDisplacementFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[displacementMap]]
     */
    addDisplacementProperties() {
        Object.defineProperty(this, "displacementMap", {
            get: () => {
                return this.getDisplacementMap();
            },
            set: val => {
                this.setDisplacementMap(val);
            }
        });
    }
    /**
     * Apply the displacementMap value from the parameters to the respective properties.
     */
    applyDisplacementParameters(params) {
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.displacementMap !== undefined) {
                this.setDisplacementMap(params.displacementMap);
            }
        }
        this.onBeforeCompile = (shader) => {
            DisplacementFeature.onBeforeCompile(this, shader);
        };
    }
    /**
     * Copy displacementMap from other DisplacementFeature.
     *
     * @param source The material to copy property values from.
     */
    copyDisplacementParameters(source) {
        this.setDisplacementMap(source.displacementMap);
        return this;
    }
}
exports.DisplacementFeatureMixin = DisplacementFeatureMixin;
/**
 * Namespace with support functions for implementors of `FadingFeature`.
 */
var FadingFeature;
(function (FadingFeature) {
    FadingFeature.DEFAULT_FADE_NEAR = -1.0;
    FadingFeature.DEFAULT_FADE_FAR = -1.0;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);
        }
    }
    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The
     * fading feature will be disabled if fadeFar <= 0.0.
     *
     * @param fadingMaterial FadingFeature
     */
    function updateDistanceFadeFeature(fadingMaterial) {
        fadingMaterial.needsUpdate = true;
        if (fadingMaterial.defines === undefined) {
            fadingMaterial.defines = {};
        }
        if (fadingMaterial.fadeFar !== undefined && fadingMaterial.fadeFar > 0.0) {
            // Add this define to differentiate it internally from other MeshBasicMaterial
            fadingMaterial.defines.FADING_MATERIAL = "";
        }
    }
    FadingFeature.updateDistanceFadeFeature = updateDistanceFadeFeature;
    /**
     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control fading based on view distance.
     *
     * @param fadingMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(fadingMaterial, shader) {
        if (fadingMaterial.fadeFar === undefined || fadingMaterial.fadeFar <= 0.0) {
            return;
        }
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not available for this material, so the fading shader chunks
        // have the #ifdefs commented out.
        // Create the uniforms for the shader (if not already existing), and add the new uniforms
        // to it:
        const uniforms = shader.uniforms;
        uniforms.fadeNear = { value: fadingMaterial.fadeNear };
        uniforms.fadeFar = { value: fadingMaterial.fadeFar };
        // Append the new fading shader cod directly after the fog code. This is done by adding an
        // include directive for the fading code.
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    }
    FadingFeature.onBeforeCompile = onBeforeCompile;
    /**
     * As threejs is rendering the transparent objects last (internally), regardless of their
     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In
     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the
     * fade distance value is less than 1.
     *
     * @param object [[THREE.Object3D]] to prepare for rendering.
     * @param fadeNear The fadeNear value to set in the material.
     * @param fadeFar The fadeFar value to set in the material.
     * @param forceMaterialToTransparent If `true`, the material will be forced to render with
     *          blending set to `true`. May be `false` if the material is known to be transparent
     *          anyway.
     * @param updateUniforms If `true`, the fading uniforms are set. Not rquired if material is
     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].
     * @param additionalCallback If defined, this function will be called before the function will
     *          return.
     */
    function addRenderHelper(object, fadeNear, fadeFar, forceMaterialToTransparent, updateUniforms, additionalCallback) {
        // tslint:disable-next-line:no-unused-variable
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
            if (forceMaterialToTransparent) {
                //
                material.transparent = true;
            }
            const fadingMaterial = material;
            fadingMaterial.fadeNear =
                fadeNear === undefined
                    ? FadingFeature.DEFAULT_FADE_NEAR
                    : cameraToWorldDistance(fadeNear, camera);
            fadingMaterial.fadeFar =
                fadeFar === undefined
                    ? FadingFeature.DEFAULT_FADE_FAR
                    : cameraToWorldDistance(fadeFar, camera);
            if (updateUniforms) {
                const properties = renderer.properties.get(material);
                if (properties.shader !== undefined &&
                    properties.shader.uniforms.fadeNear !== undefined) {
                    properties.shader.uniforms.fadeNear.value = fadingMaterial.fadeNear;
                    properties.shader.uniforms.fadeFar.value = fadingMaterial.fadeFar;
                    fadingMaterial.uniformsNeedUpdate = true;
                }
            }
            if (additionalCallback !== undefined) {
                additionalCallback(renderer, material);
            }
        });
        if (forceMaterialToTransparent) {
            object.onAfterRender = (renderer, scene, camera, geom, material) => {
                material.transparent = false;
            };
        }
    }
    FadingFeature.addRenderHelper = addRenderHelper;
})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and
 * `fadeFar`. Thre is some special handling for the fadeNear/fadeFar properties, which get some
 * setters and getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class FadingFeatureMixin {
    constructor() {
        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    getFadeNear() {
        return this.m_fadeNear;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    setFadeNear(value) {
        this.needsUpdate = this.needsUpdate || value !== this.m_fadeNear;
        this.m_fadeNear = value;
        if (this.needsUpdate) {
            FadingFeature.updateDistanceFadeFeature(this);
        }
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    getFadeFar() {
        return this.m_fadeFar;
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    setFadeFar(value) {
        this.needsUpdate = this.needsUpdate || value !== this.m_fadeFar;
        this.m_fadeFar = value;
        if (this.needsUpdate) {
            FadingFeature.updateDistanceFadeFeature(this);
        }
    }
    /**
     * The mixin classes should call this method to register the properties [[fadeNear]] and
     * [[fadeFar]].
     */
    addFadingProperties() {
        Object.defineProperty(this, "fadeNear", {
            get: () => {
                return this.getFadeNear();
            },
            set: val => {
                this.setFadeNear(val);
            }
        });
        Object.defineProperty(this, "fadeFar", {
            get: () => {
                return this.getFadeFar();
            },
            set: val => {
                this.setFadeFar(val);
            }
        });
    }
    /**
     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.
     *
     * @param params `FadingMeshBasicMaterial` parameters.
     */
    applyFadingParameters(params) {
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.fadeNear !== undefined) {
                this.setFadeNear(params.fadeNear);
            }
            if (params.fadeFar !== undefined) {
                this.setFadeFar(params.fadeFar);
            }
        }
        this.onBeforeCompile = (shader) => {
            FadingFeature.onBeforeCompile(this, shader);
        };
    }
    /**
     * Copy fadeNear/fadeFar values from other FadingFeature.
     *
     * @param source The material to copy property values from.
     */
    copyFadingParameters(source) {
        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
        return this;
    }
}
exports.FadingFeatureMixin = FadingFeatureMixin;
var ExtrusionFeature;
(function (ExtrusionFeature) {
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);
        }
    }
    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].
     *
     * @param ExtrusionMaterial ExtrusionFeature
     */
    function updateExtrusionFeature(extrusionMaterial) {
        extrusionMaterial.needsUpdate = true;
        if (extrusionMaterial.defines === undefined) {
            extrusionMaterial.defines = {};
        }
        if (extrusionMaterial.extrusionRatio !== undefined &&
            extrusionMaterial.extrusionRatio >= AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MIN) {
            // Add this define to differentiate it internally from other MeshBasicMaterial
            extrusionMaterial.defines.EXTRUSION_MATERIAL = "";
        }
    }
    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;
    /**
     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control extrusion.
     *
     * @param extrusionMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(extrusionMaterial, shader) {
        if (extrusionMaterial.extrusionRatio === undefined) {
            return;
        }
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        // Create the uniforms for the shader (if not already existing), and add the new uniforms
        // to it:
        const uniforms = shader.uniforms;
        uniforms.extrusionRatio = { value: extrusionMaterial.extrusionRatio };
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    }
    ExtrusionFeature.onBeforeCompile = onBeforeCompile;
    /**
     * Handles animated extrusion on each frame. Should be installed as respective
     * Object3D.onBeforeRender of meshes which use animated extusion feature.
     */
    function addRenderHelper(object) {
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, ExtrusionFeature.onBeforeRender);
    }
    ExtrusionFeature.addRenderHelper = addRenderHelper;
    function onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const extrusionMaterial = material;
        const properties = renderer.properties.get(material);
        if (properties.shader !== undefined &&
            properties.shader.uniforms.extrusionRatio !== undefined) {
            properties.shader.uniforms.extrusionRatio.value =
                extrusionMaterial.extrusionRatio || AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
            extrusionMaterial.uniformsNeedUpdate = true;
        }
    }
    ExtrusionFeature.onBeforeRender = onBeforeRender;
})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.
 * Thre is some special handling for the extrusionRatio property, which get some setters and
 * getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class ExtrusionFeatureMixin {
    constructor() {
        this.m_extrusion = AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    getExtrusionRatio() {
        return this.m_extrusion;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    setExtrusionRatio(value) {
        this.needsUpdate = this.needsUpdate || value !== this.m_extrusion;
        this.m_extrusion = value;
        if (this.needsUpdate) {
            ExtrusionFeature.updateExtrusionFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[extrusionRatio]]
     */
    addExtrusionProperties() {
        Object.defineProperty(this, "extrusionRatio", {
            get: () => {
                return this.getExtrusionRatio();
            },
            set: val => {
                this.setExtrusionRatio(val);
            }
        });
    }
    /**
     * Apply the extrusionRatio value from the parameters to the respective properties.
     */
    applyExtrusionParameters(params) {
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.extrusionRatio !== undefined) {
                this.setExtrusionRatio(params.extrusionRatio);
            }
        }
        this.onBeforeCompile = (shader) => {
            ExtrusionFeature.onBeforeCompile(this, shader);
        };
    }
    /**
     * Copy extrusionRatio values from other ExtrusionFeature.
     *
     * @param source The material to copy property values from.
     */
    copyExtrusionParameters(source) {
        this.setExtrusionRatio(source.extrusionRatio === undefined
            ? AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX
            : source.extrusionRatio);
        return this;
    }
}
exports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;
/**
 * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and
 * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is
 * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]
 * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are
 * updated to world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshBasicMaterial extends THREE.MeshBasicMaterial {
    /**
     * Constructs a new `FadingMeshBasicMaterial`.
     *
     * @param params `FadingMeshBasicMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(params);
        this.addDisplacementProperties();
        this.applyDisplacementParameters(params);
    }
    clone() {
        return new MapMeshBasicMaterial().copy(this);
    }
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        this.copyDisplacementParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    get displacementMap() {
        return undefined;
    }
    // tslint:disable-next-line:no-unused-variable
    set displacementMap(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
    addDisplacementProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyDisplacementParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyDisplacementParameters(source) {
        // to be overridden
    }
}
exports.MapMeshBasicMaterial = MapMeshBasicMaterial;
/**
 * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and
 * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also
 * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,
 * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to
 * world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshStandardMaterial extends THREE.MeshStandardMaterial {
    /**
     * Constructs a new `FadingMeshStandardMaterial`.
     *
     * @param params `FadingMeshStandardMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(params);
    }
    clone() {
        return new MapMeshStandardMaterial().copy(this);
    }
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshStandardMaterial = MapMeshStandardMaterial;
/**
 * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual
 * implementations of the mixed in functions.
 */
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);


/***/ }),

/***/ "../harp-materials/lib/SepiaShader.ts":
/*!********************************************!*\
  !*** ../harp-materials/lib/SepiaShader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `SepiaShader`.
 */
exports.SepiaShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float amount;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec3 c = color.rgb;
            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );
        }`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts":
/*!*************************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    extrusion_pars_vertex: `
attribute vec3 extrusionAxis;
uniform float extrusionRatio;
`,
    extrusion_vertex: `
transformed = transformed - extrusionAxis + extrusionAxis * extrusionRatio;
`,
    extrusion_pars_fragment: `
uniform float extrusionRatio;
`,
    extrusion_fragment: `
gl_FragColor.a *= smoothstep( 0.0, 0.25, extrusionRatio );
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/FadingChunks.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/FadingChunks.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The shader chunks have their lines "#ifdef USE_FADING" commented out, because currently the
 * mesh materials use individually created shader strings based on the materials settings.
 * @see [[FadingMeshBasicMaterial]]
 **/
exports.default = {
    fading_pars_vertex: `
varying float fadingDepth;
`,
    fading_vertex: `
fadingDepth = -mvPosition.z;
`,
    fading_pars_fragment: `
varying float fadingDepth;
uniform float fadeNear;
uniform float fadeFar;
`,
    fading_fragment: `

// lerp with "hard" edges
//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);

// smooth transitions
float fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );

gl_FragColor.a *= 1.0 - fadingFactor;

// debugging color:
// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/LinesChunks.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/LinesChunks.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    extrude_line_vert_func: `
void extrudeLine(vec2 segment, vec4 bt, vec3 t, float lineWidth, inout vec3 pos, inout vec2 uv) {
    float uu = uv.x / 2.0 + 0.5;
    float ss = mix(segment.x, segment.y, uu);

    float angle = bt.w;
    vec3 dir = bt.xyz;
    if (angle != 0.0) {
        pos += uv.y * lineWidth * dir / cos(angle / 2.0);
        uv.x = ss + uv.x * lineWidth * uv.y * tan(angle / 2.0);
    }
    else {
        pos += uv.y * lineWidth * dir + uv.x * lineWidth * t;
        uv.x = ss + uv.x * lineWidth;
    }
}
`,
    join_dist_func: `
float joinDist(vec2 segment, vec2 texcoord) {
    float d = abs(texcoord.y);
    float dx = texcoord.x;
    if (dx < segment.x) {
        d = max(d, length(texcoord - vec2(segment.x, 0.0)));
    } else if (dx > segment.y) {
        d = max(d, length(texcoord - vec2(segment.y, 0.0)));
    }
    return d;
}
`,
    tile_clip_func: `
void tileClip(vec2 tilePos, vec2 tileSize) {
    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))
        discard;
    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))
        discard;
}
`,
    high_precision_vert_func: `
vec3 subtractDblEyePos( const in vec3 pos ) {
    vec3 t1 = positionLow - u_eyepos_lowpart;
    vec3 e = t1 - positionLow;
    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;
    vec3 high_delta = t1 + t2;
    vec3 low_delta = t2 - (high_delta - t1);
    return (high_delta + low_delta);
}
`
};


/***/ }),

/***/ "../harp-materials/lib/SolidLineMaterial.ts":
/*!**************************************************!*\
  !*** ../harp-materials/lib/SolidLineMaterial.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#define SEGMENT_OFFSET 0.1

attribute vec2 extrusionCoord;
attribute vec3 position;
attribute vec4 bitangent;
attribute vec3 tangent;
attribute vec2 uv;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float lineWidth;
uniform sampler2D displacementMap;

varying vec2 vExtrusionCoord;
varying vec2 vSegment;
varying float vLinewidth;
varying vec3 vPosition;

#if USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    vLinewidth = lineWidth;
    vSegment = abs(extrusionCoord) - SEGMENT_OFFSET;

    vec3 pos = position;
    vec2 extrusionDir = sign(extrusionCoord);

    extrudeLine(vSegment, bitangent, tangent, lineWidth, pos, extrusionDir);

    #ifdef USE_DISPLACEMENTMAP
    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    vPosition = pos;
    vExtrusionCoord = vec2(extrusionDir.x, extrusionDir.y * lineWidth);

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    #if USE_COLOR
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;
uniform vec2 tileSize;
#if DASHED_LINE
uniform float dashSize;
uniform float gapSize;
#endif

varying vec2 vExtrusionCoord;
varying vec2 vSegment;
varying float vLinewidth;
varying vec3 vPosition;

#if USE_COLOR
varying vec3 vColor;
#endif

#include <join_dist_func>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {

    float alpha = opacity;

    #if TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    float dist = joinDist(vSegment, vExtrusionCoord) - vLinewidth;
    float width = fwidth(dist);
    alpha *= (1.0 - smoothstep(-width, width, dist));

    #if DASHED_LINE
    float halfSegment = (dashSize + gapSize) / dashSize * 0.5;
    float segmentDist = mod(vExtrusionCoord.x, dashSize + gapSize) / dashSize;
    float dashDist = 0.5 - distance(segmentDist, halfSegment);
    float dashWidth = fwidth(dashDist);
    alpha *= smoothstep(-dashWidth, dashWidth, dashDist);
    #endif

    #if USE_COLOR
    gl_FragColor = vec4( diffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( diffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render solid variable-width lines.
 */
class SolidLineMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `SolidLineMaterial`.
     *
     * @param params `SolidLineMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        const defines = {
            DASHED_LINE: 0,
            TILE_CLIP: 0,
            USE_COLOR: 0
        };
        const hasFog = params !== undefined && params.fog === true;
        if (hasFog) {
            defines.USE_FOG = "";
        }
        const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;
        if (hasDisplacementMap) {
            defines.USE_DISPLACEMENTMAP = "";
        }
        const shaderParams = {
            name: "SolidLineMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: THREE.UniformsUtils.merge([
                {
                    diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                    lineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),
                    opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),
                    tileSize: new THREE.Uniform(new THREE.Vector2()),
                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                    displacementMap: new THREE.Uniform(hasDisplacementMap ? params.displacementMap : new THREE.Texture())
                },
                // We need the fog uniforms available when we use `updateFog` as the internal
                // recompilation cannot add or remove uniforms.
                THREE.UniformsLib.fog
            ]),
            defines,
            transparent: true,
            fog: true
        };
        super(shaderParams);
        this.extensions.derivatives = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.lineWidth !== undefined) {
                this.lineWidth = params.lineWidth;
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.depthTest !== undefined) {
                this.depthTest = params.depthTest;
            }
            if (params.depthWrite !== undefined) {
                this.depthWrite = params.depthWrite;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            this.fog = hasFog;
        }
    }
    /**
     * The method to call to recompile a material to get a new fog define.
     *
     * @param enableFog Whether we want to enable the fog.
     */
    updateFog(enableFog) {
        if (!enableFog) {
            delete this.defines.USE_FOG;
        }
        else {
            this.defines.USE_FOG = "";
        }
    }
    /**
     * Line opacity.
     */
    get opacity() {
        return this.uniforms.opacity.value;
    }
    set opacity(value) {
        if (this.uniforms !== undefined) {
            this.uniforms.opacity.value = value;
        }
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value = value;
    }
    /**
     * Line width.
     */
    get lineWidth() {
        return this.uniforms.lineWidth.value;
    }
    set lineWidth(value) {
        this.uniforms.lineWidth.value = value;
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        const fadeFar = this.uniforms.fadeFar.value;
        this.uniforms.fadeFar.value = value;
        const doFade = fadeFar !== undefined && fadeFar > 0.0;
        if (doFade) {
            this.defines.USE_FADING = "";
        }
        else {
            delete this.defines.USE_FADING;
        }
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        this.uniforms.displacementMap.value = map;
        if (map !== undefined) {
            this.uniforms.displacementMap.value.needsUpdate = true;
            this.defines.USE_DISPLACEMENTMAP = "";
        }
        else {
            delete this.defines.USE_DISPLACEMENTMAP;
        }
        this.needsUpdate = true;
    }
}
SolidLineMaterial.DEFAULT_COLOR = 0xff0000;
SolidLineMaterial.DEFAULT_WIDTH = 1.0;
SolidLineMaterial.DEFAULT_OPACITY = 1.0;
exports.SolidLineMaterial = SolidLineMaterial;


/***/ }),

/***/ "../harp-materials/lib/Utils.ts":
/*!**************************************!*\
  !*** ../harp-materials/lib/Utils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Insert shader includes after another shader include.
 *
 * @param shaderContent Original string.
 * @param shaderName String to append to.
 * @param insertedShaderName String to append after string `shaderA`.
 * @param addTab If `true`, a tab character will be inserted before `shaderB`.
 */
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
    const tabChar = addTab === true ? "\t" : "";
    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>
${tabChar}#include <${insertedShaderName}>`);
    return result;
}
exports.insertShaderInclude = insertShaderInclude;


/***/ }),

/***/ "../harp-materials/lib/VignetteShader.ts":
/*!***********************************************!*\
  !*** ../harp-materials/lib/VignetteShader.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `VignetteShader`.
 */
exports.VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        offset: { value: 1.0 },
        darkness: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D( tDiffuse, vUv );
            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );
        }`
};


/***/ }),

/***/ "../harp-omv-datasource/index.ts":
/*!***************************************!*\
  !*** ../harp-omv-datasource/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/OmvDataFilter */ "../harp-omv-datasource/lib/OmvDataFilter.ts"));
__export(__webpack_require__(/*! ./lib/OmvDataSource */ "../harp-omv-datasource/lib/OmvDataSource.ts"));
__export(__webpack_require__(/*! ./lib/OmvDecoderDefs */ "../harp-omv-datasource/lib/OmvDecoderDefs.ts"));
__export(__webpack_require__(/*! ./lib/OmvTile */ "../harp-omv-datasource/lib/OmvTile.ts"));
__export(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ "../harp-omv-datasource/lib/OmvDebugLabelsTile.ts"));
__export(__webpack_require__(/*! ./lib/OmvRestClient */ "../harp-omv-datasource/lib/OmvRestClient.ts"));


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDataFilter.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDataFilter.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-omv-datasource/lib/OmvDecoderDefs.ts");
/**
 * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well
 * as an [[OmvFeatureModifier]].
 *
 */
class OmvFeatureFilterDescriptionBuilder {
    /**
     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as
     * well as an [[OmvFeatureModifier]].
     *
     * @param processLayersDefault If `true`, all unspecified layers will be processed. If `false`,
     * all unspecified layers will be ignored.
     * @param processPointsDefault If `true`, all unspecified point features will be processed. If
     * `false`, all unspecified point features will be ignored.
     * @param processLinesDefault If `true`, all unspecified line features will be processed. If
     * `false`, all unspecified line features will be ignored.
     * @param processPolygonsDefault If `true`, all unspecified polygon features will be processed.
     * If `false`, all unspecified polygon features will be ignored.
     */
    constructor(options) {
        this.m_processLayersDefault = true;
        this.m_processPointsDefault = true;
        this.m_processLinesDefault = true;
        this.m_processPolygonsDefault = true;
        this.m_layersToProcess = new Array();
        this.m_layersToIgnore = new Array();
        this.m_pointsToProcess = new Array();
        this.m_ignoredPoints = new Array();
        this.m_linesToProcess = new Array();
        this.m_linesToIgnore = new Array();
        this.m_polygonsToProcess = new Array();
        this.m_polygonsToIgnore = new Array();
        this.m_kindsToProcess = [];
        this.m_kindsToIgnore = [];
        if (options) {
            this.m_processLayersDefault =
                options.processLayersDefault !== undefined ? options.processLayersDefault : true;
            this.m_processPointsDefault =
                options.processPointsDefault !== undefined ? options.processPointsDefault : true;
            this.m_processLinesDefault =
                options.processLinesDefault !== undefined ? options.processLinesDefault : true;
            this.m_processPolygonsDefault =
                options.processPolygonsDefault !== undefined
                    ? options.processPolygonsDefault
                    : true;
        }
    }
    /**
     * Add a layer that should be processed.
     *
     * @param layer Layer name to be matched.
     * @param match Match condition.
     */
    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToProcess.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a layer that should be ignored.
     *
     * @param layer Layer name to be matched.
     * @param match Match condition.
     */
    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToIgnore.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a valid point feature.
     *
     * @param options Feature options.
     */
    processPoint(options) {
        this.addItem(this.m_pointsToProcess, options);
    }
    /**
     * Add valid point features.
     *
     * @param options Multi feature options.
     */
    processPoints(options) {
        this.addItems(this.m_pointsToProcess, options);
    }
    /**
     * Add a point feature that should be ignored.
     *
     * @param options Feature options.
     */
    ignorePoint(options) {
        this.addItem(this.m_ignoredPoints, options);
    }
    /**
     * Add point features that should be ignored.
     *
     * @param options Multi feature options.
     */
    ignorePoints(options) {
        this.addItems(this.m_ignoredPoints, options);
    }
    /**
     * Add a valid line feature.
     *
     * @param options Feature options.
     */
    processLine(options) {
        this.addItem(this.m_linesToProcess, options);
    }
    /**
     * Add valid line features.
     *
     * @param options Multi feature options.
     */
    processLines(options) {
        this.addItems(this.m_linesToProcess, options);
    }
    /**
     * Ignore a line feature.
     *
     * @param options Feature options.
     */
    ignoreLine(options) {
        this.addItem(this.m_linesToIgnore, options);
    }
    /**
     * Ignore line features.
     *
     * @param options Multi feature options.
     */
    ignoreLines(options) {
        this.addItems(this.m_linesToIgnore, options);
    }
    /**
     * Add a valid polygon feature.
     *
     * @param options Feature options.
     */
    processPolygon(options) {
        this.addItem(this.m_polygonsToProcess, options);
    }
    /**
     * Add valid polygon features.
     *
     * @param options Multi feature options.
     */
    processPolygons(options) {
        this.addItems(this.m_polygonsToProcess, options);
    }
    /**
     * Ignore a valid polygon feature.
     *
     * @param options Feature options.
     */
    ignorePolygon(options) {
        this.addItem(this.m_polygonsToIgnore, options);
    }
    /**
     * Ignore polygon features.
     *
     * @param options Multi feature options.
     */
    ignorePolygons(options) {
        this.addItems(this.m_polygonsToIgnore, options);
    }
    /**
     * Add all the specified strings as "enabledKinds".
     *
     * @param {string[]} enabledKinds List of kinds that should be generated.
     */
    processKinds(enabledKinds) {
        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);
    }
    /**
     * Add all the specified strings as "disabledKinds".
     *
     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.
     */
    ignoreKinds(disabledKinds) {
        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);
    }
    /**
     * Create a filter description that can be passed as an option to the [[OmvDataSource]].
     */
    createDescription() {
        return {
            processLayersDefault: this.m_processLayersDefault,
            processPointsDefault: this.m_processPointsDefault,
            processLinesDefault: this.m_processLinesDefault,
            processPolygonsDefault: this.m_processPolygonsDefault,
            layersToProcess: this.m_layersToProcess,
            layersToIgnore: this.m_layersToIgnore,
            pointsToProcess: this.m_pointsToProcess,
            pointsToIgnore: this.m_ignoredPoints,
            linesToProcess: this.m_linesToProcess,
            linesToIgnore: this.m_linesToIgnore,
            polygonsToProcess: this.m_polygonsToProcess,
            polygonsToIgnore: this.m_polygonsToIgnore,
            kindsToProcess: this.m_kindsToProcess,
            kindsToIgnore: this.m_kindsToIgnore
        };
    }
    addItem(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomType !== undefined
                ? Array.isArray(options.geomType)
                    ? options.geomType
                    : [options.geomType]
                : undefined,
            classes: [
                {
                    value: options.featureClass,
                    match: options.matchClass === undefined
                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                        : options.matchClass
                }
            ],
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
    addItems(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomTypes !== undefined
                ? Array.isArray(options.geomTypes)
                    ? options.geomTypes
                    : [options.geomTypes]
                : undefined,
            classes: options.featureClasses,
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
}
exports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;
/**
 * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`
 * features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureFilter {
    constructor(description) {
        this.description = description;
        if (this.description.kindsToProcess.length > 0) {
            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description
                .kindsToProcess);
        }
        if (this.description.kindsToIgnore.length > 0) {
            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description
                .kindsToIgnore);
        }
    }
    static matchLayer(layer, layerItems, level) {
        for (const layerItem of layerItems) {
            if (level < layerItem.minLevel || level > layerItem.maxLevel) {
                continue;
            }
            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {
                return true;
            }
        }
        return false;
    }
    wantsLayer(layer, level) {
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {
            return true;
        }
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {
            return false;
        }
        return this.description.processLayersDefault;
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);
    }
    wantsKind(kind) {
        // undefined -> no way to filter
        if (kind === undefined) {
            return true;
        }
        return (!(this.disabledKinds !== undefined &&
            this.disabledKinds.hasOrIntersects(kind)) ||
            (this.enabledKinds !== undefined &&
                this.enabledKinds.hasOrIntersects(kind)));
    }
    get hasKindFilter() {
        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;
    }
    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {
        for (const item of itemsToProcess) {
            if (level < item.minLevel || level > item.maxLevel) {
                continue;
            }
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return true;
            }
        }
        for (const item of itemsToIgnore) {
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return false;
            }
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;
/**
 * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter
 * `TileData` features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureModifier {
    constructor(description) {
        this.description = description;
    }
    static matchItems(layerName, featureClass, items) {
        for (const item of items) {
            if (item.classes !== undefined) {
                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {
                    continue;
                }
                for (const matchClass of item.classes) {
                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    static matchAttribute(layerName, env, items) {
        for (const item of items) {
            if (item.featureAttribute !== undefined) {
                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&
                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {
                    return true;
                }
            }
        }
        return false;
    }
    doProcessPointFeature(layer, env) {
        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);
    }
    doProcessLineFeature(layer, env) {
        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);
    }
    doProcessPolygonFeature(layer, env) {
        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);
    }
    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {
        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {
            return defaultResult;
        }
        let featureClass;
        const featureClassThing = env.lookup("class");
        if (featureClassThing !== undefined && featureClassThing !== null) {
            featureClass = featureClassThing.toString();
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {
            return true;
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {
            return false;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {
            return true;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {
            return false;
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDataSource.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDataSource.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-omv-datasource/lib/OmvDecoderDefs.ts");
const OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ "../harp-omv-datasource/lib/OmvRestClient.ts");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "../harp-omv-datasource/lib/OmvTile.ts");
/**
 * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.
 *
 * @param params The parameters passed into the OmvDataSource.
 */
function getDataProvider(params) {
    if (params.dataProvider) {
        return params.dataProvider;
    }
    else if (params.baseUrl) {
        return new OmvRestClient_1.OmvRestClient(params);
    }
    else {
        throw new Error("OmvDataSource: missing baseUrl or dataProvider params");
    }
}
class OmvDataSource extends harp_mapview_decoder_1.TileDataSource {
    constructor(m_params) {
        super(m_params.tileFactory || new harp_mapview_decoder_1.TileFactory(OmvTile_1.OmvTile), {
            styleSetName: m_params.styleSetName || "omv",
            name: m_params.name,
            tilingScheme: harp_geoutils_1.webMercatorTilingScheme,
            dataProvider: getDataProvider(m_params),
            concurrentDecoderServiceName: OmvDecoderDefs_1.OMV_TILE_DECODER_SERVICE_TYPE,
            decoder: m_params.decoder,
            concurrentDecoderScriptUrl: m_params.concurrentDecoderScriptUrl,
            copyrightInfo: m_params.copyrightInfo,
            minZoomLevel: harp_utils_1.getOptionValue(m_params.minZoomLevel, 1),
            maxZoomLevel: harp_utils_1.getOptionValue(m_params.maxZoomLevel, 14),
            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1)
        });
        this.m_params = m_params;
        this.cacheable = true;
        this.m_decoderOptions = {
            showMissingTechniques: this.m_params.showMissingTechniques === true,
            filterDescription: this.m_params.filterDescr,
            gatherFeatureIds: this.m_params.gatherFeatureIds === true,
            createTileInfo: this.m_params.createTileInfo === true,
            gatherRoadSegments: this.m_params.gatherRoadSegments === true,
            featureModifierId: this.m_params.featureModifierId,
            skipShortLabels: this.m_params.skipShortLabels,
            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1),
            enableElevationOverlay: this.m_params.enableElevationOverlay === true
        };
    }
    /**
     * Set a theme for the data source instance.
     * @param styleSet The [[Theme]] to be added.
     */
    setStyleSet(styleSet, languages) {
        if (styleSet === undefined) {
            return;
        }
        this.configureDecoder(styleSet, languages, this.m_decoderOptions);
    }
    /**
     * Remove the current data filter.
     * Will be applied to the decoder, which might be shared with other omv datasources.
     */
    removeDataFilter() {
        this.configureDecoder(undefined, undefined, {
            filterDescription: null
        });
    }
    /**
     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].
     * Will be applied to the decoder, which might be shared with other omv datasources.
     *
     * @param filterDescription Data filter description created with
     * [[OmvFeatureFilterDescriptionBuilder]].
     */
    setDataFilter(filterDescription) {
        this.m_decoderOptions.filterDescription =
            filterDescription !== null ? filterDescription : undefined;
        this.configureDecoder(undefined, undefined, {
            filterDescription
        });
    }
    shouldPreloadTiles() {
        return true;
    }
    /**
     * Check if a data source should be rendered or not depending on the zoom level.
     *
     * @param zoomLevel Zoom level.
     * @param tileKey Level of the tile.
     * @returns `true` if the data source should be rendered.
     */
    shouldRender(zoomLevel, tileKey) {
        if (tileKey.level > this.maxZoomLevel) {
            return false;
        }
        if (tileKey.level === this.maxZoomLevel && zoomLevel >= this.maxZoomLevel) {
            return true;
        }
        return super.shouldRender(zoomLevel, tileKey);
    }
    setLanguages(languages) {
        if (languages !== undefined) {
            this.configureDecoder(undefined, languages, undefined);
        }
    }
    get storageLevelOffset() {
        return super.storageLevelOffset;
    }
    set storageLevelOffset(levelOffset) {
        super.storageLevelOffset = levelOffset;
        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;
        this.configureDecoder(undefined, undefined, {
            storageLevelOffset: this.storageLevelOffset
        });
    }
    setEnableElevationOverlay(enable) {
        if (this.m_decoderOptions.enableElevationOverlay !== enable) {
            this.m_decoderOptions.enableElevationOverlay = enable;
            this.configureDecoder(undefined, undefined, {
                enableElevationOverlay: enable
            });
        }
    }
    configureDecoder(styleSet, languages, options) {
        this.m_tileLoaderCache.clear();
        this.decoder.configure(styleSet, languages, options);
        this.mapView.markTilesDirty(this);
    }
}
exports.OmvDataSource = OmvDataSource;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDebugLabelsTile.ts":
/*!********************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDebugLabelsTile.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const TileGeometryCreator_1 = __webpack_require__(/*! ../../harp-mapview/lib/geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "../harp-omv-datasource/lib/OmvTile.ts");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 2,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterialWF = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterialWF.wireframe = true;
const debugCircleMaterial2WF = new THREE.MeshBasicMaterial({
    color: 0x8080ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterial2WF.wireframe = true;
const debugBlackCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const textRenderStyle = new harp_text_canvas_1.TextRenderStyle();
const textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();
textRenderStyle.fontSize = {
    unit: harp_text_canvas_1.FontUnit.Point,
    size: 9,
    backgroundSize: 0
};
textRenderStyle.opacity = 0.75;
textRenderStyle.backgroundOpacity = 0.75;
class OmvDebugLabelsTile extends OmvTile_1.OmvTile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
    loadingFinished() {
        this.addLabelDebugInfo();
    }
    /**
     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.
     */
    addLabelDebugInfo() {
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_TEXT_PATHS", true)
        const debugTextPaths = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS");
        const debugTextPathsFull = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS_FULL");
        if (!(debugTextPaths || debugTextPathsFull) || this.decodedTile === undefined) {
            return;
        }
        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const decodedTile = this.decodedTile;
        tileGeometryCreator.createTextElements(this, decodedTile);
        const colorMap = new Map();
        // allow limiting to specific names and/or index. There can be many paths with the same text
        const textFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.TEXT");
        const indexFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.INDEX");
        const zoomLevel = this.mapView.zoomLevel;
        if (decodedTile.textPathGeometries !== undefined) {
            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);
        }
        if (this.preparedTextPaths !== undefined) {
            const lineGeometry = new THREE.BufferGeometry();
            const lineIndices = new Array();
            const linePositions = new Array();
            const redPointGeometry = new THREE.BufferGeometry();
            const redPointIndices = new Array();
            const redPointPositions = new Array();
            const blackPointGeometry = new THREE.BufferGeometry();
            const blackPointIndices = new Array();
            const blackPointPositions = new Array();
            let baseVertex = 0;
            const pointScale = this.mapView.pixelToWorld;
            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                if (technique.color !== undefined) {
                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, zoomLevel)));
                }
                baseVertex = linePositions.length / 3;
                const text = textPath.text;
                const elementIndex = this.preparedTextPaths.indexOf(textPath);
                const createDebugInfo = (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&
                    (indexFilter === undefined || indexFilter === elementIndex);
                if (createDebugInfo) {
                    for (let i = 0; i < textPath.path.length; i += 3) {
                        const pathIndex = i / 3;
                        const x = textPath.path[i];
                        const y = textPath.path[i + 1];
                        // raise it a bit, so we get identify connectivity visually by tilting
                        const z = textPath.path[i + 2] + i / 3;
                        if (debugTextPaths) {
                            linePositions.push(x, y, z);
                        }
                        const isRedPoint = i === 0;
                        if (debugTextPathsFull || isRedPoint) {
                            const pointSize = pointScale * (isRedPoint ? 6 : 4);
                            const positions = isRedPoint ? redPointPositions : blackPointPositions;
                            const indices = isRedPoint ? redPointIndices : blackPointIndices;
                            positions.push(x, y - pointSize, z);
                            positions.push(x + pointSize, y, z);
                            positions.push(x, y + pointSize, z);
                            positions.push(x - pointSize, y, z);
                            const pointIndex = positions.length / 3;
                            indices.push(pointIndex - 4);
                            indices.push(pointIndex - 3);
                            indices.push(pointIndex - 2);
                            indices.push(pointIndex - 4);
                            indices.push(pointIndex - 2);
                            indices.push(pointIndex - 1);
                            if (debugTextPathsFull) {
                                // give point index a label
                                const label = pathIndex % 5 === 0
                                    ? text + ":" + pathIndex
                                    : Number(pathIndex).toString();
                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue(technique.priority || 0, zoomLevel), technique.xOffset || 0.0, technique.yOffset || 0.0);
                                labelElement.minZoomLevel = technique.minZoomLevel;
                                labelElement.mayOverlap = true;
                                labelElement.reserveSpace = false;
                                labelElement.alwaysOnTop = true;
                                labelElement.ignoreDistance = true;
                                this.addUserTextElement(labelElement);
                            }
                        }
                    }
                    // the lines of a path share a common geometry
                    const N = textPath.path.length / 3;
                    for (let i = 0; i < N; ++i) {
                        if (i > 0) {
                            lineIndices.push(baseVertex + i);
                        }
                        if (i + 1 < N) {
                            lineIndices.push(baseVertex + i);
                        }
                    }
                }
            }
            if (lineIndices.length > 0) {
                lineGeometry.addGroup(0, lineIndices.length, 0);
                lineGeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(linePositions), 3));
                lineGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(lineIndices), 1));
                const lineMesh = new THREE.LineSegments(lineGeometry, debugMaterial);
                lineMesh.renderOrder = 2000;
                this.objects.push(lineMesh);
            }
            if (redPointIndices.length > 0) {
                redPointGeometry.addGroup(0, redPointIndices.length, 0);
                redPointGeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(redPointPositions), 3));
                redPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(redPointIndices), 1));
                const redPointMesh = new THREE.Mesh(redPointGeometry, debugCircleMaterial);
                redPointMesh.renderOrder = 3000;
                this.objects.push(redPointMesh);
            }
            if (blackPointIndices.length > 0) {
                blackPointGeometry.addGroup(0, blackPointIndices.length, 0);
                blackPointGeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(blackPointPositions), 3));
                blackPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(blackPointIndices), 1));
                const blackPointMesh = new THREE.Mesh(blackPointGeometry, debugBlackCircleMaterial);
                blackPointMesh.renderOrder = 2500;
                this.objects.push(blackPointMesh);
            }
        }
    }
}
exports.OmvDebugLabelsTile = OmvDebugLabelsTile;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDecoderDefs.ts":
/*!****************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDecoderDefs.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.
 */
var FeatureModifierId;
(function (FeatureModifierId) {
    /**
     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.
     */
    FeatureModifierId[FeatureModifierId["tomTom"] = 0] = "tomTom";
})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));
/**
 * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.
 */
var OmvFilterString;
(function (OmvFilterString) {
    /**
     * Match condition.
     */
    let StringMatch;
    (function (StringMatch) {
        /** Matches any. */
        StringMatch[StringMatch["Any"] = 0] = "Any";
        /** Exact match. */
        StringMatch[StringMatch["Match"] = 1] = "Match";
        /** Matches if a test string starts with a filter string. */
        StringMatch[StringMatch["StartsWith"] = 2] = "StartsWith";
        /** Matches if a test string contains a filter string. */
        StringMatch[StringMatch["Contains"] = 3] = "Contains";
        /** Matches if a test string ends with a filter string. */
        StringMatch[StringMatch["EndsWith"] = 4] = "EndsWith";
    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));
    /**
     * Check for a string against a filter.
     *
     * @param str The string to check against a filter.
     * @param filterString The filter containing the match condition.
     * @returns `true` if the match condition is satisfied.
     */
    function matchString(str, filterString) {
        switch (filterString.match) {
            case OmvFilterString.StringMatch.Any:
                return true;
            case OmvFilterString.StringMatch.Match:
                return str === filterString.value;
            case OmvFilterString.StringMatch.StartsWith:
                return filterString.value.startsWith(str);
            case OmvFilterString.StringMatch.EndsWith:
                return filterString.value.endsWith(str);
            default:
                return str.indexOf(filterString.value) >= 0;
        }
    }
    OmvFilterString.matchString = matchString;
})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));
var OmvGeometryType;
(function (OmvGeometryType) {
    OmvGeometryType[OmvGeometryType["UNKNOWN"] = 0] = "UNKNOWN";
    OmvGeometryType[OmvGeometryType["POINT"] = 1] = "POINT";
    OmvGeometryType[OmvGeometryType["LINESTRING"] = 2] = "LINESTRING";
    OmvGeometryType[OmvGeometryType["POLYGON"] = 3] = "POLYGON";
})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));
/**
 * Default OMV tile decoder service type.
 *
 * Used for requesting decoder services using [[WorkerServiceManager]].
 */
exports.OMV_TILE_DECODER_SERVICE_TYPE = "omv-tile-decoder";
/**
 * Default OMV tiler service type.
 *
 * Used for requesting tiler services using [[WorkerServiceManager]].
 */
exports.OMV_TILER_SERVICE_TYPE = "omv-tiler";


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvRestClient.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvRestClient.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "../harp-transfer-manager/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("OmvRestClient");
// tslint:disable:max-line-length
var APIFormat;
(function (APIFormat) {
    /**
     * Use the REST API format of HERE Vector Tiles Server component version 1.
     *
     * Usage:
     *
     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv
     *
     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:
     *
     *     Authorization: Bearer $authenticationToken
     *
     * Format definition:
     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`
     *
     * Default authentication method used: [[AuthenticationTypeBearer]].
     */
    APIFormat[APIFormat["HereV1"] = 0] = "HereV1";
    /**
     * Use the REST API format of Mapbox Vector Tile API v4.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`
     *
     * Sample URL:
     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["MapboxV4"] = 1] = "MapboxV4";
    /**
     * Use the REST API format of XYZ Vector Tile API in MVT format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZMVT"] = 2] = "XYZMVT";
    /**
     * Use the REST API format of XYZ Vector Tile API in JSON format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZJson"] = 3] = "XYZJson";
    /**
     * Use the REST API format of XYZ Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZOMV"] = 4] = "XYZOMV";
    /**
     * Use the REST API format of Tomtoms Vector Tile API v1.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`
     *
     * Sample URL:
     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`
     *
     * Default authentication method used: [[AuthenticationTypeTomTomV1]].
     */
    APIFormat[APIFormat["TomtomV1"] = 5] = "TomtomV1";
    /**
     * Use the REST API format of XYZ Space Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZSpace"] = 6] = "XYZSpace";
})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod[AuthenticationMethod["QueryString"] = 0] = "QueryString";
    AuthenticationMethod[AuthenticationMethod["AuthorizationHeader"] = 1] = "AuthorizationHeader";
})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));
/**
 * Authentication method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeBearer = {
    method: AuthenticationMethod.AuthorizationHeader,
    name: "Bearer"
};
/**
 * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeTomTomV1 = {
    method: AuthenticationMethod.QueryString,
    name: "key"
};
exports.AuthenticationTypeAccessToken = {
    method: AuthenticationMethod.QueryString,
    name: "access_token"
};
/**
 * REST client supporting getting protobuf OMV Tile from REST-based servers.
 */
class OmvRestClient {
    constructor(params) {
        this.params = params;
        this.downloadManager =
            params.downloadManager === undefined
                ? harp_transfer_manager_1.TransferManager.instance()
                : params.downloadManager;
    }
    /** Overriding abstract method, in this case doing nothing. */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // not needed
        });
    }
    /** Overriding abstract method, in this case always returning `true`. */
    ready() {
        return true;
    }
    /**
     * Asynchronously fetches a tile from this restful server.
     *
     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is
     * returned.
     *
     * @example
     * ```typescript
     * const response = layer.getTile(tileKey);
     * if (!response.ok) {
     *     // a network error happened
     *     console.error("Unable to download tile", response.statusText);
     *     return;
     * }
     * if (response.status === 404) {
     *     // 404 -, no data exists at the given tile. Do nothing.
     *     return;
     * }
     *
     * // the response is ok and contains data, access it e.g. as arrayBuffer:
     * const payload = await response.arrayBuffer();
     * ```
     *
     * @param tileKey The tile key of the tile.
     * @param tileRequestInit Optional request options to be passed to fetch when downloading a
     * tile.
     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.
     */
    getTile(tileKey, abortSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            const init = { signal: abortSignal };
            let tileUrl = this.dataUrl(tileKey);
            const authenticationCode = yield this.getActualAuthenticationCode();
            tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);
            if (this.params.apiFormat === APIFormat.XYZJson) {
                return this.downloadManager.downloadJson(tileUrl, init);
            }
            return this.downloadManager.downloadArrayBuffer(tileUrl, init);
        });
    }
    /**
     * Get actual authentication code/token for this request according to configuration.
     */
    getActualAuthenticationCode() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.params.authenticationCode === "string") {
                return this.params.authenticationCode;
            }
            else if (this.params.authenticationCode !== undefined) {
                return this.params.authenticationCode();
            }
            else if (this.params.getBearerToken !== undefined) {
                return this.params.getBearerToken();
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * Get default authnentication method basing on apiFormat and other params.
     */
    getDefaultAuthMethod() {
        if (this.params.getBearerToken !== undefined) {
            return exports.AuthenticationTypeBearer;
        }
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
                return exports.AuthenticationTypeBearer;
            case APIFormat.MapboxV4:
            case APIFormat.XYZOMV:
            case APIFormat.XYZMVT:
            case APIFormat.XYZSpace:
            case APIFormat.XYZJson:
                return exports.AuthenticationTypeAccessToken;
            case APIFormat.TomtomV1:
                return exports.AuthenticationTypeTomTomV1;
            default:
                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);
                return undefined;
        }
    }
    /**
     * Apply athentication code/token using configured (or default) authentication method.
     *
     * @param url
     * @param init request extra data
     * @param authenticationCode authentication/token to be applied
     * @return new url to be used
     */
    applyAuthCode(url, init, authenticationCode) {
        if (authenticationCode === undefined) {
            return url;
        }
        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();
        if (authMethod === undefined) {
            return url;
        }
        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {
            if (init.headers === undefined) {
                init.headers = new Headers();
            }
            const authType = authMethod.name || "Bearer";
            init.headers.append("Authorization", `${authType} ${authenticationCode}`);
        }
        else if (authMethod.method === AuthenticationMethod.QueryString) {
            const attrName = authMethod.name || "access_token";
            url = this.addQueryParams(url, [[attrName, authenticationCode]]);
        }
        return url;
    }
    /**
     * Get actual tile URL depending on configured API format.
     */
    dataUrl(tileKey) {
        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ? "_" : "/");
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
            case APIFormat.XYZOMV:
                path += "/omv";
                break;
            case APIFormat.MapboxV4:
                path += ".mvt";
                break;
            case APIFormat.XYZMVT:
                path += ".mvt";
                break;
            case APIFormat.XYZJson:
                path += ".json";
                break;
            case APIFormat.XYZSpace:
                path += ".mvt";
                break;
            case APIFormat.TomtomV1:
                path += ".pbf";
                break;
            default:
                logger.warn(`Not supported API format: ${this.params.apiFormat}`);
                break;
        }
        return this.params.baseUrl + path;
    }
    addQueryParams(url, queryParams) {
        let queryString = "";
        let concatinator = url.indexOf("?") !== -1 ? "&" : "?";
        for (const param of queryParams) {
            queryString += concatinator + param[0] + "=" + param[1];
            if (concatinator === "?") {
                concatinator = "&";
            }
        }
        return url + queryString;
    }
}
exports.OmvRestClient = OmvRestClient;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvTile.ts":
/*!*********************************************!*\
  !*** ../harp-omv-datasource/lib/OmvTile.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
class OmvTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
}
exports.OmvTile = OmvTile;


/***/ }),

/***/ "../harp-text-canvas/index.ts":
/*!************************************!*\
  !*** ../harp-text-canvas/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/rendering/FontCatalog */ "../harp-text-canvas/lib/rendering/FontCatalog.ts"));
__export(__webpack_require__(/*! ./lib/rendering/GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts"));
__export(__webpack_require__(/*! ./lib/rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts"));
__export(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ "../harp-text-canvas/lib/rendering/TextBufferObject.ts"));
__export(__webpack_require__(/*! ./lib/TextCanvas */ "../harp-text-canvas/lib/TextCanvas.ts"));
__export(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ "../harp-text-canvas/lib/utils/ContextualArabicConverter.ts"));
__export(__webpack_require__(/*! ./lib/utils/MaterialUtils */ "../harp-text-canvas/lib/utils/MaterialUtils.ts"));
__export(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts"));
__export(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts"));


/***/ }),

/***/ "../harp-text-canvas/lib/TextCanvas.ts":
/*!*********************************************!*\
  !*** ../harp-text-canvas/lib/TextCanvas.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ "../harp-text-canvas/lib/rendering/TextBufferObject.ts");
const TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ "../harp-text-canvas/lib/typesetting/LineTypesetter.ts");
const PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ "../harp-text-canvas/lib/typesetting/PathTypesetter.ts");
const MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ "../harp-text-canvas/lib/utils/MaterialUtils.ts");
const tempTextPosition = new THREE.Vector3();
const tempTextBounds = {
    array: [new THREE.Box2()],
    offset: 0
};
let tempVertexBuffer = new Float32Array();
/**
 * Default's [[TextCanvas]] layer identifier.
 */
exports.DEFAULT_TEXT_CANVAS_LAYER = 0;
/**
 * three.js text rendering engine which can manage and render high-quality, transformable, stylable
 * and properly layout SDF and MSDF text.
 */
class TextCanvas {
    /**
     * Constructs a new `TextCanvas`.
     *
     * @param params `TextCanvas` construction parameters.
     *
     * @returns New `TextCanvas`.
     */
    constructor(params) {
        this.m_renderer = params.renderer;
        this.m_fontCatalog = params.fontCatalog;
        this.minGlyphCount = params.minGlyphCount;
        this.maxGlyphCount = params.maxGlyphCount;
        if (params.material === undefined) {
            this.m_ownsMaterial = true;
            this.m_material = MaterialUtils_1.createSdfTextMaterial({ fontCatalog: params.fontCatalog });
        }
        else {
            this.m_ownsMaterial = false;
            this.m_material = params.material;
        }
        if (params.backgroundMaterial === undefined) {
            this.m_ownsBgMaterial = true;
            this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                isBackground: true
            });
        }
        else {
            this.m_ownsBgMaterial = false;
            this.m_bgMaterial = params.backgroundMaterial;
        }
        this.m_defaultLayer = {
            id: exports.DEFAULT_TEXT_CANVAS_LAYER,
            storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
        };
        this.m_layers = [this.m_defaultLayer];
        this.m_defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();
        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;
        this.m_defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();
        this.m_currentTextLayoutStyle = this.m_defaultTextLayoutStyle;
        this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();
        this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();
    }
    /**
     * Currently active [[FontCatalog]].
     */
    get fontCatalog() {
        return this.m_fontCatalog;
    }
    set fontCatalog(value) {
        this.m_fontCatalog = value;
        const material = this.m_material;
        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
        const bgMaterial = this.m_bgMaterial;
        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
    }
    /**
     * Currently active text rendering material.
     */
    get material() {
        return this.m_material;
    }
    set material(value) {
        if (this.m_ownsMaterial) {
            this.m_material.dispose();
            this.m_ownsMaterial = false;
        }
        this.m_material = value;
        for (const layer of this.m_layers) {
            layer.storage.mesh.material = this.m_material;
        }
    }
    /**
     * Currently active text background rendering material.
     */
    get backgroundMaterial() {
        return this.m_bgMaterial;
    }
    set backgroundMaterial(value) {
        if (this.m_ownsBgMaterial) {
            this.m_bgMaterial.dispose();
            this.m_ownsBgMaterial = false;
        }
        this.m_bgMaterial = value;
        for (const layer of this.m_layers) {
            layer.storage.backgroundMesh.material = this.m_bgMaterial;
        }
    }
    /**
     * Currently active text rendering style.
     */
    get textRenderStyle() {
        return this.m_currentTextRenderStyle;
    }
    set textRenderStyle(style) {
        this.m_currentTextRenderStyle = style;
    }
    /**
     * Currently active text layout style.
     */
    get textLayoutStyle() {
        return this.m_currentTextLayoutStyle;
    }
    set textLayoutStyle(style) {
        this.m_currentTextLayoutStyle = style;
    }
    /**
     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).
     */
    clear() {
        for (const layer of this.m_layers) {
            layer.storage.clear();
        }
        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;
    }
    /**
     * Renders the content of this `TextCanvas`.
     *
     * @param camera Orthographic camera.
     * @param target Optional render target.
     * @param clear Optional render target clear operation.
     */
    render(camera, target, clear) {
        this.m_fontCatalog.update(this.m_renderer);
        let oldTarget = null;
        if (target !== undefined) {
            oldTarget = this.m_renderer.getRenderTarget();
            this.m_renderer.setRenderTarget(target);
        }
        if (clear === true) {
            this.m_renderer.clear(true);
        }
        for (const layer of this.m_layers) {
            layer.storage.update();
            this.m_renderer.clear(false, true);
            this.m_renderer.render(layer.storage.scene, camera);
        }
        if (target !== undefined) {
            this.m_renderer.setRenderTarget(oldTarget);
        }
    }
    /**
     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the
     * input `layerId`, it just returns this one instead.
     *
     * @param layerId Desired layer identifier.
     *
     * @returns Created [[TextCanvasLayer]].
     */
    addLayer(layerId) {
        let result = this.getLayer(layerId);
        if (result === undefined) {
            result = {
                id: layerId,
                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
            };
            this.m_layers.push(result);
            this.m_layers.sort((a, b) => {
                return a.id - b.id;
            });
        }
        return result;
    }
    /**
     * Retrieves a specific `TextCanvas` rendering layer.
     *
     * @param layerId Desired layer identifier.
     *
     * @returns Selected [[TextCanvasLayer]].
     */
    getLayer(layerId) {
        return this.m_layers.find(layer => layer.id === layerId);
    }
    /**
     * Retrieves all `TextCanvas` rendering layers.
     *
     * @returns Array of [[TextCanvasLayer]]s.
     */
    getAllLayers() {
        return this.m_layers;
    }
    /**
     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and
     * [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param outputBounds Output text bounding box.
     * @param params Optional measurement parameters.
     *
     * @returns Result of the measurement. If `false`, some error occurred during execution and the
     * input text couldn't be properly measured.
     */
    measureText(text, outputBounds, params) {
        tempTextPosition.set(0, 0, 0);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let outputCharacterBounds;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            outputCharacterBounds = params.outputCharacterBounds;
            if (params.path !== undefined) {
                const pathOrigin = params.path.getPoint(0);
                if (pathOrigin === null) {
                    return false;
                }
                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        return this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: outputBounds,
            individualBounds: outputCharacterBounds,
            letterCaseArray: upperCaseArray
        });
    }
    /**
     * Adds the input text to this `TextCanvas` in the specified screen position. The current
     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param position Screen position.
     * @param params Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addText(text, position, params) {
        tempTextPosition.copy(position);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let targetLayer = this.m_defaultLayer;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            if (params.path !== undefined) {
                tempTextPosition.set(0, 0, tempTextPosition.z);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = this.placeText({
            input: text,
            textPath: path,
            textPathOverflow: pathOverflow,
            layer: targetLayer,
            letterCaseArray: upperCaseArray
        });
        if (result && params !== undefined) {
            if (params.updatePosition === true) {
                position.copy(tempTextPosition);
            }
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the
     * result of performing the `addText` function for the input text in the screen origin.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param params Optional creation parameters.
     *
     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be
     * retrieved from the current [[FontCatalog]]).
     */
    createTextBufferObject(text, params) {
        tempTextPosition.set(0, 0, 0);
        let glyphArray;
        let upperCaseArray;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof text !== "string") {
            glyphArray = text;
            if (params !== undefined && params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        else {
            upperCaseArray = [];
            glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);
            if (glyphArray === undefined) {
                return undefined;
            }
        }
        let path;
        let pathOverflow;
        let textBounds;
        let characterBounds;
        let renderStyle;
        let layoutStyle;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.outputBounds === true) {
                textBounds = new THREE.Box2();
            }
            if (params.outputCharacterBounds === true) {
                characterBounds = [];
            }
            if (params.storeStyles === true) {
                renderStyle = this.m_currentTextRenderStyle;
                layoutStyle = this.m_currentTextLayoutStyle;
            }
        }
        this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            computeTextBuffer: true,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: textBounds,
            individualBounds: characterBounds,
            letterCaseArray: upperCaseArray
        });
        return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
    }
    /**
     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can
     * be provided to override the attributes stored in the buffer.
     *
     * @param textBufferObject [[TextBufferObject]] to add.
     * @param params Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addTextBufferObject(textBufferObject, params) {
        let targetLayer = this.m_defaultLayer;
        let position;
        let scale;
        let rotation;
        let color;
        let opacity;
        let bgColor;
        let bgOpacity;
        if (params !== undefined) {
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            position = params.position;
            scale = params.scale;
            rotation = params.rotation;
            color = params.color;
            opacity = params.opacity;
            bgColor = params.backgroundColor;
            bgOpacity = params.backgroundOpacity;
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
        if (result && params !== undefined) {
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Executes the `pickCallback` for all previously stored picking data for text covering the
     * specified screen position.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickText(position, callback) {
        for (const layer of this.m_layers) {
            layer.storage.pick(position, callback);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.
     *
     * @param info The info object to increment with the values from this `TextCanvas`.
     */
    getMemoryUsage(info) {
        this.m_fontCatalog.updateMemoryUsage(info);
        for (const layer of this.m_layers) {
            layer.storage.updateMemoryUsage(info);
        }
    }
    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs
    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for
    // the input (as a whole or on a per-character basis).
    placeText(params) {
        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
            if (params.bounds !== undefined) {
                params.bounds.min.set(0, 0);
                params.bounds.max.set(0, 0);
            }
            if (params.individualBounds !== undefined) {
                params.individualBounds.length = 0;
            }
            return true;
        }
        let glyphArray;
        let smallCapsTransformations;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof params.input !== "string") {
            glyphArray = params.input;
            if (params.letterCaseArray) {
                smallCapsTransformations = params.letterCaseArray;
            }
        }
        else {
            smallCapsTransformations = [];
            glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);
            if (glyphArray === undefined) {
                return false;
            }
        }
        let glyphBounds;
        if (params.individualBounds !== undefined) {
            tempTextBounds.array = params.individualBounds;
            tempTextBounds.offset = 0;
            glyphBounds = tempTextBounds;
        }
        if (params.bounds !== undefined) {
            params.bounds.min.set(Infinity, Infinity);
            params.bounds.max.set(-Infinity, -Infinity);
        }
        if (params.computeTextBuffer === true) {
            tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);
        }
        const isPath = params.textPath !== undefined;
        const typesettingParams = {
            glyphs: glyphArray,
            fontCatalog: this.m_fontCatalog,
            textRenderStyle: this.m_currentTextRenderStyle,
            textLayoutStyle: this.m_currentTextLayoutStyle,
            position: tempTextPosition,
            geometry: params.layer.storage,
            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,
            globalBounds: params.bounds,
            individualBounds: glyphBounds,
            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined
        };
        let result = true;
        if (isPath) {
            Object.assign(typesettingParams, {
                path: params.textPath,
                pathOverflow: params.textPathOverflow === true
            });
            result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
        }
        else {
            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
        }
        if (glyphBounds !== undefined) {
            glyphBounds.array.length = glyphBounds.offset;
        }
        return result;
    }
}
exports.TextCanvas = TextCanvas;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/FontCatalog.ts":
/*!********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/FontCatalog.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts");
const GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ "../harp-text-canvas/lib/rendering/GlyphTextureCache.ts");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const ASSETS_PATH = "_Assets/";
const BOLD_ASSETS_PATH = "_BoldAssets/";
const ITALIC_ASSETS_PATH = "_ItalicAssets/";
const BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
const REPLACEMENT_PATH = "_Assets/Extra/";
/**
 * Collection of font assets used to render glyphs when using a [[TextCanvas]].
 *
 * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed
 * to cover the widest Unicode code point range possible. In order to manage all these assets
 * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and
 * assets for a block are only loaded once a glyph belonging to that block is requested.
 *
 * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture
 * resource, which can be sampled to render all currently loaded glyphs.
 *
 */
class FontCatalog {
    /**
     * @hidden
     * Creates a new FontCatalog.
     *
     * @param url FontCatalog's URL.
     * @param name FontCatalog's name.
     * @param type FontCatalog's type (sdf or msdf).
     * @param size FontCatalog's glyph size (pixels).
     * @param maxWidth FontCatalog's maximum glyph width (pixels).
     * @param maxHeight FontCatalog's maximum glyph height (pixels).
     * @param distanceRange Distance range used to generate the SDF bitmaps.
     * @param fonts Array of supported fonts.
     * @param unicodeBlocks Array of supported Unicode blocks.
     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     * @param m_replacementGlyph [[GlyphData]] to be used whenever a Unicode code point is not
     * supported by this `FontCatalog`.
     *
     * @returns New FontCatalog.
     */
    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
        this.url = url;
        this.name = name;
        this.type = type;
        this.size = size;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.distanceRange = distanceRange;
        this.fonts = fonts;
        this.unicodeBlocks = unicodeBlocks;
        this.maxCodePointCount = maxCodePointCount;
        this.m_replacementGlyph = m_replacementGlyph;
        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
        this.m_loadingJson = new Map();
        this.m_loadingPages = new Map();
        this.m_loadingGlyphs = new Map();
        this.m_loadedJson = new Map();
        this.m_loadedPages = new Map();
        this.m_loadedGlyphs = new Map();
    }
    /**
     * Loads a `FontCatalog`.
     *
     * @param url Asset url.
     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     *
     * @returns `FontCatalog` Promise.
     */
    static load(path, maxCodePointCount) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = new URL(path, window.location.href);
            const fontCatalog = yield FontCatalog.loadJSON(url.href);
            const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);
            const replacementJson = yield FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
            const replacementTexture = yield FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
            replacementTexture.wrapS = THREE.ClampToEdgeWrapping;
            replacementTexture.wrapT = THREE.ClampToEdgeWrapping;
            replacementTexture.minFilter = THREE.NearestFilter;
            replacementTexture.needsUpdate = true;
            const replacementFont = fontCatalog.fonts.find((font) => font.name === "Extra");
            const replacementGlyph = new GlyphData_1.GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont);
            const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
            return fontCatalogInfo;
        });
    }
    static loadTexture(url) {
        return new Promise(resolve => {
            new THREE.TextureLoader().load(url, resolve);
        });
    }
    static loadJSON(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(url);
            if (!response.ok) {
                throw new Error(`${url} Status Text:  ${response.statusText}`);
            }
            const rawJSON = yield response.text();
            return JSON.parse(rawJSON);
        });
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.fonts.length = 0;
        this.unicodeBlocks.length = 0;
        this.m_glyphTextureCache.dispose();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Removes all loaded (and loading) assets.
     */
    clear() {
        this.m_glyphTextureCache.clear();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer WebGLRenderer.
     */
    update(renderer) {
        this.m_glyphTextureCache.update(renderer);
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_glyphTextureCache.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_glyphTextureCache.textureSize;
    }
    /**
     * Current internal loading state.
     */
    get isLoading() {
        return (this.m_loadingJson.size > 0 ||
            this.m_loadingPages.size > 0 ||
            this.m_loadingGlyphs.size > 0);
    }
    /**
     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls
     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.
     *
     * @param block Requested [[UnicodeBlock]].
     * @param font [[Font]] to retrieve this Unicode block from.
     * @param fontStyle [[FontStyle]] assets to load.
     * @param loadPages If `true`, all pages in this Unicode block will also be loaded.
     *
     * @returns Loaded Unicode Block json.
     */
    loadBlock(block, font, fontStyle, loadPages) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetsPath = this.getAssetsPath(fontStyle, font);
            const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
            let json = this.m_loadedJson.get(jsonPath);
            if (json === undefined) {
                let jsonPromise = this.m_loadingJson.get(jsonPath);
                if (jsonPromise === undefined) {
                    try {
                        jsonPromise = FontCatalog.loadJSON(jsonPath);
                        this.m_loadingJson.set(jsonPath, jsonPromise);
                        json = yield jsonPromise;
                        this.m_loadingJson.delete(jsonPath);
                        this.m_loadedJson.set(jsonPath, json);
                    }
                    catch (e) {
                        // tslint:disable-next-line:no-console
                        console.error(e);
                        this.m_loadingJson.delete(jsonPath);
                    }
                }
                else {
                    json = yield jsonPromise;
                }
            }
            const pagePromises = [];
            if (loadPages === true) {
                for (const page of json.pages) {
                    pagePromises.push(this.loadPage(`${assetsPath}/${page}`));
                }
            }
            yield Promise.all(pagePromises);
            return json;
        });
    }
    /**
     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).
     * Safe to call when no assets for this block have been loaded.
     *
     * @param block Requested [[UnicodeBlock]].
     * @param font [[Font]] to remove this Unicode block from.
     * @param fontStyle [[FontStyle]] assets to remove.
     */
    removeBlock(block, font, fontStyle) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        const json = this.m_loadedJson.get(jsonPath);
        if (json !== undefined) {
            for (const page of json.pages) {
                const pagePath = `${assetsPath}/${page}`;
                this.m_loadingPages.delete(pagePath);
                this.m_loadedPages.delete(pagePath);
            }
            this.m_loadingJson.delete(jsonPath);
            this.m_loadedJson.delete(jsonPath);
        }
    }
    /**
     * Loads all the required glyphs needed to render the input text. Character repetition will not
     * be considered, and only styled assets (with applied font selection, style and variants) will
     * be loaded.
     *
     * @param input Input text.
     * @param style Specific [[TextRenderStyle]] for which glyphs will be loaded.
     *
     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.
     */
    loadCharset(input, style) {
        return __awaiter(this, void 0, void 0, function* () {
            const fontName = style.fontName;
            const fontStyle = style.fontStyle;
            const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||
                style.fontVariant === TextStyle_1.FontVariant.SmallCaps;
            const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, (c, s) => {
                return s.indexOf(c) + 1 ? "" : c;
            });
            const glyphPromises = [];
            for (const char of charset) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const fontHash = `${font.name}_${fontStyle}`;
                const glyphHash = `${fontHash}_${codePoint}`;
                let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);
                if (fontGlyphMap === undefined) {
                    fontGlyphMap = new Map();
                    this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
                }
                const glyph = fontGlyphMap.get(codePoint);
                if (glyph === undefined) {
                    let glyphPromise = this.m_loadingGlyphs.get(glyphHash);
                    if (glyphPromise === undefined) {
                        if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {
                            const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);
                            fontGlyphMap.set(codePoint, replacementGlyph);
                            this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
                            continue;
                        }
                        let charUnicodeBlock;
                        for (const block of this.unicodeBlocks) {
                            if (codePoint >= block.min && codePoint <= block.max) {
                                charUnicodeBlock = block;
                                break;
                            }
                        }
                        glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
                        this.m_loadingGlyphs.set(glyphHash, glyphPromise);
                        glyphPromise.then((loadedGlyph) => {
                            this.m_loadingGlyphs.delete(glyphHash);
                            fontGlyphMap.set(codePoint, loadedGlyph);
                            this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
                        });
                    }
                    glyphPromises.push(glyphPromise);
                }
                else if (!this.m_glyphTextureCache.has(glyphHash)) {
                    glyphPromises.push(Promise.resolve(glyph));
                    this.m_glyphTextureCache.add(glyphHash, glyph);
                }
            }
            return Promise.all(glyphPromises);
        });
    }
    /**
     * Retrieves the loaded [[GlyphData]] for a specific character.
     * Returns `undefined` if the assets for this glyph haven't been loaded yet.
     *
     * @param codePoint Character's Unicode code point.
     * @param font [[Font]] to get this glyph from.
     * @param fontStyle Specific [[FontStyle]] to get glyphs for.
     *
     * @returns [[GlyphData]] for this code point.
     */
    getGlyph(codePoint, font, fontStyle) {
        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);
        if (fontGlyphMap === undefined) {
            return undefined;
        }
        return fontGlyphMap.get(codePoint);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for the specified text.
     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.
     *
     * @param input Input text.
     * @param style Specific [[TextRenderStyle]] to get glyphs for.
     * @param letterCaseArray Array containing the original letter case for the requested glyphs.
     *
     * @returns Array containing [[GlyphData]] for each character of the input text.
     */
    getGlyphs(input, style, letterCaseArray) {
        const result = [];
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const fontVariant = style.fontVariant;
        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;
        for (const character of input) {
            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;
            for (const char of transformedCharacter) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const glyphData = this.getGlyph(codePoint, font, fontStyle);
                if (glyphData !== undefined) {
                    result.push(glyphData);
                    if (letterCaseArray !== undefined) {
                        letterCaseArray.push(char !== character);
                    }
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    /**
     * Gets the best matched font for a specific character.
     *
     * @param codePoint Character's Unicode code point.
     * @param fontName Font name suggestion.
     *
     * @returns Best matched font.
     */
    getFont(codePoint, fontName) {
        let selectedFontName = this.fonts[0].name;
        for (const block of this.unicodeBlocks) {
            if (codePoint >= block.min && codePoint <= block.max) {
                selectedFontName =
                    fontName !== undefined &&
                        block.fonts.find(element => {
                            return element === fontName;
                        }) !== undefined
                        ? fontName
                        : block.fonts[0];
                break;
            }
        }
        return this.fonts.find(element => {
            return element.name === selectedFontName;
        });
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.
     *
     * @param info The info object to increment with the values from this `FontCatalog`.
     */
    updateMemoryUsage(info) {
        let numBytes = 0;
        for (const block of this.unicodeBlocks) {
            numBytes += (block.max - block.min) * 2;
        }
        // Always stored in RGBA internally.
        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
        for (const page in this.m_loadedPages.entries) {
            if (this.m_loadedPages.get(page) !== undefined) {
                const loadedPage = this.m_loadedPages.get(page);
                if (loadedPage !== undefined) {
                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
                }
            }
        }
        info.heapSize += numBytes + textureBytes;
        info.gpuSize += textureBytes;
    }
    createReplacementGlyph(codePoint, char, font) {
        const replacementGlyph = this.m_replacementGlyph.clone();
        replacementGlyph.codePoint = codePoint;
        replacementGlyph.character = char;
        replacementGlyph.font = font;
        return replacementGlyph;
    }
    loadAssets(codePoint, fontStyle, block, font) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.loadBlock(block, font, fontStyle);
            if (json === undefined) {
                return this.m_replacementGlyph;
            }
            const sourceGlyphData = json.chars.find(char => char.id === codePoint);
            const assetsPath = this.getAssetsPath(fontStyle, font);
            const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;
            const texture = yield this.loadPage(texturePath);
            const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);
            return glyphData;
        });
    }
    loadPage(pagePath) {
        return __awaiter(this, void 0, void 0, function* () {
            let page = this.m_loadedPages.get(pagePath);
            if (page === undefined) {
                let pagePromise = this.m_loadingPages.get(pagePath);
                if (pagePromise === undefined) {
                    pagePromise = FontCatalog.loadTexture(pagePath);
                    this.m_loadingPages.set(pagePath, pagePromise);
                    page = yield pagePromise;
                    page.wrapS = THREE.ClampToEdgeWrapping;
                    page.wrapT = THREE.ClampToEdgeWrapping;
                    page.minFilter = THREE.NearestFilter;
                    page.needsUpdate = true;
                    if (this.m_loadingPages.delete(pagePath)) {
                        this.m_loadedPages.set(pagePath, page);
                    }
                    this.m_loadingPages.delete(pagePath);
                }
                else {
                    page = yield pagePromise;
                }
            }
            return page;
        });
    }
    getAssetsPath(fontStyle, font) {
        let fontStylePath = ASSETS_PATH;
        switch (fontStyle) {
            case TextStyle_1.FontStyle.Bold:
                if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.Italic:
                if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.BoldItalic:
                if (font.boldItalic !== undefined) {
                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;
                }
                else if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                else if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
        }
        return `${this.url}/${this.name}${fontStylePath}${font.name}`;
    }
}
exports.FontCatalog = FontCatalog;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/GlyphData.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/GlyphData.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * Structure containing all the required information necessary to render a BMFont glyph using
 * [[TextCanvas]].
 */
class GlyphData {
    /**
     * Creates a new `GlyphData` object.
     *
     * @param codePoint Unicode code point.
     * @param block Unicode block.
     * @param width Glyph' width.
     * @param height Glyph' height.
     * @param advanceX Amount of pixel to move after placing this glyph.
     * @param offsetX Horizontal offset from the glyph' origin.
     * @param offsetY Vertical offset from the glyph' origin.
     * @param u0 Glyph' left texture coordinate.
     * @param v0 Glyph' bottom texture coordinate.
     * @param u1 Glyph' right texture coordinate.
     * @param v1 Glyph' top texture coordinate.
     * @param texture Glyph' source texture atlas page.
     * @param font Glyph' font.
     *
     * @returns New `GlyphData`.
     */
    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font) {
        this.codePoint = codePoint;
        this.block = block;
        this.width = width;
        this.height = height;
        this.advanceX = advanceX;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.texture = texture;
        this.font = font;
        /**
         * Array containing the positions for all corners of this glyph.
         */
        this.positions = [];
        /**
         * Array containing the source texture coordinates for all corners of this glyph.
         * Used to sample the original texture atlas pages.
         */
        this.sourceTextureCoordinates = [];
        /**
         * Array containing the dynamic texture coordinates for all corners of this glyph.
         * Used to sample the dynamic texture atlas page.
         */
        this.dynamicTextureCoordinates = [];
        /**
         * Source texture atlas' page copy index.
         */
        this.copyIndex = 0;
        /**
         * Flag indicating if glyph can be currently rendered.
         */
        this.isInCache = false;
        this.character = String.fromCodePoint(codePoint);
        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);
        const left = this.offsetX;
        const right = left + this.width;
        const top = font.metrics.lineHeight - this.offsetY;
        const bottom = top - this.height;
        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));
        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));
        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));
    }
    /**
     * Clone this `GlyphData`.
     *
     * @returns Cloned `GlyphData`.
     */
    clone() {
        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font);
    }
}
exports.GlyphData = GlyphData;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/GlyphTextureCache.ts":
/*!**************************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/GlyphTextureCache.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts");
const TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ "../harp-text-canvas/lib/rendering/TextMaterials.ts");
/**
 * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined
 * by the maximum number of texture units available on a pixel shader for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS
 */
const MAX_NUM_COPY_PAGES = 8;
/**
 * Maximum texture size supported. This amount is determined by the maximum texture size supported
 * for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE
 */
const MAX_TEXTURE_SIZE = 4096;
/**
 * @hidden
 * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].
 * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.
 */
class GlyphTextureCache {
    /**
     * Creates a `GlyphTextureCache` object.
     *
     * @param capacity Cache's maximum glyph capacity.
     * @param entryWidth Maximum entry width.
     * @param entryHeight Maximum entry height.
     *
     * @returns New `GlyphTextureCache`.
     */
    constructor(capacity, entryWidth, entryHeight) {
        this.capacity = capacity;
        this.entryWidth = entryWidth;
        this.entryHeight = entryHeight;
        const nRows = Math.floor(Math.sqrt(capacity));
        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
            // tslint:disable-next-line:no-console
            console.warn("GlyphTextureCache texture size (" +
                this.m_textureSize.x +
                ", " +
                this.m_textureSize.y +
                ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" +
                MAX_TEXTURE_SIZE +
                ").\n" +
                "This could result in rendering errors on some devices.\n" +
                "Please consider reducing its capacity or input assets size.");
        }
        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);
        this.initCacheEntries();
        this.m_scene = new THREE.Scene();
        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
        this.m_camera.position.z = 1;
        this.m_camera.updateMatrixWorld(false);
        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            depthBuffer: false,
            stencilBuffer: false
        });
        this.m_copyTextureSet = new Set();
        this.m_copyTransform = new THREE.Matrix3();
        this.m_copyPositions = [];
        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
        this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial();
        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);
        this.m_copyVertexBuffer.setDynamic(true);
        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
        this.m_copyGeometry = new THREE.BufferGeometry();
        this.m_copyGeometry.addAttribute("position", this.m_copyPositionAttribute);
        this.m_copyGeometry.addAttribute("uv", this.m_copyUVAttribute);
        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        copyIndexBuffer.setDynamic(true);
        this.m_copyGeometry.setIndex(copyIndexBuffer);
        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);
        this.m_copyMesh.frustumCulled = false;
        this.m_copyGeometryDrawCount = 0;
        this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial();
        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);
        this.m_clearPositionAttribute.setDynamic(true);
        this.m_clearGeometry = new THREE.BufferGeometry();
        this.m_clearGeometry.addAttribute("position", this.m_clearPositionAttribute);
        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        clearIndexBuffer.setDynamic(true);
        this.m_clearGeometry.setIndex(clearIndexBuffer);
        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);
        this.m_clearMesh.frustumCulled = false;
        this.m_clearGeometryDrawCount = 0;
        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.m_entryCache.clear();
        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
        this.m_rt.dispose();
        this.m_clearMaterial.dispose();
        this.m_copyMaterial.dispose();
        this.m_copyTextureSet.clear();
        this.m_clearGeometry.dispose();
        this.m_copyGeometry.dispose();
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_rt.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_textureSize;
    }
    /**
     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested
     * entry will be replaced.
     *
     * @param hash Entry's hash.
     * @param glyph Entry's glyph data.
     */
    add(hash, glyph) {
        const entry = this.m_entryCache.get(hash);
        if (entry !== undefined) {
            return;
        }
        const oldestEntry = this.m_entryCache.oldest;
        if (oldestEntry === null) {
            throw new Error("GlyphTextureCache is uninitialized!");
        }
        this.clearCacheEntry(oldestEntry.value);
        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
    }
    /**
     * Checks if an entry is in the cache.
     *
     * @param hash Entry's hash.
     *
     * @returns Test result.
     */
    has(hash) {
        return this.m_entryCache.has(hash);
    }
    /**
     * Retrieves an entry from the cache.
     *
     * @param hash Entry's hash.
     *
     * @returns Retrieval result.
     */
    get(hash) {
        return this.m_entryCache.get(hash);
    }
    /**
     * Clears the internal LRUCache.
     */
    clear() {
        this.m_copyGeometryDrawCount = 0;
        this.m_clearGeometryDrawCount = 0;
        this.m_entryCache.clear();
        this.m_copyTextureSet.clear();
        this.initCacheEntries();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer WebGLRenderer.
     */
    update(renderer) {
        let oldRenderTarget = null;
        const willClearGeometry = this.m_clearGeometryDrawCount > 0;
        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;
        if (willClearGeometry || willCopyGeometry) {
            oldRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(this.m_rt);
        }
        if (willClearGeometry) {
            this.m_clearPositionAttribute.needsUpdate = true;
            this.m_clearPositionAttribute.updateRange.offset = 0;
            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
            this.m_clearGeometry.index.needsUpdate = true;
            this.m_clearGeometry.index.updateRange.offset = 0;
            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
            this.m_clearMesh.visible = true;
            this.m_copyMesh.visible = false;
            renderer.render(this.m_scene, this.m_camera);
            this.m_clearGeometryDrawCount = 0;
            this.m_clearMesh.visible = false;
        }
        if (willCopyGeometry) {
            this.m_copyVertexBuffer.needsUpdate = true;
            this.m_copyVertexBuffer.updateRange.offset = 0;
            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
            this.m_copyGeometry.index.needsUpdate = true;
            this.m_copyGeometry.index.updateRange.offset = 0;
            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
            this.m_copyMesh.visible = true;
            const srcPages = Array.from(this.m_copyTextureSet);
            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {
                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {
                    const pageIndex = pageOffset + i;
                    if (pageIndex < this.m_copyTextureSet.size) {
                        this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
                    }
                }
                renderer.render(this.m_scene, this.m_camera);
            }
            this.m_copyTextureSet.clear();
            this.m_copyGeometryDrawCount = 0;
        }
        if (willClearGeometry || willCopyGeometry) {
            renderer.setRenderTarget(oldRenderTarget);
        }
    }
    initCacheEntries() {
        const dummyMetrics = {
            size: 0,
            distanceRange: 0,
            base: 0,
            lineHeight: 0,
            lineGap: 0,
            capHeight: 0,
            xHeight: 0
        };
        const dummyFont = {
            name: "",
            metrics: dummyMetrics,
            charset: ""
        };
        const dummyGlyphData = new GlyphData_1.GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);
        for (let i = 0; i < this.m_cacheHeight; i++) {
            for (let j = 0; j < this.m_cacheWidth; j++) {
                const dummyEntry = {
                    glyphData: dummyGlyphData,
                    location: new THREE.Vector2(j, i)
                };
                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);
            }
        }
    }
    copyGlyphToCache(hash, glyph, cacheLocation) {
        this.m_copyTextureSet.add(glyph.texture);
        let copyTextureIndex = 0;
        for (const value of this.m_copyTextureSet.values()) {
            if (value === glyph.texture) {
                break;
            }
            copyTextureIndex++;
        }
        glyph.copyIndex = copyTextureIndex;
        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
        }
        if (this.m_copyGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_copyGeometryDrawCount * 4;
        const baseIndex = this.m_copyGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);
            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);
        }
        this.m_copyGeometry.index.setX(baseIndex, baseVertex);
        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_copyGeometryDrawCount;
        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
        glyph.dynamicTextureCoordinates[0].set(u0, v0);
        glyph.dynamicTextureCoordinates[1].set(u1, v0);
        glyph.dynamicTextureCoordinates[2].set(u0, v1);
        glyph.dynamicTextureCoordinates[3].set(u1, v1);
        glyph.isInCache = true;
        this.m_entryCache.set(hash, {
            glyphData: glyph,
            location: cacheLocation
        });
    }
    clearCacheEntry(entry) {
        entry.glyphData.isInCache = false;
        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        if (this.m_clearGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_clearGeometryDrawCount * 4;
        const baseIndex = this.m_clearGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
        }
        this.m_clearGeometry.index.setX(baseIndex, baseVertex);
        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_clearGeometryDrawCount;
    }
}
exports.GlyphTextureCache = GlyphTextureCache;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextBufferObject.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextBufferObject.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Object containing vertex buffer data generated by [[TextCanvas]].
 */
class TextBufferObject {
    /**
     * Constructs a new `TextBufferObject`.
     *
     * @param glyphs Input glyphs.
     * @param buffer Buffer containing the data generated by [[TextCanvas]].
     * @param bounds Optional text bounds.
     * @param characterBounds Optional character bounds.
     * @param textRenderStyle [[TextRenderStyle]] applied by [[TextCanvas]].
     * @param textLayoutStyle [[TextLayoutStyle]] applied by [[TextCanvas]].
     *
     * @returns New `TextBufferObject`.
     */
    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
        this.glyphs = glyphs;
        this.buffer = buffer;
        this.bounds = bounds;
        this.characterBounds = characterBounds;
        this.textRenderStyle = textRenderStyle;
        this.textLayoutStyle = textLayoutStyle;
    }
}
exports.TextBufferObject = TextBufferObject;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextGeometry.ts":
/*!*********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextGeometry.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
exports.MAX_CAPACITY = 65536;
exports.VERTEX_BUFFER_STRIDE = 16;
exports.INDEX_BUFFER_STRIDE = 1;
exports.VERTICES_PER_QUAD = 4;
exports.INDICES_PER_QUAD = 6;
exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;
exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].
 */
class TextGeometry {
    /**
     * Creates a new `TextGeometry`.
     *
     * @param material Material used to render foreground glyphs.
     * @param backgroundMaterial Material used to render background glyphs.
     * @param initialSize Initial amount of glyphs that can be stored.
     * @param capacity Maximum glyph capacity.
     *
     * @returns New `TextGeometry`.
     */
    constructor(scene, material, backgroundMaterial, initialSize, capacity) {
        this.scene = scene;
        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);
        this.m_currentCapacity = Math.min(initialSize, capacity);
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setDynamic(true);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setDynamic(true);
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.addAttribute("position", this.m_positionAttribute);
        this.m_geometry.addAttribute("uv", this.m_uvAttribute);
        this.m_geometry.addAttribute("color", this.m_colorAttribute);
        this.m_geometry.addAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray = new Array(this.m_currentCapacity);
        this.m_mesh = new THREE.Mesh(this.m_geometry, material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
    /**
     * Count of currently drawn glyphs.
     */
    get drawCount() {
        return this.m_drawCount;
    }
    /**
     * Mesh used to render foreground glyphs.
     */
    get mesh() {
        return this.m_mesh;
    }
    /**
     * Mesh used to render background glyphs.
     */
    get backgroundMesh() {
        return this.m_bgMesh;
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_geometry.dispose();
    }
    /**
     * Clear the geometry.
     */
    clear() {
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
    }
    /**
     * Update the GPU resources to reflect the latest additions to the geometry.
     */
    update() {
        if (this.drawCount > this.m_updateOffset) {
            this.m_vertexBuffer.needsUpdate = true;
            this.m_vertexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_vertexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.needsUpdate = true;
            this.m_indexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
        }
        this.m_updateOffset = this.m_drawCount;
        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);
    }
    /**
     * Add a new glyph to the `TextGeometry`.
     *
     * @param glyphData [[GlyphData]] holding the glyph description.
     * @param corners Transformed glyph corners.
     * @param weight Foreground glyph sampling weight.
     * @param bgWeight Foreground glyph sampling weight.
     * @param mirrored If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).
     * @param style Currently set [[TextRenderStyle]].
     *
     * @returns Result of the addition.
     */
    add(glyphData, corners, weight, bgWeight, mirrored, style) {
        if (this.m_drawCount >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;
        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
        }
        this.m_indexBuffer.setX(baseIndex, baseVertex);
        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_drawCount;
        return true;
    }
    /**
     * Add a new glyph to a text buffer.
     *
     * @param buffer Target buffer where glyph attributes will be stored.
     * @param offset Offset of the target buffer.
     * @param glyphData [[GlyphData]] holding the glyph description.
     * @param corners Transformed glyph corners.
     * @param weight Foreground glyph sampling weight.
     * @param bgWeight Foreground glyph sampling weight.
     * @param mirrored If `true`, UVs will be mirrored (needed for RTL punctuation).
     * @param style Currently set [[TextRenderStyle]].
     */
    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;
            buffer[vertexOffset] = corners[i].x;
            buffer[vertexOffset + 1] = corners[i].y;
            buffer[vertexOffset + 2] = corners[i].z;
            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
            buffer[vertexOffset + 6] = weight;
            buffer[vertexOffset + 7] = bgWeight;
            buffer[vertexOffset + 8] = style.color.r;
            buffer[vertexOffset + 9] = style.color.g;
            buffer[vertexOffset + 10] = style.color.b;
            buffer[vertexOffset + 11] = style.opacity;
            buffer[vertexOffset + 12] = style.backgroundColor.r;
            buffer[vertexOffset + 13] = style.backgroundColor.g;
            buffer[vertexOffset + 14] = style.backgroundColor.b;
            buffer[vertexOffset + 15] = style.backgroundOpacity;
        }
    }
    /**
     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can
     * be passed to override the passed attribute data.
     *
     * @param textBufferObject [[TextBufferObject]] containing computed glyphs.
     * @param position Override position value.
     * @param scale Override scale value.
     * @param rotation Override rotation value.
     * @param color Override color value.
     * @param opacity Override opacity value.
     * @param bgColor Override background color value.
     * @param bgOpacity Override background opacity value.
     *
     * @returns Result of the addition.
     */
    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const s = scale || 1.0;
        const r = rotation || 0.0;
        const cosR = Math.cos(r);
        const sinR = Math.sin(r);
        const offsetX = position !== undefined ? position.x : 0.0;
        const offsetY = position !== undefined ? position.y : 0.0;
        const offsetZ = position !== undefined ? position.z : 0.0;
        const buffer = textBufferObject.buffer;
        const rot = buffer[3];
        const rotSign = rot < 0 ? -1.0 : 1.0;
        const red = color !== undefined ? color.r : buffer[8];
        const green = color !== undefined ? color.g : buffer[9];
        const blue = color !== undefined ? color.b : buffer[10];
        const alpha = opacity !== undefined ? opacity : buffer[11];
        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];
        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];
        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];
        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];
        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;
        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {
            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            const glyph = textBufferObject.glyphs[i];
            if (!glyph.isInCache) {
                return false;
            }
            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];
            const w = buffer[srcOffset + 6];
            const bw = buffer[srcOffset + 7];
            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {
                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];
                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];
                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;
                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);
                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
            }
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);
        }
        this.m_drawCount += textBufferObject.glyphs.length;
        return true;
    }
    /**
     * Adds picking data for glyphs from the specified start until the last glyph added.
     *
     * @param startIdx First glyph index that this picking data is associated to.
     * @param endIdx Last glyph index that this picking data is associated to.
     * @param pickingData Picking data to be added.
     */
    addPickingData(startIdx, endIdx, pickingData) {
        if (this.m_pickingCount >= this.m_currentCapacity) {
            return false;
        }
        this.m_pickingDataArray[this.m_pickingCount] = {
            start: Math.min(startIdx, this.capacity),
            end: Math.min(endIdx, this.capacity),
            data: pickingData
        };
        ++this.m_pickingCount;
        return true;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs
     * are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pick(screenPosition, pickCallback) {
        for (const pickingData of this.m_pickingDataArray) {
            if (pickingData === undefined) {
                return;
            }
            for (let i = pickingData.start; i < pickingData.end; ++i) {
                const positionIndex = i * exports.VERTICES_PER_QUAD;
                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x < minX) {
                    continue;
                }
                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x > maxX) {
                    continue;
                }
                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y < minY) {
                    continue;
                }
                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y > maxY) {
                    continue;
                }
                pickCallback(pickingData.data);
                break;
            }
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.
     *
     * @param info The info object to increment with the values from this `TextGeometry`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +
            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    resizeBuffers(size) {
        this.m_currentCapacity = size;
        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);
        newVertexBuffer.set(this.m_vertexBuffer.array);
        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setDynamic(true);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);
        newIndexBuffer.set(this.m_indexBuffer.array);
        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setDynamic(true);
        this.m_geometry.dispose();
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.addAttribute("position", this.m_positionAttribute);
        this.m_geometry.addAttribute("uv", this.m_uvAttribute);
        this.m_geometry.addAttribute("color", this.m_colorAttribute);
        this.m_geometry.addAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray.length = this.m_currentCapacity;
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
}
exports.TextGeometry = TextGeometry;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextMaterials.ts":
/*!**********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextMaterials.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const SdfShaderChunks = {
    sdf_attributes: `
        attribute vec4 position;
        attribute vec4 uv;
        attribute vec4 color;
        attribute vec4 bgColor;
        `,
    sdf_varying: `
        varying vec4 vColor;
        varying float vWeight;
        varying vec2 vUv;
        varying float vRotation;
        `,
    sdf_varying_computation: `
        #if BG_TEXT
        vColor = bgColor;
        vWeight = uv.w;
        #else
        vColor = color;
        vWeight = uv.z;
        #endif
        vUv = vec2(uv.xy);
        vRotation = position.w;
        `,
    sdf_frag_uniforms: `
        uniform sampler2D sdfTexture;
        uniform vec4 sdfParams;
        `,
    sdf_sampling_functions: `
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }

        float getDistance(vec2 uvOffset) {
            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;
            #if MSDF
            return median(sample.r, sample.g, sample.b);
            #else
            return sample.r;
            #endif
        }

        float getOpacity(vec2 uvOffset, float weight) {
            vec2 uv = vUv + uvOffset;
            vec2 rotatedUVs = abs(vec2(
                cos(vRotation) * uv.x - sin(vRotation) * uv.y,
                sin(vRotation) * uv.x + cos(vRotation) * uv.y));

            float dx = dFdx(rotatedUVs.x) * sdfParams.x;
            float dy = dFdy(rotatedUVs.y) * sdfParams.y;
            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );

            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;
            return clamp(dist * toPixels + 0.5, 0.0, 1.0);
        }
        `
};
Object.assign(THREE.ShaderChunk, SdfShaderChunks);
const clearVertexSource = `
    attribute vec2 position;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const clearFragmentSource = `
    precision highp float;
    precision highp int;

    void main() {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }`;
const copyVertexSource = `
    attribute vec3 position;
    attribute vec2 uv;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 vUv;

    void main() {
        vUv = vec3(uv.xy, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const copyFragmentSource = `
    precision highp float;
    precision highp int;

    uniform float pageOffset;
    uniform sampler2D page0;
    uniform sampler2D page1;
    uniform sampler2D page2;
    uniform sampler2D page3;
    uniform sampler2D page4;
    uniform sampler2D page5;
    uniform sampler2D page6;
    uniform sampler2D page7;

    varying vec3 vUv;

    void main() {
        vec4 sample = vec4(0.0);
        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;
        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);
        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);
        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);
        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);
        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);
        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);
        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);
        else sample = texture2D(page7, vUv.xy);

        gl_FragColor = sample;
    }`;
const sdfTextVertexSource = `
    #include <sdf_attributes>
    #include <sdf_varying>

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        #include <sdf_varying_computation>
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    }`;
const sdfTextFragmentSource = `
    precision highp float;
    precision highp int;

    #include <sdf_varying>
    #include <sdf_frag_uniforms>
    #include <sdf_sampling_functions>

    void main() {
        vec4 color = vColor;
        color.a *= getOpacity(vec2(0.0), vWeight);
        if (color.a < 0.05) {
            discard;
        }
        gl_FragColor = color;
    }`;
/**
 * @hidden
 * Material used for clearing glyphs from a [[GlyphTextureCache]].
 */
class GlyphClearMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphClearMaterial`.
     *
     * @returns New `GlyphClearMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphClearMaterial",
            vertexShader: clearVertexSource,
            fragmentShader: clearFragmentSource,
            uniforms: {},
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphClearMaterial = GlyphClearMaterial;
/**
 * @hidden
 * Material used for copying glyphs into a [[GlyphTextureCache]].
 */
class GlyphCopyMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphCopyMaterial`.
     *
     * @returns New `GlyphCopyMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphCopyMaterial",
            vertexShader: copyVertexSource,
            fragmentShader: copyFragmentSource,
            uniforms: {
                pageOffset: new THREE.Uniform(0.0),
                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)
            },
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphCopyMaterial = GlyphCopyMaterial;
/**
 * @hidden
 * Material designed to render transformable, high quality SDF text.
 */
class SdfTextMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `SdfTextMaterial`.
     *
     * @param params Material parameters.
     *
     * @returns New `SdfTextMaterial`.
     */
    constructor(params) {
        const shaderParams = {
            name: "SdfTextMaterial",
            vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,
            fragmentShader: params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,
            uniforms: {
                sdfTexture: new THREE.Uniform(params.texture),
                sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
            },
            defines: {
                MSDF: params.isMsdf ? 1.0 : 0.0,
                BG_TEXT: params.isBackground ? 1.0 : 0.0
            },
            depthTest: true,
            depthWrite: true,
            side: THREE.DoubleSide,
            transparent: true
        };
        super(shaderParams);
        this.extensions.derivatives = true;
    }
}
exports.SdfTextMaterial = SdfTextMaterial;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextStyle.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextStyle.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Unit of measurement used to specify a font's size.
 */
var FontUnit;
(function (FontUnit) {
    FontUnit[FontUnit["Em"] = 0] = "Em";
    FontUnit[FontUnit["Pixel"] = 1] = "Pixel";
    FontUnit[FontUnit["Point"] = 2] = "Point";
    FontUnit[FontUnit["Percent"] = 3] = "Percent";
})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
/**
 * Style to be used when rendering glyphs.
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["BoldItalic"] = 3] = "BoldItalic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
/**
 * Variant to be used when rendering.
 */
var FontVariant;
(function (FontVariant) {
    FontVariant[FontVariant["Regular"] = 0] = "Regular";
    FontVariant[FontVariant["AllCaps"] = 1] = "AllCaps";
    FontVariant[FontVariant["SmallCaps"] = 2] = "SmallCaps";
})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));
/**
 * Vertical alignment to be used when placing text.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Above"] = 0] = "Above";
    VerticalAlignment[VerticalAlignment["Center"] = -0.5] = "Center";
    VerticalAlignment[VerticalAlignment["Below"] = -1] = "Below";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Horizontal alignment to be used when placing text.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = -1] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Text wrapping rule used when `lineWidth` is reached.
 */
var WrappingMode;
(function (WrappingMode) {
    WrappingMode[WrappingMode["None"] = 0] = "None";
    WrappingMode[WrappingMode["Character"] = 1] = "Character";
    WrappingMode[WrappingMode["Word"] = 2] = "Word";
})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));
/**
 * Namespace containing default values for all members of [[TextRenderParameters]] and
 * [[TextLayoutParameters]].
 */
var DefaultTextStyle;
(function (DefaultTextStyle) {
    DefaultTextStyle.DEFAULT_FONT_NAME = "";
    DefaultTextStyle.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(FontUnit.Pixel),
        size: Object.freeze(16.0),
        backgroundSize: Object.freeze(0.0)
    };
    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;
    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;
    DefaultTextStyle.DEFAULT_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_OPACITY = 1.0;
    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;
    DefaultTextStyle.DEFAULT_TRACKING = 0.0;
    DefaultTextStyle.DEFAULT_LEADING = 0.0;
    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;
    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;
    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;
})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));
/**
 * [[TextCanvas]] text rendering style.
 */
class TextRenderStyle {
    /**
     * Creates a new `TextRenderStyle`.
     *
     * @param params Input [[TextRenderParameters]].
     *
     * @returns New `TextRenderStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            fontName: params.fontName !== undefined
                ? params.fontName
                : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== undefined
                ? params.fontSize
                : {
                    unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                    size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                    backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
                },
            fontStyle: params.fontStyle !== undefined
                ? params.fontStyle
                : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== undefined
                ? params.fontVariant
                : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== undefined
                ? params.color
                : new THREE.Color(DefaultTextStyle.DEFAULT_COLOR),
            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== undefined
                ? params.backgroundColor
                : new THREE.Color(DefaultTextStyle.DEFAULT_BACKGROUND_COLOR),
            backgroundOpacity: params.backgroundOpacity !== undefined
                ? params.backgroundOpacity
                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    /**
     * Current [[TextRenderParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign({}, this.m_params, value);
    }
    /**
     * Name of the preferred [[Font]] to be used when rendering.
     */
    get fontName() {
        return this.m_params.fontName;
    }
    set fontName(value) {
        this.m_params.fontName = value;
    }
    /**
     * Collection of unit and sizes to apply for the currently active [[Font]].
     */
    get fontSize() {
        return this.m_params.fontSize;
    }
    set fontSize(value) {
        this.m_params.fontSize = value;
    }
    /**
     * Glyph style to apply for the currently active [[Font]].
     */
    get fontStyle() {
        return this.m_params.fontStyle;
    }
    set fontStyle(value) {
        this.m_params.fontStyle = value;
    }
    /**
     * Glyph variant to apply for the currently active [[Font]].
     */
    get fontVariant() {
        return this.m_params.fontVariant;
    }
    set fontVariant(value) {
        this.m_params.fontVariant = value;
    }
    /**
     * Glyph local rotation (radians).
     */
    get rotation() {
        return this.m_params.rotation;
    }
    set rotation(value) {
        this.m_params.rotation = value;
    }
    /**
     * Glyph color.
     */
    get color() {
        return this.m_params.color;
    }
    set color(value) {
        this.m_params.color = value;
    }
    /**
     * Glyph background color.
     */
    get backgroundColor() {
        return this.m_params.backgroundColor;
    }
    set backgroundColor(value) {
        this.m_params.backgroundColor = value;
    }
    /**
     * Glyph opacity.
     */
    get opacity() {
        return this.m_params.opacity;
    }
    set opacity(value) {
        this.m_params.opacity = value;
    }
    /**
     * Glyph background opacity.
     */
    get backgroundOpacity() {
        return this.m_params.backgroundOpacity;
    }
    set backgroundOpacity(value) {
        this.m_params.backgroundOpacity = value;
    }
    /**
     * Clone this `TextRenderStyle`.
     *
     * @param params Input [[TextRenderParameters]].
     *
     * @returns Cloned `TextRenderStyle`.
     */
    clone(params = {}) {
        return new TextRenderStyle(Object.assign({}, this.m_params, params));
    }
}
exports.TextRenderStyle = TextRenderStyle;
/**
 * [[TextCanvas]] text rendering style.
 */
class TextLayoutStyle {
    /**
     * Creates a new `TextLayoutStyle`.
     *
     * @param params Input [[TextLayoutParameters]].
     *
     * @returns New `TextLayoutStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== undefined
                ? params.maxLines
                : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== undefined
                ? params.lineWidth
                : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== undefined
                ? params.canvasRotation
                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== undefined
                ? params.lineRotation
                : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== undefined
                ? params.wrappingMode
                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment: params.verticalAlignment !== undefined
                ? params.verticalAlignment
                : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT,
            horizontalAlignment: params.horizontalAlignment !== undefined
                ? params.horizontalAlignment
                : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT
        };
    }
    /**
     * Current [[TextLayoutParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign({}, this.m_params, value);
    }
    /**
     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].
     */
    get tracking() {
        return this.m_params.tracking;
    }
    set tracking(value) {
        this.m_params.tracking = value;
    }
    /**
     * Inter-line spacing (pixels). Scaled by [[FontSize]].
     */
    get leading() {
        return this.m_params.leading;
    }
    set leading(value) {
        this.m_params.leading = value;
    }
    /**
     * Maximum number of lines to be considered when using [[TextCanvas]].
     */
    get maxLines() {
        return this.m_params.maxLines;
    }
    set maxLines(value) {
        this.m_params.maxLines = value;
    }
    /**
     * Maximum line width (pixels).
     */
    get lineWidth() {
        return this.m_params.lineWidth;
    }
    set lineWidth(value) {
        this.m_params.lineWidth = value;
    }
    /**
     * [[TextCanvas]] rotation (radians).
     */
    get canvasRotation() {
        return this.m_params.canvasRotation;
    }
    set canvasRotation(value) {
        this.m_params.canvasRotation = value;
    }
    /**
     * Line typesetting rotation (radians).
     */
    get lineRotation() {
        return this.m_params.lineRotation;
    }
    set lineRotation(value) {
        this.m_params.lineRotation = value;
    }
    /**
     * Wrapping (line-breaking) mode.
     */
    get wrappingMode() {
        return this.m_params.wrappingMode;
    }
    set wrappingMode(value) {
        this.m_params.wrappingMode = value;
    }
    /**
     * Text position regarding the baseline.
     */
    get verticalAlignment() {
        return this.m_params.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.m_params.verticalAlignment = value;
    }
    /**
     * Text position inside a line.
     */
    get horizontalAlignment() {
        return this.m_params.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.m_params.horizontalAlignment = value;
    }
    /**
     * Clone this `TextLayoutStyle`.
     *
     * @param params Input [[TextLayoutParameters]].
     *
     * @returns Cloned `TextLayoutStyle`.
     */
    clone(params = {}) {
        return new TextLayoutStyle(Object.assign({}, this.m_params, params));
    }
}
exports.TextLayoutStyle = TextLayoutStyle;


/***/ }),

/***/ "../harp-text-canvas/lib/typesetting/LineTypesetter.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/typesetting/LineTypesetter.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * @hidden
 * [[Typesetter]] implementation that handles multi-line complex layout text.
 */
class LineTypesetter {
    /**
     * Creates a `LineTypesetter` object.
     *
     * @returns New `LineTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
    }
    /**
     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple
     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,
     * such as:
     * - Maximum line width.
     * - Word and character wrapping.
     * - Maximum number of lines.
     * - Vertical and horizontal alignment.
     * - Leading (spacing between lines).
     *
     * @param params Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_currentParams.position.y +=
            this.m_currentParams.textLayoutStyle.verticalAlignment *
                this.m_currentParams.glyphs[0].font.metrics.capHeight *
                this.m_tempScale;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // Compute line origin and height.
        const origin = this.m_currentParams.position.x;
        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +
            this.m_currentParams.textLayoutStyle.leading;
        // Initialize line-breaking and wrapping variables.
        let lineStartIdx = 0;
        let glyphWrapIdx = 0;
        let wordWrapIdx = 0;
        let lineStartX = 0;
        let lineCurrX = 0;
        let glyphWrapX = 0;
        let wordWrapX = 0;
        let lineCount = 0;
        let isBidirectionalLine = false;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
                break;
            }
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);
            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);
            // Check if this line should be treated as bidirectional.
            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectionalLine = true;
            }
            // Advance the line's current X offset (only for printable characters).
            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                lineCurrX +=
                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                        this.m_tempScale *
                        (this.m_tempSmallCaps
                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                            : 1.0);
            }
            // If this is the first character in a line, update the line's X offset values (needed
            // to properly center and wrap).
            if (i === lineStartIdx) {
                lineStartX = lineCurrX;
                glyphWrapX = lineCurrX;
                wordWrapX = lineCurrX;
            }
            // Check if should break the current line.
            if (isNewLine ||
                (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth)) {
                // Perform wrapping.
                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {
                    let wrapPointIdx = glyphWrapIdx;
                    let wrapPointX = glyphWrapX;
                    // Only wrap words when more than a single word fits into the current line.
                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                        wordWrapX !== lineStartX) {
                        wrapPointIdx = wordWrapIdx;
                        wrapPointX = wordWrapX;
                    }
                    lineCurrX = wrapPointX;
                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
                }
                // Calculate the correct starting position for the line base on alignment, and place
                // all glyphs in it.
                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                this.m_currentParams.position.x =
                    this.m_currentParams.position.x + lineCurrX * lineAlignment;
                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
                    return false;
                }
                // Update the line position.
                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
                this.m_currentParams.position.x = origin;
                // Find the beginning of a new line (removing trailing white spaces).
                while (i !== lineStartIdx &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {
                    ++i;
                }
                lineStartIdx = i + 1;
                if (lineStartIdx === this.m_currentParams.glyphs.length) {
                    break;
                }
                // Only reset the line's direction when a new line character is found (to keep
                // correct bidirectional behaviour when a bidirectional run is placed between
                // multiple lines).
                if (isNewLine) {
                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
                    this.m_tempRunDirection = this.m_tempLineDirection;
                }
                // Reset the line placement parameters.
                lineStartX = 0;
                lineCurrX = 0;
                glyphWrapIdx = lineStartIdx;
                glyphWrapX = 0;
                wordWrapIdx = lineStartIdx;
                wordWrapX = 0;
                isBidirectionalLine = false;
                lineCount++;
            }
            // If not, should if we should record any new wrapping points.
            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                !isWhiteSpace) {
                // Update the per-glyph wrapping point.
                glyphWrapIdx = i;
                glyphWrapX = lineCurrX;
                // Update the word wrapping point (only if mode is correctly set and we are
                // currently placed at the end of a word).
                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||
                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
                    wordWrapIdx = i;
                    wordWrapX = lineCurrX;
                }
            }
        }
        // If we still haven't placed all characters, place a final line.
        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&
            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                : this.m_currentParams.textLayoutStyle.horizontalAlignment;
            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
                return false;
            }
        }
        return true;
    }
    // Place characters alongside a line. Text direction is taken into account, and text is broken
    // into directional runs.
    placeLine(startIdx, endIdx, direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(startIdx, endIdx, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        // Initialize line placement parameters.
        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
        const origin = position.x;
        let offset = 0;
        let runStart = startIdx;
        for (let i = startIdx; i <= endIdx; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (isRTL) {
                    position.x = origin + offset;
                }
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                if (!isRTL) {
                    position.x = origin + offset;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (isRTL) {
                        position.x = origin + offset;
                    }
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    if (!isRTL) {
                        position.x = origin + offset;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
            // Advance the offset position in the line.
            offset +=
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)
                        : 1.0) *
                    direction;
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart <= endIdx) {
            if (isRTL) {
                position.x = origin + offset;
            }
            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
                return false;
            }
            if (!isRTL) {
                position.x = origin + offset;
            }
        }
        return true;
    }
    // Place a directional run of index inside a line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Advance the current position and proceed to next glyph in the run.
            position.set(position.x +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.cos(textLayoutStyle.lineRotation), position.y +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.sin(textLayoutStyle.lineRotation), position.z);
        }
        return true;
    }
}
exports.LineTypesetter = LineTypesetter;


/***/ }),

/***/ "../harp-text-canvas/lib/typesetting/PathTypesetter.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/typesetting/PathTypesetter.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * @hidden
 * [[Typesetter]] implementation that arranges glyphs alongside a specified path.
 */
class PathTypesetter {
    /**
     * Creates a `PathTypesetter` object.
     *
     * @returns New `PathTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
        this.m_tempPathPosition = new THREE.Vector3();
        this.m_tempPathLength = 0.0;
        this.m_tempPathOffset = 0.0;
    }
    /**
     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single
     * bidirectional line that follows the specified path. Characters will be orientated and placed
     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and
     * [[HorizontalAlignment]].
     *
     * @param params Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_tempPathLength = this.m_currentParams.path.getLength();
        this.m_tempPathOffset = 0.0;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // To be able to properly set the horizontal alignment on a path, we need to first retrieve
        // how much of the path the input text covers, so we can calculate the correct initial
        // offset.
        let isBidirectional = false;
        let pathWidth = 0.0;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectional = true;
            }
            pathWidth +=
                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                        : 1.0);
        }
        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +
            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /
                this.m_tempPathLength, 0), 1);
        // Place the input text as a single path line.
        return this.placeLine(this.m_tempLineDirection, isBidirectional);
    }
    // Place characters alongside a path line. Text direction is taken into account, and text is
    // broken into directional runs.
    placeLine(direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        // Initialize line placement parameters.
        let runStart = 0;
        for (let i = runStart; i < glyphDataArray.length; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart < glyphDataArray.length) {
            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
                return false;
            }
        }
        return true;
    }
    // Place a directional run of index inside a path line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        const path = this.m_currentParams.path;
        const defaultGlyphRotation = textRenderStyle.rotation;
        const normalDisplacement = textLayoutStyle.verticalAlignment *
            glyphDataArray[0].font.metrics.capHeight *
            this.m_tempScale;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Update the current interpolated path position and angle.
            const textPoint = path.getPoint(this.m_tempPathOffset);
            if (textPoint === null) {
                return this.m_currentParams.pathOverflow;
            }
            const tangent = path.getTangent(this.m_tempPathOffset);
            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
            const angle = Math.atan2(tangent.y, tangent.x);
            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
            textRenderStyle.rotation = defaultGlyphRotation + angle;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                this.m_tempCorners[j].x -= position.x;
                this.m_tempCorners[j].y -= position.y;
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Restore the original glyph rotation.
            textRenderStyle.rotation = defaultGlyphRotation;
            // Advance the current position and proceed to next glyph in the run.
            this.m_tempPathOffset +=
                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /
                    this.m_tempPathLength;
        }
        return true;
    }
}
exports.PathTypesetter = PathTypesetter;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/ContextualArabicConverter.ts":
/*!******************************************************************!*\
  !*** ../harp-text-canvas/lib/utils/ContextualArabicConverter.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ContextualForm;
(function (ContextualForm) {
    ContextualForm[ContextualForm["Initial"] = 0] = "Initial";
    ContextualForm[ContextualForm["Medial"] = 1] = "Medial";
    ContextualForm[ContextualForm["Final"] = 2] = "Final";
})(ContextualForm || (ContextualForm = {}));
var CombinedForm;
(function (CombinedForm) {
    CombinedForm[CombinedForm["Isolated"] = 0] = "Isolated";
    CombinedForm[CombinedForm["Connected"] = 1] = "Connected";
})(CombinedForm || (CombinedForm = {}));
/**
 * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms
 * (in Unicode Block 'Arabic Presentation Forms-B').
 */
class ContextualArabicConverter {
    constructor() {
        this.m_singleCharactersMap = new Map();
        this.m_combinedCharactersMap = new Map();
        // Single characters.
        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA
        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA
        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE
        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA
        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW
        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA
        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF
        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH
        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA
        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH
        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH
        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM
        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH
        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH
        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL
        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL
        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH
        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN
        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN
        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN
        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD
        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD
        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH
        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH
        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN
        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN
        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL
        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH
        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF
        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF
        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM
        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM
        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON
        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH
        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW
        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA
        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH
        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH
        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh
        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh
        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh
        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf
        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh
        // Combined characters.
        this.m_combinedCharactersMap.set(0x0644, new Map());
        // LAM_ALEF_MADDA
        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);
        // LAM_ALEF_HAMZA_ABOVE
        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);
        // LAM_ALEF_HAMZA_BELOW
        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);
        // LAM_ALEF
        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);
        // Neutral characters.
        this.m_neutralCharacters = [
            0x0610,
            0x0612,
            0x0613,
            0x0614,
            0x0615,
            0x064b,
            0x064c,
            0x064d,
            0x064e,
            0x064f,
            0x0650,
            0x0651,
            0x0652,
            0x0653,
            0x0654,
            0x0655,
            0x0656,
            0x0657,
            0x0658,
            0x0670,
            0x06d6,
            0x06d7,
            0x06d8,
            0x06d9,
            0x06da,
            0x06db,
            0x06dc,
            0x06df,
            0x06e0,
            0x06e1,
            0x06e2,
            0x06e3,
            0x06e4,
            0x06e7,
            0x06e8,
            0x06ea,
            0x06eb,
            0x06ec,
            0x06ed // ARABIC SMALL LOW MEEM
        ];
    }
    static get instance() {
        if (this.m_instance === undefined) {
            this.m_instance = new ContextualArabicConverter();
        }
        return this.m_instance;
    }
    /**
     * Converts isolated arabic characters into their contextual form.
     *
     * @param input String with isolated arabic characters.
     */
    convert(input) {
        let output = "";
        for (let i = 0; i < input.length; ++i) {
            const currentCodePoint = input.charCodeAt(i);
            // Only process arabic characters in the map.
            if (this.isArabicCharacter(currentCodePoint)) {
                // Find the first previous non-neutral character.
                let prevIndex = i - 1;
                for (; prevIndex >= 0; --prevIndex) {
                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {
                        break;
                    }
                }
                // Check if the previous character has ligatures with following characters.
                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;
                if (prevCodePoint !== undefined) {
                    const prevMap = this.getCharacterMap(prevCodePoint);
                    if (prevMap === undefined ||
                        (prevMap[ContextualForm.Initial] === undefined &&
                            prevMap[ContextualForm.Medial] === undefined)) {
                        prevCodePoint = undefined;
                    }
                }
                // Find the first next non-neutral character.
                let nextIndex = i + 1;
                for (; nextIndex < input.length; ++nextIndex) {
                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {
                        break;
                    }
                }
                // Check if the next character has ligatures with previous characters.
                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;
                if (nextCodePoint !== undefined) {
                    const nextMap = this.getCharacterMap(nextCodePoint);
                    if (nextMap === undefined ||
                        (nextMap[ContextualForm.Medial] === undefined &&
                            nextMap[ContextualForm.Final] === undefined)) {
                        nextCodePoint = undefined;
                    }
                }
                // Check for Lam Alef combinated forms.
                if (currentCodePoint === 0x0644 &&
                    nextCodePoint !== undefined &&
                    (nextCodePoint === 0x0622 ||
                        nextCodePoint === 0x0623 ||
                        nextCodePoint === 0x0625 ||
                        nextCodePoint === 0x0627)) {
                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
                    if (prevCodePoint !== undefined) {
                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);
                    }
                    else {
                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);
                    }
                    // Skip the next character and continue.
                    ++i;
                    continue;
                }
                // Check for single character contextual forms.
                const map = this.getCharacterMap(currentCodePoint);
                // Intermediate.
                if (prevCodePoint !== undefined &&
                    nextCodePoint !== undefined &&
                    map[ContextualForm.Medial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Medial]);
                }
                // Final.
                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Final]);
                }
                // Initial.
                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Initial]);
                }
                // Isolated.
                else {
                    output += String.fromCharCode(currentCodePoint);
                }
            }
            else {
                output += String.fromCharCode(currentCodePoint);
            }
        }
        return output;
    }
    isArabicCharacter(codePoint) {
        return this.m_singleCharactersMap.has(codePoint);
    }
    getCharacterMap(codePoint) {
        return this.m_singleCharactersMap.get(codePoint);
    }
    getCombinedCharacterMap(codePoint, nextCodePoint) {
        const map = this.m_combinedCharactersMap.get(codePoint);
        if (map !== undefined) {
            return map.get(nextCodePoint);
        }
        return undefined;
    }
    isNeutral(codePoint) {
        for (const character of this.m_neutralCharacters) {
            if (character === codePoint) {
                return true;
            }
        }
        return false;
    }
}
exports.ContextualArabicConverter = ContextualArabicConverter;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/MaterialUtils.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/utils/MaterialUtils.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ "../harp-text-canvas/lib/rendering/TextMaterials.ts");
/**
 * Helper function designed to create [[SdfTextMaterials]] that can be rendered using
 * [[TextCanvas]].
 *
 * @param params Material parameters.
 *
 * @returns New `SdfTextMaterial`.
 */
function createSdfTextMaterial(params) {
    return new TextMaterials_1.SdfTextMaterial({
        texture: params.fontCatalog.texture,
        textureSize: params.fontCatalog.textureSize,
        size: params.fontCatalog.size,
        distanceRange: params.fontCatalog.distanceRange,
        isMsdf: params.fontCatalog.type === "msdf",
        isBackground: params.isBackground === true,
        vertexSource: params.vertexSource,
        fragmentSource: params.fragmentSource
    });
}
exports.createSdfTextMaterial = createSdfTextMaterial;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/TypesettingUtils.ts":
/*!*********************************************************!*\
  !*** ../harp-text-canvas/lib/utils/TypesettingUtils.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * Collection of different constants and utility functions used by [[Typesetter]]s.
 */
var TypesettingUtils;
(function (TypesettingUtils) {
    /**
     * Ratio between EMs and Pixels.
     */
    TypesettingUtils.EM_TO_PX = 16.0;
    /**
     * Ratio between Points and Pixels.
     */
    TypesettingUtils.PT_TO_PX = 1.25;
    /**
     * Angle used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;
    /**
     * Horizontal offset used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);
    /**
     * Convert between any size specified in any [[FontUnit]] to pixels.
     *
     * @param size Font size (specified in `unit`).
     * @param unit Size unit.
     * @param originalSize Original size (pixels)
     *
     * @returns Pixel size.
     */
    function getPixelSize(size, unit, originalSize) {
        let result = size;
        switch (unit) {
            case TextStyle_1.FontUnit.Em:
                result *= TypesettingUtils.EM_TO_PX;
                break;
            case TextStyle_1.FontUnit.Point:
                result *= TypesettingUtils.PT_TO_PX;
                break;
            case TextStyle_1.FontUnit.Percent:
                result *= (1.0 / 100) * originalSize;
                break;
        }
        return result;
    }
    TypesettingUtils.getPixelSize = getPixelSize;
    /**
     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.
     *
     * @param glyphs Array containing [[TransformedGlyphData]].
     * @param index Index to `glyphDataArray`.
     * @param fontVariant Currently active [[FontVariant]].
     *
     * @returns Glyph `SmallCaps` scale.
     */
    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;
        return isSmallCaps
            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight
            : 1.0;
    }
    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;
    /**
     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].
     *
     * @param glyphs Array containing [[GlyphData]].
     * @param offset `glyphDataArray` offset.
     *
     * @returns Strong direction.
     */
    function getDirection(glyphs, offset) {
        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        let index = offset;
        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&
            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
            index < glyphs.length - 1) {
            ++index;
        }
        if (Math.abs(glyphs[index].direction) === 1.0) {
            result = glyphs[index].direction;
        }
        return result;
    }
    TypesettingUtils.getDirection = getDirection;
    /**
     * Computes the transformation matrix for a glyph.
     *
     * @param transform Matrix used to store the results.
     * @param position Glyph' position.
     * @param scale Glyph' scale.
     * @param rotation [[TextCanvas]] rotation.
     * @param localRotation Glyph' local rotation.
     */
    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(rotation);
        const localCosAngle = Math.cos(localRotation);
        const localSinAngle = Math.sin(localRotation);
        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);
    }
    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;
    /**
     * Updates the supplied bounds with the computed screen-space corners for a given glyph.
     *
     * @param corners Glyph' corners.
     * @param globalBounds Global text bounds.
     * @param individualBounds Individual per-character bounds.
     */
    function updateBounds(corners, globalBounds, individualBounds) {
        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        if (individualBounds !== undefined) {
            if (individualBounds.array[individualBounds.offset] !== undefined) {
                individualBounds.array[individualBounds.offset].min.set(minX, minY);
                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
            }
            else {
                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));
            }
            ++individualBounds.offset;
        }
        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
    }
    TypesettingUtils.updateBounds = updateBounds;
})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));


/***/ }),

/***/ "../harp-text-canvas/lib/utils/UnicodeUtils.ts":
/*!*****************************************************!*\
  !*** ../harp-text-canvas/lib/utils/UnicodeUtils.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Namespace containing useful information when dealing with Unicode's code points.
 */
var UnicodeUtils;
(function (UnicodeUtils) {
    /**
     * Range of Unicode code points considered as white space.
     * https://en.wikipedia.org/wiki/Whitespace_character
     */
    UnicodeUtils.whiteSpaceRanges = [
        [0x0009, 0x0009],
        [0x0020, 0x0020],
        [0x1680, 0x1680],
        [0x2000, 0x2006],
        [0x2008, 0x200a],
        [0x205f, 0x3000],
        [0x180e, 0x180e],
        [0x200b, 0x200d]
    ];
    /**
     * Checks if a character should be considered as a white space.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isWhiteSpace(codePoint) {
        for (const range of UnicodeUtils.whiteSpaceRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isWhiteSpace = isWhiteSpace;
    /**
     * Range of Unicode code points considered as `NewLine`.
     * https://en.wikipedia.org/wiki/Newline#Unicode
     */
    UnicodeUtils.newLineRanges = [[0x000a, 0x000d], [0x0085, 0x0085], [0x2028, 0x2029]];
    /**
     * Checks if a character should be considered as a new line.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isNewLine(codePoint) {
        for (const range of UnicodeUtils.newLineRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isNewLine = isNewLine;
    /**
     * Range of Unicode code points considered as non-printable.
     * https://en.wikipedia.org/wiki/Unicode_control_characters
     */
    UnicodeUtils.nonPrintableRanges = [[0x0000, 0x001f], [0x007f, 0x009f]];
    /**
     * Checks if a character's can be printed (rendered).
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isPrintable(codePoint) {
        for (const range of UnicodeUtils.nonPrintableRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return false;
            }
        }
        return true;
    }
    UnicodeUtils.isPrintable = isPrintable;
    /**
     * Unicode code point direction.
     */
    let Direction;
    (function (Direction) {
        Direction[Direction["Neutral"] = 0] = "Neutral";
        Direction[Direction["Weak"] = 0.5] = "Weak";
        Direction[Direction["LTR"] = 1] = "LTR";
        Direction[Direction["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));
    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).
    /**
     * Unicode Blocks which have inherent RTL direction.
     * These blocks correspond to the scripts described here:
     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts
     */
    UnicodeUtils.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    /**
     * ASCII punctuation is considered to have neutral direction:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.neutralBidirectionalRanges = [
        [0x0020, 0x002f],
        [0x003a, 0x0040],
        [0x005b, 0x0060],
        [0x007b, 0x007e]
    ];
    /**
     * Latin and arabic numerals are considered to have weak directionality:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block
     */
    UnicodeUtils.weakBidirectionalRanges = [[0x0030, 0x0039], [0x0660, 0x0669], [0x06f0, 0x06f9]];
    /**
     * Returns the Unicode's character direction.
     *
     * @param codePoint Character's Unicode code point.
     * @param block Character's Unicode block.
     *
     * @returns Character's direction.
     */
    function getDirection(codePoint, block) {
        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).
        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {
            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                return Direction.Weak;
            }
        }
        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {
            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                return Direction.Neutral;
            }
        }
        // Check for RTL/LTR.
        const rtl = UnicodeUtils.rtlBlocks.find(element => {
            return element === block;
        });
        if (rtl !== undefined) {
            return Direction.RTL;
        }
        else {
            return Direction.LTR;
        }
    }
    UnicodeUtils.getDirection = getDirection;
    /**
     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering
     * a RTL string to preserve their intrinsic meaning.
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.rtlMirroredCodePoints = [
        0x0028,
        0x0029,
        0x003c,
        0x003e,
        0x005b,
        0x005d,
        0x007b,
        0x007d
    ];
    /**
     * Checks if a character should be mirrored on an RTL run.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isRtlMirrored(codePoint) {
        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {
            return element === codePoint;
        }) !== undefined);
    }
    UnicodeUtils.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));


/***/ }),

/***/ "../harp-transfer-manager/index.ts":
/*!*****************************************!*\
  !*** ../harp-transfer-manager/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./src/TransferManager */ "../harp-transfer-manager/src/TransferManager.ts"));


/***/ }),

/***/ "../harp-transfer-manager/src/TransferManager.ts":
/*!*******************************************************!*\
  !*** ../harp-transfer-manager/src/TransferManager.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @module
 *
 * This module provides classes to ease downloading URLs. In particular, following redirects,
 * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
/** @internal
 * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.
 * This class allows wrapping other promises or long running functions for later execution.
 */
class DeferredPromise {
    constructor(executor) {
        this.executor = executor;
        this.doExec = false;
        this.promise = new Promise((resolve, reject) => {
            this.resolveFunc = resolve;
            this.rejectFunc = reject;
            if (this.doExec) {
                this.execInnerPromise(this.resolveFunc, this.rejectFunc);
            }
        });
    }
    /**
     * When `exec` is called the deferred executor function is executed.
     */
    exec() {
        if (this.resolveFunc === undefined || this.rejectFunc === undefined) {
            // deferred promise not yet initialized - handle it in callback above
            this.doExec = true;
            return;
        }
        this.execInnerPromise(this.resolveFunc, this.rejectFunc);
    }
    execInnerPromise(resolveFunc, rejectFunc) {
        this.executor()
            .then(result => resolveFunc(result))
            .catch(err => rejectFunc(err));
    }
}
/**
 * `TransferManager` for downloading URLs.
 *
 * Features:
 *
 * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded
 *   once.
 * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that
 *   would otherwise stall the browser.
 * * Retries the downloads with an increasing timeout on HTTP 503 replies.
 *
 * The static method [[instance]] can be used to get a default constructed instance.
 */
class TransferManager {
    /**
     * Constructs a new [[TransferManager]].
     *
     * @param fetchFunction The default fetch function to use.
     * @param maxRetries The maximum amount to try to re-fetch a resource.
     */
    constructor(fetchFunction = fetch, maxRetries = 5) {
        this.fetchFunction = fetchFunction;
        this.maxRetries = maxRetries;
        this.activeDownloadCount = 0;
        this.downloadQueue = new Array();
        this.activeDownloads = new Map();
    }
    /**
     * Returns a default instance of [[TransferManager]].
     */
    static instance() {
        return TransferManager.defaultInstance;
    }
    static fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetchFunction(url, init);
                if (response.status !== 503 || retryCount > maxRetries) {
                    return response;
                }
            }
            catch (err) {
                if (err.hasOwnProperty("isCancelled") ||
                    (err.hasOwnProperty("name") && err.name === "AbortError") ||
                    retryCount > maxRetries) {
                    throw err;
                }
            }
            return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init));
        });
    }
    static waitFor(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
    /**
     * Downloads a JSON object. Merges downloads if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same resource to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url The URL to download
     * @param init Optional extra parameters for the download.
     */
    downloadJson(url, init) {
        return this.downloadAs(response => response.json(), url, init);
    }
    /**
     * Downloads a binary object. Merges downloads if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same resource to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url The URL to download
     * @param init Optional extra parameters for the download
     */
    downloadArrayBuffer(url, init) {
        return this.download(url, init).then(response => response.arrayBuffer());
    }
    /**
     * Downloads a URL and returns the response.
     *
     * Does not merge multiple requests to the same URL.
     *
     * @param url The URL to download.
     * @param init Optional extra parameters for the download.
     */
    download(url, init) {
        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {
            const deferred = new DeferredPromise(() => this.doDownload(url, init));
            this.downloadQueue.push(deferred);
            return deferred.promise;
        }
        return this.doDownload(url, init);
    }
    doDownload(url, init) {
        ++this.activeDownloadCount;
        return TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init)
            .then(response => {
            this.onDownloadDone();
            return response;
        })
            .catch(err => {
            this.onDownloadDone();
            throw err;
        });
    }
    onDownloadDone() {
        --this.activeDownloadCount;
        this.execDeferredDownload();
    }
    execDeferredDownload() {
        const future = this.downloadQueue.pop();
        if (future === undefined) {
            return;
        }
        future.exec();
    }
    downloadAs(converter, url, init) {
        const cacheKey = url;
        const pendingFetch = this.activeDownloads.get(cacheKey);
        if (pendingFetch !== undefined) {
            return Promise.resolve(pendingFetch);
        }
        const newFetch = this.download(url, init)
            .then(response => {
            this.activeDownloads.delete(cacheKey);
            if (response.ok) {
                return converter(response);
            }
            throw new Error(JSON.stringify(response));
        })
            .catch(err => {
            this.activeDownloads.delete(cacheKey);
            throw err;
        });
        this.activeDownloads.set(cacheKey, newFetch);
        return newFetch;
    }
}
/**
 * The timeout in milliseconds to wait between retries. This timeout is multiplied with the
 * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and
 * so on.
 */
TransferManager.retryTimeout = 500;
/**
 * The amount of maximum parallel downloads to allow.
 */
TransferManager.maxParallelDownloads = 16;
TransferManager.defaultInstance = new TransferManager();
exports.TransferManager = TransferManager;


/***/ }),

/***/ "../harp-utils/index.ts":
/*!******************************!*\
  !*** ../harp-utils/index.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/GroupedPriorityList */ "../harp-utils/lib/GroupedPriorityList.ts"));
__export(__webpack_require__(/*! ./lib/Logger */ "../harp-utils/lib/Logger/index.ts"));
__export(__webpack_require__(/*! ./lib/Math2D */ "../harp-utils/lib/Math2D.ts"));
__export(__webpack_require__(/*! ./lib/MathUtils */ "../harp-utils/lib/MathUtils.ts"));
__export(__webpack_require__(/*! ./lib/Mixins */ "../harp-utils/lib/Mixins.ts"));
__export(__webpack_require__(/*! ./lib/assert */ "../harp-utils/lib/assert.ts"));
__export(__webpack_require__(/*! ./lib/ContextLogger */ "../harp-utils/lib/ContextLogger.ts"));
__export(__webpack_require__(/*! ./lib/PerformanceTimer */ "../harp-utils/lib/PerformanceTimer.ts"));
__export(__webpack_require__(/*! ./lib/ObjectUtils */ "../harp-utils/lib/ObjectUtils.ts"));
__export(__webpack_require__(/*! ./lib/OptionsUtils */ "../harp-utils/lib/OptionsUtils.ts"));
__export(__webpack_require__(/*! ./lib/UrlResolver */ "../harp-utils/lib/UrlResolver.ts"));
__export(__webpack_require__(/*! ./lib/UrlUtils */ "../harp-utils/lib/UrlUtils.ts"));
__export(__webpack_require__(/*! ./lib/Functions */ "../harp-utils/lib/Functions.ts"));


/***/ }),

/***/ "../harp-utils/lib/ContextLogger.ts":
/*!******************************************!*\
  !*** ../harp-utils/lib/ContextLogger.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`
 * before first actual log message.
 */
class ContextLogger {
    /**
     * Construct a context-aware logger that logs to `m_logger`.
     */
    constructor(m_logger, headerMessage) {
        this.m_logger = m_logger;
        this.headerMessage = headerMessage;
        this.context = [];
        this.m_headerLogged = false;
        // They, are public member functions it's just tslint who doesn't understand this.
        // tslint:disable:member-ordering
        this.warn = this.createLogMethod("warn");
        this.info = this.createLogMethod("info");
        this.error = this.createLogMethod("error");
    }
    /**
     * Push "attribute-like" context.
     *
     * Following log messages will be prefixed with `name` or `.name` depending on current context.
     */
    pushAttr(name) {
        this.context.push(`${this.context.length > 0 ? "." : ""}${name}`);
    }
    /**
     * Push "index-like" context.
     *
     * Following log messages will be prefixed with `[index]`.
     */
    pushIndex(index) {
        this.context.push(`[${index}]`);
    }
    pop() {
        this.context.pop();
    }
    // tslint:enable:member-ordering
    createLogMethod(severity) {
        return (message, ...rest) => {
            if (!this.m_headerLogged) {
                this.m_logger.info(this.headerMessage);
                this.m_headerLogged = true;
            }
            this.m_logger[severity](`${this.context.join("")}: ${message}`, ...rest);
        };
    }
}
exports.ContextLogger = ContextLogger;


/***/ }),

/***/ "../harp-utils/lib/Functions.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/Functions.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Chains two functions for further assigning as one wrapped callback function
 */
function chainCallbacks(f1, f2) {
    return function (...args) {
        if (f1) {
            f1.apply(this, args);
        }
        return f2.apply(this, args);
    };
}
exports.chainCallbacks = chainCallbacks;


/***/ }),

/***/ "../harp-utils/lib/GroupedPriorityList.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/GroupedPriorityList.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The `PriorityListGroup` contains a list of [[PriorityListElement]]s that all have the same
 * (integer) priority.
 */
class PriorityListGroup {
    constructor(priority, elements = new Array()) {
        this.priority = priority;
        this.elements = elements;
    }
    /**
     * Create and return a deep copy of the `PriorityListGroup<T>`.
     *
     * @returns A clone of the `PriorityListGroup<T>`.
     */
    clone() {
        return new PriorityListGroup(this.priority, this.elements.slice());
    }
}
exports.PriorityListGroup = PriorityListGroup;
/**
 * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items
 * in priority groups.
 */
class GroupedPriorityList {
    constructor() {
        this.groups = new Map();
    }
    /**
     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.
     *
     * @param element Element to be added.
     */
    add(element) {
        this.getGroup(element.priority).elements.push(element);
    }
    /**
     * Remove an element from the `GroupedPriorityList`.
     *
     * Note: It is required that the priority is the same as it was when the element has been added.
     * Otherwise, the removal will fail.
     *
     * @param element Element to be removed.
     * @returns `True` if the element was removed, `false` otherwise.
     */
    remove(element) {
        const group = this.getGroup(element.priority);
        if (group !== undefined) {
            const foundIndex = group.elements.indexOf(element);
            if (foundIndex >= 0) {
                group.elements.splice(foundIndex, 1);
                if (group.elements.length === 0) {
                    const normalizedPriority = Math.floor(element.priority);
                    this.groups.delete(normalizedPriority);
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Remove all internal [[PriorityListGroup]]s.
     */
    clear() {
        this.groups.clear();
    }
    /**
     * Merge another [[GroupedPriorityList]] into this one.
     *
     * @param other Other group to merge.
     */
    merge(other) {
        for (const otherGroup of other.groups) {
            const group = this.findGroup(otherGroup[1].priority);
            if (group === undefined) {
                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
                continue;
            }
            group.elements = group.elements.concat(otherGroup[1].elements);
        }
        return this;
    }
    /**
     * Return a sorted list of [[PriorityListGroup]]s.
     */
    get sortedGroups() {
        const groups = [];
        for (const priorityList of this.groups) {
            groups.push(priorityList[1]);
        }
        groups.sort((a, b) => {
            return b.priority - a.priority;
        });
        return groups;
    }
    /**
     * Apply function to all elements in this `GroupedPriorityList`.
     *
     * @param {(element: T) => void} fun Function to apply.
     */
    forEach(fun) {
        for (const group of this.groups) {
            group[1].elements.forEach(fun);
        }
    }
    /**
     * Count the number of elements in this `GroupedPriorityList`.
     */
    count() {
        let n = 0;
        for (const group of this.groups) {
            n += group[1].elements.length;
        }
        return n;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority The priority to retrieve all elements from.
     */
    findGroup(priority) {
        const normalizedPriority = Math.floor(priority);
        const group = this.groups.get(normalizedPriority);
        return group;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority The priority to retrieve all elements from.
     */
    getGroup(priority) {
        let group = this.findGroup(priority);
        if (group === undefined) {
            const normalizedPriority = Math.floor(priority);
            group = new PriorityListGroup(normalizedPriority);
            this.groups.set(normalizedPriority, group);
        }
        return group;
    }
}
exports.GroupedPriorityList = GroupedPriorityList;


/***/ }),

/***/ "../harp-utils/lib/Logger/ConsoleChannel.ts":
/*!**************************************************!*\
  !*** ../harp-utils/lib/Logger/ConsoleChannel.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class for the default console channel.
 */
class ConsoleChannel {
    error(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.error(message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.debug(message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.info(message, ...optionalParams);
    }
    log(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.log(message, ...optionalParams);
    }
    trace(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.trace(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.warn(message, ...optionalParams);
    }
}
exports.ConsoleChannel = ConsoleChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/ILogger.ts":
/*!*******************************************!*\
  !*** ../harp-utils/lib/Logger/ILogger.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enum log levels
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Log"] = 2] = "Log";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warn"] = 4] = "Warn";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Logger options to configure logger
 */
class LoggerOptions {
}
exports.LoggerOptions = LoggerOptions;


/***/ }),

/***/ "../harp-utils/lib/Logger/Logger.ts":
/*!******************************************!*\
  !*** ../harp-utils/lib/Logger/Logger.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts");
/**
 * Logger class.
 */
class Logger {
    constructor(name, m_channel, options) {
        this.name = name;
        this.m_channel = m_channel;
        this.enabled = true;
        this.level = ILogger_1.LogLevel.Trace;
        if (options !== undefined) {
            this.update(options);
        }
    }
    error(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {
            this.m_channel.error(this.prefix, message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {
            this.m_channel.debug(this.prefix, message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {
            this.m_channel.info(this.prefix, message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {
            this.m_channel.log(this.prefix, message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {
            this.m_channel.trace(this.prefix, message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {
            this.m_channel.warn(this.prefix, message, ...optionalParams);
        }
    }
    update(options) {
        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;
        this.level = options.level === undefined ? this.level : options.level;
    }
    get prefix() {
        return this.name + ":";
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "../harp-utils/lib/Logger/LoggerManager.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/Logger/LoggerManager.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ "../harp-utils/lib/Logger/LoggerManagerImpl.ts");
/**
 * The LoggerManager class implements a singleton object that handles logging.
 *
 * Example:
 *
 * ```typescript
 *
 * const logger = LoggerManager.instance.create("MyFontLoaderClass");
 * if (missingFonts.length > 0) {
 *     logger.error("These fonts can not be loaded: ", missingFonts);
 * } else {
 *     logger.log("All fonts have been loaded.");
 * }
 * ```
 */
class LoggerManager {
    static get instance() {
        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());
    }
}
exports.LoggerManager = LoggerManager;


/***/ }),

/***/ "../harp-utils/lib/Logger/LoggerManagerImpl.ts":
/*!*****************************************************!*\
  !*** ../harp-utils/lib/Logger/LoggerManagerImpl.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ "../harp-utils/lib/Logger/ConsoleChannel.ts");
const Logger_1 = __webpack_require__(/*! ./Logger */ "../harp-utils/lib/Logger/Logger.ts");
const WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ "../harp-utils/lib/Logger/WorkerChannel.ts");
/**
 * LoggerManagerImpl is the class for the singleton instance of the logger manager.
 * It handles channels and loggers.
 */
class LoggerManagerImpl {
    constructor() {
        this.m_loggers = [];
        this.channel =
            typeof self === "undefined" || typeof self.document !== "undefined"
                ? new ConsoleChannel_1.ConsoleChannel()
                : new WorkerChannel_1.WorkerChannel();
    }
    getLoggerNames() {
        return this.m_loggers.map(logger => logger.name);
    }
    getLogger(name) {
        return this.m_loggers.find(logger => logger.name === name);
    }
    create(loggerName, options) {
        const logger = new Logger_1.Logger(loggerName, this.channel, options);
        this.m_loggers.push(logger);
        return logger;
    }
    dispose(logger) {
        const found = this.m_loggers.indexOf(logger);
        if (found < 0) {
            throw new Error(`Cannot unregister "${logger}" : no such logger registered.`);
        }
        this.m_loggers.splice(found, 1);
    }
    updateAll(options) {
        for (const logger of this.m_loggers) {
            logger.update(options);
        }
    }
    update(loggerName, config) {
        for (const logger of this.m_loggers) {
            if (logger.name === loggerName) {
                logger.update(config);
            }
        }
    }
    enableAll(enabled) {
        for (const logger of this.m_loggers) {
            logger.enabled = enabled;
        }
    }
    enable(loggerName, value) {
        this.update(loggerName, { enabled: value });
    }
    setLogLevelForAll(level) {
        for (const logger of this.m_loggers) {
            logger.level = level;
        }
    }
    setLogLevel(loggerName, level) {
        this.update(loggerName, { level });
    }
    setChannel(channel) {
        this.channel = channel;
    }
}
exports.LoggerManagerImpl = LoggerManagerImpl;


/***/ }),

/***/ "../harp-utils/lib/Logger/MultiChannel.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/Logger/MultiChannel.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class allowing mixing several channels.
 */
class MultiChannel {
    constructor(...channels) {
        this.channels = [];
        this.channels = channels;
    }
    error(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.warn(message, ...optionalParams);
        }
    }
}
exports.MultiChannel = MultiChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/WorkerChannel.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/Logger/WorkerChannel.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts");
exports.WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
/**
 * The class for the worker channel.
 */
class WorkerChannel {
    error(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Error
        };
        self.postMessage(workerMessage);
    }
    debug(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Debug
        };
        self.postMessage(workerMessage);
    }
    info(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Info
        };
        self.postMessage(workerMessage);
    }
    log(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Log
        };
        self.postMessage(workerMessage);
    }
    trace(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Trace
        };
        self.postMessage(workerMessage);
    }
    warn(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Warn
        };
        self.postMessage(workerMessage);
    }
}
exports.WorkerChannel = WorkerChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/index.ts":
/*!*****************************************!*\
  !*** ../harp-utils/lib/Logger/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ConsoleChannel */ "../harp-utils/lib/Logger/ConsoleChannel.ts"));
__export(__webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts"));
__export(__webpack_require__(/*! ./Logger */ "../harp-utils/lib/Logger/Logger.ts"));
__export(__webpack_require__(/*! ./LoggerManager */ "../harp-utils/lib/Logger/LoggerManager.ts"));
__export(__webpack_require__(/*! ./MultiChannel */ "../harp-utils/lib/Logger/MultiChannel.ts"));
__export(__webpack_require__(/*! ./WorkerChannel */ "../harp-utils/lib/Logger/WorkerChannel.ts"));


/***/ }),

/***/ "../harp-utils/lib/Math2D.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/Math2D.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Math2D;
(function (Math2D) {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    class Box {
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x New X value.
         * @param y New y value.
         * @param w New w value.
         * @param h New h value.
         */
        constructor(x = 0, y = 0, w = 0, h = 0) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Set new values to all properties of the box.
         *
         * @param x New X value.
         * @param y New y value.
         * @param w New w value.
         * @param h New h value.
         */
        set(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Test box for inclusion of point.
         *
         * @param x X coordinate of point.
         * @param y Y coordinate of point.
         */
        contains(x, y) {
            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
        }
        /**
         * Test two boxes for intersection.
         *
         * @param other Box 2 to test for intersection.
         */
        intersects(other) {
            return (this.x <= other.x + other.w &&
                this.x + this.w >= other.x &&
                this.y <= other.y + other.h &&
                this.y + this.h >= other.y);
        }
    }
    Math2D.Box = Box;
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax Point a.x
     * @param ay Point a.y
     * @param bx Point b.x
     * @param by Point b.y
     * @returns Squared distance between the two points
     */
    function distSquared(ax, ay, bx, by) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
    }
    Math2D.distSquared = distSquared;
    /**
     * Computes the squared length of a line.
     *
     * @param line An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    function computeSquaredLineLength(line) {
        let squaredLineLength = 0;
        const length = line.length - 4;
        for (let i = 0; i < length; i += 3) {
            const xDiff = line[i + 3] - line[i];
            const yDiff = line[i + 4] - line[i + 1];
            squaredLineLength += xDiff * xDiff + yDiff * yDiff;
        }
        return squaredLineLength;
    }
    Math2D.computeSquaredLineLength = computeSquaredLineLength;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px Test point X
     * @param py Test point y
     * @param l0x Line segment start X
     * @param l0y Line segment start Y
     * @param l1x Line segment end X
     * @param l1y Line segment end Y
     * @returns Squared distance between point and line segment
     */
    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
        if (lineLengthSuared === 0) {
            return distSquared(px, py, l0x, l0y);
        }
        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
        t = Math.max(0, Math.min(1, t));
        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
    }
    Math2D.distToSegmentSquared = distToSegmentSquared;
})(Math2D = exports.Math2D || (exports.Math2D = {}));


/***/ }),

/***/ "../harp-utils/lib/MathUtils.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/MathUtils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MathUtils;
(function (MathUtils) {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value The value to be clamped.
     * @param min Minimum value.
     * @param max Maximum value.
     *
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Returns a linear interpolation between the values of edge0 and edge1 based on the factor.
     *
     * Given two known points the linear interpolant between these points may be presented as
     * straight line. This means that for given factor change the resulting change of return
     * value is always const.
     * @see https://en.wikipedia.org/wiki/Linear_interpolation
     *
     * @param edge0
     * @param edge1
     * @param factor Interpolation factor that ranges between: 0 <= x <= 1.
     */
    function lerp(edge0, edge1, factor) {
        return edge0 * (1 - factor) + edge1 * factor;
    }
    MathUtils.lerp = lerp;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0
     * @param edge1
     * @param x
     */
    function smoothStep(edge0, edge1, x) {
        // Scale, bias and saturate x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * (3 - 2 * x);
    }
    MathUtils.smoothStep = smoothStep;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0
     * @param edge1
     * @param x
     */
    function smootherStep(edge0, edge1, x) {
        // Scale, and clamp x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    MathUtils.smootherStep = smootherStep;
    /**
     * Maps a number from one range to another.
     *
     * @param val The incoming value to be converted.
     * @param inMin Lower bound of the value's current range.
     * @param inMax Upper bound of the value's current range.
     * @param outMin Lower bound of the value's target range.
     * @param outMax Upper bound of the value's target range.
     */
    function map(val, inMin, inMax, outMin, outMax) {
        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }
    MathUtils.map = map;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a First number.
     * @param b Second number.
     */
    function min2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.min(result, b);
        }
        return result;
    }
    MathUtils.min2 = min2;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a First number.
     * @param b Second number.
     */
    function max2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.max(result, b);
        }
        return result;
    }
    MathUtils.max2 = max2;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value Value to check.
     * @param lowerBound The lower bound to check the value against.
     * @param upperBound The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    function isClamped(value, lowerBound, upperBound) {
        if (lowerBound !== undefined && value < lowerBound) {
            return false;
        }
        if (upperBound !== undefined && value > upperBound) {
            return false;
        }
        return true;
    }
    MathUtils.isClamped = isClamped;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue
     * @param endValue
     * @param time
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    function easeInOutCubic(startValue, endValue, time) {
        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        return startValue + (endValue - startValue) * timeValue;
    }
    MathUtils.easeInOutCubic = easeInOutCubic;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "../harp-utils/lib/Mixins.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/Mixins.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor Class to mix methods and properties into.
 * @param baseCtors Class to take all methods and properties from.
 */
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
exports.applyMixins = applyMixins;
/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor Class to mix methods into.
 * @param baseCtors Class to take all methods from.
 */
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
            if (descriptor !== undefined && descriptor.get === undefined) {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            }
        });
    });
}
exports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;


/***/ }),

/***/ "../harp-utils/lib/ObjectUtils.ts":
/*!****************************************!*\
  !*** ../harp-utils/lib/ObjectUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
function cloneDeep(obj) {
    const cache = new Map();
    function cloneInternal(src) {
        if (src === null) {
            return null;
        }
        else if (typeof src === "object") {
            const cached = cache.get(src);
            if (cached !== undefined) {
                return cached;
            }
            if (Array.isArray(src)) {
                const result = [];
                cache.set(src, result);
                result.length = src.length;
                for (let i = 0; i < result.length; ++i) {
                    result[i] = cloneInternal(src[i]);
                }
                return result;
            }
            else if (src instanceof Date) {
                const result = new Date(src.getTime());
                cache.set(src, result);
                return result;
            }
            else if (src instanceof RegExp) {
                const result = new RegExp(src.source, src.flags);
                cache.set(src, result);
                return result;
            }
            else if (src.constructor !== Object) {
                throw new Error("cloneDeep doesn't support objects with custom prototypes");
            }
            else {
                const result = {};
                cache.set(src, result);
                for (const key in src) {
                    if (src.hasOwnProperty(key)) {
                        result[key] = cloneInternal(src[key]);
                    }
                }
                return result;
            }
        }
        else {
            // string, number, boolean, undefined and functions are returned as is
            return src;
        }
    }
    const r = cloneInternal(obj);
    cache.clear();
    return r;
}
exports.cloneDeep = cloneDeep;


/***/ }),

/***/ "../harp-utils/lib/OptionsUtils.ts":
/*!*****************************************!*\
  !*** ../harp-utils/lib/OptionsUtils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function getOptionValue(...values) {
    for (const candidate of values) {
        if (candidate !== undefined && candidate !== null) {
            return candidate;
        }
    }
    return undefined;
}
exports.getOptionValue = getOptionValue;
/**
 * Merge options into existing parameters object.
 *
 * Convenience helper with _similar_ semantics as:
 *
 *     const finalParams1 = { ...defaults, ... options };
 *     const finalParams2 = Object.assign({}, defaults, options);
 *
 * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.
 * `defaults` is used as _parameters_ template.
 *
 * This doc uses following notion of `option` and `parameter` terms:
 * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object
 *    * `parameter` usually have sensible and usually used default
 *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)
 *    * `parameter` can be overriden by specyfying `option` with same name
 * * `option` means value that may be passed optionally, overrides `parameter` value with same name
 *
 * Usage:
 *
 *     interface FooParams {
 *         useTextures: boolean;
 *         opacity: number;
 *     }
 *
 *     const FOO_DEFAULTS: FooParams = {
 *         useTextures: true,
 *         opacity: 0.8
 *     };
 *
 *     type FooOptions = Partial<FooParams>;
 *
 *     function doSomething(options: FooOptions) {
 *         const params = mergeWithOptions(FOO_DEFAULTS, options);
 *             // typeof params === FooParams
 *             // params.opacity = 0.5
 *             // params.useTextures = true
 *             // params.someOtherOptionFromOtherApi is not defined
 *     }
 *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};
 *     doSomething(opt);
 *
 * Rationale:
 *   * both `Object.assign` and spread operator copy extra options
 *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist
 *     in options object
 *
 * @param parameters parmeters template object holding all expected parameters
 * @param options options object
 * @returns new object with `parameters` overriden by values from `options`
 */
function mergeWithOptions(parameters, options) {
    // NOTE: `as object` needed due to TypeScript bug:
    //       https://github.com/Microsoft/TypeScript/issues/14409
    // tslint:disable-next-line:no-object-literal-type-assertion
    const result = Object.assign({}, parameters);
    if (options === undefined || options === null) {
        return result;
    }
    for (const prop in parameters) {
        if (parameters.hasOwnProperty(prop)) {
            const optionValue = options[prop];
            if (optionValue !== undefined && optionValue !== null) {
                result[prop] = optionValue;
            }
        }
    }
    return result;
}
exports.mergeWithOptions = mergeWithOptions;


/***/ }),

/***/ "../harp-utils/lib/PerformanceTimer.ts":
/*!*********************************************!*\
  !*** ../harp-utils/lib/PerformanceTimer.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
/**
 * See:
 * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now
 */
/* tslint:ensable:max-line-length */
class PerformanceTimer {
    /**
     * Returns timestamp in milliseconds since page load.
     *
     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,
     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two
     * samples.
     *
     * Example:
     * ```typescript
     * const now = PerformanceTimer.now();
     * // call some expensive function for which you want to check the duration.
     * const end = PerformanceTimer.now();
     * const elapsedTime = end - now;
     * ```
     */
    static now() {
        return PerformanceTimer.nowFunc();
    }
    static getNowFunc() {
        if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
            return () => performance.now();
        }
        // fall back to Date.getTime()
        return () => {
            return new Date().getTime();
        };
    }
}
// tslint:disable-next-line:no-unused-variable
PerformanceTimer.instance = new PerformanceTimer();
PerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();
exports.PerformanceTimer = PerformanceTimer;


/***/ }),

/***/ "../harp-utils/lib/UrlResolver.ts":
/*!****************************************!*\
  !*** ../harp-utils/lib/UrlResolver.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Resolves URL using default URL resolver.
 *
 * By default URL resolver is just identity function, it can be changed using
 * [[setDefaultUrlResolver].
 */
function defaultUrlResolver(url) {
    if (customDefaultUrlResolver !== undefined) {
        return customDefaultUrlResolver(url);
    }
    else {
        return url;
    }
}
exports.defaultUrlResolver = defaultUrlResolver;
/**
 * Change resolver used by [[defaultUrlResolver]].
 *
 * `undefined` resets default resolver to identity function.
 *
 * @param resolver
 */
function setDefaultUrlResolver(resolver) {
    customDefaultUrlResolver = resolver;
}
exports.setDefaultUrlResolver = setDefaultUrlResolver;
let customDefaultUrlResolver;
/**
 * Compose URL resolvers.
 *
 * Creates new `UrlResolver` that applies resolvers in orders or arguments.
 *
 * Example:
 *
 *     const themeUrl = ...; // url of parent object
 *     const childUrlResolver = composeUrlResolvers(
 *           (childUrl: string) => resolveReferenceUrl(themeUrl, childUrl),
 *           defaultUrlResolver
 *     );
 */
function composeUrlResolvers(...resolvers) {
    return (originalUrl) => {
        return resolvers.reduce((url, resolver) => {
            if (resolver !== undefined) {
                return resolver(url);
            }
            else {
                return url;
            }
        }, originalUrl);
    };
}
exports.composeUrlResolvers = composeUrlResolvers;


/***/ }),

/***/ "../harp-utils/lib/UrlUtils.ts":
/*!*************************************!*\
  !*** ../harp-utils/lib/UrlUtils.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Resolve URL of referenced object.
 *
 * Resolves `childUrl` as it would be loaded from location specified by `parentUrl`.
 *
 * If `childUrl` is absolute, then it is returned unchanged.
 * If `childUrl` is origin-absolute path, then only origin path is taken from `parentUrl`.
 *
 * See [[baseUrl]] for reference how base URL of `parentUrl` is determined.
 *
 * Examples:
 *
 *     // normal case, child is sibling
 *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent is "folder", so child is just located in this folder
 *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent looks like leaf, so last component is stripped
 *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png
 *
 *     // origin-absolute URL, takes only origin from parent
 *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json
 *
 * @param parentUrl URL of parent resource
 * @param childUrl URL of child as referenced from parent resource
 * @return `childUrl` as if anchored in location of `parentUrl`
 */
function resolveReferenceUrl(parentUrl, childUrl) {
    if (absoluteUrlWithOriginRe.test(childUrl)) {
        return childUrl;
    }
    else if (childUrl.startsWith("/")) {
        const origin = getUrlOrigin(parentUrl);
        return origin + childUrl;
    }
    else {
        if (childUrl.startsWith("./")) {
            childUrl = childUrl.substr(2);
        }
        const parentBaseUrl = baseUrl(parentUrl);
        return parentBaseUrl + childUrl;
    }
}
exports.resolveReferenceUrl = resolveReferenceUrl;
const absoluteUrlWithOriginRe = new RegExp("^(?:[a-z]+:)?//", "i");
/**
 * Returns base URL of given resource URL.
 *
 * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if
 * `url` ends with name component it is treated as "leaf", so last path component is removed.
 *
 * Standalone files (without any folder structure) are considered relative to `./`.
 *
 * Examples:
 * ```
 *     https://foo.com/themes/a.json -> https://foo.com/themes/
 *     https://foo.com/themes/ -> https://foo.com/themes/
 *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf
 *     themes/day.json -> themes/
 *     themes -> ./
 * ```
 */
function baseUrl(url) {
    if (url === undefined) {
        return "./";
    }
    const idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    }
    else {
        return url.substring(0, idx + 1);
    }
}
exports.baseUrl = baseUrl;
/**
 * Get `origin` part of URL.
 *
 * @example
 *    https://example.com/foo -> https://example.com
 *    //example.com:8080/ -> //example.com:8080
 *    file:///etc/hosts ->
 *
 * @param url input URL
 * @return origin of given URL
 */
function getUrlOrigin(url) {
    if (url === undefined) {
        return "";
    }
    const parsed = getUrlHostAndProtocol(url);
    if (parsed.protocol === "file:") {
        return "file://";
    }
    else if (parsed.host && parsed.protocol) {
        return parsed.protocol + "//" + parsed.host;
    }
    else if (parsed.host) {
        return "//" + parsed.host;
    }
    else if (parsed.protocol) {
        return parsed.protocol + "//";
    }
    else {
        return "";
    }
}
exports.getUrlOrigin = getUrlOrigin;
/**
 * Parse `host` and `protocol` part from URL.
 */
function getUrlHostAndProtocol(url) {
    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
    const match = url.match(urlOriginRe);
    if (!match) {
        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);
    }
    return {
        protocol: match[1],
        host: match[2]
    };
}
exports.getUrlHostAndProtocol = getUrlHostAndProtocol;


/***/ }),

/***/ "../harp-utils/lib/assert.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/assert.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
//TODO: Make assertHandler configurable
/**
 * Implementation of assert as a development help
 *
 * Note - this is deliberately a global function so that minimizers remove the
 * entire call when building for production.
 *
 * @hidden
 * @param condition Condition to match, if false, throws an Error(message)
 * @param message Optional message, defaults to "ASSERTION failed"
 */
function assert(condition, message) {
    if (!isProduction) {
        if (!condition) {
            throw new Error(message !== undefined ? message : "ASSERTION failed");
        }
    }
}
exports.assert = assert;
function assertExists(element, message) {
    if (!isProduction) {
        if (element === undefined || element === null) {
            throw new Error(message !== undefined ? message : "ASSERTION failed: Element is undefined or null");
        }
    }
    return element;
}
exports.assertExists = assertExists;


/***/ }),

/***/ "../harp-webtile-datasource/index.ts":
/*!*******************************************!*\
  !*** ../harp-webtile-datasource/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/WebTileDataSource */ "../harp-webtile-datasource/lib/WebTileDataSource.ts"));


/***/ }),

/***/ "../harp-webtile-datasource/lib/WebTileDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-webtile-datasource/lib/WebTileDataSource.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
// tslint:disable-next-line: max-line-length
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
// tslint:disable-next-line:no-var-requires
const RTree = __webpack_require__(/*! rtree */ "../../node_modules/rtree/lib/index.js");
const textureLoader = new THREE.TextureLoader();
textureLoader.crossOrigin = ""; // empty assignment required to support CORS
/**
 * Mapping from ISO-639-1 language codes to codes used by HERE Map Tile API (MARC)
 *
 * @see https://developer.here.com/documentation/map-tile/topics/resource-base-maptile.html
 * @see [MARC Code List for Languages](https://www.loc.gov/marc/languages/)
 */
const WEBTILE_LANGUAGE_DICTIONARY = {
    eu: "baq",
    ca: "cat",
    zh: "chi",
    cs: "cze",
    da: "dan",
    nl: "dut",
    en: "eng",
    fi: "fin",
    fr: "fre",
    de: "ger",
    ga: "gle",
    el: "gre",
    he: "heb",
    hi: "hin",
    id: "ind",
    it: "ita",
    no: "nor",
    fa: "per",
    pl: "pol",
    pt: "por",
    ru: "rus",
    si: "sin",
    es: "spa",
    sv: "swe",
    th: "tha",
    tr: "tur",
    uk: "ukr",
    ur: "urd",
    vi: "vie",
    cy: "wel"
};
const hereCopyrightInfo = {
    id: "here.com",
    year: new Date().getFullYear(),
    label: "HERE"
};
/**
 * Instances of `WebTileDataSource` can be used to add Web Tile to [[MapView]].
 *
 * Example:
 *
 * ```typescript
 * const webTileDataSource = new WebTileDataSource({
 *     appId: <appId>,
 *     appCode: <appCode>
 * });
 * ```
 * @see [[DataSource]], [[OmvDataSource]].
 */
class WebTileDataSource extends harp_mapview_1.DataSource {
    /**
     * Constructs a new `WebTileDataSource`.
     *
     * @param m_options Represents the [[WebTileDataSourceParameters]].
     */
    constructor(m_options) {
        super("webtile", undefined, 1, 20);
        this.m_options = m_options;
        this.cacheable = true;
        this.storageLevelOffset = -1;
        this.m_resolution = harp_utils_1.getOptionValue(m_options.resolution, 512 /* resolution512 */);
        if (this.m_resolution === 512 /* resolution512 */) {
            this.maxZoomLevel = 19; // 512x512 tiles do not have z19
        }
        this.m_ppi = harp_utils_1.getOptionValue(m_options.ppi, 72 /* ppi72 */);
        this.m_tileBaseAddress = m_options.tileBaseAddress || WebTileDataSource.TILE_BASE_NORMAL;
        if (this.m_tileBaseAddress === WebTileDataSource.TILE_AERIAL_SATELLITE &&
            this.m_ppi !== 72 /* ppi72 */) {
            throw new Error("Requested combination of scheme satellite.day and ppi is not valid");
        }
    }
    shouldPreloadTiles() {
        return true;
    }
    getTilingScheme() {
        return harp_geoutils_1.webMercatorTilingScheme;
    }
    setLanguages(languages) {
        if (languages !== undefined) {
            this.mapIsoLanguageToWebTile(languages);
            this.mapView.markTilesDirty(this);
        }
    }
    getTile(tileKey) {
        const tile = new harp_mapview_1.Tile(this, tileKey);
        const column = tileKey.column;
        const row = tileKey.row;
        const level = tileKey.level;
        const { appId, appCode } = this.m_options;
        const quadKey = tileKey.toQuadKey();
        const server = parseInt(quadKey[quadKey.length - 1], 10) + 1;
        let url = `https://${server}.${this.m_tileBaseAddress}/` +
            `${level}/${column}/${row}/${this.m_resolution}/png8` +
            `?app_id=${appId}&app_code=${appCode}` +
            harp_utils_1.getOptionValue(this.m_options.additionalRequestParameters, "");
        if (this.m_ppi !== 72 /* ppi72 */) {
            // because ppi=72 is default, we do not include it in the request
            url += `&ppi=${this.m_ppi}`;
        }
        if (this.m_languages !== undefined && this.m_languages[0] !== undefined) {
            url += `&lg=${this.m_languages[0]}`;
        }
        if (this.m_languages !== undefined && this.m_languages[1] !== undefined) {
            url += `&lg2=${this.m_languages[1]}`;
        }
        Promise.all([this.loadTexture(url), this.getTileCopyright(tile)])
            .then(([texture, copyrightInfo]) => {
            tile.copyrightInfo = copyrightInfo;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            tile.addOwnedTexture(texture);
            const shouldSubdivide = this.projection.type === harp_geoutils_1.ProjectionType.Spherical;
            const sourceProjection = this.getTilingScheme().projection;
            const tmpV = new THREE.Vector3();
            const { east, west, north, south } = tile.geoBox;
            const g = new THREE.BufferGeometry();
            const posAttr = new THREE.BufferAttribute(new Float32Array([
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), tmpV)
                    .toArray()
            ]), 3);
            g.addAttribute("position", posAttr);
            const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);
            g.addAttribute("uv", uvAttr);
            g.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
            if (shouldSubdivide) {
                const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.Math.degToRad(10), sourceProjection);
                modifier.modify(g);
            }
            for (let i = 0; i < posAttr.array.length; i += 3) {
                tmpV.set(posAttr.array[i], posAttr.array[i + 1], posAttr.array[i + 2]);
                this.projection.reprojectPoint(sourceProjection, tmpV, tmpV);
                tmpV.sub(tile.center);
                posAttr.array[i] = tmpV.x;
                posAttr.array[i + 1] = tmpV.y;
                posAttr.array[i + 2] = tmpV.z;
            }
            posAttr.needsUpdate = true;
            const material = new THREE.MeshBasicMaterial({
                map: texture
            });
            const mesh = new THREE.Mesh(g, material);
            tile.objects.push(mesh);
            tile.invalidateResourceInfo();
            this.requestUpdate();
        })
            .catch(error => {
            logger.error(`failed to load webtile ${tileKey.mortonCode()}: ${error}`);
        });
        return tile;
    }
    parseBaseUrl(url) {
        const parsed = new URL(url.startsWith("https:") ? url : `https://${url}`);
        const fullPath = parsed.pathname;
        const maptilePathRegexp = new RegExp("^(/maptile/2.1/)([^/]+)/([^/]+)/([^/]+)");
        const match = fullPath.match(maptilePathRegexp);
        if (!match) {
            throw new Error(`WebTileDataSource: invalid baseUrl: ${url}`);
        }
        return {
            baseUrl: parsed.host,
            path: match[1],
            tileType: match[2],
            mapVersion: match[3],
            scheme: match[4]
        };
    }
    loadTexture(url) {
        return new Promise((resolve, reject) => {
            textureLoader.load(url, texture => {
                resolve(texture);
            }, undefined, // onProgress
            () => {
                // ErrorEvent received here doesn't have any meaningful code/ message to be
                // shown
                reject(new Error("failed to load texture"));
            });
        });
    }
    getTileCopyright(tile) {
        return __awaiter(this, void 0, void 0, function* () {
            // NOTE:
            // For some reason Map Tile copyright endpoint doesn't return HERE as copyright holder, so
            // add it statically.
            //
            // (https://developer.here.com/documentation/map-tile/topics/resource-copyright.html)
            const result = [hereCopyrightInfo];
            if (this.m_options.gatherCopyrightInfo === false) {
                return result;
            }
            const rtree = yield this.getCopyrightCoverageData();
            const tileBounds = {
                x: Math.min(tile.geoBox.west, tile.geoBox.east),
                y: Math.min(tile.geoBox.south, tile.geoBox.north),
                h: Math.abs(tile.geoBox.longitudeSpan),
                w: Math.abs(tile.geoBox.latitudeSpan)
            };
            const matchingEntries = rtree.search(tileBounds);
            const tileLevel = tile.tileKey.level;
            if (!matchingEntries) {
                return result;
            }
            for (const entry of matchingEntries) {
                const minLevel = harp_utils_1.getOptionValue(entry.minLevel, 0);
                const maxLevel = harp_utils_1.getOptionValue(entry.maxLevel, Infinity);
                if (tileLevel >= minLevel && tileLevel <= maxLevel) {
                    result.push({
                        id: entry.label
                    });
                }
            }
            return result;
        });
    }
    getCopyrightCoverageData() {
        const cachedResponse = this.m_cachedCopyrightResponse;
        if (cachedResponse !== undefined) {
            return cachedResponse;
        }
        const mapTileParams = this.parseBaseUrl(this.m_tileBaseAddress);
        const baseHostName = mapTileParams.baseUrl;
        const mapId = harp_utils_1.getOptionValue(mapTileParams.mapVersion, "newest");
        const scheme = mapTileParams.scheme || "normal.day";
        const baseScheme = scheme.split(".")[0] || "normal";
        const { appId, appCode } = this.m_options;
        const url = `https://1.${baseHostName}/maptile/2.1/copyright/${mapId}` +
            `?output=json&app_id=${appId}&app_code=${appCode}`;
        this.m_cachedCopyrightResponse = fetch(url)
            .then(response => response.json())
            .then((responseJson) => {
            const entries = responseJson[baseScheme] || [];
            const tree = new RTree();
            if (!entries) {
                return tree;
            }
            for (const entry of entries) {
                if (!entry.boxes) {
                    const wholeWorld = {
                        x: -180,
                        y: -90,
                        w: 360,
                        h: 180
                    };
                    tree.insert(wholeWorld, entry);
                }
                else {
                    for (const box of entry.boxes) {
                        const [bottom, left, top, right] = box;
                        const bounds = {
                            x: Math.min(left, right),
                            y: Math.min(bottom, top),
                            w: Math.abs(left - right),
                            h: Math.abs(top - bottom)
                        };
                        tree.insert(bounds, entry);
                    }
                }
            }
            return tree;
        });
        return this.m_cachedCopyrightResponse;
    }
    mapIsoLanguageToWebTile(languages) {
        this.m_languages = [];
        for (const language of languages) {
            if (WEBTILE_LANGUAGE_DICTIONARY[language] !== undefined) {
                this.m_languages.push(WEBTILE_LANGUAGE_DICTIONARY[language]);
            }
        }
    }
}
/**
 * Base address for Base Map rendered using `normal.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-normal-day-view.html
 */
WebTileDataSource.TILE_BASE_NORMAL = "base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day";
/**
 * Base address for Aerial Map rendered using `hybrid.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-hybrid-map.html
 */
WebTileDataSource.TILE_AERIAL_HYBRID = "aerial.maps.api.here.com/maptile/2.1/maptile/newest/hybrid.day";
/**
 * Base address for Aerial Map rendered using `satellite.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-satellite-map.html
 */
WebTileDataSource.TILE_AERIAL_SATELLITE = "aerial.maps.api.here.com/maptile/2.1/maptile/newest/satellite.day";
/**
 * Base address for Traffic Map rendered using `normal.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-traffic.html
 */
WebTileDataSource.TILE_TRAFFIC_NORMAL = "traffic.maps.api.here.com/maptile/2.1/traffictile/newest/normal.day";
exports.WebTileDataSource = WebTileDataSource;


/***/ }),

/***/ "./lib/BundleMain.ts":
/*!***************************!*\
  !*** ./lib/BundleMain.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const WorkerLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Default decoder url for bundled map component.
 */
exports.DEFAULT_DECODER_SCRIPT_URL = "harp.gl:harp-decoders.js";
/**
 * Basename of map bundle script - used by [[getBundleScriptUrl]] as fallback, when
 * `document.currentScript` is not present.
 *
 * @hidden
 */
exports.BUNDLE_SCRIPT_BASENAME = "harp";
/**
 * Guess `harp(.min).js` script URL.
 *
 * Required to find default URLs `harp-decoders.js` which are hosted together, not necessarily with
 * base URL of current page.
 *
 * @see https://stackoverflow.com/questions/2976651
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript
 * @hidden
 */
function getBundleScriptUrl() {
    if (bundleScriptUrl !== undefined) {
        return bundleScriptUrl;
    }
    const currentScript = document.currentScript;
    const baseScriptUrl = currentScript ? currentScript.src : getScriptUrl(exports.BUNDLE_SCRIPT_BASENAME);
    if (baseScriptUrl) {
        bundleScriptUrl = baseScriptUrl;
        return bundleScriptUrl;
    }
    else {
        bundleScriptUrl = null;
        return undefined;
    }
}
exports.getBundleScriptUrl = getBundleScriptUrl;
/**
 * Memoizes result of [[getBundleScriptUrl]].
 * @hidden
 */
let bundleScriptUrl;
/**
 * Get script URL assumet it's already loaded in DOM.
 *
 * Required to find default URLs `harp.(min.)js` and `three().min).js` which are required to
 * properly start decoder bundle.
 *
 * @see https://stackoverflow.com/questions/2976651
 * @hidden
 */
function getScriptUrl(name) {
    const scriptElement = document.querySelector(`script[src*='/${name}.min.js']`) ||
        document.querySelector(`script[src='${name}.min.js']`) ||
        document.querySelector(`script[src*='/${name}.js']`) ||
        document.querySelector(`script[src='${name}.js']`);
    if (scriptElement) {
        return scriptElement.src;
    }
    else {
        return undefined;
    }
}
exports.getScriptUrl = getScriptUrl;
const HARP_GL_BUNDLED_ASSETS_PREFIX = "harp.gl:";
/**
 * Resolve URLs with support for `harp.gl` bundle specific URLs.
 *
 * URLs with prefix `harp.gl:` are resolved relatively to `harp.js` bundle's base URL.
 *
 * @hidden
 */
function resolveBundledResourceUrl(url) {
    if (url.startsWith(HARP_GL_BUNDLED_ASSETS_PREFIX)) {
        const bundleSriptUrl = getBundleScriptUrl();
        if (bundleSriptUrl === null || bundleSriptUrl === undefined) {
            throw new Error(`harp.js: cannot resolve ${url} because 'harp.gl' base url is not set.`);
        }
        else {
            url = url.substring(HARP_GL_BUNDLED_ASSETS_PREFIX.length);
            if (url.startsWith("/")) {
                url = url.substring(1);
            }
            return harp_utils_1.baseUrl(bundleSriptUrl) + url;
        }
    }
    return url;
}
exports.resolveBundledResourceUrl = resolveBundledResourceUrl;
const getActualDecoderScriptUrl = () => {
    const baseScriptUrl = getBundleScriptUrl();
    if (!baseScriptUrl) {
        // tslint:disable-next-line:no-console
        console.error(`harp.js: Unable to determine default location of 'harp-decoders(min).js'. ` +
            `See https://github.com/heremaps/harp.gl/@here/harp.gl.`);
    }
    if (!WorkerLoader_1.WorkerLoader.dependencyUrlMapping.three) {
        // tslint:disable-next-line:no-console
        console.error(`harp.js: Unable to determine location of 'three(.min).js'. ` +
            "`See https://github.com/heremaps/harp.gl/@here/harp.gl.`");
    }
    const isMinified = baseScriptUrl && baseScriptUrl.endsWith(".min.js");
    const decoderScriptName = !isMinified
        ? exports.DEFAULT_DECODER_SCRIPT_URL
        : exports.DEFAULT_DECODER_SCRIPT_URL.replace(".js$", ".min.js");
    return resolveBundledResourceUrl(decoderScriptName);
};
/**
 * Guess decoder script URL.
 *
 * Assumes that decoder script - `harp-decoders.js` is in same place as main bundle and calculates
 * it's URL.
 *
 * Minified version of `harp.js` bundle loads minified version of decoder.
 * Hooks in [[ConcurrentDecoderFacade]] to use this URL as default `defaultScriptUrl`.
 *
 * @hidden
 */
function installDefaultDecoderUrlHook() {
    harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl = "";
    harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl = "";
    const threeUrl = getScriptUrl("three");
    WorkerLoader_1.WorkerLoader.dependencyUrlMapping.three = threeUrl;
    const oldDecoderGetWorkerSet = harp_mapview_1.ConcurrentDecoderFacade.getWorkerSet;
    harp_mapview_1.ConcurrentDecoderFacade.getWorkerSet = (scriptUrl) => {
        if (scriptUrl === undefined && harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl === "") {
            const newScriptUrl = getActualDecoderScriptUrl();
            harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl = newScriptUrl;
        }
        return oldDecoderGetWorkerSet.apply(harp_mapview_1.ConcurrentDecoderFacade, [scriptUrl]);
    };
    const oldTilerGetWorkerSet = harp_mapview_1.ConcurrentTilerFacade.getWorkerSet;
    harp_mapview_1.ConcurrentTilerFacade.getWorkerSet = (scriptUrl) => {
        if (scriptUrl === undefined && harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl === "") {
            const newScriptUrl = getActualDecoderScriptUrl();
            harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl = newScriptUrl;
        }
        return oldTilerGetWorkerSet.apply(harp_mapview_1.ConcurrentTilerFacade, [scriptUrl]);
    };
}
/**
 * Initialize `harp.gl` bundle.
 *
 * Install specific default decoder urls into [[ConcurrentDecoderFacade]].
 * @hidden
 */
function mapBundleMain() {
    const mapBundleUrl = getBundleScriptUrl();
    if (mapBundleUrl !== null && mapBundleUrl !== undefined) {
        harp_utils_1.setDefaultUrlResolver(resolveBundledResourceUrl);
    }
    installDefaultDecoderUrlHook();
}
exports.mapBundleMain = mapBundleMain;


/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const BundleMain_1 = __webpack_require__(/*! ./BundleMain */ "./lib/BundleMain.ts");
if (!window.THREE) {
    // tslint:disable-next-line:no-console
    console.warn("harp.js: It looks like 'three.js' is not loaded. This script requires 'THREE' object to " +
        "be defined. See https://github.com/heremaps/harp.gl/@here/harp.gl.");
}
__export(__webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts"));
__export(__webpack_require__(/*! @here/harp-omv-datasource */ "../harp-omv-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-geojson-datasource */ "../harp-geojson-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-features-datasource */ "../harp-features-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-webtile-datasource */ "../harp-webtile-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-map-controls/lib/MapControls */ "../harp-map-controls/lib/MapControls.ts"));
__export(__webpack_require__(/*! @here/harp-map-controls/lib/MapControlsUI */ "../harp-map-controls/lib/MapControlsUI.ts"));
__export(__webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts"));
__export(__webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts"));
__export(__webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts"));
BundleMain_1.mapBundleMain();


/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=harp.js.map